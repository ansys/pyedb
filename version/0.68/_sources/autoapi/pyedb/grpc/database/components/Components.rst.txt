





:class:`Components`
===================


.. py:class:: pyedb.grpc.database.components.Components(p_edb: Any)

   Bases: :py:obj:`object`


   
   Manages EDB components and related methods accessible from `Edb.components`.


   :Parameters:

       **p_edb** : :class:`pyedb.grpc.edb.Edb`
           EDB object.













   .. rubric:: Examples

   >>> from pyedb import Edb
   >>> edb = Edb("myaedbfolder")
   >>> edb.components

   ..
       !! processed by numpydoc !!



.. py:currentmodule:: Components

Overview
--------

.. tab-set::



   .. tab-item:: Methods

      .. list-table::
          :header-rows: 0
          :widths: auto

          * - :py:attr:`~import_definition`
            - Import component definitions from a JSON file.
          * - :py:attr:`~export_definition`
            - Export component definitions to a JSON file.
          * - :py:attr:`~refresh_components`
            - Refresh the component dictionary.
          * - :py:attr:`~get_component_by_name`
            - Retrieve a component by name.
          * - :py:attr:`~get_pin_from_component`
            - Get pins from a component with optional filtering.
          * - :py:attr:`~get_components_from_nets`
            - Get components connected to specified nets.
          * - :py:attr:`~get_component_placement_vector`
            - Get placement vector between two components.
          * - :py:attr:`~get_solder_ball_height`
            - Get solder ball height of a component.
          * - :py:attr:`~get_vendor_libraries`
            - Get vendor component libraries.
          * - :py:attr:`~create_source_on_component`
            - Create sources on components.
          * - :py:attr:`~create_port_on_pins`
            - Create port on pins.
          * - :py:attr:`~create_port_on_component`
            - Create ports on a component.
          * - :py:attr:`~create`
            - Create a new component.
          * - :py:attr:`~create_component_from_pins`
            - Create component from pins.
          * - :py:attr:`~set_component_model`
            - Set component model.
          * - :py:attr:`~create_pingroup_from_pins`
            - Create pin group from pins.
          * - :py:attr:`~delete_single_pin_rlc`
            - Delete or deactivate single-pin RLC components.
          * - :py:attr:`~delete`
            - Delete a component.
          * - :py:attr:`~disable_rlc_component`
            - Disable RLC component.
          * - :py:attr:`~set_solder_ball`
            - Set solder ball properties for a component.
          * - :py:attr:`~set_component_rlc`
            - Set RLC values for a component.
          * - :py:attr:`~update_rlc_from_bom`
            - Update RLC values from BOM file.
          * - :py:attr:`~import_bom`
            - Import BOM file.
          * - :py:attr:`~export_bom`
            - Export BOM file.
          * - :py:attr:`~find_by_reference_designator`
            - Find component by reference designator.
          * - :py:attr:`~get_aedt_pin_name`
            - Get AEDT pin name.
          * - :py:attr:`~get_pins`
            - Get pins of a component.
          * - :py:attr:`~get_pin_position`
            - Get pin position.
          * - :py:attr:`~get_pins_name_from_net`
            - Get pin names from net.
          * - :py:attr:`~get_nets_from_pin_list`
            - Get nets from pin list.
          * - :py:attr:`~get_component_net_connection_info`
            - Get net connection info for a component.
          * - :py:attr:`~get_rats`
            - Get RATS (Reference Designator, Pin, Net) information.
          * - :py:attr:`~get_through_resistor_list`
            - Get through resistors below threshold.
          * - :py:attr:`~short_component_pins`
            - Short component pins with traces.
          * - :py:attr:`~create_pin_group`
            - Create pin group on a component.
          * - :py:attr:`~create_pin_group_on_net`
            - Create pin group by net name.
          * - :py:attr:`~deactivate_rlc_component`
            - Deactivate RLC component with a possibility to convert it to a circuit port.
          * - :py:attr:`~add_port_on_rlc_component`
            - Deactivate RLC component and replace it with a circuit port.
          * - :py:attr:`~replace_rlc_by_gap_boundaries`
            - Replace RLC component by RLC gap boundaries. These boundary types are compatible with 3D modeler export.
          * - :py:attr:`~add_rlc_boundary`
            - Add RLC gap boundary on component and replace it with a circuit port.


   .. tab-item:: Properties

      .. list-table::
          :header-rows: 0
          :widths: auto

          * - :py:attr:`~instances`
            - Dictionary of all component instances in the layout.
          * - :py:attr:`~definitions`
            - Dictionary of all component definitions.
          * - :py:attr:`~nport_comp_definition`
            - Dictionary of N-port component definitions.
          * - :py:attr:`~resistors`
            - Dictionary of resistor components.
          * - :py:attr:`~capacitors`
            - Dictionary of capacitor components.
          * - :py:attr:`~inductors`
            - Dictionary of inductor components.
          * - :py:attr:`~ICs`
            - Dictionary of integrated circuit components.
          * - :py:attr:`~IOs`
            - Dictionary of I/O components.
          * - :py:attr:`~Others`
            - Dictionary of other components.
          * - :py:attr:`~components_by_partname`
            - Dictionary of components grouped by part name.




   .. tab-item:: Special methods

      .. list-table::
          :header-rows: 0
          :widths: auto

          * - :py:attr:`~__getitem__`
            - Get a component or component definition by name.




Import detail
-------------

.. code-block:: python

    from pyedb.grpc.database.components import Components

Property detail
---------------

.. py:property:: instances
   :type: Dict[str, pyedb.grpc.database.hierarchy.component.Component]


   
   Dictionary of all component instances in the layout.





   :Returns:

       :class:`python:dict`\[:class:`python:str`, :class:`pyedb.grpc.database.hierarchy.component.Component`]
           Dictionary of component instances keyed by name.










   .. rubric:: Examples

   >>> edbapp.components.instances

   ..
       !! processed by numpydoc !!

.. py:property:: definitions
   :type: Dict[str, pyedb.grpc.database.definition.component_def.ComponentDef]


   
   Dictionary of all component definitions.





   :Returns:

       :class:`python:dict`\[:class:`python:str`, :class:`pyedb.grpc.database.definition.component_def.ComponentDef`]
           Dictionary of component definitions keyed by name.










   .. rubric:: Examples

   >>> edbapp.components.definitions

   ..
       !! processed by numpydoc !!

.. py:property:: nport_comp_definition
   :type: Dict[str, pyedb.grpc.database.definition.component_def.ComponentDef]


   
   Dictionary of N-port component definitions.





   :Returns:

       :class:`python:dict`\[:class:`python:str`, :class:`pyedb.grpc.database.hierarchy.component.Component`]
           Dictionary of N-port component definitions keyed by name.











   ..
       !! processed by numpydoc !!

.. py:property:: resistors
   :type: Dict[str, pyedb.grpc.database.hierarchy.component.Component]


   
   Dictionary of resistor components.





   :Returns:

       :class:`python:dict`\[:class:`python:str`, :class:`pyedb.grpc.database.hierarchy.component.Component`]
           Dictionary of resistor components keyed by name.










   .. rubric:: Examples

   >>> edbapp.components.resistors

   ..
       !! processed by numpydoc !!

.. py:property:: capacitors
   :type: Dict[str, pyedb.grpc.database.hierarchy.component.Component]


   
   Dictionary of capacitor components.





   :Returns:

       :class:`python:dict`\[:class:`python:str`, :class:`pyedb.grpc.database.hierarchy.component.Component`]
           Dictionary of capacitor components keyed by name.










   .. rubric:: Examples

   >>> edbapp.components.capacitors

   ..
       !! processed by numpydoc !!

.. py:property:: inductors
   :type: Dict[str, pyedb.grpc.database.hierarchy.component.Component]


   
   Dictionary of inductor components.





   :Returns:

       :class:`python:dict`\[:class:`python:str`, :class:`pyedb.grpc.database.hierarchy.component.Component`]
           Dictionary of inductor components keyed by name.










   .. rubric:: Examples

   >>> edbapp.components.inductors

   ..
       !! processed by numpydoc !!

.. py:property:: ICs
   :type: Dict[str, pyedb.grpc.database.hierarchy.component.Component]


   
   Dictionary of integrated circuit components.





   :Returns:

       :class:`python:dict`\[:class:`python:str`, :class:`pyedb.grpc.database.hierarchy.component.Component`]
           Dictionary of IC components keyed by name.










   .. rubric:: Examples

   >>> edbapp.components.ICs

   ..
       !! processed by numpydoc !!

.. py:property:: IOs
   :type: Dict[str, pyedb.grpc.database.hierarchy.component.Component]


   
   Dictionary of I/O components.





   :Returns:

       :class:`python:dict`\[:class:`python:str`, :class:`pyedb.grpc.database.hierarchy.component.Component`]
           Dictionary of I/O components keyed by name.










   .. rubric:: Examples

   >>> edbapp.components.IOs

   ..
       !! processed by numpydoc !!

.. py:property:: Others
   :type: Dict[str, pyedb.grpc.database.hierarchy.component.Component]


   
   Dictionary of other components.





   :Returns:

       :class:`python:dict`\[:class:`python:str`, :class:`pyedb.grpc.database.hierarchy.component.Component`]
           Dictionary of other components keyed by name.










   .. rubric:: Examples

   >>> edbapp.components.Others

   ..
       !! processed by numpydoc !!

.. py:property:: components_by_partname
   :type: Dict[str, List[pyedb.grpc.database.hierarchy.component.Component]]


   
   Dictionary of components grouped by part name.





   :Returns:

       :class:`python:dict`\[:class:`python:str`, :class:`python:list`\[:class:`pyedb.grpc.database.hierarchy.component.Component`]]
           Dictionary of components lists keyed by part name.










   .. rubric:: Examples

   >>> edbapp.components.components_by_partname

   ..
       !! processed by numpydoc !!




Method detail
-------------

.. py:method:: __getitem__(name: str) -> Optional[Union[pyedb.grpc.database.hierarchy.component.Component, pyedb.grpc.database.definition.component_def.ComponentDef]]

   
   Get a component or component definition by name.


   :Parameters:

       **name** : :class:`python:str`
           Name of the component or definition.



   :Returns:

       :class:`pyedb.grpc.database.hierarchy.component.Component` :obj:`or`
           ..

       :class:`pyedb.grpc.database.definition.component_def.ComponentDef` or :data:`python:None`
           Component instance if found, component definition if found by name, otherwise None.










   .. rubric:: Examples

   >>> component = edbapp.components["R1"]

   ..
       !! processed by numpydoc !!

.. py:method:: import_definition(file_path) -> bool

   
   Import component definitions from a JSON file.


   :Parameters:

       **file_path** : :class:`python:str`
           Path to the JSON file.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           True if successful, False otherwise.










   .. rubric:: Examples

   >>> edbapp.components.import_definition("definitions.json")

   ..
       !! processed by numpydoc !!

.. py:method:: export_definition(file_path) -> bool

   
   Export component definitions to a JSON file.


   :Parameters:

       **file_path** : :class:`python:str`
           Path to the output JSON file.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           True if successful, False otherwise.










   .. rubric:: Examples

   >>> edbapp.components.export_definition("exported_definitions.json")

   ..
       !! processed by numpydoc !!

.. py:method:: refresh_components() -> bool

   
   Refresh the component dictionary.





   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           True if successful, False otherwise.










   .. rubric:: Examples

   >>> edbapp.components.refresh_components()

   ..
       !! processed by numpydoc !!

.. py:method:: get_component_by_name(name) -> pyedb.grpc.database.hierarchy.component.Component

   
   Retrieve a component by name.


   :Parameters:

       **name** : :class:`python:str`
           Name of the component.



   :Returns:

       :class:`pyedb.grpc.database.hierarchy.component.Component`
           Component instance.










   .. rubric:: Examples

   >>> comp = edbapp.components.get_component_by_name("R1")

   ..
       !! processed by numpydoc !!

.. py:method:: get_pin_from_component(component: Union[str, pyedb.grpc.database.hierarchy.component.Component], net_name: Optional[Union[str, List[str]]] = None, pin_name: Optional[str] = None) -> List[Any]

   
   Get pins from a component with optional filtering.


   :Parameters:

       **component** : :class:`python:str` or :class:`pyedb.grpc.database.hierarchy.component.Component`
           Component name or instance.

       **net_name** : :class:`python:str` or :class:`python:list`\[:class:`python:str`], :obj:`optional`
           Net name(s) to filter by.

       **pin_name** : :class:`python:str`, :obj:`optional`
           Pin name to filter by.



   :Returns:

       :class:`python:list`\[:class:`pyedb.grpc.database.padstacks.PadstackInstance`]
           List of pin instances.










   .. rubric:: Examples

   >>> from pyedb import Edb
   >>> edb = Edb("my_aedb")
   >>> edb.components.get_pin_from_component("R1", net_name="GND")

   ..
       !! processed by numpydoc !!

.. py:method:: get_components_from_nets(netlist=None) -> list[str]

   
   Get components connected to specified nets.


   :Parameters:

       **netlist** : :class:`python:str` or :class:`python:list`\[:class:`python:str`], :obj:`optional`
           Net name(s) to filter by.



   :Returns:

       :class:`python:list`\[:class:`python:str`]
           List of component names.










   .. rubric:: Examples

   >>> comps = edbapp.components.get_components_from_nets(["GND", "VCC"])

   ..
       !! processed by numpydoc !!

.. py:method:: get_component_placement_vector(mounted_component: pyedb.grpc.database.hierarchy.component.Component, hosting_component: pyedb.grpc.database.hierarchy.component.Component, mounted_component_pin1: str, mounted_component_pin2: str, hosting_component_pin1: str, hosting_component_pin2: str, flipped: bool = False) -> Tuple[bool, List[float], float, float]

   
   Get placement vector between two components.


   :Parameters:

       **mounted_component** : :class:`pyedb.grpc.database.hierarchy.component.Component`
           Mounted component.

       **hosting_component** : :class:`pyedb.grpc.database.hierarchy.component.Component`
           Hosting component.

       **mounted_component_pin1** : :class:`python:str`
           Pin name on mounted component.

       **mounted_component_pin2** : :class:`python:str`
           Pin name on mounted component.

       **hosting_component_pin1** : :class:`python:str`
           Pin name on hosting component.

       **hosting_component_pin2** : :class:`python:str`
           Pin name on hosting component.

       **flipped** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Whether the component is flipped.



   :Returns:

       :class:`python:tuple`
           (success, vector, rotation, solder_ball_height)










   .. rubric:: Examples

   >>> success, vec, rot, height = edbapp.components.get_component_placement_vector(...)

   ..
       !! processed by numpydoc !!

.. py:method:: get_solder_ball_height(cmp: Union[str, pyedb.grpc.database.hierarchy.component.Component]) -> float

   
   Get solder ball height of a component.


   :Parameters:

       **cmp** : :class:`python:str` or :class:`pyedb.grpc.database.hierarchy.component.Component`
           Component name or instance.



   :Returns:

       :class:`python:float`
           Solder ball height in meters.










   .. rubric:: Examples

   >>> height = edbapp.components.get_solder_ball_height("U1")

   ..
       !! processed by numpydoc !!

.. py:method:: get_vendor_libraries() -> pyedb.component_libraries.ansys_components.ComponentLib

   
   Get vendor component libraries.





   :Returns:

       :class:`pyedb.component_libraries.ansys_components.ComponentLib`
           Component library object.










   .. rubric:: Examples

   >>> lib = edbapp.components.get_vendor_libraries()

   ..
       !! processed by numpydoc !!

.. py:method:: create_source_on_component(sources=None)

   
   Create sources on components.

   .. deprecated:: 0.28.0
       Use :func:`pyedb.grpc.core.excitations.create_source_on_component` instead.

   :Parameters:

       **sources** : :class:`python:list`, :obj:`optional`
           List of sources.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           True if successful, False otherwise.











   ..
       !! processed by numpydoc !!

.. py:method:: create_port_on_pins(refdes, pins, reference_pins, impedance=50.0, port_name=None, pec_boundary=False, pingroup_on_single_pin=False)

   
   Create port on pins.

   .. deprecated:: 0.28.0
       Use :func:`pyedb.grpc.core.excitations.create_port_on_pins` instead.

   :Parameters:

       **refdes** : :class:`python:str`
           Reference designator.

       **pins** : :class:`python:list`
           List of pins.

       **reference_pins** : :class:`python:list`
           List of reference pins.

       **impedance** : :class:`python:float`, :obj:`optional`
           Port impedance.

       **port_name** : :class:`python:str`, :obj:`optional`
           Port name.

       **pec_boundary** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Use PEC boundary.

       **pingroup_on_single_pin** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Use pin group on single pin.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           True if successful, False otherwise.











   ..
       !! processed by numpydoc !!

.. py:method:: create_port_on_component(component, net_list, port_type=SourceType.CoaxPort, do_pingroup=True, reference_net='gnd', port_name=None, solder_balls_height=None, solder_balls_size=None, solder_balls_mid_size=None, extend_reference_pins_outside_component=False)

   
   Create ports on a component.

   .. deprecated:: 0.28.0
       Use :func:`pyedb.grpc.core.excitations.create_port_on_component` instead.

   :Parameters:

       **component** : :class:`python:str`
           Component name.

       **net_list** : :class:`python:list`
           List of nets.

       **port_type** : :obj:`SourceType`, :obj:`optional`
           Port type.

       **do_pingroup** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Use pin groups.

       **reference_net** : :class:`python:str`, :obj:`optional`
           Reference net.

       **port_name** : :class:`python:str`, :obj:`optional`
           Port name.

       **solder_balls_height** : :class:`python:float`, :obj:`optional`
           Solder ball height.

       **solder_balls_size** : :class:`python:float`, :obj:`optional`
           Solder ball size.

       **solder_balls_mid_size** : :class:`python:float`, :obj:`optional`
           Solder ball mid size.

       **extend_reference_pins_outside_component** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Extend reference pins outside component.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           True if successful, False otherwise.











   ..
       !! processed by numpydoc !!

.. py:method:: create(pins: List[Any], component_name: Optional[str] = None, placement_layer: Optional[str] = None, component_part_name: Optional[str] = None, is_rlc: bool = False, r_value: Optional[float] = None, c_value: Optional[float] = None, l_value: Optional[float] = None, is_parallel: bool = False) -> Union[pyedb.grpc.database.hierarchy.component.Component, bool]

   
   Create a new component.


   :Parameters:

       **pins** : :class:`python:list`\[:class:`pyedb.grpc.database.padstacks.PadstackInstance`]
           List of pins.

       **component_name** : :class:`python:str`, :obj:`optional`
           Component name.

       **placement_layer** : :class:`python:str`, :obj:`optional`
           Placement layer name.

       **component_part_name** : :class:`python:str`, :obj:`optional`
           Part name.

       **is_rlc** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Whether the component is RLC.

       **r_value** : :class:`python:float`, :obj:`optional`
           Resistance value.

       **c_value** : :class:`python:float`, :obj:`optional`
           Capacitance value.

       **l_value** : :class:`python:float`, :obj:`optional`
           Inductance value.

       **is_parallel** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Whether RLC is parallel.



   :Returns:

       :class:`pyedb.grpc.database.hierarchy.component.Component` or :ref:`bool <python:bltin-boolean-values>`
           New component instance if successful, False otherwise.










   .. rubric:: Examples

   >>> new_comp = edbapp.components.create(pins, "R1")

   ..
       !! processed by numpydoc !!

.. py:method:: create_component_from_pins(pins, component_name, placement_layer=None, component_part_name=None) -> Union[pyedb.grpc.database.hierarchy.component.Component, bool]

   
   Create component from pins.

   .. deprecated:: 0.6.62
       Use :func:`create` instead.

   :Parameters:

       **pins** : :class:`python:list`
           List of pins.

       **component_name** : :class:`python:str`
           Component name.

       **placement_layer** : :class:`python:str`, :obj:`optional`
           Placement layer.

       **component_part_name** : :class:`python:str`, :obj:`optional`
           Part name.



   :Returns:

       :class:`pyedb.grpc.database.hierarchy.component.Component` or :ref:`bool <python:bltin-boolean-values>`
           Component instance if successful, False otherwise.











   ..
       !! processed by numpydoc !!

.. py:method:: set_component_model(componentname: str, model_type: str = 'Spice', modelpath: Optional[str] = None, modelname: Optional[str] = None) -> bool

   
   Set component model.


   :Parameters:

       **componentname** : :class:`python:str`
           Component name.

       **model_type** : :class:`python:str`, :obj:`optional`
           Model type ("Spice" or "Touchstone").

       **modelpath** : :class:`python:str`, :obj:`optional`
           Model file path.

       **modelname** : :class:`python:str`, :obj:`optional`
           Model name.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           True if successful, False otherwise.










   .. rubric:: Examples

   >>> edbapp.components.set_component_model("U1", "Spice", "path/to/model.sp")

   ..
       !! processed by numpydoc !!

.. py:method:: create_pingroup_from_pins(pins: List[Any], group_name: Optional[str] = None) -> Union[pyedb.grpc.database.hierarchy.pingroup.PinGroup, bool]

   
   Create pin group from pins.


   :Parameters:

       **pins** : :class:`python:list`\[:class:`pyedb.grpc.database.padstacks.PadstackInstance`]
           List of pins.

       **group_name** : :class:`python:str`, :obj:`optional`
           Group name.



   :Returns:

       :class:`pyedb.grpc.database.hierarchy.pingroup.PinGroup` or :ref:`bool <python:bltin-boolean-values>`
           Pin group instance if successful, False otherwise.










   .. rubric:: Examples

   >>> pingroup = edbapp.components.create_pingroup_from_pins(pins, "GND_pins")

   ..
       !! processed by numpydoc !!

.. py:method:: delete_single_pin_rlc(deactivate_only: bool = False) -> List[str]

   
   Delete or deactivate single-pin RLC components.


   :Parameters:

       **deactivate_only** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Whether to only deactivate instead of deleting.



   :Returns:

       :class:`python:list`\[:class:`python:str`]
           List of affected components.










   .. rubric:: Examples

   >>> deleted = edbapp.components.delete_single_pin_rlc()

   ..
       !! processed by numpydoc !!

.. py:method:: delete(component_name: str) -> bool

   
   Delete a component.


   :Parameters:

       **component_name** : :class:`python:str`
           Component name.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           True if successful, False otherwise.










   .. rubric:: Examples

   >>> edbapp.components.delete("R1")

   ..
       !! processed by numpydoc !!

.. py:method:: disable_rlc_component(component_name: str) -> bool

   
   Disable RLC component.


   :Parameters:

       **component_name** : :class:`python:str`
           Component name.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           True if successful, False otherwise.










   .. rubric:: Examples

   >>> edbapp.components.disable_rlc_component("R1")

   ..
       !! processed by numpydoc !!

.. py:method:: set_solder_ball(component: Union[str, pyedb.grpc.database.hierarchy.component.Component] = '', sball_diam: Optional[float] = None, sball_height: Optional[float] = None, shape: str = 'Cylinder', sball_mid_diam: Optional[float] = None, chip_orientation: str = 'chip_down', auto_reference_size: bool = True, reference_size_x: float = 0, reference_size_y: float = 0, reference_height: float = 0) -> bool

   
   Set solder ball properties for a component.


   :Parameters:

       **component** : :class:`python:str` or :class:`pyedb.grpc.database.hierarchy.component.Component`, :obj:`optional`
           Component name or instance.

       **sball_diam** : :class:`python:float`, :obj:`optional`
           Solder ball diameter.

       **sball_height** : :class:`python:float`, :obj:`optional`
           Solder ball height.

       **shape** : :class:`python:str`, :obj:`optional`
           Solder ball shape ("Cylinder" or "Spheroid").

       **sball_mid_diam** : :class:`python:float`, :obj:`optional`
           Solder ball mid diameter.

       **chip_orientation** : :class:`python:str`, :obj:`optional`
           Chip orientation ("chip_down" or "chip_up").

       **auto_reference_size** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Use auto reference size.

       **reference_size_x** : :class:`python:float`, :obj:`optional`
           Reference size X.

       **reference_size_y** : :class:`python:float`, :obj:`optional`
           Reference size Y.

       **reference_height** : :class:`python:float`, :obj:`optional`
           Reference height.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           True if successful, False otherwise.










   .. rubric:: Examples

   >>> edbapp.components.set_solder_ball("U1", sball_diam=0.5e-3)

   ..
       !! processed by numpydoc !!

.. py:method:: set_component_rlc(componentname: str, res_value: Optional[float] = None, ind_value: Optional[float] = None, cap_value: Optional[float] = None, isparallel: bool = False) -> bool

   
   Set RLC values for a component.


   :Parameters:

       **componentname** : :class:`python:str`
           Component name.

       **res_value** : :class:`python:float`, :obj:`optional`
           Resistance value.

       **ind_value** : :class:`python:float`, :obj:`optional`
           Inductance value.

       **cap_value** : :class:`python:float`, :obj:`optional`
           Capacitance value.

       **isparallel** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Whether RLC is parallel.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           True if successful, False otherwise.










   .. rubric:: Examples

   >>> edbapp.components.set_component_rlc("R1", res_value=50)

   ..
       !! processed by numpydoc !!

.. py:method:: update_rlc_from_bom(bom_file: str, delimiter: str = ';', valuefield: str = 'Func des', comptype: str = 'Prod name', refdes: str = 'Pos / Place') -> bool

   
   Update RLC values from BOM file.


   :Parameters:

       **bom_file** : :class:`python:str`
           BOM file path.

       **delimiter** : :class:`python:str`, :obj:`optional`
           Delimiter character.

       **valuefield** : :class:`python:str`, :obj:`optional`
           Value field name.

       **comptype** : :class:`python:str`, :obj:`optional`
           Component type field name.

       **refdes** : :class:`python:str`, :obj:`optional`
           Reference designator field name.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           True if successful, False otherwise.










   .. rubric:: Examples

   >>> edbapp.components.update_rlc_from_bom("bom.csv")

   ..
       !! processed by numpydoc !!

.. py:method:: import_bom(bom_file: str, delimiter: str = ',', refdes_col: int = 0, part_name_col: int = 1, comp_type_col: int = 2, value_col: int = 3) -> bool

   
   Import BOM file.


   :Parameters:

       **bom_file** : :class:`python:str`
           BOM file path.

       **delimiter** : :class:`python:str`, :obj:`optional`
           Delimiter character.

       **refdes_col** : :class:`python:int`, :obj:`optional`
           Reference designator column index.

       **part_name_col** : :class:`python:int`, :obj:`optional`
           Part name column index.

       **comp_type_col** : :class:`python:int`, :obj:`optional`
           Component type column index.

       **value_col** : :class:`python:int`, :obj:`optional`
           Value column index.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           True if successful, False otherwise.










   .. rubric:: Examples

   >>> edbapp.components.import_bom("bom.csv")

   ..
       !! processed by numpydoc !!

.. py:method:: export_bom(bom_file: str, delimiter: str = ',') -> bool

   
   Export BOM file.


   :Parameters:

       **bom_file** : :class:`python:str`
           Output file path.

       **delimiter** : :class:`python:str`, :obj:`optional`
           Delimiter character.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           True if successful, False otherwise.










   .. rubric:: Examples

   >>> edbapp.components.export_bom("exported_bom.csv")

   ..
       !! processed by numpydoc !!

.. py:method:: find_by_reference_designator(reference_designator: str) -> pyedb.grpc.database.hierarchy.component.Component

   
   Find component by reference designator.


   :Parameters:

       **reference_designator** : :class:`python:str`
           Reference designator.



   :Returns:

       :class:`pyedb.grpc.database.hierarchy.component.Component`
           Component instance.










   .. rubric:: Examples

   >>> comp = edbapp.components.find_by_reference_designator("R1")

   ..
       !! processed by numpydoc !!

.. py:method:: get_aedt_pin_name(pin: Any) -> str

   
   Get AEDT pin name.


   :Parameters:

       **pin** : :class:`pyedb.grpc.database.padstacks.PadstackInstance`
           Pin instance.



   :Returns:

       :class:`python:str`
           AEDT pin name.










   .. rubric:: Examples

   >>> name = edbapp.components.get_aedt_pin_name(pin)

   ..
       !! processed by numpydoc !!

.. py:method:: get_pins(reference_designator: str, net_name: Optional[str] = None, pin_name: Optional[str] = None) -> Dict[str, Any]

   
   Get pins of a component.


   :Parameters:

       **reference_designator** : :class:`python:str`
           Reference designator.

       **net_name** : :class:`python:str`, :obj:`optional`
           Net name filter.

       **pin_name** : :class:`python:str`, :obj:`optional`
           Pin name filter.



   :Returns:

       :class:`python:dict`
           Dictionary of pins.










   .. rubric:: Examples

   >>> pins = edbapp.components.get_pins("U1", net_name="GND")

   ..
       !! processed by numpydoc !!

.. py:method:: get_pin_position(pin: Any) -> List[float]

   
   Get pin position.


   :Parameters:

       **pin** : :class:`pyedb.grpc.database.padstacks.PadstackInstance`
           Pin instance.



   :Returns:

       :class:`python:list`\[:class:`python:float`]
           [x, y] position in meters.










   .. rubric:: Examples

   >>> pos = edbapp.components.get_pin_position(pin)

   ..
       !! processed by numpydoc !!

.. py:method:: get_pins_name_from_net(net_name: str, pin_list: Optional[List[Any]] = None) -> List[str]

   
   Get pin names from net.


   :Parameters:

       **net_name** : :class:`python:str`
           Net name.

       **pin_list** : :class:`python:list`, :obj:`optional`
           List of pins to search.



   :Returns:

       :class:`python:list`\[:class:`python:str`]
           List of pin names.










   .. rubric:: Examples

   >>> pins = edbapp.components.get_pins_name_from_net("GND")

   ..
       !! processed by numpydoc !!

.. py:method:: get_nets_from_pin_list(pins: List[Any]) -> List[str]

   
   Get nets from pin list.


   :Parameters:

       **pins** : :class:`python:list`
           List of pins.



   :Returns:

       :class:`python:list`\[:class:`python:str`]
           List of net names.










   .. rubric:: Examples

   >>> nets = edbapp.components.get_nets_from_pin_list(pins)

   ..
       !! processed by numpydoc !!

.. py:method:: get_component_net_connection_info(refdes: str) -> Dict[str, List[str]]

   
   Get net connection info for a component.


   :Parameters:

       **refdes** : :class:`python:str`
           Reference designator.



   :Returns:

       :class:`python:dict`
           Dictionary with refdes, pin_name, and net_name.










   .. rubric:: Examples

   >>> info = edbapp.components.get_component_net_connection_info("U1")

   ..
       !! processed by numpydoc !!

.. py:method:: get_rats() -> List[Dict[str, List[str]]]

   
   Get RATS (Reference Designator, Pin, Net) information.





   :Returns:

       :class:`python:list`\[:class:`python:dict`]
           List of dictionaries with refdes, pin_name, and net_name.










   .. rubric:: Examples

   >>> rats = edbapp.components.get_rats()

   ..
       !! processed by numpydoc !!

.. py:method:: get_through_resistor_list(threshold: float = 1) -> List[str]

   
   Get through resistors below threshold.


   :Parameters:

       **threshold** : :class:`python:float`, :obj:`optional`
           Resistance threshold.



   :Returns:

       :class:`python:list`\[:class:`python:str`]
           List of component names.










   .. rubric:: Examples

   >>> resistors = edbapp.components.get_through_resistor_list(1)

   ..
       !! processed by numpydoc !!

.. py:method:: short_component_pins(component_name: str, pins_to_short: Optional[List[str]] = None, width: float = 0.001) -> bool

   
   Short component pins with traces.


   :Parameters:

       **component_name** : :class:`python:str`
           Component name.

       **pins_to_short** : :class:`python:list`\[:class:`python:str`], :obj:`optional`
           List of pin names to short.

       **width** : :class:`python:float`, :obj:`optional`
           Trace width.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           True if successful, False otherwise.










   .. rubric:: Examples

   >>> edbapp.components.short_component_pins("J4A2", ["G4", "9", "3"])

   ..
       !! processed by numpydoc !!

.. py:method:: create_pin_group(reference_designator: str, pin_numbers: Union[str, List[str]], group_name: Optional[str] = None) -> Union[Tuple[str, pyedb.grpc.database.hierarchy.pingroup.PinGroup], bool]

   
   Create pin group on a component.


   :Parameters:

       **reference_designator** : :class:`python:str`
           Reference designator.

       **pin_numbers** : :class:`python:list`\[:class:`python:str`]
           List of pin names.

       **group_name** : :class:`python:str`, :obj:`optional`
           Group name.



   :Returns:

       :class:`python:tuple`\[:class:`python:str`, :class:`pyedb.grpc.database.hierarchy.pingroup.PinGroup`] :obj:`or` :ref:`bool <python:bltin-boolean-values>`
           (group_name, PinGroup) if successful, False otherwise.










   .. rubric:: Examples

   >>> name, group = edbapp.components.create_pin_group("U1", ["1", "2"])

   ..
       !! processed by numpydoc !!

.. py:method:: create_pin_group_on_net(reference_designator: str, net_name: str, group_name: Optional[str] = None) -> Union[pyedb.grpc.database.hierarchy.pingroup.PinGroup, Tuple[str, pyedb.grpc.database.hierarchy.pingroup.PinGroup], bool]

   
   Create pin group by net name.


   :Parameters:

       **reference_designator** : :class:`python:str`
           Reference designator.

       **net_name** : :class:`python:str`
           Net name.

       **group_name** : :class:`python:str`, :obj:`optional`
           Group name.



   :Returns:

       :class:`pyedb.grpc.database.hierarchy.pingroup.PinGroup`
           Pin group instance.










   .. rubric:: Examples

   >>> group = edbapp.components.create_pin_group_on_net("U1", "GND")

   ..
       !! processed by numpydoc !!

.. py:method:: deactivate_rlc_component(component: Optional[str] = None, create_circuit_port: bool = False, pec_boundary: bool = False) -> bool

   
   Deactivate RLC component with a possibility to convert it to a circuit port.


   :Parameters:

       **component** : :class:`python:str`
           Reference designator of the RLC component.

       **create_circuit_port** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Whether to replace the deactivated RLC component with a circuit port. The default
           is ``False``.

       **pec_boundary** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Whether to define the PEC boundary, The default is ``False``. If set to ``True``,
           a perfect short is created between the pin and impedance is ignored. This
           parameter is only supported on a port created between two pins, such as
           when there is no pin group.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ``True`` when successful, ``False`` when failed.










   .. rubric:: Examples

   >>> from pyedb import Edb
   >>> edb_file = r"C:\my_edb_file.aedb"
   >>> edb = Edb(edb_file)
   >>> for cmp in list(edb.components.instances.keys()):
   >>>     edb.components.deactivate_rlc_component(component=cmp, create_circuit_port=False)
   >>> edb.save()
   >>> edb.close()

   ..
       !! processed by numpydoc !!

.. py:method:: add_port_on_rlc_component(component: Optional[Union[str, pyedb.grpc.database.hierarchy.component.Component]] = None, circuit_ports: bool = True, pec_boundary: bool = False) -> bool

   
   Deactivate RLC component and replace it with a circuit port.
   The circuit port supports only two-pin components.


   :Parameters:

       **component** : :class:`python:str`
           Reference designator of the RLC component.

       **circuit_ports** : :ref:`bool <python:bltin-boolean-values>`
           ``True`` will replace RLC component by circuit ports, ``False`` gap ports compatible with HFSS 3D modeler
           export.

       **pec_boundary** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Whether to define the PEC boundary, The default is ``False``. If set to ``True``,
           a perfect short is created between the pin and impedance is ignored. This
           parameter is only supported on a port created between two pins, such as
           when there is no pin group.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ``True`` when successful, ``False`` when failed.










   .. rubric:: Examples

   >>> from pyedb import Edb
   >>> edb = Edb()
   >>> edb.source_excitation.add_port_on_rlc_component("R1")

   ..
       !! processed by numpydoc !!

.. py:method:: replace_rlc_by_gap_boundaries(component: Optional[Union[str, pyedb.grpc.database.hierarchy.component.Component]] = None) -> bool

   
   Replace RLC component by RLC gap boundaries. These boundary types are compatible with 3D modeler export.
   Only 2 pins RLC components are supported in this command.


   :Parameters:

       **component** : :class:`python:str`
           Reference designator of the RLC component.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ..

       ``True`` :obj:`when` :obj:`succeed`, ``False`` :obj:`if` :obj:`it` failed.
           ..










   .. rubric:: Examples

   >>> from pyedb import Edb
   >>> edb = Edb("edb_file")
   >>>  for refdes, cmp in edb.components.capacitors.items():
   >>>     edb.components.replace_rlc_by_gap_boundaries(refdes)
   >>> edb.save()
   >>> edb.close()

   ..
       !! processed by numpydoc !!

.. py:method:: add_rlc_boundary(component: Optional[Union[str, pyedb.grpc.database.hierarchy.component.Component]] = None, circuit_type: bool = True) -> bool

   
   Add RLC gap boundary on component and replace it with a circuit port.
   The circuit port supports only 2-pin components.

   . deprecated:: pyedb 0.28.0
   Use :func:`pyedb.grpc.core.excitations.add_rlc_boundary` instead.

   :Parameters:

       **component** : :class:`python:str`
           Reference designator of the RLC component.

       **circuit_type** : :ref:`bool <python:bltin-boolean-values>`
           When ``True`` circuit type are defined, if ``False`` gap type will be used instead (compatible with HFSS 3D
           modeler). Default value is ``True``.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ``True`` when successful, ``False`` when failed.











   ..
       !! processed by numpydoc !!




