





:class:`Stackup`
================


.. py:class:: pyedb.dotnet.database.stackup.Stackup(pedb, edb_object=None)

   Bases: :py:obj:`LayerCollection`


   
   Manages EDB methods for stackup accessible from `Edb.stackup` property.
















   ..
       !! processed by numpydoc !!



.. py:currentmodule:: Stackup

Overview
--------

.. tab-set::



   .. tab-item:: Methods

      .. list-table::
          :header-rows: 0
          :widths: auto

          * - :py:attr:`~create_symmetric_stackup`
            - Create a symmetric stackup.
          * - :py:attr:`~add_outline_layer`
            - Add an outline layer named ``"Outline"`` if it is not present.
          * - :py:attr:`~add_layer`
            - Insert a layer into stackup.
          * - :py:attr:`~remove_layer`
            - Remove a layer from stackup.
          * - :py:attr:`~export`
            - Export stackup definition to a CSV or JSON file.
          * - :py:attr:`~export_stackup`
            - Export stackup definition to a CSV or JSON file.
          * - :py:attr:`~stackup_limits`
            - Retrieve stackup limits.
          * - :py:attr:`~limits`
            - Retrieve stackup limits.
          * - :py:attr:`~flip_design`
            - Flip the current design of a layout.
          * - :py:attr:`~get_layout_thickness`
            - Return the layout thickness.
          * - :py:attr:`~adjust_solder_dielectrics`
            - Adjust the stack-up by adding or modifying dielectric layers that contains Solder Balls.
          * - :py:attr:`~place_in_layout`
            - Place current Cell into another cell using layer placement method.
          * - :py:attr:`~place_in_layout_3d_placement`
            - Place current Cell into another cell using 3d placement method.
          * - :py:attr:`~place_instance`
            - Place current Cell into another cell using 3d placement method.
          * - :py:attr:`~place_a3dcomp_3d_placement`
            - Place a 3D Component into current layout.
          * - :py:attr:`~residual_copper_area_per_layer`
            - Report residual copper area per layer in percentage.
          * - :py:attr:`~load`
            - Import stackup from a file. The file format can be XML, CSV, or JSON. Valid control file must
          * - :py:attr:`~plot`
            - Plot current stackup and, optionally, overlap padstack definitions.
          * - :py:attr:`~load_from_xml`
            - Load stackup from a XML file.


   .. tab-item:: Properties

      .. list-table::
          :header-rows: 0
          :widths: auto

          * - :py:attr:`~layer_types`
            - Layer types.
          * - :py:attr:`~thickness`
            - Retrieve Stackup thickness.
          * - :py:attr:`~num_layers`
            - Retrieve the stackup layer number.
          * - :py:attr:`~mode`
            - Stackup mode.
          * - :py:attr:`~stackup_mode`
            - Stackup mode.
          * - :py:attr:`~signal_layers`
            - Retrieve the dictionary of signal layers.
          * - :py:attr:`~dielectric_layers`
            - Dielectric layers.




   .. tab-item:: Special methods

      .. list-table::
          :header-rows: 0
          :widths: auto

          * - :py:attr:`~__getitem__`
            - 




Import detail
-------------

.. code-block:: python

    from pyedb.dotnet.database.stackup import Stackup

Property detail
---------------

.. py:property:: layer_types

   
   Layer types.



   :Returns:

       :obj:`type`
           Types of layers.













   ..
       !! processed by numpydoc !!

.. py:property:: thickness

   
   Retrieve Stackup thickness.



   :Returns:

       :class:`python:float`
           Layout stackup thickness.













   ..
       !! processed by numpydoc !!

.. py:property:: num_layers

   
   Retrieve the stackup layer number.



   :Returns:

       :class:`python:int`
           layer number.













   ..
       !! processed by numpydoc !!

.. py:property:: mode

   
   Stackup mode.



   :Returns:

       :class:`python:int`, :class:`python:str`
           Type of the stackup mode, where:
           
           * 0 - Laminate
           * 1 - Overlapping
           * 2 - MultiZone













   ..
       !! processed by numpydoc !!

.. py:property:: stackup_mode

   
   Stackup mode.

   .. deprecated:: 0.6.52
      Use :func:`mode` method instead.


   :Returns:

       :class:`python:int`, :class:`python:str`
           Type of the stackup mode, where:
           
           * 0 - Laminate
           * 1 - Overlapping
           * 2 - MultiZone













   ..
       !! processed by numpydoc !!

.. py:property:: signal_layers

   
   Retrieve the dictionary of signal layers.



   :Returns:

       :obj:`Dict`\[:class:`python:str`, :class:`pyedb.dotnet.database.edb_data.layer_data.LayerEdbClass`]
           ..













   ..
       !! processed by numpydoc !!

.. py:property:: dielectric_layers

   
   Dielectric layers.



   :Returns:

       :class:`python:dict`\[:class:`python:str`, :class:`dotnet.database.edb_data.layer_data.EDBLayer`]
           Dictionary of dielectric layers.













   ..
       !! processed by numpydoc !!




Method detail
-------------

.. py:method:: __getitem__(item)

.. py:method:: create_symmetric_stackup(layer_count, inner_layer_thickness='17um', outer_layer_thickness='50um', dielectric_thickness='100um', dielectric_material='FR4_epoxy', soldermask=True, soldermask_thickness='20um')

   
   Create a symmetric stackup.


   :Parameters:

       **layer_count** : :class:`python:int`
           Number of layer count.

       **inner_layer_thickness** : :class:`python:str`, :class:`python:float`, :obj:`optional`
           Thickness of inner conductor layer.

       **outer_layer_thickness** : :class:`python:str`, :class:`python:float`, :obj:`optional`
           Thickness of outer conductor layer.

       **dielectric_thickness** : :class:`python:str`, :class:`python:float`, :obj:`optional`
           Thickness of dielectric layer.

       **dielectric_material** : :class:`python:str`, :obj:`optional`
           Material of dielectric layer.

       **soldermask** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Whether to create soldermask layers. The default is``True``.

       **soldermask_thickness** : :class:`python:str`, :obj:`optional`
           Thickness of soldermask layer.

   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ..













   ..
       !! processed by numpydoc !!

.. py:method:: add_outline_layer(outline_name='Outline')

   
   Add an outline layer named ``"Outline"`` if it is not present.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           "True" if successful, ``False`` if failed.













   ..
       !! processed by numpydoc !!

.. py:method:: add_layer(layer_name, base_layer=None, method='add_on_top', layer_type='signal', material='copper', fillMaterial='FR4_epoxy', thickness='35um', etch_factor=None, is_negative=False, enable_roughness=False, elevation=None)

   
   Insert a layer into stackup.


   :Parameters:

       **layer_name** : :class:`python:str`
           Name of the layer.

       **base_layer** : :class:`python:str`, :obj:`optional`
           Name of the base layer.

       **method** : :class:`python:str`, :obj:`optional`
           Where to insert the new layer. The default is ``"add_on_top"``. Options are ``"add_on_top"``,
           ``"add_on_bottom"``, ``"insert_above"``, ``"insert_below"``, ``"add_at_elevation"``,.

       **layer_type** : :class:`python:str`, :obj:`optional`
           Type of layer. The default is ``"signal"``. Options are ``"signal"``, ``"dielectric"``, ``"conducting"``,
            ``"air_lines"``, ``"error"``, ``"symbol"``, ``"measure"``, ``"assembly"``, ``"silkscreen"``,
            ``"solder_mask"``, ``"solder_paste"``, ``"glue"``, ``"wirebond"``, ``"hfss_region"``, ``"user"``.

       **material** : :class:`python:str`, :obj:`optional`
           Material of the layer.

       **fillMaterial** : :class:`python:str`, :obj:`optional`
           Fill material of the layer.

       **thickness** : :class:`python:str`, :class:`python:float`, :obj:`optional`
           Thickness of the layer.

       **etch_factor** : :class:`python:int`, :class:`python:float`, :obj:`optional`
           Etch factor of the layer.

       **is_negative** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Whether the layer is negative.

       **enable_roughness** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Whether roughness is enabled.

       **elevation** : :class:`python:float`, :obj:`optional`
           Elevation of new layer. Only valid for Overlapping Stackup.

   :Returns:

       :class:`pyedb.dotnet.database.edb_data.layer_data.LayerEdbClass`
           ..













   ..
       !! processed by numpydoc !!

.. py:method:: remove_layer(name)

   
   Remove a layer from stackup.


   :Parameters:

       **name** : :class:`python:str`
           Name of the layer to remove.

   :Returns:

       
           ..













   ..
       !! processed by numpydoc !!

.. py:method:: export(fpath, file_format='xml', include_material_with_layer=False)

   
   Export stackup definition to a CSV or JSON file.


   :Parameters:

       **fpath** : :class:`python:str`
           File path to csv or json file.

       **file_format** : :class:`python:str`, :obj:`optional`
           Format of the file to export. The default is ``"csv"``. Options are ``"csv"``, ``"xlsx"``,
           ``"json"``.

       **include_material_with_layer** : :ref:`bool <python:bltin-boolean-values>`, optional.
           Whether to include the material definition inside layer ones. This parameter is only used
           when a JSON file is exported. The default is ``False``, which keeps the material definition
           section in the JSON file. If ``True``, the material definition is included inside the layer ones.











   .. rubric:: Examples

   >>> from pyedb import Edb
   >>> edb = Edb()
   >>> edb.stackup.export("stackup.xml")



   ..
       !! processed by numpydoc !!

.. py:method:: export_stackup(fpath, file_format='xml', include_material_with_layer=False)

   
   Export stackup definition to a CSV or JSON file.

   .. deprecated:: 0.6.61
      Use :func:`export` instead.

   :Parameters:

       **fpath** : :class:`python:str`
           File path to CSV or JSON file.

       **file_format** : :class:`python:str`, :obj:`optional`
           Format of the file to export. The default is ``"csv"``. Options are ``"csv"``, ``"xlsx"``
           and ``"json"``.

       **include_material_with_layer** : :ref:`bool <python:bltin-boolean-values>`, optional.
           Whether to include the material definition inside layer objects. This parameter is only used
           when a JSON file is exported. The default is ``False``, which keeps the material definition
           section in the JSON file. If ``True``, the material definition is included inside the layer ones.











   .. rubric:: Examples

   >>> from pyedb import Edb
   >>> edb = Edb()
   >>> edb.stackup.export_stackup("stackup.xml")



   ..
       !! processed by numpydoc !!

.. py:method:: stackup_limits(only_metals=False)

   
   Retrieve stackup limits.

   .. deprecated:: 0.6.62
      Use :func:`Edb.stackup.limits` function instead.

   :Parameters:

       **only_metals** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Whether to retrieve only metals. The default is ``False``.

   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ``True`` when successful, ``False`` when failed.













   ..
       !! processed by numpydoc !!

.. py:method:: limits(only_metals=False)

   
   Retrieve stackup limits.


   :Parameters:

       **only_metals** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Whether to retrieve only metals. The default is ``False``.

   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ``True`` when successful, ``False`` when failed.













   ..
       !! processed by numpydoc !!

.. py:method:: flip_design()

   
   Flip the current design of a layout.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ``True`` when succeed ``False`` if not.










   .. rubric:: Examples

   >>> edb = Edb(edbpath=targetfile, edbversion="2021.2")
   >>> edb.stackup.flip_design()
   >>> edb.save()
   >>> edb.close_edb()



   ..
       !! processed by numpydoc !!

.. py:method:: get_layout_thickness()

   
   Return the layout thickness.



   :Returns:

       :class:`python:float`
           The thickness value.













   ..
       !! processed by numpydoc !!

.. py:method:: adjust_solder_dielectrics()

   
   Adjust the stack-up by adding or modifying dielectric layers that contains Solder Balls.
   This method identifies the solder-ball height and adjust the dielectric thickness on top (or bottom) to fit
   the thickness in order to merge another layout.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ..













   ..
       !! processed by numpydoc !!

.. py:method:: place_in_layout(edb, angle=0.0, offset_x=0.0, offset_y=0.0, flipped_stackup=True, place_on_top=True)

   
   Place current Cell into another cell using layer placement method.
   Flip the current layer stackup of a layout if requested. Transform parameters currently not supported.


   :Parameters:

       **edb** : :obj:`Edb`
           Cell on which to place the current layout. If None the Cell will be applied on an empty new Cell.

       **angle** : :obj:`double`, :obj:`optional`
           The rotation angle applied on the design.

       **offset_x** : :obj:`double`, :obj:`optional`
           The x offset value.

       **offset_y** : :obj:`double`, :obj:`optional`
           The y offset value.

       **flipped_stackup** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Either if the current layout is inverted.
           If `True` and place_on_top is `True` the stackup will be flipped before the merge.

       **place_on_top** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Either if place the current layout on Top or Bottom of destination Layout.

   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ``True`` when succeed ``False`` if not.










   .. rubric:: Examples

   >>> edb1 = Edb(edbpath=targetfile1, edbversion="2021.2")
   >>> edb2 = Edb(edbpath=targetfile2, edbversion="2021.2")

   >>> hosting_cmp = edb1.components.get_component_by_name("U100")
   >>> mounted_cmp = edb2.components.get_component_by_name("BGA")

   >>> vector, rotation, solder_ball_height = edb1.components.get_component_placement_vector(
   ...     mounted_component=mounted_cmp,
   ...     hosting_component=hosting_cmp,
   ...     mounted_component_pin1="A12",
   ...     mounted_component_pin2="A14",
   ...     hosting_component_pin1="A12",
   ...     hosting_component_pin2="A14",
   ... )
   >>> edb2.stackup.place_in_layout(
   ...     edb1.active_cell,
   ...     angle=0.0,
   ...     offset_x=vector[0],
   ...     offset_y=vector[1],
   ...     flipped_stackup=False,
   ...     place_on_top=True,
   ... )



   ..
       !! processed by numpydoc !!

.. py:method:: place_in_layout_3d_placement(edb, angle=0.0, offset_x=0.0, offset_y=0.0, flipped_stackup=True, place_on_top=True, solder_height=0)

   
   Place current Cell into another cell using 3d placement method.
   Flip the current layer stackup of a layout if requested. Transform parameters currently not supported.


   :Parameters:

       **edb** : :obj:`Edb`
           Cell on which to place the current layout. If None the Cell will be applied on an empty new Cell.

       **angle** : :obj:`double`, :obj:`optional`
           The rotation angle applied on the design.

       **offset_x** : :obj:`double`, :obj:`optional`
           The x offset value.

       **offset_y** : :obj:`double`, :obj:`optional`
           The y offset value.

       **flipped_stackup** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Either if the current layout is inverted.
           If `True` and place_on_top is `True` the stackup will be flipped before the merge.

       **place_on_top** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Either if place the current layout on Top or Bottom of destination Layout.

       **solder_height** : :class:`python:float`, :obj:`optional`
           Solder Ball or Bumps eight.
           This value will be added to the elevation to align the two layouts.

   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ``True`` when succeed ``False`` if not.










   .. rubric:: Examples

   >>> edb1 = Edb(edbpath=targetfile1, edbversion="2021.2")
   >>> edb2 = Edb(edbpath=targetfile2, edbversion="2021.2")
   >>> hosting_cmp = edb1.components.get_component_by_name("U100")
   >>> mounted_cmp = edb2.components.get_component_by_name("BGA")
   >>> edb2.stackup.place_in_layout(
   ...     edb1.active_cell,
   ...     angle=0.0,
   ...     offset_x="1mm",
   ...     offset_y="2mm",
   ...     flipped_stackup=False,
   ...     place_on_top=True,
   ... )



   ..
       !! processed by numpydoc !!

.. py:method:: place_instance(component_edb, angle=0.0, offset_x=0.0, offset_y=0.0, offset_z=0.0, flipped_stackup=True, place_on_top=True, solder_height=0)

   
   Place current Cell into another cell using 3d placement method.
   Flip the current layer stackup of a layout if requested. Transform parameters currently not supported.


   :Parameters:

       **component_edb** : :obj:`Edb`
           Cell to place in the current layout.

       **angle** : :obj:`double`, :obj:`optional`
           The rotation angle applied on the design.

       **offset_x** : :obj:`double`, :obj:`optional`
           The x offset value.
           The default value is ``0.0``.

       **offset_y** : :obj:`double`, :obj:`optional`
           The y offset value.
           The default value is ``0.0``.

       **offset_z** : :obj:`double`, :obj:`optional`
           The z offset value. (i.e. elevation offset for placement relative to the top layer conductor).
           The default value is ``0.0``, which places the cell layout on top of the top conductor
           layer of the target EDB.

       **flipped_stackup** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Either if the current layout is inverted.
           If `True` and place_on_top is `True` the stackup will be flipped before the merge.

       **place_on_top** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Either if place the component_edb layout on Top or Bottom of destination Layout.

       **solder_height** : :class:`python:float`, :obj:`optional`
           Solder Ball or Bumps eight.
           This value will be added to the elevation to align the two layouts.

   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ``True`` when succeed ``False`` if not.










   .. rubric:: Examples

   >>> edb1 = Edb(edbpath=targetfile1, edbversion="2021.2")
   >>> edb2 = Edb(edbpath=targetfile2, edbversion="2021.2")
   >>> hosting_cmp = edb1.components.get_component_by_name("U100")
   >>> mounted_cmp = edb2.components.get_component_by_name("BGA")
   >>> edb1.stackup.place_instance(
   ...     edb2,
   ...     angle=0.0,
   ...     offset_x="1mm",
   ...     offset_y="2mm",
   ...     flipped_stackup=False,
   ...     place_on_top=True,
   ... )



   ..
       !! processed by numpydoc !!

.. py:method:: place_a3dcomp_3d_placement(a3dcomp_path, angle=0.0, offset_x=0.0, offset_y=0.0, offset_z=0.0, place_on_top=True)

   
   Place a 3D Component into current layout.
    3D Component ports are not visible via EDB. They will be visible after the EDB has been opened in Ansys
    Electronics Desktop as a project.


   :Parameters:

       **a3dcomp_path** : :class:`python:str`
           Path to the 3D Component file (\*.a3dcomp) to place.

       **angle** : :obj:`double`, :obj:`optional`
           Clockwise rotation angle applied to the a3dcomp.

       **offset_x** : :obj:`double`, :obj:`optional`
           The x offset value.
           The default value is ``0.0``.

       **offset_y** : :obj:`double`, :obj:`optional`
           The y offset value.
           The default value is ``0.0``.

       **offset_z** : :obj:`double`, :obj:`optional`
           The z offset value. (i.e. elevation)
           The default value is ``0.0``.

       **place_on_top** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Whether to place the 3D Component on the top or the bottom of this layout.
           If ``False`` then the 3D Component will also be flipped over around its X axis.

   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ``True`` if successful and ``False`` if not.










   .. rubric:: Examples

   >>> edb1 = Edb(edbpath=targetfile1, edbversion="2021.2")
   >>> a3dcomp_path = "connector.a3dcomp"
   >>> edb1.stackup.place_a3dcomp_3d_placement(
   ...     a3dcomp_path,
   ...     angle=0.0,
   ...     offset_x="1mm",
   ...     offset_y="2mm",
   ...     flipped_stackup=False,
   ...     place_on_top=True,
   ... )



   ..
       !! processed by numpydoc !!

.. py:method:: residual_copper_area_per_layer()

   
   Report residual copper area per layer in percentage.



   :Returns:

       :class:`python:dict`
           Copper area per layer.










   .. rubric:: Examples

   >>> edb = Edb(edbpath=targetfile1, edbversion="2021.2")
   >>> edb.stackup.residual_copper_area_per_layer()



   ..
       !! processed by numpydoc !!

.. py:method:: load(file_path, rename=False)

   
   Import stackup from a file. The file format can be XML, CSV, or JSON. Valid control file must
   have the same number of signal layers. Signals layers can be renamed. Dielectric layers can be
   added and deleted.


   :Parameters:

       **file_path** : :class:`python:str`, :class:`python:dict`
           Path to stackup file or dict with stackup details.

       **rename** : :ref:`bool <python:bltin-boolean-values>`
           If rename is ``False`` then layer in layout not found in the stackup file are deleted.
           Otherwise, if the number of layer in the stackup file equals the number of stackup layer
           in the layout, layers are renamed according the file.
           Note that layer order matters, and has to be writtent from top to bottom layer in the file.

   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ``True`` when successful, ``False`` when failed.










   .. rubric:: Examples

   >>> from pyedb import Edb
   >>> edb = Edb()
   >>> edb.stackup.load("stackup.xml")



   ..
       !! processed by numpydoc !!

.. py:method:: plot(save_plot=None, size=(2000, 1500), plot_definitions=None, first_layer=None, last_layer=None, scale_elevation=True, show=True)

   
   Plot current stackup and, optionally, overlap padstack definitions.
   Plot supports only 'Laminate' and 'Overlapping' stackup types.


   :Parameters:

       **save_plot** : :class:`python:str`, :obj:`optional`
           If a path is specified the plot will be saved in this location.
           If ``save_plot`` is provided, the ``show`` parameter is ignored.

       **size** : :class:`python:tuple`, :obj:`optional`
           Image size in pixel (width, height). Default value is ``(2000, 1500)``

       **plot_definitions** : :class:`python:str`, :class:`python:list`, :obj:`optional`
           List of padstack definitions to plot on the stackup.
           It is supported only for Laminate mode.

       **first_layer** : :class:`python:str` or :class:`pyedb.dotnet.database.edb_data.layer_data.LayerEdbClass`
           First layer to plot from the bottom. Default is `None` to start plotting from bottom.

       **last_layer** : :class:`python:str` or :class:`pyedb.dotnet.database.edb_data.layer_data.LayerEdbClass`
           Last layer to plot from the bottom. Default is `None` to plot up to top layer.

       **scale_elevation** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           The real layer thickness is scaled so that max_thickness = 3 * min_thickness.
           Default is `True`.

       **show** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Whether to show the plot or not. Default is `True`.

   :Returns:

       :class:`matplotlib.plt`
           ..













   ..
       !! processed by numpydoc !!

.. py:method:: load_from_xml(file_path)

   
   Load stackup from a XML file.


   :Parameters:

       **file_path: str**
           Path to external XML file.

   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ``True`` when successful, ``False`` when failed.













   ..
       !! processed by numpydoc !!




