





:class:`GeometryOperators`
==========================


.. py:class:: pyedb.modeler.geometry_operators.GeometryOperators

   Bases: :py:obj:`object`


   
   Manages geometry operators.
















   ..
       !! processed by numpydoc !!


































































.. py:currentmodule:: GeometryOperators

Overview
--------

.. tab-set::






   .. tab-item:: Static methods

      .. list-table::
          :header-rows: 0
          :widths: auto

          * - :py:attr:`~List2list`
            - Convert a C# list object to a Python list.
          * - :py:attr:`~parse_dim_arg`
            - Convert a number and unit to a float.
          * - :py:attr:`~draft_type_str`
            - Retrieve the draft type.
          * - :py:attr:`~get_mid_point`
            - Evaluate the midpoint between two points.
          * - :py:attr:`~get_triangle_area`
            - Evaluate the area of a triangle defined by its three vertices.
          * - :py:attr:`~v_cross`
            - Evaluate the cross product of two geometry vectors.
          * - :py:attr:`~v_dot`
            - Evaluate the dot product between two geometry vectors.
          * - :py:attr:`~v_prod`
            - Evaluate the product between a scalar value and a vector.
          * - :py:attr:`~v_rotate_about_axis`
            - Evaluate rotation of a vector around an axis.
          * - :py:attr:`~v_sub`
            - Evaluate two geometry vectors by subtracting them (a-b).
          * - :py:attr:`~v_sum`
            - Evaluate two geometry vectors by adding them (a+b).
          * - :py:attr:`~v_norm`
            - Evaluate the Euclidean norm of a geometry vector.
          * - :py:attr:`~normalize_vector`
            - Normalize a geometry vector.
          * - :py:attr:`~v_points`
            - Vector from one point to another point.
          * - :py:attr:`~points_distance`
            - Evaluate the distance between two points expressed as their Cartesian coordinates.
          * - :py:attr:`~find_point_on_plane`
            - Find a point on a plane.
          * - :py:attr:`~distance_vector`
            - Evaluate the vector distance between point ``p`` and a line defined by two points, ``a`` and ``b``.
          * - :py:attr:`~is_between_points`
            - Check if a point lies on the segment defined by two points.
          * - :py:attr:`~is_parallel`
            - Check if a segment defined by two points is parallel to a segment defined by two other points.
          * - :py:attr:`~parallel_coeff`
            - ADD DESCRIPTION.
          * - :py:attr:`~is_collinear`
            - Check if two vectors are collinear (parallel or anti-parallel).
          * - :py:attr:`~is_projection_inside`
            - Project a segment onto another segment and check if the projected segment is inside it.
          * - :py:attr:`~arrays_positions_sum`
            - Return the sum of two vertices lists.
          * - :py:attr:`~v_angle`
            - Evaluate the angle between two geometry vectors.
          * - :py:attr:`~pointing_to_axis`
            - Retrieve the axes from the HFSS X axis and Y pointing axis as per
          * - :py:attr:`~axis_to_euler_zxz`
            - Retrieve Euler angles of a frame following the rotation sequence ZXZ.
          * - :py:attr:`~axis_to_euler_zyz`
            - Retrieve Euler angles of a frame following the rotation sequence ZYZ.
          * - :py:attr:`~quaternion_to_axis`
            - Convert a quaternion to a rotated frame defined by X, Y, and Z axes.
          * - :py:attr:`~quaternion_to_axis_angle`
            - Convert a quaternion to the axis angle rotation formulation.
          * - :py:attr:`~axis_angle_to_quaternion`
            - Convert the axis angle rotation formulation to a quaternion.
          * - :py:attr:`~quaternion_to_euler_zxz`
            - Convert a quaternion to Euler angles following rotation sequence ZXZ.
          * - :py:attr:`~euler_zxz_to_quaternion`
            - Convert the Euler angles following rotation sequence ZXZ to a quaternion.
          * - :py:attr:`~quaternion_to_euler_zyz`
            - Convert a quaternion to Euler angles following rotation sequence ZYZ.
          * - :py:attr:`~euler_zyz_to_quaternion`
            - Convert the Euler angles following rotation sequence ZYZ to a quaternion.
          * - :py:attr:`~deg2rad`
            - Convert the angle from degrees to radians.
          * - :py:attr:`~rad2deg`
            - Convert the angle from radians to degrees.
          * - :py:attr:`~atan2`
            - Implementation of atan2 that does not suffer from the following issues:
          * - :py:attr:`~q_prod`
            - Evaluate the product of two quaternions, ``p`` and ``q``, defined as:
          * - :py:attr:`~q_rotation`
            - Evaluate the rotation of a vector, defined by a quaternion.
          * - :py:attr:`~q_rotation_inv`
            - Evaluate the inverse rotation of a vector that is defined by a quaternion.
          * - :py:attr:`~get_polygon_centroid`
            - Evaluate the centroid of a polygon defined by its points.
          * - :py:attr:`~cs_xy_pointing_expression`
            - Return x_pointing and y_pointing vectors as expressions from
          * - :py:attr:`~get_numeric`
            - Convert a string to a numeric value. Discard the suffix.
          * - :py:attr:`~is_small`
            - Return ``True`` if the number represented by s is zero (i.e very small).
          * - :py:attr:`~numeric_cs`
            - Return a list of [x,y,z] numeric values given a coordinate system as input.
          * - :py:attr:`~orient_polygon`
            - Orient a polygon clockwise or counterclockwise. The vertices should be already ordered either way.
          * - :py:attr:`~v_angle_sign`
            - Evaluate the signed angle between two geometry vectors.
          * - :py:attr:`~v_angle_sign_2D`
            - Evaluate the signed angle between two 2D geometry vectors.
          * - :py:attr:`~point_in_polygon`
            - Determine if a point is inside, outside the polygon or at exactly at the border.
          * - :py:attr:`~is_point_in_polygon`
            - Determine if a point is inside or outside a polygon, both located on the same plane.
          * - :py:attr:`~are_segments_intersecting`
            - Determine if the two segments a and b are intersecting.
          * - :py:attr:`~is_segment_intersecting_polygon`
            - Determine if a segment defined by two points ``a`` and ``b`` intersects a polygon.
          * - :py:attr:`~is_perpendicular`
            - Check if two vectors are perpendicular.
          * - :py:attr:`~is_point_projection_in_segment`
            - Check if a point projection lies on the segment defined by two points.
          * - :py:attr:`~point_segment_distance`
            - Calculate the distance between a point ``p`` and a segment defined by two points ``a`` and ``b``.
          * - :py:attr:`~find_largest_rectangle_inside_polygon`
            - Find the largest area rectangles of arbitrary orientation in a polygon.
          * - :py:attr:`~degrees_over_rounded`
            - Ceil of angle.
          * - :py:attr:`~radians_over_rounded`
            - Radian angle ceiling.
          * - :py:attr:`~degrees_default_rounded`
            - Convert angle to degree with given digits rounding.
          * - :py:attr:`~radians_default_rounded`
            - Convert to radians with given round.
          * - :py:attr:`~find_closest_points`
            - Given a list of points, finds the closest points to a reference point.
          * - :py:attr:`~mirror_point`
            - Mirror point about a plane defining by a point on the plane and a normal point.
          * - :py:attr:`~find_points_along_lines`
            - Detect all points that are placed along lines.
          * - :py:attr:`~smallest_distance_between_polygons`
            - Find the smallest distance between two polygons using KDTree for efficient nearest neighbor search.





Import detail
-------------

.. code-block:: python

    from pyedb.modeler.geometry_operators import GeometryOperators



Method detail
-------------

.. py:method:: List2list(input_list)
   :staticmethod:


   
   Convert a C# list object to a Python list.

   This function performs a deep conversion.

   :Parameters:

       **input_list** : :obj:`List`
           C# list to convert to a Python list.



   :Returns:

       :obj:`List`
           Converted Python list.











   ..
       !! processed by numpydoc !!

.. py:method:: parse_dim_arg(string, scale_to_unit=None, variable_manager=None)
   :staticmethod:


   
   Convert a number and unit to a float.
   Angles are converted in radians.


   :Parameters:

       **string** : :class:`python:str`, :obj:`optional`
           String to convert. For example, ``"2mm"``. The default is ``None``.

       **scale_to_unit** : :class:`python:str`, :obj:`optional`
           Units for the value to convert. For example, ``"mm"``.

       **variable_manager** : :class:`pyedb.dotnet.database.Variables.VariableManager`, :obj:`optional`
           Try to parse formula and returns numeric value.
           The default is ``None``.



   :Returns:

       :class:`python:float`
           Value for the converted value and units. For example, ``0.002``.










   .. rubric:: Examples

   Parse `'"2mm"'`.

   >>> from pyedb.modeler.geometry_operators import GeometryOperators as go
   >>> go.parse_dim_arg("2mm")
   >>> 0.002

   Use the optional argument ``scale_to_unit`` to specify the destination unit.

   >>> go.parse_dim_arg("2mm", scale_to_unit="mm")
   >>> 2.0

   ..
       !! processed by numpydoc !!

.. py:method:: draft_type_str(val)
   :staticmethod:


   
   Retrieve the draft type.


   :Parameters:

       **val** : :class:`python:int`
           ``SWEEPDRAFT`` enum value.



   :Returns:

       :class:`python:str`
           Type of the draft.











   ..
       !! processed by numpydoc !!

.. py:method:: get_mid_point(v1, v2)
   :staticmethod:


   
   Evaluate the midpoint between two points.


   :Parameters:

       **v1** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the first point.

       **v2** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the second point.



   :Returns:

       :obj:`List`
           List of ``[x, y, z]`` coordinates for the midpoint.











   ..
       !! processed by numpydoc !!

.. py:method:: get_triangle_area(v1, v2, v3)
   :staticmethod:


   
   Evaluate the area of a triangle defined by its three vertices.


   :Parameters:

       **v1** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the first vertex.

       **v2** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the second vertex.

       **v3** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the third vertex.



   :Returns:

       :class:`python:float`
           Area of the triangle.











   ..
       !! processed by numpydoc !!

.. py:method:: v_cross(a, b)
   :staticmethod:


   
   Evaluate the cross product of two geometry vectors.


   :Parameters:

       **a** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the first vector.

       **b** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the second vector.



   :Returns:

       :obj:`List`
           List of ``[x, y, z]`` coordinates for the result vector.











   ..
       !! processed by numpydoc !!

.. py:method:: v_dot(a, b)
   :staticmethod:


   
   Evaluate the dot product between two geometry vectors.


   :Parameters:

       **a** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the first vector.

       **b** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the second vector.



   :Returns:

       :class:`python:float`
           Result of the dot product.











   ..
       !! processed by numpydoc !!

.. py:method:: v_prod(s, v)
   :staticmethod:


   
   Evaluate the product between a scalar value and a vector.


   :Parameters:

       **s** : :class:`python:float`
           Scalar value.

       **v** : :obj:`List`
           List of values for the vector in the format ``[v1, v2,..., vn]``.
           The vector can be any length.



   :Returns:

       :obj:`List`
           List of values for the result vector. This list is the
           same length as the list for the input vector.











   ..
       !! processed by numpydoc !!

.. py:method:: v_rotate_about_axis(vector, angle, radians=False, axis='z')
   :staticmethod:


   
   Evaluate rotation of a vector around an axis.


   :Parameters:

       **vector** : :class:`python:list`
           List of the three component of the vector.

       **angle** : :class:`python:float`
           Angle by which the vector is to be rotated (radians or degree).

       **radians** : :ref:`bool <python:bltin-boolean-values>`, :obj:`optional`
           Whether the angle is expressed in radians. Default is ``False``.

       **axis** : :class:`python:str`, :obj:`optional`
           Axis about which to rotate the vector. Default is ``"z"``.



   :Returns:

       :class:`python:list`
           List of values for the result vector.











   ..
       !! processed by numpydoc !!

.. py:method:: v_sub(a, b)
   :staticmethod:


   
   Evaluate two geometry vectors by subtracting them (a-b).


   :Parameters:

       **a** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the first vector.

       **b** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the second vector.



   :Returns:

       :obj:`List`
           List of ``[x, y, z]`` coordinates for the result vector.











   ..
       !! processed by numpydoc !!

.. py:method:: v_sum(a, b)
   :staticmethod:


   
   Evaluate two geometry vectors by adding them (a+b).


   :Parameters:

       **a** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the first vector.

       **b** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the second vector.



   :Returns:

       :obj:`List`
           List of ``[x, y, z]`` coordinates for the result vector.











   ..
       !! processed by numpydoc !!

.. py:method:: v_norm(a)
   :staticmethod:


   
   Evaluate the Euclidean norm of a geometry vector.


   :Parameters:

       **a** : :obj:`List`
           ..

       **List of ``[x, y, z]`` coordinates for the vector.**
           ..



   :Returns:

       :class:`python:float`
           Evaluated norm in the same unit as the coordinates for the input vector.











   ..
       !! processed by numpydoc !!

.. py:method:: normalize_vector(v)
   :staticmethod:


   
   Normalize a geometry vector.


   :Parameters:

       **v** : :obj:`List`
           List of ``[x, y, z]`` coordinates for vector.



   :Returns:

       :obj:`List`
           List of ``[x, y, z]`` coordinates for the normalized vector.











   ..
       !! processed by numpydoc !!

.. py:method:: v_points(p1, p2)
   :staticmethod:


   
   Vector from one point to another point.


   :Parameters:

       **p1** : :obj:`List`
           Coordinates ``[x1,y1,z1]`` for the first point.

       **p2** : :obj:`List`
           Coordinates ``[x2,y2,z2]`` for second point.



   :Returns:

       :obj:`List`
           Coordinates ``[vx, vy, vz]`` for the vector from the first point to the second point.











   ..
       !! processed by numpydoc !!

.. py:method:: points_distance(p1, p2)
   :staticmethod:


   
   Evaluate the distance between two points expressed as their Cartesian coordinates.


   :Parameters:

       **p1** : :obj:`List`
           List of ``[x1,y1,z1]`` coordinates for the first point.

       **p2** : :obj:`List`
           List of ``[x2,y2,z2]`` coordinates for the second ppint.



   :Returns:

       :class:`python:float`
           Distance between the two points in the same unit as the coordinates for the points.











   ..
       !! processed by numpydoc !!

.. py:method:: find_point_on_plane(pointlists, direction=0)
   :staticmethod:


   
   Find a point on a plane.


   :Parameters:

       **pointlists** : :obj:`List`
           List of points.

       **direction** : :class:`python:int`, :obj:`optional`
           The default is ``0``.



   :Returns:

       :obj:`List`
           ..











   ..
       !! processed by numpydoc !!

.. py:method:: distance_vector(p, a, b)
   :staticmethod:


   
   Evaluate the vector distance between point ``p`` and a line defined by two points, ``a`` and ``b``.

   .. note::
       he formula is  ``d = (a-p)-((a-p)dot p)n``, where ``a`` is a point of the line (either ``a`` or ``b``)
       and ``n`` is the unit vector in the direction of the line.

   :Parameters:

       **p** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the reference point.

       **a** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the first point of the segment.

       **b** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the second point of the segment.



   :Returns:

       :obj:`List`
           List of ``[x, y, z]`` coordinates for the distance vector.











   ..
       !! processed by numpydoc !!

.. py:method:: is_between_points(p, a, b, tol=1e-06)
   :staticmethod:


   
   Check if a point lies on the segment defined by two points.


   :Parameters:

       **p** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the reference point ``p``.

       **a** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the first point of the segment.

       **b** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the second point of the segment.

       **tol** : :class:`python:float`
           Linear tolerance. The default value is ``1e-6``.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ``True`` when the point lies on the segment defined by the two points, ``False`` otherwise.











   ..
       !! processed by numpydoc !!

.. py:method:: is_parallel(a1, a2, b1, b2, tol=1e-06)
   :staticmethod:


   
   Check if a segment defined by two points is parallel to a segment defined by two other points.


   :Parameters:

       **a1** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the first point of the fiirst segment.

       **a2** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the second point of the first segment.

       **b1** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the first point of the second segment.

       **b2** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the second point of the second segment.

       **tol** : :class:`python:float`
           Linear tolerance. The default value is ``1e-6``.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ``True`` when successful, ``False`` when failed.











   ..
       !! processed by numpydoc !!

.. py:method:: parallel_coeff(a1, a2, b1, b2)
   :staticmethod:


   
   ADD DESCRIPTION.


   :Parameters:

       **a1** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the first point of the first segment.

       **a2** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the second point of the first segment.

       **b1** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the first point of the second segment.

       **b2** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the second point of the second segment.



   :Returns:

       :class:`python:float`
           _vdot of 4 vertices of 2 segments.











   ..
       !! processed by numpydoc !!

.. py:method:: is_collinear(a, b, tol=1e-06)
   :staticmethod:


   
   Check if two vectors are collinear (parallel or anti-parallel).


   :Parameters:

       **a** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the first vector.

       **b** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the second vector.

       **tol** : :class:`python:float`
           Linear tolerance. The default value is ``1e-6``.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ``True`` if vectors are collinear, ``False`` otherwise.











   ..
       !! processed by numpydoc !!

.. py:method:: is_projection_inside(a1, a2, b1, b2)
   :staticmethod:


   
   Project a segment onto another segment and check if the projected segment is inside it.


   :Parameters:

       **a1** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the first point of the projected segment.

       **a2** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the second point of the projected segment.

       **b1** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the first point of the other segment.

       **b2** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the second point of the other segment.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ``True`` when the projected segment is inside the other segmennt, ``False`` otherwise.











   ..
       !! processed by numpydoc !!

.. py:method:: arrays_positions_sum(vertlist1, vertlist2)
   :staticmethod:


   
   Return the sum of two vertices lists.


   :Parameters:

       **vertlist1** : :obj:`List`
           ..

       **vertlist2** : :obj:`List`
           ..



   :Returns:

       :class:`python:float`
           ..











   ..
       !! processed by numpydoc !!

.. py:method:: v_angle(a, b)
   :staticmethod:


   
   Evaluate the angle between two geometry vectors.


   :Parameters:

       **a** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the first vector.

       **b** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the second vector.



   :Returns:

       :class:`python:float`
           Angle in radians.











   ..
       !! processed by numpydoc !!

.. py:method:: pointing_to_axis(x_pointing, y_pointing)
   :staticmethod:


   
   Retrieve the axes from the HFSS X axis and Y pointing axis as per
   the definition of the AEDT interface coordinate system.


   :Parameters:

       **x_pointing** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the X axis.

       **y_pointing** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the Y pointing axis.



   :Returns:

       :class:`python:tuple`
           ``[Xx, Xy, Xz], [Yx, Yy, Yz], [Zx, Zy, Zz]`` of the three axes (normalized).











   ..
       !! processed by numpydoc !!

.. py:method:: axis_to_euler_zxz(x, y, z)
   :staticmethod:


   
   Retrieve Euler angles of a frame following the rotation sequence ZXZ.

   Provides assumption for the gimbal lock problem.

   :Parameters:

       **x** : :obj:`List`
           List of ``[Xx, Xy, Xz]`` coordinates for the X axis.

       **y** : :obj:`List`
           List of ``[Yx, Yy, Yz]`` coordinates for the Y axis.

       **z** : :obj:`List`
           List of ``[Zx, Zy, Zz]`` coordinates for the Z axis.



   :Returns:

       :class:`python:tuple`
           (phi, theta, psi) containing the Euler angles in radians.











   ..
       !! processed by numpydoc !!

.. py:method:: axis_to_euler_zyz(x, y, z)
   :staticmethod:


   
   Retrieve Euler angles of a frame following the rotation sequence ZYZ.

   Provides assumption for the gimbal lock problem.

   :Parameters:

       **x** : :obj:`List`
           List of ``[Xx, Xy, Xz]`` coordinates for the X axis.

       **y** : :obj:`List`
           List of ``[Yx, Yy, Yz]`` coordinates for the Y axis.

       **z** : :obj:`List`
           List of ``[Zx, Zy, Zz]`` coordinates for the Z axis.



   :Returns:

       :class:`python:tuple`
           (phi, theta, psi) containing the Euler angles in radians.











   ..
       !! processed by numpydoc !!

.. py:method:: quaternion_to_axis(q)
   :staticmethod:


   
   Convert a quaternion to a rotated frame defined by X, Y, and Z axes.


   :Parameters:

       **q** : :obj:`List`
           List of ``[q1, q2, q3, q4]`` coordinates for the quaternion.



   :Returns:

       :class:`python:tuple`
           [Xx, Xy, Xz], [Yx, Yy, Yz], [Zx, Zy, Zz] of the three axes (normalized).











   ..
       !! processed by numpydoc !!

.. py:method:: quaternion_to_axis_angle(q)
   :staticmethod:


   
   Convert a quaternion to the axis angle rotation formulation.


   :Parameters:

       **q** : :obj:`List`
           List of ``[q1, q2, q3, q4]`` coordinates for the quaternion.



   :Returns:

       :class:`python:tuple`
           ([ux, uy, uz], theta) containing the rotation axes expressed as X, Y, Z components of
           the unit vector ``u`` and the rotation angle theta expressed in radians.











   ..
       !! processed by numpydoc !!

.. py:method:: axis_angle_to_quaternion(u, theta)
   :staticmethod:


   
   Convert the axis angle rotation formulation to a quaternion.


   :Parameters:

       **u** : :obj:`List`
           List of ``[ux, uy, uz]`` coordinates for the rotation axis.

       **theta** : :class:`python:float`
           Angle of rotation in radians.



   :Returns:

       :obj:`List`
           List of ``[q1, q2, q3, q4]`` coordinates for the quaternion.











   ..
       !! processed by numpydoc !!

.. py:method:: quaternion_to_euler_zxz(q)
   :staticmethod:


   
   Convert a quaternion to Euler angles following rotation sequence ZXZ.


   :Parameters:

       **q** : :obj:`List`
           List of ``[q1, q2, q3, q4]`` coordinates for the quaternion.



   :Returns:

       :class:`python:tuple`
           (phi, theta, psi) containing the Euler angles in radians.











   ..
       !! processed by numpydoc !!

.. py:method:: euler_zxz_to_quaternion(phi, theta, psi)
   :staticmethod:


   
   Convert the Euler angles following rotation sequence ZXZ to a quaternion.


   :Parameters:

       **phi** : :class:`python:float`
           Euler angle psi in radians.

       **theta** : :class:`python:float`
           Euler angle theta in radians.

       **psi** : :class:`python:float`
           Euler angle phi in radians.



   :Returns:

       :obj:`List`
           List of ``[q1, q2, q3, q4]`` coordinates for the quaternion.











   ..
       !! processed by numpydoc !!

.. py:method:: quaternion_to_euler_zyz(q)
   :staticmethod:


   
   Convert a quaternion to Euler angles following rotation sequence ZYZ.


   :Parameters:

       **q** : :obj:`List`
           List of ``[q1, q2, q3, q4]`` coordinates for the quaternion.



   :Returns:

       :class:`python:tuple`
           (phi, theta, psi) containing the Euler angles in radians.











   ..
       !! processed by numpydoc !!

.. py:method:: euler_zyz_to_quaternion(phi, theta, psi)
   :staticmethod:


   
   Convert the Euler angles following rotation sequence ZYZ to a quaternion.


   :Parameters:

       **phi** : :class:`python:float`
           Euler angle psi in radians.

       **theta** : :class:`python:float`
           Euler angle theta in radians.

       **psi** : :class:`python:float`
           Euler angle phi in radians.



   :Returns:

       :obj:`List`
           List of ``[q1, q2, q3, q4]`` coordinates for the quaternion.











   ..
       !! processed by numpydoc !!

.. py:method:: deg2rad(angle)
   :staticmethod:


   
   Convert the angle from degrees to radians.


   :Parameters:

       **angle** : :class:`python:float`
           Angle in degrees.



   :Returns:

       :class:`python:float`
           Angle in radians.











   ..
       !! processed by numpydoc !!

.. py:method:: rad2deg(angle)
   :staticmethod:


   
   Convert the angle from radians to degrees.


   :Parameters:

       **angle** : :class:`python:float`
           Angle in radians.



   :Returns:

       :class:`python:float`
           Angle in degrees.











   ..
       !! processed by numpydoc !!

.. py:method:: atan2(y, x)
   :staticmethod:


   
   Implementation of atan2 that does not suffer from the following issues:
   math.atan2(0.0, 0.0) = 0.0
   math.atan2(-0.0, 0.0) = -0.0
   math.atan2(0.0, -0.0) = 3.141592653589793
   math.atan2(-0.0, -0.0) = -3.141592653589793
   and returns always 0.0.


   :Parameters:

       **y** : :class:`python:float`
           Y-axis value for atan2.

       **x** : :class:`python:float`
           X-axis value for atan2.



   :Returns:

       :class:`python:float`
           ..











   ..
       !! processed by numpydoc !!

.. py:method:: q_prod(p, q)
   :staticmethod:


   
   Evaluate the product of two quaternions, ``p`` and ``q``, defined as:
   p = p0 + p' = p0 + ip1 + jp2 + kp3.
   q = q0 + q' = q0 + iq1 + jq2 + kq3.
   r = pq = p0q0 - p' • q' + p0q' + q0p' + p' x q'.


   :Parameters:

       **p** : :obj:`List`
           List of ``[p1, p2, p3, p4]`` coordinates for quaternion ``p``.

       **q** : :obj:`List`
           List of ``[p1, p2, p3, p4]`` coordinates for quaternion ``q``.



   :Returns:

       :obj:`List`
           List of [r1, r2, r3, r4] coordinates for the result quaternion.











   ..
       !! processed by numpydoc !!

.. py:method:: q_rotation(v, q)
   :staticmethod:


   
   Evaluate the rotation of a vector, defined by a quaternion.
   Evaluated as:
   ``"q = q0 + q' = q0 + iq1 + jq2 + kq3"``,
   ``"w = qvq* = (q0^2 - |q'|^2)v + 2(q' • v)q' + 2q0(q' x v)"``.


   :Parameters:

       **v** : :obj:`List`
           List of ``[v1, v2, v3]`` coordinates for the vector.

       **q** : :obj:`List`
           List of ``[q1, q2, q3, q4]`` coordinates for the quaternion.



   :Returns:

       :obj:`List`
           List of ``[w1, w2, w3]`` coordinates for the result vector ``w``.











   ..
       !! processed by numpydoc !!

.. py:method:: q_rotation_inv(v, q)
   :staticmethod:


   
   Evaluate the inverse rotation of a vector that is defined by a quaternion.

   It can also be the rotation of the coordinate frame with respect to the vector.

       q = q0 + q' = q0 + iq1 + jq2 + kq3
       q* = q0 - q' = q0 - iq1 - jq2 - kq3
       w = q*vq

   :Parameters:

       **v** : :obj:`List`
           List of ``[v1, v2, v3]`` coordinates for the vector.

       **q** : :obj:`List`
           List of ``[q1, q2, q3, q4]`` coordinates for the quaternion.



   :Returns:

       :obj:`List`
           List of ``[w1, w2, w3]`` coordinates for the vector.











   ..
       !! processed by numpydoc !!

.. py:method:: get_polygon_centroid(pts)
   :staticmethod:


   
   Evaluate the centroid of a polygon defined by its points.


   :Parameters:

       **pts** : :obj:`List`
           List of points, with each point defined by its ``[x,y,z]`` coordinates.



   :Returns:

       :obj:`List`
           List of [x,y,z] coordinates for the centroid of the polygon.











   ..
       !! processed by numpydoc !!

.. py:method:: cs_xy_pointing_expression(yaw, pitch, roll)
   :staticmethod:


   
   Return x_pointing and y_pointing vectors as expressions from
   the yaw, ptich, and roll input (as strings).


   :Parameters:

       **yaw** : :class:`python:str`, :obj:`required`
           String expression for the yaw angle (rotation about Z-axis)

       **pitch** : :class:`python:str`
           String expression for the pitch angle (rotation about Y-axis)

       **roll** : :class:`python:str`
           String expression for the roll angle (rotation about X-axis)



   :Returns:

       [:obj:`x_pointing`, :obj:`y_pointing`] :obj:`vector` expressions.
           ..











   ..
       !! processed by numpydoc !!

.. py:method:: get_numeric(s)
   :staticmethod:


   
   Convert a string to a numeric value. Discard the suffix.
















   ..
       !! processed by numpydoc !!

.. py:method:: is_small(s)
   :staticmethod:


   
   Return ``True`` if the number represented by s is zero (i.e very small).


   :Parameters:

       **s** : :obj:`numeric` or :class:`python:str`
           Variable value.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ..











   ..
       !! processed by numpydoc !!

.. py:method:: numeric_cs(cs_in)
   :staticmethod:


   
   Return a list of [x,y,z] numeric values given a coordinate system as input.


   :Parameters:

       **cs_in** : :obj:`List` :obj:`of` :class:`python:str` or :class:`python:str`
           ``["x", "y", "z"]`` or "Global".














   ..
       !! processed by numpydoc !!

.. py:method:: orient_polygon(x, y, clockwise=True)
   :staticmethod:


   
   Orient a polygon clockwise or counterclockwise. The vertices should be already ordered either way.
   Use this function to change the orientation.
   The polygon is represented by its vertices coordinates.


   :Parameters:

       **x** : :obj:`List`
           List of x coordinates of the vertices. Length must be >= 1.
           Degenerate polygon with only 2 points is also accepted, in this case the points are returned unchanged.

       **y** : :obj:`List`
           List of y coordinates of the vertices. Must be of the same length as x.

       **clockwise** : :ref:`bool <python:bltin-boolean-values>`
           If ``True`` the polygon is oriented clockwise, if ``False`` it is oriented counterclockwise.
           Default is ``True``.



   :Returns:

       :obj:`List` :obj:`of` :obj:`List`
           Lists of oriented vertices.











   ..
       !! processed by numpydoc !!

.. py:method:: v_angle_sign(va, vb, vn, right_handed=True)
   :staticmethod:


   
   Evaluate the signed angle between two geometry vectors.
   The sign is evaluated respect to the normal to the plane containing the two vectors as per the following rule.
   In case of opposite vectors, it returns an angle equal to 180deg (always positive).
   Assuming that the plane normal is normalized (vb == 1), the signed angle is simplified.
   For the right-handed rotation from Va to Vb:
   - atan2((va x Vb) . vn, va . vb).
   For the left-handed rotation from Va to Vb:
   - atan2((Vb x va) . vn, va . vb).


   :Parameters:

       **va** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the first vector.

       **vb** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the second vector.

       **vn** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the plane normal.

       **right_handed** : :ref:`bool <python:bltin-boolean-values>`
           Whether to consider the right-handed rotation from va to vb. The default is ``True``.
           When ``False``, left-hand rotation from va to vb is considered.



   :Returns:

       :class:`python:float`
           Angle in radians.











   ..
       !! processed by numpydoc !!

.. py:method:: v_angle_sign_2D(va, vb, right_handed=True)
   :staticmethod:


   
   Evaluate the signed angle between two 2D geometry vectors.
   Iit the 2D version of the ``GeometryOperators.v_angle_sign`` considering vn = [0,0,1].
   In case of opposite vectors, it returns an angle equal to 180deg (always positive).


   :Parameters:

       **va** : :obj:`List`
           List of ``[x, y]`` coordinates for the first vector.

       **vb** : :obj:`List`
           List of ``[x, y]`` coordinates for the second vector.

       **right_handed** : :ref:`bool <python:bltin-boolean-values>`
           Whether to consider the right-handed rotation from Va to Vb. The default is ``True``.
           When ``False``, left-hand rotation from Va to Vb is considered.



   :Returns:

       :class:`python:float`
           Angle in radians.











   ..
       !! processed by numpydoc !!

.. py:method:: point_in_polygon(point, polygon, tolerance=1e-08)
   :staticmethod:


   
   Determine if a point is inside, outside the polygon or at exactly at the border.

   The method implements the radial algorithm (https://es.wikipedia.org/wiki/Algoritmo_radial)

   point : List
       List of ``[x, y]`` coordinates.
   polygon : List
       [[x1, x2, ..., xn],[y1, y2, ..., yn]]
   tolerance : float
       tolerance used for the algorithm. Default value is 1e-8.




   :Returns:

       :class:`python:int`
           - ``-1`` When the point is outside the polygon.
           - ``0`` When the point is exactly on one of the sides of the polygon.
           - ``1`` When the point is inside the polygon.











   ..
       !! processed by numpydoc !!

.. py:method:: is_point_in_polygon(point, polygon)
   :staticmethod:


   
   Determine if a point is inside or outside a polygon, both located on the same plane.

   The method implements the radial algorithm (https://es.wikipedia.org/wiki/Algoritmo_radial)

   point : List
       List of ``[x, y]`` coordinates.
   polygon : List
       [[x1, x2, ..., xn],[y1, y2, ..., yn]]




   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ``True`` if the point is inside the polygon or exactly on one of its sides.
           ``False`` otherwise.











   ..
       !! processed by numpydoc !!

.. py:method:: are_segments_intersecting(a1, a2, b1, b2, include_collinear=True)
   :staticmethod:


   
   Determine if the two segments a and b are intersecting.

   a1 : List
       First point of segment a. List of ``[x, y]`` coordinates.
   a2 : List
       Second point of segment a. List of ``[x, y]`` coordinates.
   b1 : List
       First point of segment b. List of ``[x, y]`` coordinates.
   b2 : List
       Second point of segment b. List of ``[x, y]`` coordinates.
   include_collinear : bool
       If ``True`` two segments are considered intersecting also if just one end lies on the other segment.
       Default is ``True``.




   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ``True`` if the segments are intersecting.
           ``False`` otherwise.











   ..
       !! processed by numpydoc !!

.. py:method:: is_segment_intersecting_polygon(a, b, polygon)
   :staticmethod:


   
   Determine if a segment defined by two points ``a`` and ``b`` intersects a polygon.
   Points on the vertices and on the polygon boundaries are not considered intersecting.

   a : List
       First point of the segment. List of ``[x, y]`` coordinates.
   b : List
       Second point of the segment. List of ``[x, y]`` coordinates.
   polygon : List
       [[x1, x2, ..., xn],[y1, y2, ..., yn]]




   :Returns:

       :class:`python:float`
           ``True`` if the segment intersect the polygon. ``False`` otherwise.











   ..
       !! processed by numpydoc !!

.. py:method:: is_perpendicular(a, b, tol=1e-06)
   :staticmethod:


   
   Check if two vectors are perpendicular.


   :Parameters:

       **a** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the first vector.

       **b** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the second vector.

       **tol** : :class:`python:float`
           Linear tolerance. The default value is ``1e-6``.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ``True`` if vectors are perpendicular, ``False`` otherwise.











   ..
       !! processed by numpydoc !!

.. py:method:: is_point_projection_in_segment(p, a, b)
   :staticmethod:


   
   Check if a point projection lies on the segment defined by two points.


   :Parameters:

       **p** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the reference point ``p``.

       **a** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the first point of the segment.

       **b** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the second point of the segment.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ``True`` when the projection point lies on the segment defined by the two points, ``False`` otherwise.











   ..
       !! processed by numpydoc !!

.. py:method:: point_segment_distance(p, a, b)
   :staticmethod:


   
   Calculate the distance between a point ``p`` and a segment defined by two points ``a`` and ``b``.


   :Parameters:

       **p** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the reference point ``p``.

       **a** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the first point of the segment.

       **b** : :obj:`List`
           List of ``[x, y, z]`` coordinates for the second point of the segment.



   :Returns:

       :class:`python:float`
           Distance between the point and the segment.











   ..
       !! processed by numpydoc !!

.. py:method:: find_largest_rectangle_inside_polygon(polygon, partition_max_order=16)
   :staticmethod:


   
   Find the largest area rectangles of arbitrary orientation in a polygon.

   Implements the algorithm described by Rubén Molano, et al.
   *"Finding the largest area rectangle of arbitrary orientation in a closed contour"*, published in
   *Applied Mathematics and Computation*.
   https://doi.org/10.1016/j.amc.2012.03.063.
   (https://www.sciencedirect.com/science/article/pii/S0096300312003207)

   :Parameters:

       **polygon** : :obj:`List`
           [[x1, x2, ..., xn],[y1, y2, ..., yn]]

       **partition_max_order** : :class:`python:float`, :obj:`optional`
           Order of the lattice partition used to find the quasi-lattice polygon that approximates ``polygon``.
           Default is ``16``.



   :Returns:

       :obj:`List` :obj:`of` :obj:`List`
           List containing the rectangles points. Return all rectangles found.
           List is in the form: [[[x1, y1],[x2, y2],...],[[x1, y1],[x2, y2],...],...].











   ..
       !! processed by numpydoc !!

.. py:method:: degrees_over_rounded(angle, digits)
   :staticmethod:


   
   Ceil of angle.


   :Parameters:

       **angle** : :class:`python:float`
           Angle in radians which will be converted to degrees and will be over-rounded to the next "digits" decimal.

       **digits** : :class:`python:int`
           Integer number which is the number of decimals.



   :Returns:

       :class:`python:float`
           ..











   ..
       !! processed by numpydoc !!

.. py:method:: radians_over_rounded(angle, digits)
   :staticmethod:


   
   Radian angle ceiling.


   :Parameters:

       **angle** : :class:`python:float`
           Angle in degrees which will be converted to radians and will be over-rounded to the  next "digits" decimal.

       **digits** : :class:`python:int`
           Integer number which is the number of decimals.



   :Returns:

       :class:`python:float`
           ..











   ..
       !! processed by numpydoc !!

.. py:method:: degrees_default_rounded(angle, digits)
   :staticmethod:


   
   Convert angle to degree with given digits rounding.


   :Parameters:

       **angle** : :class:`python:float`
           Angle in radians which will be converted to degrees and will be under-rounded to the next "digits" decimal.

       **digits** : :class:`python:int`
           Integer number which is the number of decimals.



   :Returns:

       :class:`python:float`
           ..











   ..
       !! processed by numpydoc !!

.. py:method:: radians_default_rounded(angle, digits)
   :staticmethod:


   
   Convert to radians with given round.


   :Parameters:

       **angle** : :class:`python:float`
           Angle in degrees which will be converted to radians and will be under-rounded to the next "digits" decimal.

       **digits** : :class:`python:int`
           Integer number which is the number of decimals.



   :Returns:

       :class:`python:float`
           ..











   ..
       !! processed by numpydoc !!

.. py:method:: find_closest_points(points_list, reference_point, tol=1e-06)
   :staticmethod:


   
   Given a list of points, finds the closest points to a reference point.
   It returns a list of points because more than one can be found.
   It works with 2D or 3D points. The tolerance used to evaluate the distance
   to the reference point can be specified.


   :Parameters:

       **points_list** : :obj:`List` :obj:`of` :obj:`List`
           List of points. The points can be defined in 2D or 3D space.

       **reference_point** : :obj:`List`
           The reference point. The point can be defined in 2D or 3D space (same as points_list).

       **tol** : :class:`python:float`, :obj:`optional`
           The tolerance used to evaluate the distance. Default is ``1e-6``.



   :Returns:

       :obj:`List` :obj:`of` :obj:`List`
           ..











   ..
       !! processed by numpydoc !!

.. py:method:: mirror_point(start, reference, vector)
   :staticmethod:


   
   Mirror point about a plane defining by a point on the plane and a normal point.


   :Parameters:

       **start** : :class:`python:list`
           Point to be mirrored

       **reference** : :class:`python:list`
           The reference point. Point on the plane around which you want to mirror the object.

       **vector** : :class:`python:list`
           Normalized vector used for the mirroring.



   :Returns:

       :obj:`List`
           List of the reflected point.











   ..
       !! processed by numpydoc !!

.. py:method:: find_points_along_lines(points, minimum_number_of_points=3, distance_threshold=None, selected_angles=None, return_additional_info=False)
   :staticmethod:


   
   Detect all points that are placed along lines.

   The method takes as input a list of 2D points and detects all lines that contain at least 3 points.
   Optionally, the minimum number of points contained in a line can be specified by setting the
   argument ``minimum_number_of_points``.
   As default, all points along the lines are returned, regardless of their relative distance.
   Optionally, a `distance_threshold` can be set. If two points in a line are separated by a distance larger than
   ``distance_threshold``, the line is divided in two parts. If one of those parts does not satisfy the
   ``minimum_number_of_points`` requirement, it is discarded.
   If `distance_threshold` is set (not ``None``), the computational time increases.

   points : List, numpy.ndarray
       The points to process. Can be a list of lists where each sublist
       represents a 2D point ``[x, y]`` coordinates, or a numpy array of shape (n, 2).
   minimum_number_of_points : int, optional
       The minimum number of points that a line must contain. Default is ``3``.
   distance_threshold : float, None, optional
       If two points in a line are separated by a distance larger than `distance_threshold`,
       the line is divided in two parts. Default is ``None``, in which case the control is not performed.
   selected_angles : list, None, optional
       Specify a list of angles in degrees. If specified, the method returns only the lines which
       have one of the specified angles.
       The angle is defined as the positive angle of the infinite line with respect to the x-axis
       It is positive, and between 0 and 180 degrees.
       For example, ``[90]`` indicated vertical lines parallel to the y-axis,
       ``[0]`` or ``[180]`` identifies horizontal lines parallel to the x-axis,
       ``45`` identifies lines parallel to the first quadrant bisector.
       Default is ``None``, in which case all lines are returned.
   return_additional_info : bool, optional
       Whether to return additional information about the number of elements processed.
       The default is ``True``.




   :Returns:

       :class:`python:tuple`
           The tuple contains:
           - lines: a list of lists where each sublist represents a 2D point ``[x, y]`` coordinates in each line.
           - lines indexes: a list of lists where each sublist represents the index of the point in each line.
                           The index is referring to the point position in the input point list.
           - number of processed points: optional, returned if ``return_additional_info`` is ``True``
           - number of processed lines: optional, returned if ``return_additional_info`` is ``True``
           - number of detected lines after ``minimum_number_of_points`` is applied: optional,
               returned if ``return_additional_info`` is ``True``
           - number of detected lines after ``distance_threshold`` is applied: optional,
               returned if ``return_additional_info`` is ``True``











   ..
       !! processed by numpydoc !!

.. py:method:: smallest_distance_between_polygons(polygon1, polygon2)
   :staticmethod:


   
   Find the smallest distance between two polygons using KDTree for efficient nearest neighbor search.

   Parameters:
   polygon1 (list of tuples): List of (x, y) coordinates representing the points of the first polygon.
   polygon2 (list of tuples): List of (x, y) coordinates representing the points of the second polygon.

   Returns:
   float: The smallest distance between any two points from the two polygons.

   Example:
   >>> polygon1 = [(1, 1), (4, 1), (4, 4), (1, 4)]
   >>> polygon2 = [(5, 5), (8, 5), (8, 8), (5, 8)]
   >>> smallest_distance_between_polygons(polygon1, polygon2)
   1.4142135623730951















   ..
       !! processed by numpydoc !!




