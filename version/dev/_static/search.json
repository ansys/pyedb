[
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.dc_shorts",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.dc_shorts.html#dc_shorts",
        "title": "dc_shorts",
        "section": "dc_shorts",
        "text": "Find DC shorts on layout.\nList of nets.\nIf True, rename all the nets. (default)\nIf False, only report dc shorts.\n[[net name, net name]].\ndc_shorts\npython:str\npython:list\npython:str\noptional\noptional\nList\nList\npython:str\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.dc_shorts",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.dc_shorts.html#pyedb.dotnet.database.layout_validation.LayoutValidation.dc_shorts",
        "title": "dc_shorts > dc_shorts > dc_shorts",
        "section": "dc_shorts > dc_shorts",
        "text": "LayoutValidation.dc_shorts(net_list=None, fix=False)\n\nFind DC shorts on layout.\n\nParameters\n\nnet_list\n\npython:str or python:list[python:str], optional\n\nList of nets.\n\nfix\n\nbool, optional\n\nIf True, rename all the nets. (default)\nIf False, only report dc shorts.\n\nReturns\n\nList[List[python:str, python:str]]\n\n[[net name, net name]].\n\nExamples\n\n>>> edb = Edb(\"edb_file\")\n>>> dc_shorts = edb.layout_validation.dc_shorts()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/rlc",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/rlc.html#rlc",
        "title": "Rlc",
        "section": "Rlc",
        "text": "This class is managing EDB rlck.\nRlc\n\nRlc\nRlc"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.compress_primitives",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.compress_primitives.html#compress_primitives",
        "title": "compress_primitives",
        "section": "compress_primitives",
        "text": "Compress primitives into         primitive instance collections.\nPrimitives whose only geometric difference is location will be compressed.         For example, a 4x4 grid of rectangles with the same width and height will be         compressed into one primitive instance collection.\nOnly Circle, Rectangle, and Polygon primitives            are supported in primitive instance collections.\ncompress_primitives\nprimitives\nprimitive instance collections\nCircle\nRectangle\nPolygon"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.compress_primitives",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.compress_primitives.html#pyedb.grpc.database.layout.layout.Layout.compress_primitives",
        "title": "compress_primitives > compress_primitives > compress_primitives",
        "section": "compress_primitives > compress_primitives",
        "text": "Layout.compress_primitives()\n\nCompress primitives into         primitive instance collections.\n\nPrimitives whose only geometric difference is location will be compressed.         For example, a 4x4 grid of rectangles with the same width and height will be         compressed into one primitive instance collection.\n\nOnly Circle, Rectangle, and Polygon primitives            are supported in primitive instance collections.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlProperty",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlProperty.html#controlproperty",
        "title": "ControlProperty",
        "section": "ControlProperty",
        "text": "ControlProperty"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlProperty",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlProperty.html#pyedb.grpc.database.utility.xml_control_file.ControlProperty",
        "title": "ControlProperty > ControlProperty > ControlProperty",
        "section": "ControlProperty > ControlProperty",
        "text": "class pyedb.grpc.database.utility.xml_control_file.ControlProperty(property_name, value)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.find_by_reference_designator",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.find_by_reference_designator.html#find_by_reference_designator",
        "title": "find_by_reference_designator",
        "section": "find_by_reference_designator",
        "text": "Find component by reference designator.\nReference designator.\nComponent instance.\nfind_by_reference_designator\npython:str\npyedb.grpc.database.hierarchy.component.Component"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.find_by_reference_designator",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.find_by_reference_designator.html#pyedb.grpc.database.components.Components.find_by_reference_designator",
        "title": "find_by_reference_designator > find_by_reference_designator > find_by_reference_designator",
        "section": "find_by_reference_designator > find_by_reference_designator",
        "text": "Components.find_by_reference_designator(reference_designator: str) -> Component\n\nFind component by reference designator.\n\nParameters\n\nreference_designator\n\npython:str\n\nReference designator.\n\nReturns\n\npyedb.grpc.database.hierarchy.component.Component\n\nComponent instance.\n\nExamples\n\n>>> comp = edbapp.components.find_by_reference_designator(\"R1\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the layout object.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.delete.html#pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "PadstackInstanceTerminal.delete()\n\nDelete the layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.equals",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.equals.html#equals",
        "title": "equals",
        "section": "equals",
        "text": "Determine if two points are located at the same coordinates.\nTrue if the two points are located at the same coordinates,\nFalse otherwise.\nequals\npython:float\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.equals",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.equals.html#pyedb.grpc.database.geometry.point_data.PointData.equals",
        "title": "equals > equals > equals",
        "section": "equals > equals",
        "text": "PointData.equals(other, tolerance: float = 0.0) -> bool\n\nDetermine if two points are located at the same coordinates.\n\nParameters\n\nother\n\nPoint2DLike\n\n\n\ntolerance\n\npython:float, default: 0.0\n\n\n\nReturns\n\nbool\n\nTrue if the two points are located at the same coordinates,\nFalse otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the terminal object to the correct concrete type, fetching the type if necessary.\ncast\nTerminalType\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.cast.html#pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "PadstackInstanceTerminal.cast(term_type=None)\n\nCast the terminal object to the correct concrete type, fetching the type if necessary.\n\nParameters\n\nterm_type\n\nTerminalType\n\n\n\nReturns\n\nTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.CurrentSource",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.CurrentSource.html#currentsource",
        "title": "CurrentSource",
        "section": "CurrentSource",
        "text": "Manages a current source.\nCurrentSource"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.CurrentSource",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.CurrentSource.html#pyedb.grpc.database.utility.sources.CurrentSource",
        "title": "CurrentSource > CurrentSource > CurrentSource",
        "section": "CurrentSource > CurrentSource",
        "text": "class pyedb.grpc.database.utility.sources.CurrentSource\n\nManages a current source.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj: The object to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\nfrom_attributes: Whether to extract data from object attributes.\ncontext: Additional context to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nValidationError: If the object could not be validated.\nThe validated model instance.\nmodel_validate"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_validate.html#pyedb.workflows.drc.drc.MinLineWidth.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod MinLineWidth.model_validate(obj: Any, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\nValidate a pydantic model instance.\n\nArgs:\n\nobj: The object to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\nfrom_attributes: Whether to extract data from object attributes.\ncontext: Additional context to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nRaises:\n\nValidationError: If the object could not be validated.\n\nReturns:\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.update_forward_refs",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "update_forward_refs"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.update_forward_refs",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.update_forward_refs.html#pyedb.workflows.drc.drc.Rules.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod Rules.update_forward_refs(**localns: Any) -> None\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/sweep_data",
        "href": "dotnet_api/dotnet/sim_setup_data/data/sweep_data.html#sweep-data",
        "title": "Sweep data",
        "section": "Sweep data",
        "text": "This class is the container of sweep data.\nSweepData\nManages EDB methods for a frequency sweep.\nSweep data\nSweepData"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a component from pins.\nList of EDB core pins.\nName of the reference designator for the component.\nName of the layer used for placing the component.\nPart name of the component.\nWhether if the new component will be an RLC or not.\nResistor value.\nCapacitance value.\nInductor value.\nUsing parallel model when True, series when False.\nTrue when successful, False when failed.\ncreate\npython:list\npython:str\npython:str\noptional\npython:str\noptional\noptional\npython:float\npython:float\npython:float\nTrue\nFalse\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create.html#pyedb.dotnet.database.components.Components.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "Components.create(pins, component_name=None, placement_layer=None, component_part_name=None, is_rlc=False, r_value=None, c_value=None, l_value=None, is_parallel=False)\n\nCreate a component from pins.\n\nParameters\n\npins\n\npython:list\n\nList of EDB core pins.\n\ncomponent_name\n\npython:str\n\nName of the reference designator for the component.\n\nplacement_layer\n\npython:str, optional\n\nName of the layer used for placing the component.\n\ncomponent_part_name\n\npython:str, optional\n\nPart name of the component.\n\nis_rlc\n\nbool, optional\n\nWhether if the new component will be an RLC or not.\n\nr_value\n\npython:float\n\nResistor value.\n\nc_value\n\npython:float\n\nCapacitance value.\n\nl_value\n\npython:float\n\nInductor value.\n\nis_parallel\n\nbool\n\nUsing parallel model when True, series when False.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\")\n>>> pins = edbapp.components.get_pin_from_component(\"A1\")\n>>> edbapp.components.create(pins, \"A1New\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_fields",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_fields",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_fields.html#pyedb.grpc.database.definition.materials.MaterialProperties.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "MaterialProperties.model_fields = {'conductivity': FieldInfo(annotation=Union[Annotated[float, Gt], NoneType], required=False, default=0.0), 'dc_conductivity': FieldInfo(annotation=Union[Annotated[float, Gt], NoneType], required=False, default=0.0), 'dc_permittivity': FieldInfo(annotation=Union[Annotated[float, Gt], NoneType], required=False, default=0.0), 'dielectric_loss_tangent': FieldInfo(annotation=Union[Annotated[float, Gt], NoneType], required=False, default=0.0), 'dielectric_model_frequency': FieldInfo(annotation=Union[Annotated[float, Gt], NoneType], required=False, default=0.0), 'loss_tangent_at_frequency': FieldInfo(annotation=Union[Annotated[float, Gt], NoneType], required=False, default=0.0), 'magnetic_loss_tangent': FieldInfo(annotation=Union[Annotated[float, Gt], NoneType], required=False, default=0.0), 'mass_density': FieldInfo(annotation=Union[Annotated[float, Gt], NoneType], required=False, default=0.0), 'permeability': FieldInfo(annotation=Union[Annotated[float, Gt], NoneType], required=False, default=0.0), 'permittivity': FieldInfo(annotation=Union[Annotated[float, Gt], NoneType], required=False, default=0.0), 'permittivity_at_frequency': FieldInfo(annotation=Union[Annotated[float, Gt], NoneType], required=False, default=0.0), 'poisson_ratio': FieldInfo(annotation=Union[Annotated[float, Gt], NoneType], required=False, default=0.0), 'specific_heat': FieldInfo(annotation=Union[Annotated[float, Gt], NoneType], required=False, default=0.0), 'thermal_conductivity': FieldInfo(annotation=Union[Annotated[float, Gt], NoneType], required=False, default=0.0), 'thermal_expansion_coefficient': FieldInfo(annotation=Union[Annotated[float, Gt], NoneType], required=False, default=0.0), 'youngs_modulus': FieldInfo(annotation=Union[Annotated[float, Gt], NoneType], required=False, default=0.0)}\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.delete_frequency_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.delete_frequency_sweep.html#delete_frequency_sweep",
        "title": "delete_frequency_sweep",
        "section": "delete_frequency_sweep",
        "text": "Delete a frequency sweep.\ndelete_frequency_sweep"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.delete_frequency_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.delete_frequency_sweep.html#pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.delete_frequency_sweep",
        "title": "delete_frequency_sweep > delete_frequency_sweep > delete_frequency_sweep",
        "section": "delete_frequency_sweep > delete_frequency_sweep",
        "text": "SiwaveSimulationSetup.delete_frequency_sweep(sweep_data)\n\nDelete a frequency sweep.\n\nParameters\n\nsweep_data\n\nEdbFrequencySweep.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the layout object.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.delete.html#pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "EdgeTerminal.delete()\n\nDelete the layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.create_3d_comp.html#create_3d_comp",
        "title": "create_3d_comp",
        "section": "create_3d_comp",
        "text": "Create a 3D composite model from an MCAD file.\n3D composite model created.\ncreate_3d_comp\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.create_3d_comp.html#pyedb.grpc.database.ports.ports.BundleWavePort.create_3d_comp",
        "title": "create_3d_comp > create_3d_comp > create_3d_comp",
        "section": "create_3d_comp > create_3d_comp",
        "text": "BundleWavePort.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nReturns\n\nMcadModel\n\n3D composite model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.convert_to_polygon",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.convert_to_polygon.html#convert_to_polygon",
        "title": "convert_to_polygon",
        "section": "convert_to_polygon",
        "text": "Convert path to polygon.\nPolygon when successful, False when failed.\nconvert_to_polygon\ndotnet.database.edb_data.primitives.EDBPrimitives\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.convert_to_polygon",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.convert_to_polygon.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.convert_to_polygon",
        "title": "convert_to_polygon > convert_to_polygon > convert_to_polygon",
        "section": "convert_to_polygon > convert_to_polygon",
        "text": "EdbPolygon.convert_to_polygon()\n\nConvert path to polygon.\n\nReturns\n\nbool, dotnet.database.edb_data.primitives.EDBPrimitives\n\nPolygon when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.remove_net",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.remove_net.html#remove_net",
        "title": "remove_net",
        "section": "remove_net",
        "text": "Remove a net from the extended net.\nNet to remove.\nremove_net\nNet"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.remove_net",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.remove_net.html#pyedb.grpc.database.net.extended_net.ExtendedNet.remove_net",
        "title": "remove_net > remove_net > remove_net",
        "section": "remove_net > remove_net",
        "text": "ExtendedNet.remove_net(net)\n\nRemove a net from the extended net.\n\nParameters\n\nnet\n\nNet\n\nNet to remove.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_current_source",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_current_source.html#create_current_source",
        "title": "create_current_source",
        "section": "create_current_source",
        "text": "Create a current source.\nlegacy.database.edb_data.terminals.PadstackInstanceTerminal,\nlegacy.database.edb_data.terminals.PointTerminal,\nlegacy.database.edb_data.terminals.PinGroupTerminal,\nPositive terminal of the port.\nlegacy.database.edb_data.terminals.PadstackInstanceTerminal,\nlegacy.database.edb_data.terminals.PointTerminal,\nlegacy.database.edb_data.terminals.PinGroupTerminal,\nNegative terminal of the source.\ncreate_current_source\nlegacy.database.edb_data.terminals.EdgeTerminal\nlegacy.database.edb_data.terminals.PadstackInstanceTerminal\nlegacy.database.edb_data.terminals.PointTerminal\nlegacy.database.edb_data.terminals.PinGroupTerminal\nlegacy.database.edb_data.terminals.PadstackInstanceTerminal\nlegacy.database.edb_data.terminals.PointTerminal\nlegacy.database.edb_data.terminals.PinGroupTerminal\nlegacy.edb_core.edb_data.ports.ExcitationSources"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_current_source",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_current_source.html#pyedb.dotnet.edb.Edb.create_current_source",
        "title": "create_current_source > create_current_source > create_current_source",
        "section": "create_current_source > create_current_source",
        "text": "Edb.create_current_source(terminal, ref_terminal)\n\nCreate a current source.\n\nParameters\n\nterminal\n\nlegacy.database.edb_data.terminals.EdgeTerminal,\n\nlegacy.database.edb_data.terminals.PadstackInstanceTerminal,\nlegacy.database.edb_data.terminals.PointTerminal,\nlegacy.database.edb_data.terminals.PinGroupTerminal,\nPositive terminal of the port.\n\nref_terminal\n\nclass:legacy.database.edb_data.terminals.EdgeTerminal,\n\nlegacy.database.edb_data.terminals.PadstackInstanceTerminal,\nlegacy.database.edb_data.terminals.PointTerminal,\nlegacy.database.edb_data.terminals.PinGroupTerminal,\nNegative terminal of the source.\n\nReturns\n\nlegacy.edb_core.edb_data.ports.ExcitationSources\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.edbvalue.EdbValue",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.edbvalue.EdbValue.html#edbvalue",
        "title": "EdbValue",
        "section": "EdbValue",
        "text": "Class defining Edb Value properties.\nEdbValue"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.edbvalue.EdbValue",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.edbvalue.EdbValue.html#pyedb.dotnet.database.edb_data.edbvalue.EdbValue",
        "title": "EdbValue > EdbValue > EdbValue",
        "section": "EdbValue > EdbValue",
        "text": "class pyedb.dotnet.database.edb_data.edbvalue.EdbValue(edb_obj)\n\nClass defining Edb Value properties.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_component_net_connection_info",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_component_net_connection_info.html#get_component_net_connection_info",
        "title": "get_component_net_connection_info",
        "section": "get_component_net_connection_info",
        "text": "Retrieve net connection information.\nReference designator for the net.\nDictionary of the net connection information for the reference designator.\nget_component_net_connection_info\npython:dict"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_component_net_connection_info",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_component_net_connection_info.html#pyedb.dotnet.database.components.Components.get_component_net_connection_info",
        "title": "get_component_net_connection_info > get_component_net_connection_info > get_component_net_connection_info",
        "section": "get_component_net_connection_info > get_component_net_connection_info",
        "text": "Components.get_component_net_connection_info(refdes)\n\nRetrieve net connection information.\n\nParameters\n\nrefdes\n\nReference designator for the net.\n\nReturns\n\npython:dict\n\nDictionary of the net connection information for the reference designator.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", \"project name\", \"release version\")\n>>> edbapp.components.get_component_net_connection_info(refdes)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.close_edb",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.close_edb.html#close_edb",
        "title": "close_edb",
        "section": "close_edb",
        "text": "Close EDB and cleanup variables.\n. deprecated:: pyedb 0.47.0\nUse: func:close instead.\nTrue when successful, False when failed.\nclose_edb\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.close_edb",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.close_edb.html#pyedb.dotnet.edb.Edb.close_edb",
        "title": "close_edb > close_edb > close_edb",
        "section": "close_edb > close_edb",
        "text": "Edb.close_edb()\n\nClose EDB and cleanup variables.\n\n. deprecated:: pyedb 0.47.0\nUse: func:close instead.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_layout_statistics",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_layout_statistics.html#get_layout_statistics",
        "title": "get_layout_statistics",
        "section": "get_layout_statistics",
        "text": "Get layout statistics.\nWhether to compute metal area statistics.\nNet list for area computation.\nLayout statistics object.\nget_layout_statistics\noptional\npython:list\noptional\nLayoutStatistics"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_layout_statistics",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_layout_statistics.html#pyedb.grpc.database.modeler.Modeler.get_layout_statistics",
        "title": "get_layout_statistics > get_layout_statistics > get_layout_statistics",
        "section": "get_layout_statistics > get_layout_statistics",
        "text": "Modeler.get_layout_statistics(evaluate_area: bool = False, net_list: List[str] | None = None) -> LayoutStatistics\n\nGet layout statistics.\n\nParameters\n\nevaluate_area\n\nbool, optional\n\nWhether to compute metal area statistics.\n\nnet_list\n\npython:list, optional\n\nNet list for area computation.\n\nReturns\n\nLayoutStatistics\n\nLayout statistics object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.expand",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.expand.html#expand",
        "title": "expand",
        "section": "expand",
        "text": "Expand the polygon shape by an absolute value in all direction.\nOffset can be negative for negative expansion.\nOffset value in meters.\nTolerance in meters.\nWhether to round corners or not.\nIf True, use rounded corners in the expansion otherwise use straight edges (can be degenerate).\nThe maximum corner extension (when round corners are not used) at which point the corner is clipped.\nexpand\npython:float\noptional\npython:float\noptional\noptional\npython:float\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.expand",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.expand.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.expand",
        "title": "expand > expand > expand",
        "section": "expand > expand",
        "text": "PolygonData.expand(offset=0.001, tolerance=1e-12, round_corners=True, maximum_corner_extension=0.001) -> bool\n\nExpand the polygon shape by an absolute value in all direction.\nOffset can be negative for negative expansion.\n\nParameters\n\noffset\n\npython:float, optional\n\nOffset value in meters.\n\ntolerance\n\npython:float, optional\n\nTolerance in meters.\n\nround_corners\n\nbool, optional\n\nWhether to round corners or not.\nIf True, use rounded corners in the expansion otherwise use straight edges (can be degenerate).\n\nmaximum_corner_extension\n\npython:float, optional\n\nThe maximum corner extension (when round corners are not used) at which point the corner is clipped.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.html#siwave",
        "title": "Siwave",
        "section": "Siwave",
        "text": "Initializes SIwave based on the inputs provided and manages SIwave release and closing.\nVersion of AEDT to use. The default is None, in which case\nthe active setup is used or the latest installed version is used.\nSiwave.close_project([save_project])\nClose the project.\nSiwave.export_configuration(file_path[, ...])\nExport layout information into a configuration file.\nSiwave.export_dc_simulation_report(...[, ...])\nExport the Siwave DC simulation report.\nSiwave.export_edb(file_path)\nExport the layout as EDB.\nSiwave.export_element_data(simulation_name, ...)\nExport element data.\nSiwave.export_icepak_project(file_path, ...)\nExports an Icepak project for standalone use.\nSiwave.export_siwave_report(simulation_name, ...)\nExport the Siwave report.\nSiwave.import_edb(file_path)\nImport layout from EDB.\nSiwave.load_configuration(file_path)\nLoad configuration settings from a configure file.Import\nSiwave.open_project([proj_path])\nOpen a project.\nSiwave.quit_application()\nQuit the application.\nSiwave.run_dc_simulation([...])\nRun DC simulation.\nSiwave.run_icepak_simulation(...)\nRuns an Icepak simulation.\nSiwave.save(file_path)\nSave the project.\nSiwave.save_project([projectpath, projectName])\nSave the project.\nSiwave\npython:str\npython:int\npython:float\noptional\nNone\nSiwave.close_project\nSiwave.export_configuration\nSiwave.export_dc_simulation_report\nSiwave.export_edb\nSiwave.export_element_data\nSiwave.export_icepak_project\nSiwave.export_siwave_report\nSiwave.import_edb\nSiwave.load_configuration\nSiwave.open_project\nSiwave.quit_application\nSiwave.run_dc_simulation\nSiwave.run_icepak_simulation\nSiwave.save\nSiwave.save_project"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.html#pyedb.siwave.Siwave",
        "title": "Siwave > Siwave > Siwave",
        "section": "Siwave > Siwave",
        "text": "class pyedb.siwave.Siwave(specified_version=None)\n\nInitializes SIwave based on the inputs provided and manages SIwave release and closing.\n\nParameters\n\nspecified_version\n\npython:str, python:int, python:float, optional\n\nVersion of AEDT to use. The default is None, in which case\nthe active setup is used or the latest installed version is used.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nSiwave.close_project([save_project])\n\nClose the project.\n\nSiwave.export_configuration(file_path[, ...])\n\nExport layout information into a configuration file.\n\nSiwave.export_dc_simulation_report(...[, ...])\n\nExport the Siwave DC simulation report.\n\nSiwave.export_edb(file_path)\n\nExport the layout as EDB.\n\nSiwave.export_element_data(simulation_name, ...)\n\nExport element data.\n\nSiwave.export_icepak_project(file_path, ...)\n\nExports an Icepak project for standalone use.\n\nSiwave.export_siwave_report(simulation_name, ...)\n\nExport the Siwave report.\n\nSiwave.import_edb(file_path)\n\nImport layout from EDB.\n\nSiwave.load_configuration(file_path)\n\nLoad configuration settings from a configure file.Import\n\nSiwave.open_project([proj_path])\n\nOpen a project.\n\nSiwave.quit_application()\n\nQuit the application.\n\nSiwave.run_dc_simulation([...])\n\nRun DC simulation.\n\nSiwave.run_icepak_simulation(...)\n\nRuns an Icepak simulation.\n\nSiwave.save(file_path)\n\nSave the project.\n\nSiwave.save_project([projectpath, projectName])\n\nSave the project.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_siwave_dc_setup",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_siwave_dc_setup.html#create_siwave_dc_setup",
        "title": "create_siwave_dc_setup",
        "section": "create_siwave_dc_setup",
        "text": "Create SIwave DC analysis setup.\nSetup name. Auto-generated if None.\nSetup properties to modify.\nDC analysis setup.\ncreate_siwave_dc_setup\npython:str\noptional\nSIWaveDCIRSimulationSetup"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_siwave_dc_setup",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_siwave_dc_setup.html#pyedb.grpc.edb.Edb.create_siwave_dc_setup",
        "title": "create_siwave_dc_setup > create_siwave_dc_setup > create_siwave_dc_setup",
        "section": "create_siwave_dc_setup > create_siwave_dc_setup",
        "text": "Edb.create_siwave_dc_setup(name=None, **kwargs) -> SIWaveDCIRSimulationSetup\n\nCreate SIwave DC analysis setup.\n\nParameters\n\nname\n\npython:str, optional\n\nSetup name. Auto-generated if None.\n\n**kwargs\n\nSetup properties to modify.\n\nReturns\n\nSIWaveDCIRSimulationSetup\n\nDC analysis setup.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "construct"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.construct.html#pyedb.workflows.drc.drc.MinClearance.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod MinClearance.construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_configuration",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_configuration.html#export_configuration",
        "title": "export_configuration",
        "section": "export_configuration",
        "text": "Export layout information into a configuration file.\nPath to the configuration file.\nName all the padstacks in edb.\nexport_configuration\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_configuration",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_configuration.html#pyedb.siwave.Siwave.export_configuration",
        "title": "export_configuration > export_configuration > export_configuration",
        "section": "export_configuration > export_configuration",
        "text": "Siwave.export_configuration(file_path: str, fix_padstack_names: bool = False)\n\nExport layout information into a configuration file.\n\nParameters\n\nfile_path\n\npython:str\n\nPath to the configuration file.\n\nfix_padstack_names\n\nbool\n\nName all the padstacks in edb.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_validate_strings",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj: The object containing string data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nThe validated Pydantic model.\nmodel_validate_strings"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_validate_strings",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_validate_strings.html#pyedb.workflows.drc.drc.BackDrillStubLength.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod BackDrillStubLength.model_validate_strings(obj: Any, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\nValidate the given object with string data against the Pydantic model.\n\nArgs:\n\nobj: The object containing string data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nReturns:\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_3d_comp.html#create_3d_comp",
        "title": "create_3d_comp",
        "section": "create_3d_comp",
        "text": "Create a 3D composite model from an MCAD file.\n3D composite model created.\ncreate_3d_comp\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_3d_comp.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_3d_comp",
        "title": "create_3d_comp > create_3d_comp > create_3d_comp",
        "section": "create_3d_comp > create_3d_comp",
        "text": "PadstackInstance.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nReturns\n\nMcadModel\n\n3D composite model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a component group with a component.\nLayout to create the component group in.\nName of the component group.\nName of the ComponentDef instance that             the component group refers to.\nComponent group created.\ncreate\nLayout\npython:str\npython:str\nComponentDef\nComponentGroup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create.html#pyedb.grpc.database.hierarchy.component.Component.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod Component.create(layout, name, comp_name)\n\nCreate a component group with a component.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to create the component group in.\n\nname\n\npython:str\n\nName of the component group.\n\ncomp_name\n\npython:str\n\nName of the ComponentDef instance that             the component group refers to.\n\nReturns\n\nComponentGroup\n\nComponent group created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.set_coax_port_attributes",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.set_coax_port_attributes.html#set_coax_port_attributes",
        "title": "set_coax_port_attributes",
        "section": "set_coax_port_attributes",
        "text": "Set coaxial port attribute with forcing default impedance to 50 Ohms and adjusting the coaxial extent radius.\nEdb_DATA.SimulationConfiguration object.\nTrue when succeeded, False when failed.\nset_coax_port_attributes"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.set_coax_port_attributes",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.set_coax_port_attributes.html#pyedb.dotnet.database.hfss.EdbHfss.set_coax_port_attributes",
        "title": "set_coax_port_attributes > set_coax_port_attributes > set_coax_port_attributes",
        "section": "set_coax_port_attributes > set_coax_port_attributes",
        "text": "EdbHfss.set_coax_port_attributes(simulation_setup=None)\n\nSet coaxial port attribute with forcing default impedance to 50 Ohms and adjusting the coaxial extent radius.\n\nParameters\n\nsimulation_setup\n\nEdb_DATA.SimulationConfiguration object.\n\nReturns\n\nbool\n\nTrue when succeeded, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_pins_name_from_net",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_pins_name_from_net.html#get_pins_name_from_net",
        "title": "get_pins_name_from_net",
        "section": "get_pins_name_from_net",
        "text": "Retrieve pins belonging to a net.\nList of pins to check. The default is None, in which case all pins are checked\nName of the net.\nPins belonging to the net.\nget_pins_name_from_net\npython:list\nof\nEDBPadstackInstance\noptional\nNone\npython:str\npython:list\nof\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_pins_name_from_net",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_pins_name_from_net.html#pyedb.dotnet.database.components.Components.get_pins_name_from_net",
        "title": "get_pins_name_from_net > get_pins_name_from_net > get_pins_name_from_net",
        "section": "get_pins_name_from_net > get_pins_name_from_net",
        "text": "Components.get_pins_name_from_net(net_name, pin_list=None)\n\nRetrieve pins belonging to a net.\n\nParameters\n\npin_list\n\npython:list of EDBPadstackInstance, optional\n\nList of pins to check. The default is None, in which case all pins are checked\n\nnet_name\n\npython:str\n\nName of the net.\n\nReturns\n\npython:list of python:str names:\n\nPins belonging to the net.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", \"project name\", \"release version\")\n>>> edbapp.components.get_pins_name_from_net(pin_list, net_name)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "validate"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.validate.html#pyedb.workflows.drc.drc.CopperBalance.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod CopperBalance.validate(value: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.json.html#json",
        "title": "json",
        "section": "json",
        "text": "json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.json.html#pyedb.workflows.drc.drc.MinLineWidth.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "MinLineWidth.json(*, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -> str\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create_rlc_component",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create_rlc_component.html#create_rlc_component",
        "title": "create_rlc_component",
        "section": "create_rlc_component",
        "text": "Create physical Rlc component.\nList of EDB pins, length must be 2, since only 2 pins component are currently supported.\nIt can be an dotnet.database.edb_data.padstacks_data.EDBPadstackInstance object or\nan Edb Padstack Instance object.\nComponent definition name.\nResistor value.\nCapacitance value.\nInductor value.\nUsing parallel model when True, series when False.\nCreated EDB component.\ncreate_rlc_component\npython:list\npython:str\npython:float\npython:float\npython:float\nTrue\nFalse\nComponent"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create_rlc_component",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create_rlc_component.html#pyedb.dotnet.database.components.Components.create_rlc_component",
        "title": "create_rlc_component > create_rlc_component > create_rlc_component",
        "section": "create_rlc_component > create_rlc_component",
        "text": "Components.create_rlc_component(pins, component_name='', r_value=None, c_value=None, l_value=None, is_parallel=False)\n\nCreate physical Rlc component.\n\nParameters\n\npins\n\npython:list\n\nList of EDB pins, length must be 2, since only 2 pins component are currently supported.\nIt can be an dotnet.database.edb_data.padstacks_data.EDBPadstackInstance object or\nan Edb Padstack Instance object.\n\ncomponent_name\n\npython:str\n\nComponent definition name.\n\nr_value\n\npython:float\n\nResistor value.\n\nc_value\n\npython:float\n\nCapacitance value.\n\nl_value\n\npython:float\n\nInductor value.\n\nis_parallel\n\nbool\n\nUsing parallel model when True, series when False.\n\nReturns\n\nComponent\n\nCreated EDB component.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.schema_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "schema_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.schema_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.schema_json.html#pyedb.workflows.drc.drc.BackDrillStubLength.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod BackDrillStubLength.schema_json(*, by_alias: bool = True, ref_template: str = '#/$defs/{model}', **dumps_kwargs: Any) -> str\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_parametrized_name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nString representing the new class where params are passed to cls as type variables.\nTypeError: Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_parametrized_name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_parametrized_name.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod DiffPairLengthMatch.model_parametrized_name(params: tuple[type[Any], ...]) -> str\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n\nparams: Tuple of types of the class. Given a generic class\n\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturns:\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises:\n\nTypeError: Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_current_source_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_current_source_terminal.html#create_current_source_terminal",
        "title": "create_current_source_terminal",
        "section": "create_current_source_terminal",
        "text": "Create current source terminal.\nSource magnitude, default value 1.0.\nSource phase, default value 0.0.\nSource impedance, default value 1e6.\nPin group terminal.\ncreate_current_source_terminal\npython:float\npython:int\noptional\n1.0\npython:float\npython:int\noptional\n0.0\npython:float\noptional\n1e6\nPinGroupTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_current_source_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_current_source_terminal.html#pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_current_source_terminal",
        "title": "create_current_source_terminal > create_current_source_terminal > create_current_source_terminal",
        "section": "create_current_source_terminal > create_current_source_terminal",
        "text": "PinGroup.create_current_source_terminal(magnitude=1.0, phase=0, impedance=1000000.0) -> PinGroupTerminal\n\nCreate current source terminal.\n\nParameters\n\nmagnitude\n\npython:float or python:int, optional\n\nSource magnitude, default value 1.0.\n\nphase\n\npython:float or python:int, optional\n\nSource phase, default value 0.0.\n\nimpedance\n\npython:float, optional\n\nSource impedance, default value 1e6.\n\nReturns\n\nPinGroupTerminal.\n\nPin group terminal.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.permittivity_at_frequency",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.permittivity_at_frequency.html#permittivity_at_frequency",
        "title": "permittivity_at_frequency",
        "section": "permittivity_at_frequency",
        "text": "permittivity_at_frequency"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.permittivity_at_frequency",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.permittivity_at_frequency.html#pyedb.grpc.database.definition.materials.MaterialProperties.permittivity_at_frequency",
        "title": "permittivity_at_frequency > permittivity_at_frequency > permittivity_at_frequency",
        "section": "permittivity_at_frequency > permittivity_at_frequency",
        "text": "MaterialProperties.permittivity_at_frequency: Annotated[float, Gt(gt=0)] | None\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.convert_to_3d_microvias",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.convert_to_3d_microvias.html#convert_to_3d_microvias",
        "title": "convert_to_3d_microvias",
        "section": "convert_to_3d_microvias",
        "text": "Convert actual padstack instance to microvias 3D Objects with a given aspect ratio.\nEither to convert only vias belonging to signal nets or all vias. Defaults is True.\nAngle of laser penetration in degrees. The angle defines the lowest hole diameter with this formula:\nHoleDiameter -2*tan(laser_angle* Hole depth). Hole depth is the height of the via (dielectric thickness).\nThe default is 15.\nThe lowest hole is 0.75*HoleDepth/HoleDiam.\nWhether to delete the padstack definition. The default is True.\nIf False, the padstack definition is not deleted and the hole size is set to zero.\nconvert_to_3d_microvias\noptional\nTrue\npython:float\noptional\n15\n0.75*HoleDepth/HoleDiam\noptional\nTrue\nFalse\nTrue\nwhen\nsuccessful\nFalse\nwhen"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.convert_to_3d_microvias",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.convert_to_3d_microvias.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.convert_to_3d_microvias",
        "title": "convert_to_3d_microvias > convert_to_3d_microvias > convert_to_3d_microvias",
        "section": "convert_to_3d_microvias > convert_to_3d_microvias",
        "text": "EDBPadstack.convert_to_3d_microvias(convert_only_signal_vias=True, hole_wall_angle=75, delete_padstack_def=True)\n\nConvert actual padstack instance to microvias 3D Objects with a given aspect ratio.\n\nParameters\n\nconvert_only_signal_vias\n\nbool, optional\n\nEither to convert only vias belonging to signal nets or all vias. Defaults is True.\n\nhole_wall_angle\n\npython:float, optional\n\nAngle of laser penetration in degrees. The angle defines the lowest hole diameter with this formula:\nHoleDiameter -2*tan(laser_angle* Hole depth). Hole depth is the height of the via (dielectric thickness).\nThe default is 15.\nThe lowest hole is 0.75*HoleDepth/HoleDiam.\n\ndelete_padstack_def\n\nbool, optional\n\nWhether to delete the padstack definition. The default is True.\nIf False, the padstack definition is not deleted and the hole size is set to zero.\n\nReturns\n\nTrue when successful, False when failed.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.clear",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.clear.html#clear",
        "title": "clear",
        "section": "clear",
        "text": "clear"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.clear",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.clear.html#pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.clear",
        "title": "clear > clear > clear",
        "section": "clear > clear",
        "text": "SweepData.clear()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_dump",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#python-mode)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude: A set of fields to include in the output.\nexclude: A set of fields to exclude from the output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\nA dictionary representation of the model.\nmodel_dump"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_dump",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_dump.html#pyedb.workflows.drc.drc.MinClearance.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "MinClearance.model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -> dict[str, Any]\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#python-mode)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n\nmode: The mode in which to_python should run.\n\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude: A set of fields to include in the output.\nexclude: A set of fields to exclude from the output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\n\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\n\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback: A function to call when an unknown value is encountered. If not provided,\n\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.create",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a SIwave DCIR setup.\ncreate\nSiwaveDCSimulationSetup"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.create",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.create.html#pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "SiwaveDCSimulationSetup.create(name=None)\n\nCreate a SIwave DCIR setup.\n\nReturns\n\nSiwaveDCSimulationSetup\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_wave_port",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_wave_port.html#create_wave_port",
        "title": "create_wave_port",
        "section": "create_wave_port",
        "text": "Create a wave port.\nPrimitive ID.\nCoordinate of the point to define the edge terminal.\nThe point must be on the target edge but not on the two\nends of the edge.\nName of the port. The default is None.\nImpedance of the port. The default value is 50.\nHorizontal extent factor. The default value is 5.\nVertical extent factor. The default value is 3.\nLaunch Width of PEC. The default value is \"0.01mm\".\nThe tuple contains: (Port name, pyedb.dotnet.database.edb_data.sources.Excitation).\ncreate_wave_port\npython:int\nPrimitive\npython:list\npython:str\noptional\nNone\npython:int\npython:float\noptional\n50\npython:int\npython:float\noptional\n5\npython:int\npython:float\noptional\n3\npython:str\noptional\n\"0.01mm\"\npython:tuple"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_wave_port",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_wave_port.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_wave_port",
        "title": "create_wave_port > create_wave_port > create_wave_port",
        "section": "create_wave_port > create_wave_port",
        "text": "SourceExcitation.create_wave_port(prim_id: int | Primitive, point_on_edge: List[float], port_name: str | None = None, impedance: int | float = 50, horizontal_extent_factor: int | float = 5, vertical_extent_factor: int | float = 3, pec_launch_width: str = '0.01mm') -> Tuple[str, WavePort]\n\nCreate a wave port.\n\nParameters\n\nprim_id\n\npython:int, Primitive\n\nPrimitive ID.\n\npoint_on_edge\n\npython:list\n\nCoordinate of the point to define the edge terminal.\nThe point must be on the target edge but not on the two\nends of the edge.\n\nport_name\n\npython:str, optional\n\nName of the port. The default is None.\n\nimpedance\n\npython:int, python:float, optional\n\nImpedance of the port. The default value is 50.\n\nhorizontal_extent_factor\n\npython:int, python:float, optional\n\nHorizontal extent factor. The default value is 5.\n\nvertical_extent_factor\n\npython:int, python:float, optional\n\nVertical extent factor. The default value is 3.\n\npec_launch_width\n\npython:str, optional\n\nLaunch Width of PEC. The default value is \"0.01mm\".\n\nReturns\n\npython:tuple\n\nThe tuple contains: (Port name, pyedb.dotnet.database.edb_data.sources.Excitation).\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> port_name, port = edb.source_excitation.create_wave_port(0, [0, 0])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileComponent",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileComponent.html#controlfilecomponent",
        "title": "ControlFileComponent",
        "section": "ControlFileComponent",
        "text": "Represents a component in the control file.\nControlFileComponent.add_pin(name, x, y, layer)\nAdd a pin to the component.\nControlFileComponent.add_port(name, z0, pospin)\nAdd a port to the component.\nControlFileComponent\nControlFileComponent.add_pin\nControlFileComponent.add_port"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileComponent",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileComponent.html#pyedb.grpc.database.control_file.ControlFileComponent",
        "title": "ControlFileComponent > ControlFileComponent > ControlFileComponent",
        "section": "ControlFileComponent > ControlFileComponent",
        "text": "class pyedb.grpc.database.control_file.ControlFileComponent\n\nRepresents a component in the control file.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nControlFileComponent.add_pin(name, x, y, layer)\n\nAdd a pin to the component.\n\nControlFileComponent.add_port(name, z0, pospin)\n\nAdd a port to the component.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.dict",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "dict"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.dict",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.dict.html#pyedb.grpc.database.definition.materials.MaterialProperties.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "MaterialProperties.dict(*, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Dict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.hfss.Hfss.add_setup",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.hfss.Hfss.add_setup.html#add_setup",
        "title": "add_setup",
        "section": "add_setup",
        "text": "Add HFSS analysis setup.\nSetup name (auto-generated if None).\nSweep distribution type (“linear”, “linear_count”, “decade_count”, “octave_count”, “exponential”).\nStarting frequency (Hz).\nStopping frequency (Hz).\nFrequency step (Hz) or count depending on distribution.\nUse discrete sweep.\nCreated setup object.\nadd_setup\npython:str\noptional\npython:str\noptional\npython:float\npython:str\noptional\npython:float\npython:str\noptional\npython:float\npython:str\npython:int\noptional\noptional\nHfssSimulationSetup"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.hfss.Hfss.add_setup",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.hfss.Hfss.add_setup.html#pyedb.grpc.database.hfss.Hfss.add_setup",
        "title": "add_setup > add_setup > add_setup",
        "section": "add_setup > add_setup",
        "text": "Hfss.add_setup(name=None, distribution='linear', start_freq=0, stop_freq=20000000000.0, step_freq=1000000.0, discrete_sweep=False) -> HfssSimulationSetup\n\nAdd HFSS analysis setup.\n\nParameters\n\nname\n\npython:str, optional\n\nSetup name (auto-generated if None).\n\ndistribution\n\npython:str, optional\n\nSweep distribution type (“linear”, “linear_count”, “decade_count”, “octave_count”, “exponential”).\n\nstart_freq\n\npython:float, python:str, optional\n\nStarting frequency (Hz).\n\nstop_freq\n\npython:float, python:str, optional\n\nStopping frequency (Hz).\n\nstep_freq\n\npython:float, python:str, python:int, optional\n\nFrequency step (Hz) or count depending on distribution.\n\ndiscrete_sweep\n\nbool, optional\n\nUse discrete sweep.\n\nReturns\n\nHfssSimulationSetup\n\nCreated setup object.\n\nExamples\n\n>>> hfss_setup = edb.hfss.add_setup(\n...     name=\"MySetup\",\n...     distribution=\"linear_count\",\n...     start_freq=1e9,\n...     stop_freq=10e9,\n...     step_freq=100,\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.netlist_model.NetlistModel",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.netlist_model.NetlistModel.html#netlistmodel",
        "title": "NetlistModel",
        "section": "NetlistModel",
        "text": "Manage NetlistModel.\nNetlistModel.clone()\nClone a model.\nNetlistModel.create(name)\nCreate a netlist model.\nNetlistModel\nNetlistModel\nNetlistModel.clone\nNetlistModel.create"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.netlist_model.NetlistModel",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.netlist_model.NetlistModel.html#pyedb.grpc.database.hierarchy.netlist_model.NetlistModel",
        "title": "NetlistModel > NetlistModel > NetlistModel",
        "section": "NetlistModel > NetlistModel",
        "text": "class pyedb.grpc.database.hierarchy.netlist_model.NetlistModel\n\nManage NetlistModel.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nNetlistModel.clone()\n\nClone a model.\n\nNetlistModel.create(name)\n\nCreate a netlist model.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.product_solver_option.html#product_solver_option",
        "title": "product_solver_option",
        "section": "product_solver_option",
        "text": "Get the name of the product solver option.\nID of the product.\nName of the solver.\nName of the product solver option.\nproduct_solver_option\nProductIdType\nstr\nstr"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.product_solver_option.html#pyedb.grpc.database.ports.ports.CircuitPort.product_solver_option",
        "title": "product_solver_option > product_solver_option > product_solver_option",
        "section": "product_solver_option > product_solver_option",
        "text": "CircuitPort.product_solver_option(product_id, solver_name)\n\nGet the name of the product solver option.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nsolver_name\n\nstr\n\nName of the solver.\n\nReturns\n\nstr\n\nName of the product solver option.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_connected_objects",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_connected_objects.html#get_connected_objects",
        "title": "get_connected_objects",
        "section": "get_connected_objects",
        "text": "Get connected objects.\nget_connected_objects\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_connected_objects",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_connected_objects.html#pyedb.dotnet.database.edb_data.ports.GapPort.get_connected_objects",
        "title": "get_connected_objects > get_connected_objects > get_connected_objects",
        "section": "get_connected_objects > get_connected_objects",
        "text": "GapPort.get_connected_objects()\n\nGet connected objects.\n\nReturns\n\npython:list\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.CurveApproxSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.CurveApproxSettings.html#curveapproxsettings",
        "title": "CurveApproxSettings",
        "section": "CurveApproxSettings",
        "text": "Manages EDB methods for curve approximate settings.\nCurveApproxSettings"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.CurveApproxSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.CurveApproxSettings.html#pyedb.dotnet.database.sim_setup_data.data.settings.CurveApproxSettings",
        "title": "CurveApproxSettings > CurveApproxSettings > CurveApproxSettings",
        "section": "CurveApproxSettings > CurveApproxSettings",
        "text": "class pyedb.dotnet.database.sim_setup_data.data.settings.CurveApproxSettings(parent)\n\nManages EDB methods for curve approximate settings.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/stackup",
        "href": "grpc_api/grpc/database/stackup.html#stackup",
        "title": "Stackup",
        "section": "Stackup",
        "text": "Class managing Stackup and layers.\nstackup.LayerCollection\nManages layer collections in an EDB database.\nstackup.Stackup\nManages EDB methods for stackup operations.\nStackup\nstackup.LayerCollection\nstackup.Stackup"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.get_simulation_settings",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.get_simulation_settings.html#get_simulation_settings",
        "title": "get_simulation_settings",
        "section": "get_simulation_settings",
        "text": "get_simulation_settings"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.get_simulation_settings",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.get_simulation_settings.html#pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.get_simulation_settings",
        "title": "get_simulation_settings > get_simulation_settings > get_simulation_settings",
        "section": "get_simulation_settings > get_simulation_settings",
        "text": "SiwaveSimulationSetup.get_simulation_settings()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_connected_objects",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_connected_objects.html#get_connected_objects",
        "title": "get_connected_objects",
        "section": "get_connected_objects",
        "text": "Get connected objects.\nget_connected_objects\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_connected_objects",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_connected_objects.html#pyedb.dotnet.database.edb_data.ports.WavePort.get_connected_objects",
        "title": "get_connected_objects > get_connected_objects > get_connected_objects",
        "section": "get_connected_objects > get_connected_objects",
        "text": "WavePort.get_connected_objects()\n\nGet connected objects.\n\nReturns\n\npython:list\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.add_design_variable",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.add_design_variable.html#add_design_variable",
        "title": "add_design_variable",
        "section": "add_design_variable",
        "text": "Add design variable.\nVariable name.\nVariable value with units.\nAdd as local variable. Default False.\nVariable description.\nTrue if successful, False if variable exists.\nadd_design_variable\npython:str\npython:str\npython:float\noptional\npython:str\noptional"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.add_design_variable",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.add_design_variable.html#pyedb.grpc.edb.Edb.add_design_variable",
        "title": "add_design_variable > add_design_variable > add_design_variable",
        "section": "add_design_variable > add_design_variable",
        "text": "Edb.add_design_variable(variable_name, variable_value, is_parameter=False, description=None) -> bool\n\nAdd design variable.\n\nParameters\n\nvariable_name\n\npython:str\n\nVariable name.\n\nvariable_value\n\npython:str, python:float\n\nVariable value with units.\n\nis_parameter\n\nbool, optional\n\nAdd as local variable. Default False.\n\ndescription\n\npython:str, optional\n\nVariable description.\n\nReturns\n\nbool\n\nTrue if successful, False if variable exists.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSetups",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSetups.html#controlfilesetups",
        "title": "ControlFileSetups",
        "section": "ControlFileSetups",
        "text": "Manages simulation setups.\nControlFileSetups.add_setup(name, frequency)\nAdd a simulation setup.\nControlFileSetups\nControlFileSetups.add_setup"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSetups",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSetups.html#pyedb.grpc.database.control_file.ControlFileSetups",
        "title": "ControlFileSetups > ControlFileSetups > ControlFileSetups",
        "section": "ControlFileSetups > ControlFileSetups",
        "text": "class pyedb.grpc.database.control_file.ControlFileSetups\n\nManages simulation setups.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nControlFileSetups.add_setup(name, frequency)\n\nAdd a simulation setup.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.find_by_id.html#find_by_id",
        "title": "find_by_id",
        "section": "find_by_id",
        "text": "Find a Connectable object by database ID in a given layout.\nLayout to search for the Connectable object.\nDatabase ID.\nConnectable object with the given database ID.\nfind_by_id\nLayout\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.find_by_id.html#pyedb.grpc.database.primitive.polygon.Polygon.find_by_id",
        "title": "find_by_id > find_by_id > find_by_id",
        "section": "find_by_id > find_by_id",
        "text": "classmethod Polygon.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the Connectable object.\n\nuid\n\npython:int\n\nDatabase ID.\n\nReturns\n\nConnectable\n\nConnectable object with the given database ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.auto_mesh_operation",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.auto_mesh_operation.html#auto_mesh_operation",
        "title": "auto_mesh_operation",
        "section": "auto_mesh_operation",
        "text": "Automatically create and apply a length-based mesh operation for all nets in the design.\nThe method inspects every signal net, determines the smallest trace width, and\nseeds a LengthMeshOperation whose maximum element length is\nsmallest_width * trace_ratio_seeding. Signal vias (padstack instances) are\nconfigured with the requested number of polygon sides, while power/ground vias\nare updated through the global num_via_sides advanced setting.\nRatio used to compute the maximum allowed element length from the\nsmallest trace width found in the design.  The resulting length is\nmin_width * trace_ratio_seeding.  Defaults to 3.\nNumber of sides (i.e. faceting resolution) assigned to signal\npadstack instances that belong to the nets being meshed.\nDefaults to 12.\nNumber of sides assigned to power/ground vias via the global\nadvanced.num_via_sides setting.  Defaults to 6.\nIf the design contains no terminals, making mesh seeding impossible.\nOnly primitives of type \"path\" are considered when determining the\nsmallest trace width.\nEvery (net, layer, sheet) tuple required by the mesher is\nautomatically populated; sheet are explicitly marked as False.\nExisting contents of mesh_operations are replaced by the\nsingle new operation.\nauto_mesh_operation\nLengthMeshOperation\nsmallest_width * trace_ratio_seeding\nnum_via_sides\npython:float\noptional\nmin_width * trace_ratio_seeding\n3\npython:int\noptional\n12\npython:int\noptional\nadvanced.num_via_sides\n6\nValueError\n\"path\"\n(net, layer, sheet)\nFalse\nmesh_operations"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.auto_mesh_operation",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.auto_mesh_operation.html#pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.auto_mesh_operation",
        "title": "auto_mesh_operation > auto_mesh_operation > auto_mesh_operation",
        "section": "auto_mesh_operation > auto_mesh_operation",
        "text": "HfssSimulationSetup.auto_mesh_operation(trace_ratio_seeding: float = 3, signal_via_side_number: int = 12, power_ground_via_side_number: int = 6) -> bool\n\nAutomatically create and apply a length-based mesh operation for all nets in the design.\n\nThe method inspects every signal net, determines the smallest trace width, and\nseeds a LengthMeshOperation whose maximum element length is\nsmallest_width * trace_ratio_seeding. Signal vias (padstack instances) are\nconfigured with the requested number of polygon sides, while power/ground vias\nare updated through the global num_via_sides advanced setting.\n\nParameters\n\ntrace_ratio_seeding\n\npython:float, optional\n\nRatio used to compute the maximum allowed element length from the\nsmallest trace width found in the design.  The resulting length is\nmin_width * trace_ratio_seeding.  Defaults to 3.\n\nsignal_via_side_number\n\npython:int, optional\n\nNumber of sides (i.e. faceting resolution) assigned to signal\npadstack instances that belong to the nets being meshed.\nDefaults to 12.\n\npower_ground_via_side_number\n\npython:int, optional\n\nNumber of sides assigned to power/ground vias via the global\nadvanced.num_via_sides setting.  Defaults to 6.\n\nReturns\n\nbool\n\n\n\nRaises\n\nValueError\n\nIf the design contains no terminals, making mesh seeding impossible.\n\nNotes\n\nOnly primitives of type \"path\" are considered when determining the\nsmallest trace width.\n\nEvery (net, layer, sheet) tuple required by the mesher is\nautomatically populated; sheet are explicitly marked as False.\n\nExisting contents of mesh_operations are replaced by the\nsingle new operation.\n\nExamples\n\n>>> setup = edbapp.setups[\"my_setup\"]\n>>> setup.auto_mesh_operation(trace_ratio_seeding=4, signal_vias_side_number=16)\n>>> setup.mesh_operations[0].max_length\n'2.5um'\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create_edge_port",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create_edge_port.html#create_edge_port",
        "title": "create_edge_port",
        "section": "create_edge_port",
        "text": "Name of the port.\nPosition of the port. The default is \"End\", in which case the port is created at the end of the trace.\nOptions are \"Start\" and \"End\".\nand \"Gap\".\nName of the references layer. The default is None. Only available for gap port.\nHorizontal extent factor of the wave port. The default is 5.\nVertical extent factor of the wave port. The default is 3.\nPerfect electrical conductor width of the wave port. The default is \"0.01mm\".\ncreate_edge_port\npython:str\npython:str\noptional\n\"End\"\n\"Start\"\n\"End\"\npython:str\noptional\n\"Wave\"\n\"Wave\"\n\"Gap\"\npython:str\noptional\nNone\npython:int\noptional\n5\npython:int\noptional\n3\npython:float\npython:str\noptional\n\"0.01mm\"\nGapPort"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create_edge_port",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create_edge_port.html#pyedb.grpc.database.primitive.path.Path.create_edge_port",
        "title": "create_edge_port > create_edge_port > create_edge_port",
        "section": "create_edge_port > create_edge_port",
        "text": "Path.create_edge_port(name, position='End', port_type='Wave', reference_layer=None, horizontal_extent_factor=5, vertical_extent_factor=3, pec_launch_width='0.01mm')\n\nParameters\n\nname\n\npython:str\n\nName of the port.\n\nposition\n\npython:str, optional\n\nPosition of the port. The default is \"End\", in which case the port is created at the end of the trace.\nOptions are \"Start\" and \"End\".\n\nport_type\n\npython:str, optional\n\nType of the port. The default is \"Wave\", in which case a wave port is created. Options are \"Wave\"\n\nand \"Gap\".\n\nreference_layer\n\npython:str, optional\n\nName of the references layer. The default is None. Only available for gap port.\n\nhorizontal_extent_factor\n\npython:int, optional\n\nHorizontal extent factor of the wave port. The default is 5.\n\nvertical_extent_factor\n\npython:int, optional\n\nVertical extent factor of the wave port. The default is 3.\n\npec_launch_width\n\npython:float, python:str, optional\n\nPerfect electrical conductor width of the wave port. The default is \"0.01mm\".\n\nReturns\n\nGapPort\n\n\n\nExamples\n\n>>> edbapp = pyedb.dotnet.Edb(\"myproject.aedb\")\n>>> sig = appedb.modeler.create_trace([[0, 0], [\"9mm\", 0]], \"TOP\", \"1mm\", \"SIG\", \"Flat\", \"Flat\")\n>>> sig.create_edge_port(\"pcb_port\", \"end\", \"Wave\", None, 8, 8)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_rebuild",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce: Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors: Whether to raise errors, defaults to True.\n_parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n_types_namespace: The types namespace, defaults to None.\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_rebuild",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_rebuild.html#pyedb.workflows.drc.drc.DiffPair.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod DiffPair.model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -> bool | None\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n\nforce: Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors: Whether to raise errors, defaults to True.\n_parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n_types_namespace: The types namespace, defaults to None.\n\nReturns:\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.model.Model.clone",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.model.Model.clone.html#clone",
        "title": "clone",
        "section": "clone",
        "text": "Clone a model.\nclone\nModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.model.Model.clone",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.model.Model.clone.html#pyedb.grpc.database.hierarchy.model.Model.clone",
        "title": "clone > clone > clone",
        "section": "clone > clone",
        "text": "Model.clone()\n\nClone a model.\n\nReturns\n\nModel cloned.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.create_stride.html#create_stride",
        "title": "create_stride",
        "section": "create_stride",
        "text": "Create a Stride model from an MCAD file.\nStride model created.\ncreate_stride\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.create_stride.html#pyedb.grpc.database.ports.ports.CoaxPort.create_stride",
        "title": "create_stride > create_stride > create_stride",
        "section": "create_stride > create_stride",
        "text": "CoaxPort.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nReturns\n\nMcadModel\n\nStride model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.MicroStripTechnologyStackup",
        "href": "libraries/_autosummary/pyedb.libraries.common.MicroStripTechnologyStackup.html#microstriptechnologystackup",
        "title": "MicroStripTechnologyStackup",
        "section": "MicroStripTechnologyStackup",
        "text": "Pre-defined micro-strip stackup with bottom metal, substrate and top metal.\nActive EDB session.\nBottom metal layer.\nSubstrate dielectric layer.\nTop metal layer.\nMicroStripTechnologyStackup\nansys.edb.core.database.Database\nMetalLayer\nDielectricLayer\nMetalLayer"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.MicroStripTechnologyStackup",
        "href": "libraries/_autosummary/pyedb.libraries.common.MicroStripTechnologyStackup.html#pyedb.libraries.common.MicroStripTechnologyStackup",
        "title": "MicroStripTechnologyStackup > MicroStripTechnologyStackup > MicroStripTechnologyStackup",
        "section": "MicroStripTechnologyStackup > MicroStripTechnologyStackup",
        "text": "class pyedb.libraries.common.MicroStripTechnologyStackup(pedb)\n\nPre-defined micro-strip stackup with bottom metal, substrate and top metal.\n\nParameters\n\npedb\n\nansys.edb.core.database.Database\n\nActive EDB session.\n\nExamples\n\n>>> stack = MicroStripTechnologyStackup(edb)\n>>> stack.top_metal.thickness = 5e-6\n>>> stack.substrate.material.permittivity = 9.8\n\nAttributes\n\nbottom_metal\n\nMetalLayer\n\nBottom metal layer.\n\nsubstrate\n\nDielectricLayer\n\nSubstrate dielectric layer.\n\ntop_metal\n\nMetalLayer\n\nTop metal layer.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#hfss-log-parser--pyedbworkflowsutilitieshfss_log_parser",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser",
        "section": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser",
        "text": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser\npyedb.workflows.utilities.hfss_log_parser"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#top-level-façade",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Top-level façade",
        "section": "Top-level façade",
        "text": "Bases: object\nHigh-level façade that orchestrates all block parsers.\nTypical usage:\nExecute all sub-parsers and return a unified object.\nStructured representation of the entire log.\nParsedLog\nFileNotFoundError – If log_path does not exist.\nValueError – If a mandatory block cannot be parsed.\nTop-level façade\nobject"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser.HFSSLogParser",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Top-level façade > HFSSLogParser",
        "section": "Top-level façade > HFSSLogParser",
        "text": "class pyedb.workflows.utilities.hfss_log_parser.HFSSLogParser(log_path: str | Path)\n\nBases: object\n\nHigh-level façade that orchestrates all block parsers.\n\nTypical usage:\n\n>>> log = HFSSLogParser(\"/tmp/project.aedt.batchinfo.1234/hfss.log\")\n>>> data = log.parse()\n>>> data.is_converged()\nTrue\n\n!! processed by numpydoc !!\n\n\n\nparse() -> ParsedLog\n\nExecute all sub-parsers and return a unified object.\n\nReturns\n\nStructured representation of the entire log.\n\nReturn type\n\nParsedLog\n\nRaises\n\nFileNotFoundError – If log_path does not exist.\n\nValueError – If a mandatory block cannot be parsed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser.HFSSLogParser.parse",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Top-level façade > parse",
        "section": "Top-level façade > parse",
        "text": "parse() -> ParsedLog\n\nExecute all sub-parsers and return a unified object.\n\nReturns\n\nStructured representation of the entire log.\n\nReturn type\n\nParsedLog\n\nRaises\n\nFileNotFoundError – If log_path does not exist.\n\nValueError – If a mandatory block cannot be parsed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#aggregated-result-object",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Aggregated result object",
        "section": "Aggregated result object",
        "text": "Bases: object\nRoot container returned by HFSSLogParser.parse().\nproject (ProjectInfo) – Project meta-data.\ninit_mesh (InitMesh) – Initial-mesh metrics.\nadaptive (list[AdaptivePass]) – Adaptive passes in chronological order.\nsweep (Sweep | None) – Frequency-sweep summary (None if absent).\nAlias to keep API explicit.\nExtract only error lines (warnings are ignored).\nANSYS marks errors with [error] or *** ERROR ***.\nList of stripped error lines (empty if none).\nlist[str]\nHeuristic indicating a successful end-to-end solve.\nA simulation is considered complete when both of the following\nconditions are satisfied:\nAt least one adaptive pass converged.\nA frequency-sweep block exists with elapsed time greater than zero.\nbool\nReturn True if the adaptive solver declared convergence.\nbool\nMemory (MB) consumed by the last converged adaptive pass.\nMegabytes, or math.nan if no pass converged.\nfloat\nDeep-convert the entire object to JSON-serialisable primitives.\nPlain dict / list / scalar structure.\ndict[str, Any]\nAggregated result object\nobject\nHFSSLogParser.parse()\nNone\n[error]\n*** ERROR ***\nTrue\nmath.nan\ndict\nlist"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser.ParsedLog",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Aggregated result object > ParsedLog",
        "section": "Aggregated result object > ParsedLog",
        "text": "class pyedb.workflows.utilities.hfss_log_parser.ParsedLog(project: ProjectInfo, init_mesh: InitMesh, adaptive: List[AdaptivePass], sweep: Sweep | None)\n\nBases: object\n\nRoot container returned by HFSSLogParser.parse().\n\nVariables\n\nproject (ProjectInfo) – Project meta-data.\n\ninit_mesh (InitMesh) – Initial-mesh metrics.\n\nadaptive (list[AdaptivePass]) – Adaptive passes in chronological order.\n\nsweep (Sweep | None) – Frequency-sweep summary (None if absent).\n\n!! processed by numpydoc !!\n\n\n\nadaptive_passes() -> List[AdaptivePass]\n\nAlias to keep API explicit.\n\n!! processed by numpydoc !!\n\n\n\nerrors() -> List[str]\n\nExtract only error lines (warnings are ignored).\n\nANSYS marks errors with [error] or *** ERROR ***.\n\nReturns\n\nList of stripped error lines (empty if none).\n\nReturn type\n\nlist[str]\n\n!! processed by numpydoc !!\n\n\n\nis_completed() -> bool\n\nHeuristic indicating a successful end-to-end solve.\n\nA simulation is considered complete when both of the following\nconditions are satisfied:\n\nAt least one adaptive pass converged.\n\nA frequency-sweep block exists with elapsed time greater than zero.\n\nReturn type\n\nbool\n\n!! processed by numpydoc !!\n\n\n\nis_converged() -> bool\n\nReturn True if the adaptive solver declared convergence.\n\nReturn type\n\nbool\n\n!! processed by numpydoc !!\n\n\n\nmemory_on_convergence() -> float\n\nMemory (MB) consumed by the last converged adaptive pass.\n\nReturns\n\nMegabytes, or math.nan if no pass converged.\n\nReturn type\n\nfloat\n\n!! processed by numpydoc !!\n\n\n\nto_dict() -> dict\n\nDeep-convert the entire object to JSON-serialisable primitives.\n\nReturns\n\nPlain dict / list / scalar structure.\n\nReturn type\n\ndict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser.ParsedLog.adaptive_passes",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Aggregated result object > adaptive_passes",
        "section": "Aggregated result object > adaptive_passes",
        "text": "adaptive_passes() -> List[AdaptivePass]\n\nAlias to keep API explicit.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser.ParsedLog.errors",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Aggregated result object > errors",
        "section": "Aggregated result object > errors",
        "text": "errors() -> List[str]\n\nExtract only error lines (warnings are ignored).\n\nANSYS marks errors with [error] or *** ERROR ***.\n\nReturns\n\nList of stripped error lines (empty if none).\n\nReturn type\n\nlist[str]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser.ParsedLog.is_completed",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Aggregated result object > is_completed",
        "section": "Aggregated result object > is_completed",
        "text": "is_completed() -> bool\n\nHeuristic indicating a successful end-to-end solve.\n\nA simulation is considered complete when both of the following\nconditions are satisfied:\n\nAt least one adaptive pass converged.\n\nA frequency-sweep block exists with elapsed time greater than zero.\n\nReturn type\n\nbool\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser.ParsedLog.is_converged",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Aggregated result object > is_converged",
        "section": "Aggregated result object > is_converged",
        "text": "is_converged() -> bool\n\nReturn True if the adaptive solver declared convergence.\n\nReturn type\n\nbool\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser.ParsedLog.memory_on_convergence",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Aggregated result object > memory_on_convergence",
        "section": "Aggregated result object > memory_on_convergence",
        "text": "memory_on_convergence() -> float\n\nMemory (MB) consumed by the last converged adaptive pass.\n\nReturns\n\nMegabytes, or math.nan if no pass converged.\n\nReturn type\n\nfloat\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser.ParsedLog.to_dict",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Aggregated result object > to_dict",
        "section": "Aggregated result object > to_dict",
        "text": "to_dict() -> dict\n\nDeep-convert the entire object to JSON-serialisable primitives.\n\nReturns\n\nPlain dict / list / scalar structure.\n\nReturn type\n\ndict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#data-containers",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Data containers",
        "section": "Data containers",
        "text": "Bases: object\nBasic meta-data extracted from the header of an HFSS batch log.\nname (str) – Project name (without extension).\nfile (Path) – Full path to the project file.\ndesign (str) – Active design name (may be empty).\nuser (str) – OS user that launched the solve.\ncmd_line (str) – Exact command line used for the run.\nBases: object\nStatistics reported during the initial tetrahedral meshing phase.\ntetrahedra (int) – Number of tetrahedra created.\nmemory_mb (float) – Peak memory consumption in megabytes.\nreal_time_sec (int) – Wall clock time in seconds.\ncpu_time_sec (int) – CPU time in seconds.\nBases: object\nSingle adaptive solution pass (frequency, delta-S, memory, …).\npass_nr (int) – 1-based pass index.\nfreq_hz (float) – Target frequency in hertz.\ntetrahedra (int) – Number of tetrahedra at end of pass.\nmatrix_size (int) – Order of the FEM matrix.\nmemory_mb (float) – Memory used in megabytes.\ndelta_s (float) – Maximum |ΔS| observed (None until reported).\nconverged (bool) – True if this pass triggered convergence.\nelapsed_sec (int) – Wall time spent in this pass.\nBases: object\nFrequency-sweep summary block.\ntype (str) – Sweep algorithm: Interpolating, Discrete or Fast.\nfrequencies (int) – Total number of frequency points requested.\nsolved (list[float]) – List of frequencies (Hz) actually solved.\nelapsed_sec (int) – Wall clock time for the entire sweep.\nData containers\nobject\nobject\nobject\nNone\nTrue\nobject\nInterpolating\nDiscrete\nFast"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser.ProjectInfo",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Data containers > ProjectInfo",
        "section": "Data containers > ProjectInfo",
        "text": "class pyedb.workflows.utilities.hfss_log_parser.ProjectInfo(name: str, file: Path, design: str = '', user: str = '', cmd_line: str = '')\n\nBases: object\n\nBasic meta-data extracted from the header of an HFSS batch log.\n\nVariables\n\nname (str) – Project name (without extension).\n\nfile (Path) – Full path to the project file.\n\ndesign (str) – Active design name (may be empty).\n\nuser (str) – OS user that launched the solve.\n\ncmd_line (str) – Exact command line used for the run.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser.InitMesh",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Data containers > InitMesh",
        "section": "Data containers > InitMesh",
        "text": "class pyedb.workflows.utilities.hfss_log_parser.InitMesh(tetrahedra: int, memory_mb: float, real_time_sec: int, cpu_time_sec: int)\n\nBases: object\n\nStatistics reported during the initial tetrahedral meshing phase.\n\nVariables\n\ntetrahedra (int) – Number of tetrahedra created.\n\nmemory_mb (float) – Peak memory consumption in megabytes.\n\nreal_time_sec (int) – Wall clock time in seconds.\n\ncpu_time_sec (int) – CPU time in seconds.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser.AdaptivePass",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Data containers > AdaptivePass",
        "section": "Data containers > AdaptivePass",
        "text": "class pyedb.workflows.utilities.hfss_log_parser.AdaptivePass(pass_nr: int, freq_hz: float, tetrahedra: int, matrix_size: int, memory_mb: float, delta_s: float | None, converged: bool, elapsed_sec: int)\n\nBases: object\n\nSingle adaptive solution pass (frequency, delta-S, memory, …).\n\nVariables\n\npass_nr (int) – 1-based pass index.\n\nfreq_hz (float) – Target frequency in hertz.\n\ntetrahedra (int) – Number of tetrahedra at end of pass.\n\nmatrix_size (int) – Order of the FEM matrix.\n\nmemory_mb (float) – Memory used in megabytes.\n\ndelta_s (float) – Maximum |ΔS| observed (None until reported).\n\nconverged (bool) – True if this pass triggered convergence.\n\nelapsed_sec (int) – Wall time spent in this pass.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser.Sweep",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Data containers > Sweep",
        "section": "Data containers > Sweep",
        "text": "class pyedb.workflows.utilities.hfss_log_parser.Sweep(type: str, frequencies: int, solved: List[float], elapsed_sec: int)\n\nBases: object\n\nFrequency-sweep summary block.\n\nVariables\n\ntype (str) – Sweep algorithm: Interpolating, Discrete or Fast.\n\nfrequencies (int) – Total number of frequency points requested.\n\nsolved (list[float]) – List of frequencies (Hz) actually solved.\n\nelapsed_sec (int) – Wall clock time for the entire sweep.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#block-parsers-advanced-usage",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Block parsers (advanced usage)",
        "section": "Block parsers (advanced usage)",
        "text": "Bases: BlockParser\nExtract project meta-data from the log header.\nExample:\nParse the stored lines and return a ProjectInfo instance.\nPopulated data object.\nProjectInfo\nValueError – If mandatory fields (project name or file path)\ncannot be located.\nBases: BlockParser\nBases: BlockParser\nBuild a list of AdaptivePass objects from the adaptive section.\nParse every adaptive pass and determine which one triggered convergence.\nOrdered list of passes (pass_nr always increases).\nlist[AdaptivePass]\nBases: BlockParser\nExtract frequency-sweep summary (if present).\nReturn sweep information or None if the log contains no sweep block.\nSweep summary object.\nSweep | None\nBlock parsers (advanced usage)\nBlockParser\nProjectInfo\nBlockParser\nBlockParser\nAdaptivePass\nBlockParser\nNone"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser.ProjectBlockParser",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Block parsers (advanced usage) > ProjectBlockParser",
        "section": "Block parsers (advanced usage) > ProjectBlockParser",
        "text": "class pyedb.workflows.utilities.hfss_log_parser.ProjectBlockParser(lines: List[str])\n\nBases: BlockParser\n\nExtract project meta-data from the log header.\n\nExample:\n\n>>> block = ProjectBlockParser(lines)\n>>> info = block.parse()\n>>> info.name\n'Patch_Antenna'\n\n!! processed by numpydoc !!\n\n\n\nparse() -> ProjectInfo\n\nParse the stored lines and return a ProjectInfo instance.\n\nReturns\n\nPopulated data object.\n\nReturn type\n\nProjectInfo\n\nRaises\n\nValueError – If mandatory fields (project name or file path)\ncannot be located.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser.ProjectBlockParser.parse",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Block parsers (advanced usage) > parse",
        "section": "Block parsers (advanced usage) > parse",
        "text": "parse() -> ProjectInfo\n\nParse the stored lines and return a ProjectInfo instance.\n\nReturns\n\nPopulated data object.\n\nReturn type\n\nProjectInfo\n\nRaises\n\nValueError – If mandatory fields (project name or file path)\ncannot be located.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser.InitMeshBlockParser",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Block parsers (advanced usage) > InitMeshBlockParser",
        "section": "Block parsers (advanced usage) > InitMeshBlockParser",
        "text": "class pyedb.workflows.utilities.hfss_log_parser.InitMeshBlockParser(lines: List[str])\n\nBases: BlockParser\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser.AdaptiveBlockParser",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Block parsers (advanced usage) > AdaptiveBlockParser",
        "section": "Block parsers (advanced usage) > AdaptiveBlockParser",
        "text": "class pyedb.workflows.utilities.hfss_log_parser.AdaptiveBlockParser(lines: List[str])\n\nBases: BlockParser\n\nBuild a list of AdaptivePass objects from the adaptive section.\n\n!! processed by numpydoc !!\n\n\n\nparse() -> List[AdaptivePass]\n\nParse every adaptive pass and determine which one triggered convergence.\n\nReturns\n\nOrdered list of passes (pass_nr always increases).\n\nReturn type\n\nlist[AdaptivePass]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser.AdaptiveBlockParser.parse",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Block parsers (advanced usage) > parse",
        "section": "Block parsers (advanced usage) > parse",
        "text": "parse() -> List[AdaptivePass]\n\nParse every adaptive pass and determine which one triggered convergence.\n\nReturns\n\nOrdered list of passes (pass_nr always increases).\n\nReturn type\n\nlist[AdaptivePass]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser.SweepBlockParser",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Block parsers (advanced usage) > SweepBlockParser",
        "section": "Block parsers (advanced usage) > SweepBlockParser",
        "text": "class pyedb.workflows.utilities.hfss_log_parser.SweepBlockParser(lines: List[str])\n\nBases: BlockParser\n\nExtract frequency-sweep summary (if present).\n\n!! processed by numpydoc !!\n\n\n\nparse() -> Sweep | None\n\nReturn sweep information or None if the log contains no sweep block.\n\nReturns\n\nSweep summary object.\n\nReturn type\n\nSweep | None\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser.SweepBlockParser.parse",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Block parsers (advanced usage) > parse",
        "section": "Block parsers (advanced usage) > parse",
        "text": "parse() -> Sweep | None\n\nReturn sweep information or None if the log contains no sweep block.\n\nReturns\n\nSweep summary object.\n\nReturn type\n\nSweep | None\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#base-class",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Base class",
        "section": "Base class",
        "text": "Bases: object\nBase class for a single block parser.\nBase class\nobject"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser.BlockParser",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Base class > BlockParser",
        "section": "Base class > BlockParser",
        "text": "class pyedb.workflows.utilities.hfss_log_parser.BlockParser(lines: List[str])\n\nBases: object\n\nBase class for a single block parser.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#utility-helpers",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Utility helpers",
        "section": "Utility helpers",
        "text": "The functions below are private by convention (leading underscore) but are\nexposed in the documentation for contributors and advanced users.\nConvert a human-readable frequency string to hertz.\ntext (str) – Frequency expression such as '3 GHz', '100 kHz', '10MHz'.\nNumerical value in Hz. Returns math.nan if the string\ncannot be parsed.\nfloat\nConvert an ANSYS time stamp to seconds.\nAccepts MM:SS, H:MM:SS or HH:MM:SS.\nmm_ss (str) – Time stamp extracted from the log.\nTotal elapsed seconds.\nint\nRecursively convert dataclasses / lists / primitives to plain Python types.\nUtility helpers\n'3 GHz'\n'100 kHz'\n'10MHz'\nmath.nan\nMM:SS\nH:MM:SS\nHH:MM:SS"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser._to_hz",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Utility helpers > _to_hz",
        "section": "Utility helpers > _to_hz",
        "text": "pyedb.workflows.utilities.hfss_log_parser._to_hz(text: str) -> float\n\nConvert a human-readable frequency string to hertz.\n\nParameters\n\ntext (str) – Frequency expression such as '3 GHz', '100 kHz', '10MHz'.\n\nReturns\n\nNumerical value in Hz. Returns math.nan if the string\ncannot be parsed.\n\nReturn type\n\nfloat\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser._to_sec",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Utility helpers > _to_sec",
        "section": "Utility helpers > _to_sec",
        "text": "pyedb.workflows.utilities.hfss_log_parser._to_sec(mm_ss: str) -> int\n\nConvert an ANSYS time stamp to seconds.\n\nAccepts MM:SS, H:MM:SS or HH:MM:SS.\n\nParameters\n\nmm_ss (str) – Time stamp extracted from the log.\n\nReturns\n\nTotal elapsed seconds.\n\nReturn type\n\nint\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/hfss_log_parser",
        "href": "workflows/utilities/hfss_log_parser.html#pyedb.workflows.utilities.hfss_log_parser._as_dict",
        "title": "HFSS log parser – pyedb.workflows.utilities.hfss_log_parser > Utility helpers > _as_dict",
        "section": "Utility helpers > _as_dict",
        "text": "pyedb.workflows.utilities.hfss_log_parser._as_dict(obj: Any) -> Any\n\nRecursively convert dataclasses / lists / primitives to plain Python types.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.decouple",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.decouple.html#decouple",
        "title": "decouple",
        "section": "decouple",
        "text": "Ungroup a bundle of terminals.\ndecouple"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.decouple",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.decouple.html#pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.decouple",
        "title": "decouple > decouple > decouple",
        "section": "decouple > decouple",
        "text": "BundleTerminal.decouple() -> bool\n\nUngroup a bundle of terminals.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/simulation_setup",
        "href": "dotnet_api/dotnet/utilities/simulation_setup.html#simulation-setup",
        "title": "Simulation setup",
        "section": "Simulation setup",
        "text": "This class is the container of simulation setup.\nSimulationSetupType\nAn enumeration.\nAdaptiveType\n\nSimulationSetup\nProvide base simulation setup.\nSimulation setup\nSimulationSetupType\nAdaptiveType\nSimulationSetup"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.create",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a layer collection.\nMode of the layer collection.\nLayer collection created.\ncreate\nLayerCollectionMode\nLAMINATE\nLayerCollection"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.create",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.create.html#pyedb.grpc.database.stackup.Stackup.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "static Stackup.create(mode=LayerCollectionMode.LAMINATE)\n\nCreate a layer collection.\n\nParameters\n\nmode\n\nLayerCollectionMode, default: LAMINATE\n\nMode of the layer collection.\n\nReturns\n\nLayerCollection\n\nLayer collection created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.scale",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.scale.html#scale",
        "title": "scale",
        "section": "scale",
        "text": "Scale the polygon by a linear factor from a center.\nLinear factor.\nCenter.\nscale\npython:float\nPolygonData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.scale",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.scale.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.scale",
        "title": "scale > scale > scale",
        "section": "scale > scale",
        "text": "PolygonData.scale(factor: float, center: PointLike) -> PolygonData\n\nScale the polygon by a linear factor from a center.\n\nParameters\n\nfactor\n\npython:float\n\nLinear factor.\n\ncenter\n\nPoint2DLike\n\nCenter.\n\nReturns\n\nPolygonData\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_component_by_name",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_component_by_name.html#get_component_by_name",
        "title": "get_component_by_name",
        "section": "get_component_by_name",
        "text": "Retrieve a component by name.\nName of the component.\nComponent instance.\nget_component_by_name\npython:str\npyedb.grpc.database.hierarchy.component.Component"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_component_by_name",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_component_by_name.html#pyedb.grpc.database.components.Components.get_component_by_name",
        "title": "get_component_by_name > get_component_by_name > get_component_by_name",
        "section": "get_component_by_name > get_component_by_name",
        "text": "Components.get_component_by_name(name) -> Component\n\nRetrieve a component by name.\n\nParameters\n\nname\n\npython:str\n\nName of the component.\n\nReturns\n\npyedb.grpc.database.hierarchy.component.Component\n\nComponent instance.\n\nExamples\n\n>>> comp = edbapp.components.get_component_by_name(\"R1\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/package_def",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/package_def.html#package-definition",
        "title": "Package Definition",
        "section": "Package Definition",
        "text": "These class is the containers of package definition.\nPackageDef\nManages EDB package definitions.\nPackage Definition\nPackageDef"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.find",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.find.html#find",
        "title": "find",
        "section": "find",
        "text": "Find a terminal by name in a given layout.\nLayout to search for the terminal.\nName of the terminal.\nfind\nLayout\nstr\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.find",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.find.html#pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.find",
        "title": "find > find > find",
        "section": "find > find",
        "text": "classmethod PinGroupTerminal.find(layout, name)\n\nFind a terminal by name in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the terminal.\n\nname\n\nstr\n\nName of the terminal.\n\nReturns\n\nTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_siwave_dc_results",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_siwave_dc_results.html#export_siwave_dc_results",
        "title": "export_siwave_dc_results",
        "section": "export_siwave_dc_results",
        "text": "Export SIwave DC results.\nSIwave project path.\nDC analysis name.\nCustom output folder.\nGenerate HTML report. Default True.\nExport vias report. Default True.\nExport voltage probes. Default True.\nExport current sources. Default True.\nExport voltage sources. Default True.\nExport power tree. Default True.\nExport loop resistance. Default True.\nGenerated report files.\nexport_siwave_dc_results\npython:str\npython:str\npython:str\noptional\noptional\noptional\noptional\noptional\noptional\noptional\noptional\npython:list\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_siwave_dc_results",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_siwave_dc_results.html#pyedb.grpc.edb.Edb.export_siwave_dc_results",
        "title": "export_siwave_dc_results > export_siwave_dc_results > export_siwave_dc_results",
        "section": "export_siwave_dc_results > export_siwave_dc_results",
        "text": "Edb.export_siwave_dc_results(siwave_project, solution_name, output_folder=None, html_report=True, vias=True, voltage_probes=True, current_sources=True, voltage_sources=True, power_tree=True, loop_res=True)\n\nExport SIwave DC results.\n\nParameters\n\nsiwave_project\n\npython:str\n\nSIwave project path.\n\nsolution_name\n\npython:str\n\nDC analysis name.\n\noutput_folder\n\npython:str, optional\n\nCustom output folder.\n\nhtml_report\n\nbool, optional\n\nGenerate HTML report. Default True.\n\nvias\n\nbool, optional\n\nExport vias report. Default True.\n\nvoltage_probes\n\nbool, optional\n\nExport voltage probes. Default True.\n\ncurrent_sources\n\nbool, optional\n\nExport current sources. Default True.\n\nvoltage_sources\n\nbool, optional\n\nExport voltage sources. Default True.\n\npower_tree\n\nbool, optional\n\nExport power tree. Default True.\n\nloop_res\n\nbool, optional\n\nExport loop resistance. Default True.\n\nReturns\n\npython:list[python:str]\n\nGenerated report files.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_source",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_source.html#create_voltage_source",
        "title": "create_voltage_source",
        "section": "create_voltage_source",
        "text": "Create a voltage source.\nVoltage source name\nPadstackInstanceTerminal,\nPointTerminal,\nPinGroupTerminal,\nPositive terminal of the source.\npyedb.grpc.database.terminals.PadstackInstanceTerminal,\nPadstackInstanceTerminal,\nPinGroupTerminal,\nNegative terminal of the source.\nMagnitude of the source.\nPhase of the source\ncreate_voltage_source\npython:str\noptional\nEdgeTerminal\nPadstackInstanceTerminal\nPointTerminal\nPinGroupTerminal\nEdgeTerminal\npyedb.grpc.database.terminals.PadstackInstanceTerminal\nPadstackInstanceTerminal\nPinGroupTerminal\npython:int\npython:float\noptional\npython:int\npython:float\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_source",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_source.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_source",
        "title": "create_voltage_source > create_voltage_source > create_voltage_source",
        "section": "create_voltage_source > create_voltage_source",
        "text": "SourceExcitation.create_voltage_source(terminal: PadstackInstanceTerminal | EdgeTerminal, ref_terminal: PadstackInstanceTerminal | EdgeTerminal, magnitude: int | float = 1, phase: int | float = 0) -> bool\n\nCreate a voltage source.\n\nParameters\n\nname\n\npython:str, optional\n\nVoltage source name\n\nterminal\n\nEdgeTerminal,\n\nPadstackInstanceTerminal,\nPointTerminal,\nPinGroupTerminal,\nPositive terminal of the source.\n\nref_terminal\n\nEdgeTerminal,\n\npyedb.grpc.database.terminals.PadstackInstanceTerminal,\nPadstackInstanceTerminal,\nPinGroupTerminal,\nNegative terminal of the source.\n\nmagnitude\n\npython:int, python:float, optional\n\nMagnitude of the source.\n\nphase\n\npython:int, python:float, optional\n\nPhase of the source\n\nReturns\n\nclass:ExcitationSources <legacy.database.edb_data.ports.ExcitationSources>\n\n\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> edb.source_excitation.create_voltage_source_on_pin_group(\"PG1\", \"PG2\", 3.3, name=\"VSource1\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "contribution_guide",
        "href": "contribution_guide.html#contribution-guide",
        "title": "Contribution Guide",
        "section": "Contribution Guide",
        "text": "All contributions to PyEDB are welcome. This guide helps you get started.\nContribution Guide"
    },
    {
        "objectID": "contribution_guide",
        "href": "contribution_guide.html#development-environment-setup",
        "title": "Contribution Guide > Development Environment Setup",
        "section": "Development Environment Setup",
        "text": "Fork the PyEDB repository on GitHub.\nClone your fork locally:\nInstall the package in development mode with all dependencies:\nInstall pre-commit hooks to ensure code quality:\nDevelopment Environment Setup"
    },
    {
        "objectID": "contribution_guide",
        "href": "contribution_guide.html#running-tests",
        "title": "Contribution Guide > Running Tests",
        "section": "Running Tests",
        "text": "To ensure your changes don’t break existing functionality, run the test suite:\nRunning Tests"
    },
    {
        "objectID": "contribution_guide",
        "href": "contribution_guide.html#building-documentation",
        "title": "Contribution Guide > Building Documentation",
        "section": "Building Documentation",
        "text": "To build and preview the documentation locally:\nBuilding Documentation"
    },
    {
        "objectID": "contribution_guide",
        "href": "contribution_guide.html#submission-process",
        "title": "Contribution Guide > Submission Process",
        "section": "Submission Process",
        "text": "Create a branch for your feature or bug fix: git checkout -b feature/your-feature-name\nMake your changes and add tests.\nEnsure all tests pass and pre-commit checks are satisfied.\nCommit your changes: git commit -m “Add feature: your feature description”\nPush to your fork: git push origin feature/your-feature-name\nOpen a Pull Request against the main PyEDB repository.\nSubmission Process"
    },
    {
        "objectID": "contribution_guide",
        "href": "contribution_guide.html#code-style",
        "title": "Contribution Guide > Code Style",
        "section": "Code Style",
        "text": "Follow PEP 8 guidelines.\nUse Google-style docstrings for all public functions and classes.\nInclude type hints for all function parameters and return values.\nCode Style"
    },
    {
        "objectID": "contribution_guide",
        "href": "contribution_guide.html#documentation-contributions",
        "title": "Contribution Guide > Documentation Contributions",
        "section": "Documentation Contributions",
        "text": "When adding new features, please also update the relevant documentation:\nAdd examples to the appropriate section in user_guide/common_tasks.rst.\nCreate a new Jupyter notebook in doc/notebooks/ if the feature warrants a comprehensive example.\nEnsure all new public API elements have proper docstrings.\nDocumentation Contributions"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_convex",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_convex.html#is_convex",
        "title": "is_convex",
        "section": "is_convex",
        "text": "Determine whether the polygon is a convex hull.\nTrue when the polygon is a convex hull, False otherwise.\nis_convex\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_convex",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_convex.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.is_convex",
        "title": "is_convex > is_convex > is_convex",
        "section": "is_convex > is_convex",
        "text": "PolygonData.is_convex() -> bool\n\nDetermine whether the polygon is a convex hull.\n\nReturns\n\nbool\n\nTrue when the polygon is a convex hull, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.parametrize_trace_width",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.parametrize_trace_width.html#parametrize_trace_width",
        "title": "parametrize_trace_width",
        "section": "parametrize_trace_width",
        "text": "Parametrize trace width.\nNet name(s).\nLayer name(s) filter.\nParameter name prefix.\nInitial parameter value.\nTrue if successful, False otherwise.\nparametrize_trace_width\npython:str\npython:list\npython:str\npython:list\noptional\npython:str\noptional\npython:float\npython:str\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.parametrize_trace_width",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.parametrize_trace_width.html#pyedb.grpc.database.modeler.Modeler.parametrize_trace_width",
        "title": "parametrize_trace_width > parametrize_trace_width > parametrize_trace_width",
        "section": "parametrize_trace_width > parametrize_trace_width",
        "text": "Modeler.parametrize_trace_width(nets_name: str | List[str], layers_name: str | List[str] | None = None, parameter_name: str = 'trace_width', variable_value: float | str | None = None) -> bool\n\nParametrize trace width.\n\nParameters\n\nnets_name\n\npython:str or python:list\n\nNet name(s).\n\nlayers_name\n\npython:str or python:list, optional\n\nLayer name(s) filter.\n\nparameter_name\n\npython:str, optional\n\nParameter name prefix.\n\nvariable_value\n\npython:float or python:str, optional\n\nInitial parameter value.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/extended_net",
        "href": "grpc_api/grpc/database/pyedb_lib/net/extended_net.html#extended-net",
        "title": "Extended net",
        "section": "Extended net",
        "text": "This class is managing EDB extended net.\nExtendedNet\nManages EDB functionalities for a primitives.\nExtendedNets\n\nExtended net\nExtendedNet\nExtendedNets"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_hfss_setup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_hfss_setup.html#create_hfss_setup",
        "title": "create_hfss_setup",
        "section": "create_hfss_setup",
        "text": "Create an HFSS simulation setup from a template.\nSetup name.\ncreate_hfss_setup\npython:str\noptional\nlegacy.database.edb_data.hfss_simulation_setup_data.HfssSimulationSetup"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_hfss_setup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_hfss_setup.html#pyedb.dotnet.edb.Edb.create_hfss_setup",
        "title": "create_hfss_setup > create_hfss_setup > create_hfss_setup",
        "section": "create_hfss_setup > create_hfss_setup",
        "text": "Edb.create_hfss_setup(name=None)\n\nCreate an HFSS simulation setup from a template.\n\nParameters\n\nname\n\npython:str, optional\n\nSetup name.\n\nReturns\n\nlegacy.database.edb_data.hfss_simulation_setup_data.HfssSimulationSetup\n\n\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb()\n>>> setup1 = edbapp.create_hfss_setup(\"setup1\")\n>>> setup1.hfss_port_settings.max_delta_z0 = 0.5\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.remove_all_power_modules",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.remove_all_power_modules.html#remove_all_power_modules",
        "title": "remove_all_power_modules",
        "section": "remove_all_power_modules",
        "text": "Remove all power modules in the voltage regulator.\nremove_all_power_modules"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.remove_all_power_modules",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.remove_all_power_modules.html#pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.remove_all_power_modules",
        "title": "remove_all_power_modules > remove_all_power_modules > remove_all_power_modules",
        "section": "remove_all_power_modules > remove_all_power_modules",
        "text": "VoltageRegulator.remove_all_power_modules()\n\nRemove all power modules in the voltage regulator.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_general_settings.RaptorXGeneralSettings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_general_settings.RaptorXGeneralSettings.html#raptorxgeneralsettings",
        "title": "RaptorXGeneralSettings",
        "section": "RaptorXGeneralSettings",
        "text": "Raptor X general settings class.\nRaptorXGeneralSettings"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_general_settings.RaptorXGeneralSettings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_general_settings.RaptorXGeneralSettings.html#pyedb.grpc.database.simulation_setup.raptor_x_general_settings.RaptorXGeneralSettings",
        "title": "RaptorXGeneralSettings > RaptorXGeneralSettings > RaptorXGeneralSettings",
        "section": "RaptorXGeneralSettings > RaptorXGeneralSettings",
        "text": "class pyedb.grpc.database.simulation_setup.raptor_x_general_settings.RaptorXGeneralSettings(pedb, edb_object)\n\nRaptor X general settings class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.product_solver_option.html#product_solver_option",
        "title": "product_solver_option",
        "section": "product_solver_option",
        "text": "Get the name of the product solver option.\nID of the product.\nName of the solver.\nName of the product solver option.\nproduct_solver_option\nProductIdType\nstr\nstr"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.product_solver_option.html#pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.product_solver_option",
        "title": "product_solver_option > product_solver_option > product_solver_option",
        "section": "product_solver_option > product_solver_option",
        "text": "PadstackInstanceTerminal.product_solver_option(product_id, solver_name)\n\nGet the name of the product solver option.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nsolver_name\n\nstr\n\nName of the solver.\n\nReturns\n\nstr\n\nName of the product solver option.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_source_on_component",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_source_on_component.html#create_source_on_component",
        "title": "create_source_on_component",
        "section": "create_source_on_component",
        "text": "Create voltage, current source, or resistor on component.\nList of pyedb.grpc.utility.sources.Source objects.\nTrue when successful, False when failed.\ncreate_source_on_component\npython:list\nSource\npyedb.grpc.utility.sources.Source\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_source_on_component",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_source_on_component.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_source_on_component",
        "title": "create_source_on_component > create_source_on_component > create_source_on_component",
        "section": "create_source_on_component > create_source_on_component",
        "text": "SourceExcitation.create_source_on_component(sources: Source | List[Source] | None = None) -> bool\n\nCreate voltage, current source, or resistor on component.\n\nParameters\n\nsources\n\npython:list[Source]\n\nList of pyedb.grpc.utility.sources.Source objects.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> from pyedb import Edb\n>>> from pyedb.grpc.utility.sources import Source, SourceType\n>>> edb = Edb()\n>>> source = Source(source_type=SourceType.Vsource, amplitude=\"1V\", ...)\n>>> edb.source_excitation.create_source_on_component([source])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_dump",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#python-mode)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude: A set of fields to include in the output.\nexclude: A set of fields to exclude from the output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\nA dictionary representation of the model.\nmodel_dump"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_dump",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_dump.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "DiffPairLengthMatch.model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -> dict[str, Any]\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#python-mode)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n\nmode: The mode in which to_python should run.\n\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude: A set of fields to include in the output.\nexclude: A set of fields to exclude from the output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\n\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\n\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback: A function to call when an unknown value is encountered. If not provided,\n\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.is_intersecting",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.is_intersecting.html#is_intersecting",
        "title": "is_intersecting",
        "section": "is_intersecting",
        "text": "Check if actual primitive and another primitive or polygon data intesects.\nis_intersecting\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.is_intersecting",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.is_intersecting.html#pyedb.grpc.database.primitive.circle.Circle.is_intersecting",
        "title": "is_intersecting > is_intersecting > is_intersecting",
        "section": "is_intersecting > is_intersecting",
        "text": "Circle.is_intersecting(primitive) -> bool\n\nCheck if actual primitive and another primitive or polygon data intesects.\n\nParameters\n\nprimitive\n\nPrimitive or PolygonData\n\n\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.in_polygon",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.in_polygon.html#in_polygon",
        "title": "in_polygon",
        "section": "in_polygon",
        "text": "Check if padstack Instance is in given polygon data.\nWhether to include partial intersecting instances. The default is True.\nWhether to perform a single check based on the padstack center or check the padstack bounding box.\nWhen include_partial is True, an arbitrary value is used to create a bounding box for the padstack\ninstance to check for intersection and save computation time during the cutout. The default is 300e-6.\nTrue when successful, False when failed.\nin_polygon\nPolygonData\nObject\noptional\nTrue\noptional\npython:float\noptional\ninclude_partial\nTrue\n300e-6\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.in_polygon",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.in_polygon.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.in_polygon",
        "title": "in_polygon > in_polygon > in_polygon",
        "section": "in_polygon > in_polygon",
        "text": "PadstackInstance.in_polygon(polygon_data, include_partial=True, arbitrary_extent_value=0.0003) -> bool\n\nCheck if padstack Instance is in given polygon data.\n\nParameters\n\npolygon_data\n\nPolygonData Object\n\n\n\ninclude_partial\n\nbool, optional\n\nWhether to include partial intersecting instances. The default is True.\n\nsimple_check\n\nbool, optional\n\nWhether to perform a single check based on the padstack center or check the padstack bounding box.\n\narbitrary_extent_value\n\npython:float, optional\n\nWhen include_partial is True, an arbitrary value is used to create a bounding box for the padstack\ninstance to check for intersection and save computation time during the cutout. The default is 300e-6.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.create_3d_comp.html#create_3d_comp",
        "title": "create_3d_comp",
        "section": "create_3d_comp",
        "text": "Create a 3D composite model from an MCAD file.\n3D composite model created.\ncreate_3d_comp\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.create_3d_comp.html#pyedb.grpc.database.primitive.polygon.Polygon.create_3d_comp",
        "title": "create_3d_comp > create_3d_comp > create_3d_comp",
        "section": "create_3d_comp > create_3d_comp",
        "text": "Polygon.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nReturns\n\nMcadModel\n\n3D composite model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.illegal_rlc_values",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.illegal_rlc_values.html#illegal_rlc_values",
        "title": "illegal_rlc_values",
        "section": "illegal_rlc_values",
        "text": "Find and fix RLC illegal values.\nillegal_rlc_values"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.illegal_rlc_values",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.illegal_rlc_values.html#pyedb.grpc.database.layout_validation.LayoutValidation.illegal_rlc_values",
        "title": "illegal_rlc_values > illegal_rlc_values > illegal_rlc_values",
        "section": "illegal_rlc_values > illegal_rlc_values",
        "text": "LayoutValidation.illegal_rlc_values(fix: bool = False) -> List[str]\n\nFind and fix RLC illegal values.\n\nExamples\n\n>>> edb = Edb(\"edb_file\")\n>>> # Identify components with illegal RLC values\n>>> bad_components = edb.layout_validation.illegal_rlc_values()\n>>>\n>>> # Automatically fix invalid inductor values\n>>> edb.layout_validation.illegal_rlc_values(fix=True)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_rebuild",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce: Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors: Whether to raise errors, defaults to True.\n_parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n_types_namespace: The types namespace, defaults to None.\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_rebuild",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_rebuild.html#pyedb.workflows.drc.drc.CopperBalance.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod CopperBalance.model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -> bool | None\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n\nforce: Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors: Whether to raise errors, defaults to True.\n_parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n_types_namespace: The types namespace, defaults to None.\n\nReturns:\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.DCTerminal",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.DCTerminal.html#dcterminal",
        "title": "DCTerminal",
        "section": "DCTerminal",
        "text": "Manages a dc terminal source.\nDCTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.DCTerminal",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.DCTerminal.html#pyedb.grpc.database.utility.sources.DCTerminal",
        "title": "DCTerminal > DCTerminal > DCTerminal",
        "section": "DCTerminal > DCTerminal",
        "text": "class pyedb.grpc.database.utility.sources.DCTerminal\n\nManages a dc terminal source.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.find",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.find.html#find",
        "title": "find",
        "section": "find",
        "text": "Find a pin group by name in a given layout.\nLayout to search for the pin group.\nName of the pin group.\nPin group found, None otherwise.\nfind\nLayout\npython:str\nPinGroup\nNone"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.find",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.find.html#pyedb.grpc.database.hierarchy.pingroup.PinGroup.find",
        "title": "find > find > find",
        "section": "find > find",
        "text": "classmethod PinGroup.find(layout, name)\n\nFind a pin group by name in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the pin group.\n\nname\n\npython:str\n\nName of the pin group.\n\nReturns\n\nPinGroup\n\nPin group found, None otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.in_polygon",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.in_polygon.html#in_polygon",
        "title": "in_polygon",
        "section": "in_polygon",
        "text": "Check if padstack Instance is in given polygon data.\nWhether to include partial intersecting instances. The default is True.\nTrue when successful, False when failed.\nin_polygon\nPointData\nObject\npython:list\nof\npython:float\noptional\nTrue\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.in_polygon",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.in_polygon.html#pyedb.grpc.database.primitive.polygon.Polygon.in_polygon",
        "title": "in_polygon > in_polygon > in_polygon",
        "section": "in_polygon > in_polygon",
        "text": "Polygon.in_polygon(point_data, include_partial=True) -> bool\n\nCheck if padstack Instance is in given polygon data.\n\nParameters\n\npoint_data\n\nPointData Object or python:list of python:float\n\n\n\ninclude_partial\n\nbool, optional\n\nWhether to include partial intersecting instances. The default is True.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_computed_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_computed_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_computed_fields.html#pyedb.workflows.drc.drc.MinClearance.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "MinClearance.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.Meander",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.Meander.html#meander",
        "title": "Meander",
        "section": "Meander",
        "text": "Fully-parametric micro-strip meander line.\nVertical spacing between successive meander rows [m].\nWidth of the micro-strip [m].\nHorizontal excursion of each U-turn [m].\nNumber of 180° bends.\nEDB metal layer.\nNet name assigned to the trace.\nMeander.create()\nDraw the meander in the attached EDB cell and calculate its physical length.\nMeander.electrical_length_deg(freq)\nElectrical length of the meander at the specified frequency.\nMeander\npython:float\ndefault\nmm\npython:float\ndefault\nmm\npython:float\ndefault\nmm\npython:int\ndefault\npython:str\ndefault\npython:str\ndefault\nMeander.create\nMeander.electrical_length_deg"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.Meander",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.Meander.html#pyedb.libraries.rf_libraries.base_functions.Meander",
        "title": "Meander > Meander > Meander",
        "section": "Meander > Meander",
        "text": "class pyedb.libraries.rf_libraries.base_functions.Meander(edb_cell: Edb, pitch: str | float = 0.001, trace_width: str | float = 0.0003, amplitude: str | float = 0.005, num_turns: int = 8, layer: str = 'TOP', net: str = 'SIG')\n\nFully-parametric micro-strip meander line.\n\nParameters\n\npitch\n\npython:float, default 1 mm\n\nVertical spacing between successive meander rows [m].\n\ntrace_width\n\npython:float, default 0.3 mm\n\nWidth of the micro-strip [m].\n\namplitude\n\npython:float, default 5 mm\n\nHorizontal excursion of each U-turn [m].\n\nnum_turns\n\npython:int, default 8\n\nNumber of 180° bends.\n\nlayer\n\npython:str, default “TOP”\n\nEDB metal layer.\n\nnet\n\npython:str, default “SIG”\n\nNet name assigned to the trace.\n\nExamples\n\n>>> m = Meander(pitch=0.2e-3, trace_width=0.15e-3, amplitude=2e-3, num_turns=4)\n>>> edb = Edb(\"meander.aedb\")\n>>> m._pedb = edb\n>>> m.create()\n>>> f\"{m.analytical_z0:.1f} Ω\"\n'50.1 Ω'\n>>> m.electrical_length_deg(1e9)\n59.8\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nMeander.create()\n\nDraw the meander in the attached EDB cell and calculate its physical length.\n\nMeander.electrical_length_deg(freq)\n\nElectrical length of the meander at the specified frequency.\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType.kMeshSetupSkinDepth",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType.kMeshSetupSkinDepth.html#kmeshsetupskindepth",
        "title": "kMeshSetupSkinDepth",
        "section": "kMeshSetupSkinDepth",
        "text": "kMeshSetupSkinDepth"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType.kMeshSetupSkinDepth",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType.kMeshSetupSkinDepth.html#pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType.kMeshSetupSkinDepth",
        "title": "kMeshSetupSkinDepth > kMeshSetupSkinDepth > kMeshSetupSkinDepth",
        "section": "kMeshSetupSkinDepth > kMeshSetupSkinDepth",
        "text": "MeshOpType.kMeshSetupSkinDepth = 'skin_depth'\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.hfss_extent_info.HfssExtentInfo.load_config",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.hfss_extent_info.HfssExtentInfo.load_config.html#load_config",
        "title": "load_config",
        "section": "load_config",
        "text": "Load HFSS extent configuration.\nParameters of the HFSS extent information.\nload_config"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.hfss_extent_info.HfssExtentInfo.load_config",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.hfss_extent_info.HfssExtentInfo.load_config.html#pyedb.grpc.database.utility.hfss_extent_info.HfssExtentInfo.load_config",
        "title": "load_config > load_config > load_config",
        "section": "load_config > load_config",
        "text": "HfssExtentInfo.load_config(config)\n\nLoad HFSS extent configuration.\n\nParameters\n\nconfig: dict\n\nParameters of the HFSS extent information.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/layout_statistics",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/layout_statistics.html#layout-statistics",
        "title": "Layout statistics",
        "section": "Layout statistics",
        "text": "This class is managing EDB layout statistics.\nLayoutStatistics\nStatistics object\nLayout statistics\nLayoutStatistics"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.parse_raw",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "parse_raw"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.parse_raw",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.parse_raw.html#pyedb.workflows.drc.drc.DiffPair.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod DiffPair.parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.add_point",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.add_point.html#add_point",
        "title": "add_point",
        "section": "add_point",
        "text": "Add a point at the end of the path.\nX coordinate.\nY coordinate.\nAdd point incrementally. If True, coordinates of the added point is incremental to the last point.\nThe default value is True.\nadd_point\nTrue"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.add_point",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.add_point.html#pyedb.grpc.database.primitive.path.Path.add_point",
        "title": "add_point > add_point > add_point",
        "section": "add_point > add_point",
        "text": "Path.add_point(x, y, incremental=True) -> bool\n\nAdd a point at the end of the path.\n\nParameters\n\nx: str, int, float\n\nX coordinate.\n\ny: str, in, float\n\nY coordinate.\n\nincremental: bool\n\nAdd point incrementally. If True, coordinates of the added point is incremental to the last point.\nThe default value is True.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileStackup.add_layer",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileStackup.add_layer.html#add_layer",
        "title": "add_layer",
        "section": "add_layer",
        "text": "Add a new layer.\nLayer name.\nLayer elevation.\nMaterial for the layer.\nGDS type assigned on the layer. The value must be the same as in the GDS file otherwise geometries won’t be\nimported.\nLayer name assigned in EDB or HFSS 3D layout after import.\nLayer thickness\nDefine the layer type, default value for a layer is \"conductor\"\nWhen True solver will solve inside metal, and not id False. Default value is True.\nDictionary with key and  property value.\nadd_layer\npython:str\npython:float\npython:str\npython:int\npython:str\npython:float\npython:str\n\"conductor\"\nTrue\nFalse\nTrue\npython:dict\npyedb.dotnet.database.edb_data.control_file.ControlFileLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileStackup.add_layer",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileStackup.add_layer.html#pyedb.grpc.database.utility.xml_control_file.ControlFileStackup.add_layer",
        "title": "add_layer > add_layer > add_layer",
        "section": "add_layer > add_layer",
        "text": "ControlFileStackup.add_layer(layer_name, elevation=0.0, material='', gds_type=0, target_layer='', thickness=0.0, layer_type='conductor', solve_inside=True, properties=None)\n\nAdd a new layer.\n\nParameters\n\nlayer_name\n\npython:str\n\nLayer name.\n\nelevation\n\npython:float\n\nLayer elevation.\n\nmaterial\n\npython:str\n\nMaterial for the layer.\n\ngds_type\n\npython:int\n\nGDS type assigned on the layer. The value must be the same as in the GDS file otherwise geometries won’t be\nimported.\n\ntarget_layer\n\npython:str\n\nLayer name assigned in EDB or HFSS 3D layout after import.\n\nthickness\n\npython:float\n\nLayer thickness\n\nlayer_type\n\npython:str\n\nDefine the layer type, default value for a layer is \"conductor\"\n\nsolve_inside\n\nbool\n\nWhen True solver will solve inside metal, and not id False. Default value is True.\n\nproperties\n\npython:dict\n\nDictionary with key and  property value.\n\nReturns\n\npyedb.dotnet.database.edb_data.control_file.ControlFileLayer\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.layout_obj_type.html#pyedb.grpc.database.terminal.point_terminal.PointTerminal.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "PointTerminal.layout_obj_type = 2\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_impedance_crosstalk_scan",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_impedance_crosstalk_scan.html#create_impedance_crosstalk_scan",
        "title": "create_impedance_crosstalk_scan",
        "section": "create_impedance_crosstalk_scan",
        "text": "Create Siwave crosstalk scan object\nScan type to be analyzed. 3 options are available, impedance for frequency impedance scan,\nfrequency_xtalk for frequency domain crosstalk and time_xtalk for time domain crosstalk.\nDefault value is frequency.\ncreate_impedance_crosstalk_scan\npython:str\nimpedance\nfrequency_xtalk\ntime_xtalk\nfrequency"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_impedance_crosstalk_scan",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_impedance_crosstalk_scan.html#pyedb.dotnet.database.siwave.EdbSiwave.create_impedance_crosstalk_scan",
        "title": "create_impedance_crosstalk_scan > create_impedance_crosstalk_scan > create_impedance_crosstalk_scan",
        "section": "create_impedance_crosstalk_scan > create_impedance_crosstalk_scan",
        "text": "EdbSiwave.create_impedance_crosstalk_scan(scan_type='impedance')\n\nCreate Siwave crosstalk scan object\n\nParameters\n\nscan_type\n\npython:str\n\nScan type to be analyzed. 3 options are available, impedance for frequency impedance scan,\nfrequency_xtalk for frequency domain crosstalk and time_xtalk for time domain crosstalk.\nDefault value is frequency.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileDielectric",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileDielectric.html#controlfiledielectric",
        "title": "ControlFileDielectric",
        "section": "ControlFileDielectric",
        "text": "Represents a dielectric layer in the control file.\nLayer name.\nLayer properties dictionary.\nControlFileDielectric\npython:str\npython:dict"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileDielectric",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileDielectric.html#pyedb.grpc.database.control_file.ControlFileDielectric",
        "title": "ControlFileDielectric > ControlFileDielectric > ControlFileDielectric",
        "section": "ControlFileDielectric > ControlFileDielectric",
        "text": "class pyedb.grpc.database.control_file.ControlFileDielectric(name: str, properties: Dict[str, Any])\n\nRepresents a dielectric layer in the control file.\n\nParameters\n\nname\n\npython:str\n\nLayer name.\n\nproperties\n\npython:dict\n\nLayer properties dictionary.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.points",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.points.html#points",
        "title": "points",
        "section": "points",
        "text": "Return the list of points with arcs converted to segments.\nNumber of facets to convert an arc. Default is 6.\n(X, Y).\npoints\npython:int\npython:tuple\npython:float\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.points",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.points.html#pyedb.grpc.database.primitive.polygon.Polygon.points",
        "title": "points > points > points",
        "section": "points > points",
        "text": "Polygon.points(arc_segments=6) -> tuple[float, float]\n\nReturn the list of points with arcs converted to segments.\n\nParameters\n\narc_segments\n\npython:int\n\nNumber of facets to convert an arc. Default is 6.\n\nReturns\n\npython:tuple(python:float, python:float)\n\n(X, Y).\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.intersection_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.intersection_type.html#intersection_type",
        "title": "intersection_type",
        "section": "intersection_type",
        "text": "Get intersection type between actual primitive and another primitive or polygon data.\nIntersection type:\n0 - objects do not intersect,\n1 - this object fully inside other (no common contour points),\n2 - other object fully inside this,\n3 - common contour points,\n4 - undefined intersection.\nintersection_type\nPolygon\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.intersection_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.intersection_type.html#pyedb.grpc.database.primitive.path.Path.intersection_type",
        "title": "intersection_type > intersection_type > intersection_type",
        "section": "intersection_type > intersection_type",
        "text": "Path.intersection_type(primitive)\n\nGet intersection type between actual primitive and another primitive or polygon data.\n\nParameters\n\nprimitive\n\nPolygon or PolygonData\n\n\n\nReturns\n\npython:int\n\nIntersection type:\n0 - objects do not intersect,\n1 - this object fully inside other (no common contour points),\n2 - other object fully inside this,\n3 - common contour points,\n4 - undefined intersection.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.configure_hfss_analysis_setup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.configure_hfss_analysis_setup.html#configure_hfss_analysis_setup",
        "title": "configure_hfss_analysis_setup",
        "section": "configure_hfss_analysis_setup",
        "text": "Configure HFSS analysis setup.\nEdb_DATA.SimulationConfiguration object\nTrue when succeeded, False when failed.\nconfigure_hfss_analysis_setup"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.configure_hfss_analysis_setup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.configure_hfss_analysis_setup.html#pyedb.dotnet.database.hfss.EdbHfss.configure_hfss_analysis_setup",
        "title": "configure_hfss_analysis_setup > configure_hfss_analysis_setup > configure_hfss_analysis_setup",
        "section": "configure_hfss_analysis_setup > configure_hfss_analysis_setup",
        "text": "EdbHfss.configure_hfss_analysis_setup(simulation_setup=None)\n\nConfigure HFSS analysis setup.\n\nParameters\n\nsimulation_setup\n\nEdb_DATA.SimulationConfiguration object\n\nReturns\n\nbool\n\nTrue when succeeded, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.html#edbpolygon",
        "title": "EdbPolygon",
        "section": "EdbPolygon",
        "text": "EdbPolygon.add_void(point_list)\nAdd a void to current primitive.\nEdbPolygon.area([include_voids])\nReturn the total area.\nEdbPolygon.clone()\nClone a primitive object with keeping same definition and location.\nEdbPolygon.convert_to_polygon()\nConvert path to polygon.\nEdbPolygon.delete()\nDelete this primitive.\nEdbPolygon.duplicate_across_layers(layers)\nDuplicate across layer a primitive object.\nEdbPolygon.expand([offset, tolerance, ...])\nExpand the polygon shape by an absolute value in all direction.\nEdbPolygon.fix_self_intersections()\nRemove self intersections if they exists.\nEdbPolygon.get_closest_arc_midpoint(point)\nGet the closest arc midpoint of the primitive to the input data.\nEdbPolygon.get_closest_point(point)\nGet the closest point of the primitive to the input data.\nEdbPolygon.get_connected_object_id_set()\nProduce a list of all geometries physically connected to a given layout object.\nEdbPolygon.get_connected_objects()\nGet connected objects.\nEdbPolygon.get_hfss_prop()\nGet HFSS properties.\nEdbPolygon.in_polygon(point_data[, ...])\nCheck if padstack Instance is in given polygon data.\nEdbPolygon.intersect(primitives)\nIntersect active primitive with one or more primitives.\nEdbPolygon.intersection_type(primitive)\nGet intersection type between actual primitive and another primitive or polygon data.\nEdbPolygon.is_arc(point)\nEither if a point is an arc or not.\nEdbPolygon.is_intersecting(primitive)\nCheck if actual primitive and another primitive or polygon data intesects.\nEdbPolygon.make_zone_primitive(zone_id)\nMake primitive a zone primitive with a zone specified by the provided id.\nEdbPolygon.move(vector)\nMove polygon along a vector.\nEdbPolygon.move_layer(layer)\nMove polygon to given layer.\nEdbPolygon.points([arc_segments])\nReturn the list of points with arcs converted to segments.\nEdbPolygon.points_raw()\nReturn a list of Edb points.\nEdbPolygon.remove_hfss_prop()\nRemove HFSS properties.\nEdbPolygon.rotate(angle[, center])\nRotate polygon around a center point by an angle.\nEdbPolygon.scale(factor[, center])\nScales the polygon relative to a center point by a factor.\nEdbPolygon.set_hfss_prop(material, solve_inside)\nSet HFSS properties.\nEdbPolygon.subtract(primitives)\nSubtract active primitive with one or more primitives.\nEdbPolygon.unite(primitives)\nUnite active primitive with one or more primitives.\nEdbPolygon\nEdbPolygon.add_void\nEdbPolygon.area\nEdbPolygon.clone\nEdbPolygon.convert_to_polygon\nEdbPolygon.delete\nEdbPolygon.duplicate_across_layers\nEdbPolygon.expand\nEdbPolygon.fix_self_intersections\nEdbPolygon.get_closest_arc_midpoint\nEdbPolygon.get_closest_point\nEdbPolygon.get_connected_object_id_set\nEdbPolygon.get_connected_objects\nEdbPolygon.get_hfss_prop\nEdbPolygon.in_polygon\nEdbPolygon.intersect\nEdbPolygon.intersection_type\nEdbPolygon.is_arc\nEdbPolygon.is_intersecting\nEdbPolygon.make_zone_primitive\nEdbPolygon.move\nEdbPolygon.move_layer\nEdbPolygon.points\nEdbPolygon.points_raw\nEdbPolygon.remove_hfss_prop\nEdbPolygon.rotate\nEdbPolygon.scale\nEdbPolygon.set_hfss_prop\nEdbPolygon.subtract\nEdbPolygon.unite"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon",
        "title": "EdbPolygon > EdbPolygon > EdbPolygon",
        "section": "EdbPolygon > EdbPolygon",
        "text": "class pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon(raw_primitive, core_app)\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nEdbPolygon.add_void(point_list)\n\nAdd a void to current primitive.\n\nEdbPolygon.area([include_voids])\n\nReturn the total area.\n\nEdbPolygon.clone()\n\nClone a primitive object with keeping same definition and location.\n\nEdbPolygon.convert_to_polygon()\n\nConvert path to polygon.\n\nEdbPolygon.delete()\n\nDelete this primitive.\n\nEdbPolygon.duplicate_across_layers(layers)\n\nDuplicate across layer a primitive object.\n\nEdbPolygon.expand([offset, tolerance, ...])\n\nExpand the polygon shape by an absolute value in all direction.\n\nEdbPolygon.fix_self_intersections()\n\nRemove self intersections if they exists.\n\nEdbPolygon.get_closest_arc_midpoint(point)\n\nGet the closest arc midpoint of the primitive to the input data.\n\nEdbPolygon.get_closest_point(point)\n\nGet the closest point of the primitive to the input data.\n\nEdbPolygon.get_connected_object_id_set()\n\nProduce a list of all geometries physically connected to a given layout object.\n\nEdbPolygon.get_connected_objects()\n\nGet connected objects.\n\nEdbPolygon.get_hfss_prop()\n\nGet HFSS properties.\n\nEdbPolygon.in_polygon(point_data[, ...])\n\nCheck if padstack Instance is in given polygon data.\n\nEdbPolygon.intersect(primitives)\n\nIntersect active primitive with one or more primitives.\n\nEdbPolygon.intersection_type(primitive)\n\nGet intersection type between actual primitive and another primitive or polygon data.\n\nEdbPolygon.is_arc(point)\n\nEither if a point is an arc or not.\n\nEdbPolygon.is_intersecting(primitive)\n\nCheck if actual primitive and another primitive or polygon data intesects.\n\nEdbPolygon.make_zone_primitive(zone_id)\n\nMake primitive a zone primitive with a zone specified by the provided id.\n\nEdbPolygon.move(vector)\n\nMove polygon along a vector.\n\nEdbPolygon.move_layer(layer)\n\nMove polygon to given layer.\n\nEdbPolygon.points([arc_segments])\n\nReturn the list of points with arcs converted to segments.\n\nEdbPolygon.points_raw()\n\nReturn a list of Edb points.\n\nEdbPolygon.remove_hfss_prop()\n\nRemove HFSS properties.\n\nEdbPolygon.rotate(angle[, center])\n\nRotate polygon around a center point by an angle.\n\nEdbPolygon.scale(factor[, center])\n\nScales the polygon relative to a center point by a factor.\n\nEdbPolygon.set_hfss_prop(material, solve_inside)\n\nSet HFSS properties.\n\nEdbPolygon.subtract(primitives)\n\nSubtract active primitive with one or more primitives.\n\nEdbPolygon.unite(primitives)\n\nUnite active primitive with one or more primitives.\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.simulation_settings.BaseSimulationSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.simulation_settings.BaseSimulationSettings.html#basesimulationsettings",
        "title": "BaseSimulationSettings",
        "section": "BaseSimulationSettings",
        "text": "BaseSimulationSettings"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.simulation_settings.BaseSimulationSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.simulation_settings.BaseSimulationSettings.html#pyedb.dotnet.database.sim_setup_data.data.simulation_settings.BaseSimulationSettings",
        "title": "BaseSimulationSettings > BaseSimulationSettings > BaseSimulationSettings",
        "section": "BaseSimulationSettings > BaseSimulationSettings",
        "text": "class pyedb.dotnet.database.sim_setup_data.data.simulation_settings.BaseSimulationSettings(pedb, sim_setup, edb_object)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.product_solver_names",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.product_solver_names.html#product_solver_names",
        "title": "product_solver_names",
        "section": "product_solver_names",
        "text": "Get the list of solver names.\nID of the product.\nproduct_solver_names\nProductIdType\npython:list\nof\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.product_solver_names",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.product_solver_names.html#pyedb.grpc.database.ports.ports.WavePort.product_solver_names",
        "title": "product_solver_names > product_solver_names > product_solver_names",
        "section": "product_solver_names > product_solver_names",
        "text": "WavePort.product_solver_names(product_id)\n\nGet the list of solver names.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nReturns\n\npython:list of python:str\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.from_orm",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "from_orm"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.from_orm",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.from_orm.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod DiffPairLengthMatch.from_orm(obj: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.SettingsBase.restore_default",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.SettingsBase.restore_default.html#restore_default",
        "title": "restore_default",
        "section": "restore_default",
        "text": "restore_default"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.SettingsBase.restore_default",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.SettingsBase.restore_default.html#pyedb.dotnet.database.sim_setup_data.io.siwave.SettingsBase.restore_default",
        "title": "restore_default > restore_default > restore_default",
        "section": "restore_default > restore_default",
        "text": "SettingsBase.restore_default()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_zone_to_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_zone_to_layer.html#add_zone_to_layer",
        "title": "add_zone_to_layer",
        "section": "add_zone_to_layer",
        "text": "Set the zone to the layer and update the layer in the collection.\nadd_zone_to_layer\nLayer\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_zone_to_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_zone_to_layer.html#pyedb.grpc.database.stackup.Stackup.add_zone_to_layer",
        "title": "add_zone_to_layer > add_zone_to_layer > add_zone_to_layer",
        "section": "add_zone_to_layer > add_zone_to_layer",
        "text": "Stackup.add_zone_to_layer(layer, zone, in_zone)\n\nSet the zone to the layer and update the layer in the collection.\n\nParameters\n\nlayer\n\nLayer\n\n\n\nzone\n\npython:int\n\n\n\nin_zone\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the layout object.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.delete.html#pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "VoltageRegulator.delete()\n\nDelete the layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.set_product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.set_product_solver_option.html#set_product_solver_option",
        "title": "set_product_solver_option",
        "section": "set_product_solver_option",
        "text": "Set the product solver option.\nID of the product.\nName of the solver.\nName of the product solver option.\nset_product_solver_option\nProductIdType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.set_product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.set_product_solver_option.html#pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.set_product_solver_option",
        "title": "set_product_solver_option > set_product_solver_option > set_product_solver_option",
        "section": "set_product_solver_option > set_product_solver_option",
        "text": "PinGroupTerminal.set_product_solver_option(product_id, solver_name, option)\n\nSet the product solver option.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nsolver_name\n\nobj:str\n\nName of the solver.\n\noption\n\nobj:str\n\nName of the product solver option.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileBoundaries.add_extent",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileBoundaries.add_extent.html#add_extent",
        "title": "add_extent",
        "section": "add_extent",
        "text": "Add an extent.\nExtent type. Default is “bbox”.\nDielectric extent type. Default is “bbox”.\nDielectric horizontal factor. Default is 0.25.\nAirbox horizontal factor. Default is 0.25.\nAirbox vertical factor (positive). Default is 0.25.\nAirbox vertical factor (negative). Default is 0.25.\nUse radiation boundary. Default is True.\nHonor primitives. Default is True.\nTruncate at ground. Default is True.\nCreated extent object.\nadd_extent\npython:str\noptional\npython:str\noptional\npython:float\noptional\npython:float\noptional\npython:float\noptional\npython:float\noptional\noptional\nTrue\noptional\nTrue\noptional\nTrue\nControlExtent"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileBoundaries.add_extent",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileBoundaries.add_extent.html#pyedb.grpc.database.control_file.ControlFileBoundaries.add_extent",
        "title": "add_extent > add_extent > add_extent",
        "section": "add_extent > add_extent",
        "text": "ControlFileBoundaries.add_extent(type: str = 'bbox', dieltype: str = 'bbox', diel_hactor: float = 0.25, airbox_hfactor: float = 0.25, airbox_vr_p: float = 0.25, airbox_vr_n: float = 0.25, useradiation: bool = True, honor_primitives: bool = True, truncate_at_gnd: bool = True) -> ControlExtent\n\nAdd an extent.\n\nParameters\n\ntype\n\npython:str, optional\n\nExtent type. Default is “bbox”.\n\ndieltype\n\npython:str, optional\n\nDielectric extent type. Default is “bbox”.\n\ndiel_hactor\n\npython:float, optional\n\nDielectric horizontal factor. Default is 0.25.\n\nairbox_hfactor\n\npython:float, optional\n\nAirbox horizontal factor. Default is 0.25.\n\nairbox_vr_p\n\npython:float, optional\n\nAirbox vertical factor (positive). Default is 0.25.\n\nairbox_vr_n\n\npython:float, optional\n\nAirbox vertical factor (negative). Default is 0.25.\n\nuseradiation\n\nbool, optional\n\nUse radiation boundary. Default is True.\n\nhonor_primitives\n\nbool, optional\n\nHonor primitives. Default is True.\n\ntruncate_at_gnd\n\nbool, optional\n\nTruncate at ground. Default is True.\n\nReturns\n\nControlExtent\n\nCreated extent object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.short_component_pins",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.short_component_pins.html#short_component_pins",
        "title": "short_component_pins",
        "section": "short_component_pins",
        "text": "Short component pins with traces.\nComponent name.\nList of pin names to short.\nTrace width.\nTrue if successful, False otherwise.\nshort_component_pins\npython:str\npython:list\npython:str\noptional\npython:float\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.short_component_pins",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.short_component_pins.html#pyedb.grpc.database.components.Components.short_component_pins",
        "title": "short_component_pins > short_component_pins > short_component_pins",
        "section": "short_component_pins > short_component_pins",
        "text": "Components.short_component_pins(component_name: str, pins_to_short: List[str] | None = None, width: float = 0.001) -> bool\n\nShort component pins with traces.\n\nParameters\n\ncomponent_name\n\npython:str\n\nComponent name.\n\npins_to_short\n\npython:list[python:str], optional\n\nList of pin names to short.\n\nwidth\n\npython:float, optional\n\nTrace width.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\nExamples\n\n>>> edbapp.components.short_component_pins(\"J4A2\", [\"G4\", \"9\", \"3\"])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.html#simulationsetuptype",
        "title": "SimulationSetupType",
        "section": "SimulationSetupType",
        "text": "An enumeration.\nSimulationSetupType.kHFSS\n\nSimulationSetupType.kPEM\n\nSimulationSetupType.kSIwave\n\nSimulationSetupType.kLNA\n\nSimulationSetupType.kTransient\n\nSimulationSetupType.kQEye\n\nSimulationSetupType.kVEye\n\nSimulationSetupType.kAMI\n\nSimulationSetupType.kAnalysisOption\n\nSimulationSetupType.kSIwaveDCIR\n\nSimulationSetupType.kSIwaveEMI\n\nSimulationSetupType.kHFSSPI\n\nSimulationSetupType.kDDRwizard\n\nSimulationSetupType.kQ3D\n\nSimulationSetupType\nSimulationSetupType.kHFSS\nSimulationSetupType.kPEM\nSimulationSetupType.kSIwave\nSimulationSetupType.kLNA\nSimulationSetupType.kTransient\nSimulationSetupType.kQEye\nSimulationSetupType.kVEye\nSimulationSetupType.kAMI\nSimulationSetupType.kAnalysisOption\nSimulationSetupType.kSIwaveDCIR\nSimulationSetupType.kSIwaveEMI\nSimulationSetupType.kHFSSPI\nSimulationSetupType.kDDRwizard\nSimulationSetupType.kQ3D"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.html#pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType",
        "title": "SimulationSetupType > SimulationSetupType > SimulationSetupType",
        "section": "SimulationSetupType > SimulationSetupType",
        "text": "class pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType(value)\n\nAn enumeration.\n\n!! processed by numpydoc !!\n\nAttributes\n\n\n\n\n\n\n\nSimulationSetupType.kHFSS\n\n\n\nSimulationSetupType.kPEM\n\n\n\nSimulationSetupType.kSIwave\n\n\n\nSimulationSetupType.kLNA\n\n\n\nSimulationSetupType.kTransient\n\n\n\nSimulationSetupType.kQEye\n\n\n\nSimulationSetupType.kVEye\n\n\n\nSimulationSetupType.kAMI\n\n\n\nSimulationSetupType.kAnalysisOption\n\n\n\nSimulationSetupType.kSIwaveDCIR\n\n\n\nSimulationSetupType.kSIwaveEMI\n\n\n\nSimulationSetupType.kHFSSPI\n\n\n\nSimulationSetupType.kDDRwizard\n\n\n\nSimulationSetupType.kQ3D\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.cutout_multizone_layout",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.cutout_multizone_layout.html#cutout_multizone_layout",
        "title": "cutout_multizone_layout",
        "section": "cutout_multizone_layout",
        "text": "Create a multizone project cutout.\nDictionary with EDB path as key and EDB PolygonData as value defining the zone region.\nThis dictionary is returned from the command copy_zones():\n>>> edb = Edb(edb_file)\n>>> zone_dict = edb.copy_zones(r”C:Temp    est”)\nthe common reference net name. This net name must be provided to provide a valid project.\nfirst dictionary defined_ports with edb name as key and existing port name list as value. Those ports are\nthe ones defined before processing the multizone clipping. the second is the list of connected port.\ncutout_multizone_layout\npython:dict\npython:str\nEDB\nPolygonData\npython:str\npython:dict\npython:str\nor\npython:list\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.cutout_multizone_layout",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.cutout_multizone_layout.html#pyedb.grpc.edb.Edb.cutout_multizone_layout",
        "title": "cutout_multizone_layout > cutout_multizone_layout > cutout_multizone_layout",
        "section": "cutout_multizone_layout > cutout_multizone_layout",
        "text": "Edb.cutout_multizone_layout(zone_dict, common_reference_net=None)\n\nCreate a multizone project cutout.\n\nParameters\n\nzone_dict\n\npython:dict[python:str](EDB PolygonData)\n\nDictionary with EDB path as key and EDB PolygonData as value defining the zone region.\nThis dictionary is returned from the command copy_zones():\n>>> edb = Edb(edb_file)\n>>> zone_dict = edb.copy_zones(r”C:Temp    est”)\n\ncommon_reference_net\n\npython:str\n\nthe common reference net name. This net name must be provided to provide a valid project.\n\nReturns\n\npython:dict[str: python:str] or python:list[python:str]\n\nfirst dictionary defined_ports with edb name as key and existing port name list as value. Those ports are\nthe ones defined before processing the multizone clipping. the second is the list of connected port.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.create_stride.html#create_stride",
        "title": "create_stride",
        "section": "create_stride",
        "text": "Create a Stride model from an MCAD file.\nStride model created.\ncreate_stride\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.create_stride.html#pyedb.grpc.database.primitive.rectangle.Rectangle.create_stride",
        "title": "create_stride > create_stride > create_stride",
        "section": "create_stride > create_stride",
        "text": "Rectangle.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nReturns\n\nMcadModel\n\nStride model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layer_top",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layer_top.html#add_layer_top",
        "title": "add_layer_top",
        "section": "add_layer_top",
        "text": "Add a layer on top of the stackup.\nName of the layer.\nType of the layer. The default is \"signal\". Options are \"signal\" and \"dielectric\".\nAdditional keyword arguments. Possible keys are:\n- thickness : float, layer thickness.\n- material : str, layer material.\nLayer object created.\nadd_layer_top\npython:str\npython:str\noptional\n\"signal\"\n\"signal\"\n\"dielectric\"\npython:dict\noptional\nthickness\nmaterial\npyedb.grpc.database.layers.stackup_layer.StackupLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layer_top",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layer_top.html#pyedb.grpc.database.stackup.Stackup.add_layer_top",
        "title": "add_layer_top > add_layer_top > add_layer_top",
        "section": "add_layer_top > add_layer_top",
        "text": "Stackup.add_layer_top(name: str, layer_type: str = 'signal', **kwargs) -> Layer | None\n\nAdd a layer on top of the stackup.\n\nParameters\n\nname\n\npython:str\n\nName of the layer.\n\nlayer_type\n\npython:str, optional\n\nType of the layer. The default is \"signal\". Options are \"signal\" and \"dielectric\".\n\n**kwargs\n\npython:dict, optional\n\nAdditional keyword arguments. Possible keys are:\n- thickness : float, layer thickness.\n- material : str, layer material.\n\nReturns\n\npyedb.grpc.database.layers.stackup_layer.StackupLayer\n\nLayer object created.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> top_layer = edb.stackup.add_layer_top(\n...     \"NewTopLayer\", layer_type=\"signal\", thickness=\"0.1mm\", material=\"copper\"\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.dot",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.dot.html#dot",
        "title": "dot",
        "section": "dot",
        "text": "Perform per-component multiplication (dot product) of this point and another point.\nOther point.\nDot product of the two points.\ndot\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.dot",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.dot.html#pyedb.grpc.database.geometry.point_data.PointData.dot",
        "title": "dot > dot > dot",
        "section": "dot > dot",
        "text": "PointData.dot(other: PointLike) -> float\n\nPerform per-component multiplication (dot product) of this point and another point.\n\nParameters\n\nother\n\nPoint2DLike\n\nOther point.\n\nReturns\n\npython:float\n\nDot product of the two points.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.AdaptiveType.BroadBand",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.AdaptiveType.BroadBand.html#broadband",
        "title": "BroadBand",
        "section": "BroadBand",
        "text": "BroadBand"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.AdaptiveType.BroadBand",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.AdaptiveType.BroadBand.html#pyedb.dotnet.database.utilities.simulation_setup.AdaptiveType.BroadBand",
        "title": "BroadBand > BroadBand > BroadBand",
        "section": "BroadBand > BroadBand",
        "text": "AdaptiveType.BroadBand = 2\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.create_hfss.html#create_hfss",
        "title": "create_hfss",
        "section": "create_hfss",
        "text": "Create an HFSS model from an MCAD file.\nHFSS model created.\ncreate_hfss\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.create_hfss.html#pyedb.grpc.database.terminal.point_terminal.PointTerminal.create_hfss",
        "title": "create_hfss > create_hfss > create_hfss",
        "section": "create_hfss > create_hfss",
        "text": "PointTerminal.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nReturns\n\nMcadModel\n\nHFSS model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.export_bom",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.export_bom.html#export_bom",
        "title": "export_bom",
        "section": "export_bom",
        "text": "Export Bom file from layout.\nFull path to the BOM file, which is a delimited text file.\nValue to use for the delimiter. The default is \",\".\nexport_bom\npython:str\npython:str\noptional\n\",\""
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.export_bom",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.export_bom.html#pyedb.dotnet.database.components.Components.export_bom",
        "title": "export_bom > export_bom > export_bom",
        "section": "export_bom > export_bom",
        "text": "Components.export_bom(bom_file, delimiter=',')\n\nExport Bom file from layout.\n\nParameters\n\nbom_file\n\npython:str\n\nFull path to the BOM file, which is a delimited text file.\n\ndelimiter\n\npython:str, optional\n\nValue to use for the delimiter. The default is \",\".\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData.delete",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Edb Dotnet Api Database Delete.\ndelete"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData.delete",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData.delete.html#pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "EDBExtendedNetData.delete()\n\nEdb Dotnet Api Database Delete.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_circuit_port_on_pin",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_circuit_port_on_pin.html#create_circuit_port_on_pin",
        "title": "create_circuit_port_on_pin",
        "section": "create_circuit_port_on_pin",
        "text": "Create a circuit port on a pin.\nEdb Pin\nEdb Pin\nPort Impedance\nPort Name\nPort Name.\ncreate_circuit_port_on_pin\nObject\nObject\npython:float\npython:str\noptional\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_circuit_port_on_pin",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_circuit_port_on_pin.html#pyedb.dotnet.database.siwave.EdbSiwave.create_circuit_port_on_pin",
        "title": "create_circuit_port_on_pin > create_circuit_port_on_pin > create_circuit_port_on_pin",
        "section": "create_circuit_port_on_pin > create_circuit_port_on_pin",
        "text": "EdbSiwave.create_circuit_port_on_pin(pos_pin, neg_pin, impedance=50, port_name=None)\n\nCreate a circuit port on a pin.\n\nParameters\n\npos_pin\n\nObject\n\nEdb Pin\n\nneg_pin\n\nObject\n\nEdb Pin\n\nimpedance\n\npython:float\n\nPort Impedance\n\nport_name\n\npython:str, optional\n\nPort Name\n\nReturns\n\npython:str\n\nPort Name.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", \"project name\", \"release version\")\n>>> pins = edbapp.components.get_pin_from_component(\"U2A5\")\n>>> edbapp.siwave.create_circuit_port_on_pin(pins[0], pins[1], 50, \"port_name\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_hfsspi_setup",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_hfsspi_setup.html#create_hfsspi_setup",
        "title": "create_hfsspi_setup",
        "section": "create_hfsspi_setup",
        "text": "create_hfsspi_setup"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_hfsspi_setup",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_hfsspi_setup.html#pyedb.grpc.edb.Edb.create_hfsspi_setup",
        "title": "create_hfsspi_setup > create_hfsspi_setup > create_hfsspi_setup",
        "section": "create_hfsspi_setup > create_hfsspi_setup",
        "text": "Edb.create_hfsspi_setup(name=None)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kAnalysisOption",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kAnalysisOption.html#kanalysisoption",
        "title": "kAnalysisOption",
        "section": "kAnalysisOption",
        "text": "kAnalysisOption"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kAnalysisOption",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kAnalysisOption.html#pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kAnalysisOption",
        "title": "kAnalysisOption > kAnalysisOption > kAnalysisOption",
        "section": "kAnalysisOption > kAnalysisOption",
        "text": "SimulationSetupType.kAnalysisOption = 'analysis_option'\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.plot",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.plot.html#plot",
        "title": "plot",
        "section": "plot",
        "text": "Plot a Net to Matplotlib 2D Chart.\nName of the net or list of nets to plot. If None all nets will be plotted.\nName of the layers to include in the plot. If None all the signal layers will be considered.\nIf True  the plot will be colored by net.\nIf False the plot will be colored by layer. (default)\nIf True the legend is shown in the plot. (default)\nIf False the legend is not shown.\nIf a path is specified the plot will be saved in this location.\nIf save_plot is provided, the show parameter is ignored.\nList of points of the outline to plot.\nImage size in pixel (width, height). Default value is (6000, 3000)\nWhether if use top view or bottom view. Components will be visible only for the highest layer in the view.\nIf True  the components placed on top layer are plotted.\nIf False the components are not plotted. (default).\nThis may impact in the plot computation time.\nIf nets and/or layers is specified, only the components belonging to the specified nets/layers are plotted.\nWhether to add the component names to the plot or not. Default is True.\nWhether to plot vias (circular and rectangular) or not. This may impact in the plot computation time.\nDefault is False.\nSpecify the default plot title. Is value is None the project name is assigned by default. Default value\nis None.\nWhether to show the plot or not. Default is True.\nMatplotlib ax and figures.\nplot\npython:str\npython:list\noptional\nNone\npython:str\npython:list\noptional\nNone\noptional\nTrue\nFalse\noptional\nTrue\nFalse\npython:str\noptional\nsave_plot\nshow\npython:list\noptional\npython:tuple\npython:int\noptional\n(6000, 3000)\noptional\noptional\nTrue\nFalse\nTrue\noptional\nFalse\npython:str\noptional\nNone\nNone\noptional\nax\nfig"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.plot",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.plot.html#pyedb.dotnet.database.nets.EdbNets.plot",
        "title": "plot > plot > plot",
        "section": "plot > plot",
        "text": "EdbNets.plot(nets=None, layers=None, color_by_net=False, show_legend=True, save_plot=None, outline=None, size=(6000, 3000), plot_components=True, top_view=True, show=True, annotate_component_names=True, plot_vias=False, title=None, **kwargs)\n\nPlot a Net to Matplotlib 2D Chart.\n\nParameters\n\nnets\n\npython:str, python:list, optional\n\nName of the net or list of nets to plot. If None all nets will be plotted.\n\nlayers\n\npython:str, python:list, optional\n\nName of the layers to include in the plot. If None all the signal layers will be considered.\n\ncolor_by_net\n\nbool, optional\n\nIf True  the plot will be colored by net.\nIf False the plot will be colored by layer. (default)\n\nshow_legend\n\nbool, optional\n\nIf True the legend is shown in the plot. (default)\nIf False the legend is not shown.\n\nsave_plot\n\npython:str, optional\n\nIf a path is specified the plot will be saved in this location.\nIf save_plot is provided, the show parameter is ignored.\n\noutline\n\npython:list, optional\n\nList of points of the outline to plot.\n\nsize\n\npython:tuple, python:int, optional\n\nImage size in pixel (width, height). Default value is (6000, 3000)\n\ntop_view\n\nbool, optional\n\nWhether if use top view or bottom view. Components will be visible only for the highest layer in the view.\n\nplot_components\n\nbool, optional\n\nIf True  the components placed on top layer are plotted.\nIf False the components are not plotted. (default).\nThis may impact in the plot computation time.\nIf nets and/or layers is specified, only the components belonging to the specified nets/layers are plotted.\n\nannotate_component_names: bool, optional\n\nWhether to add the component names to the plot or not. Default is True.\n\nplot_vias\n\nbool, optional\n\nWhether to plot vias (circular and rectangular) or not. This may impact in the plot computation time.\nDefault is False.\n\ntitle\n\npython:str, optional\n\nSpecify the default plot title. Is value is None the project name is assigned by default. Default value\nis None.\n\nshow\n\nbool, optional\n\nWhether to show the plot or not. Default is True.\n\nReturns\n\n(ax, fig)\n\nMatplotlib ax and figures.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.Layer",
        "href": "libraries/_autosummary/pyedb.libraries.common.Layer.html#layer",
        "title": "Layer",
        "section": "Layer",
        "text": "Physical layer inside a stackup.\nActive EDB session.\nLayer name.\nMaterial instance assigned to the layer.\nLayer thickness in meters.  Default is 1 µm.\nLayer\nansys.edb.core.database.Database\npython:str\nConductor\nDielectric\noptional\npython:float\noptional"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.Layer",
        "href": "libraries/_autosummary/pyedb.libraries.common.Layer.html#pyedb.libraries.common.Layer",
        "title": "Layer > Layer > Layer",
        "section": "Layer > Layer",
        "text": "class pyedb.libraries.common.Layer(pedb, name: str, material: Conductor | Dielectric | None = None, thickness: float = 1e-06)\n\nPhysical layer inside a stackup.\n\nParameters\n\npedb\n\nansys.edb.core.database.Database\n\nActive EDB session.\n\nname\n\npython:str\n\nLayer name.\n\nmaterial\n\nConductor or Dielectric, optional\n\nMaterial instance assigned to the layer.\n\nthickness\n\npython:float, optional\n\nLayer thickness in meters.  Default is 1 µm.\n\nExamples\n\n>>> diel = Dielectric(edb, \"FR4\")\n>>> lyr = Layer(edb, \"Core\", material=diel, thickness=100e-6)\n>>> lyr.thickness = 50e-6\n>>> edb.stackup.layers[\"Core\"].thickness\n5e-05\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.set_frequencies_linear_scale",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.set_frequencies_linear_scale.html#set_frequencies_linear_scale",
        "title": "set_frequencies_linear_scale",
        "section": "set_frequencies_linear_scale",
        "text": "Set a linear scale frequency sweep.\nStart frequency. The default is \"0.1GHz\".\nStop frequency. The default is \"20GHz\".\nStep frequency. The default is \"50MHz\".\nTrue if correctly executed, False otherwise.\nset_frequencies_linear_scale\npython:str\npython:float\noptional\n\"0.1GHz\"\npython:str\npython:float\noptional\n\"20GHz\"\npython:str\npython:float\noptional\n\"50MHz\"\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.set_frequencies_linear_scale",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.set_frequencies_linear_scale.html#pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.set_frequencies_linear_scale",
        "title": "set_frequencies_linear_scale > set_frequencies_linear_scale > set_frequencies_linear_scale",
        "section": "set_frequencies_linear_scale > set_frequencies_linear_scale",
        "text": "SweepData.set_frequencies_linear_scale(start='0.1GHz', stop='20GHz', step='50MHz')\n\nSet a linear scale frequency sweep.\n\nParameters\n\nstart\n\npython:str, python:float, optional\n\nStart frequency. The default is \"0.1GHz\".\n\nstop\n\npython:str, python:float, optional\n\nStop frequency. The default is \"20GHz\".\n\nstep\n\npython:str, python:float, optional\n\nStep frequency. The default is \"50MHz\".\n\nReturns\n\nbool\n\nTrue if correctly executed, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.get_dcconnected_net_list",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.get_dcconnected_net_list.html#get_dcconnected_net_list",
        "title": "get_dcconnected_net_list",
        "section": "get_dcconnected_net_list",
        "text": "Get nets connected to DC through inductors and low-value resistors.\nGround net names. Default is (“GND”,).\nResistance threshold value. Default is 0.001 ohms.\nList of sets of connected nets.\nget_dcconnected_net_list\npython:tuple\noptional\npython:float\noptional\npython:list\nset"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.get_dcconnected_net_list",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.get_dcconnected_net_list.html#pyedb.grpc.database.nets.Nets.get_dcconnected_net_list",
        "title": "get_dcconnected_net_list > get_dcconnected_net_list > get_dcconnected_net_list",
        "section": "get_dcconnected_net_list > get_dcconnected_net_list",
        "text": "Nets.get_dcconnected_net_list(ground_nets: List[str] = ['GND'], res_value: float = 0.001) -> List[Set[str]]\n\nGet nets connected to DC through inductors and low-value resistors.\n\nParameters\n\nground_nets\n\npython:tuple, optional\n\nGround net names. Default is (“GND”,).\n\nres_value\n\npython:float, optional\n\nResistance threshold value. Default is 0.001 ohms.\n\nReturns\n\npython:list[set]\n\nList of sets of connected nets.\n\nExamples\n\n>>> dc_connected = edb_nets.get_dcconnected_net_list(ground_nets=[\"GND\"], res_value=0.002)\n>>> for net_group in dc_connected:\n...     print(\"Connected nets:\", net_group)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.plot",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.plot.html#plot",
        "title": "plot",
        "section": "plot",
        "text": "Plot the current stackup and optionally overlap padstack definitions.\nOnly supports ‘Laminate’ and ‘Overlapping’ stackup types.\nPath to save the plot image. If provided, show is ignored.\nImage size in pixels (width, height). Default is (2000, 1500).\nList of padstack definitions to plot on the stackup. Only supported for Laminate mode.\nFirst layer to plot from the bottom. Default is None (start from bottom).\nLast layer to plot from the bottom. Default is None (plot up to top layer).\nScale real layer thickness so that max_thickness = 3 * min_thickness. Default is True.\nWhether to show the plot. Default is True.\nMatplotlib plot object.\nplot\npython:str\noptional\nshow\npython:tuple\noptional\n(2000, 1500)\npython:str\npython:list\noptional\npython:str\npyedb.grpc.database.layers.layer.Layer\noptional\nNone\npython:str\npyedb.grpc.database.layers.layer.Layer\noptional\nNone\noptional\nTrue\noptional\nTrue\nmatplotlib.pyplot"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.plot",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.plot.html#pyedb.grpc.database.stackup.Stackup.plot",
        "title": "plot > plot > plot",
        "section": "plot > plot",
        "text": "Stackup.plot(save_plot: str | None = None, size: Tuple[int, int] = (2000, 1500), plot_definitions: str | List[str] | None = None, first_layer: str | Layer | None = None, last_layer: str | Layer | None = None, scale_elevation: bool = True, show: bool = True) -> Any\n\nPlot the current stackup and optionally overlap padstack definitions.\n\nOnly supports ‘Laminate’ and ‘Overlapping’ stackup types.\n\nParameters\n\nsave_plot\n\npython:str, optional\n\nPath to save the plot image. If provided, show is ignored.\n\nsize\n\npython:tuple, optional\n\nImage size in pixels (width, height). Default is (2000, 1500).\n\nplot_definitions\n\npython:str or python:list, optional\n\nList of padstack definitions to plot on the stackup. Only supported for Laminate mode.\n\nfirst_layer\n\npython:str or pyedb.grpc.database.layers.layer.Layer, optional\n\nFirst layer to plot from the bottom. Default is None (start from bottom).\n\nlast_layer\n\npython:str or pyedb.grpc.database.layers.layer.Layer, optional\n\nLast layer to plot from the bottom. Default is None (plot up to top layer).\n\nscale_elevation\n\nbool, optional\n\nScale real layer thickness so that max_thickness = 3 * min_thickness. Default is True.\n\nshow\n\nbool, optional\n\nWhether to show the plot. Default is True.\n\nReturns\n\nmatplotlib.pyplot\n\nMatplotlib plot object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/cutout",
        "href": "workflows/utilities/cutout.html#edb-cutout",
        "title": "EDB Cutout",
        "section": "EDB Cutout",
        "text": "Overview\nQuickstart\nConvenience entry point\nComplete parameter reference\nExtent strategies\nAPI reference\nLegacy notice\nEDB Cutout"
    },
    {
        "objectID": "workflows/utilities/cutout",
        "href": "workflows/utilities/cutout.html#overview",
        "title": "EDB Cutout > Overview",
        "section": "Overview",
        "text": "The Cutout class creates a clipped (cut-out) EDB cell from an existing layout.\nAll new features, performance improvements, and bug fixes are delivered only\nthrough the gRPC back-end.\nThe legacy .NET back-end is still present for compatibility; it is deprecated\nand scheduled for removal in a future release.\nOverview\nCutout"
    },
    {
        "objectID": "workflows/utilities/cutout",
        "href": "workflows/utilities/cutout.html#quickstart",
        "title": "EDB Cutout > Quickstart",
        "section": "Quickstart",
        "text": "Quickstart"
    },
    {
        "objectID": "workflows/utilities/cutout",
        "href": "workflows/utilities/cutout.html#convenience-entry-point",
        "title": "EDB Cutout > Convenience entry point",
        "section": "Convenience entry point",
        "text": "Existing scripts continue to work without modification:\nThe edb.cutout method internally instantiates the Cutout class (gRPC-first)\nand returns the same clipped cell as in previous releases.\nConvenience entry point\nedb.cutout\nCutout"
    },
    {
        "objectID": "workflows/utilities/cutout",
        "href": "workflows/utilities/cutout.html#complete-parameter-reference",
        "title": "EDB Cutout > Complete parameter reference",
        "section": "Complete parameter reference",
        "text": "The following table lists every public parameter accepted by both the class\nconstructor and the convenience method edb.cutout.\nDefaults are shown in bold; physical values are in metres unless a\n*_units parameter is supplied.\nName\nType\nPurpose\nsignal_nets (alias “signals”)\nlist[str]\nNet names to retain in the cut-out (required).\nreference_nets (alias “references”)\nlist[str]\nNet names used as reference (required).\nexpansion_size\nfloat | str\nAdditional margin around computed extent.  0.002\nextent_type\nstr\nExtent algorithm: “ConvexHull”, “Conforming”, “Bounding”.\nuse_round_corner\nbool\nApply rounded corners after expansion.  False\ncustom_extent\nlist[tuple[float,float]] | None\nClosed polygon [(x1,y1), …] overriding automatic extent.  None\ncustom_extent_units\nstr\nLength unit for custom_extent.  “mm”\ninclude_voids_in_extents\nbool\nInclude voids ≥ 5 % of extent area while Building clip polygon.  False\nopen_cutout_at_end\nbool\nLoad the resulting .AEDB into the active edb object.  True\noutput_file\nstr\nFull path where the clipped .AEDB is saved.  “” (in-place)\nuse_pyaedt_cutout\nbool\nUse PyAEDT-based clipping instead of native EDB API.  True\nsmart\\_cutout\nbool\nAuto-enlarge expansion_size until every port has a reference.  False\nexpansion_factor\nfloat\nIf > 0, compute initial expansion_size from trace-width/dielectric.  0\nmaximum_iterations\nint\nMax attempts for smart_cutout before giving up.  10\nnumber_of_threads\nint\nWorker threads for polygon clipping and padstack cleaning.  1\nremove_single_pin_components\nbool\nDelete RLC components with only one pin after cut-out.  False\npreserve_components_with_model\nbool\nKeep every pin of components that carry a Spice/S-parameter model.  False\ncheck\\_terminals\nbool\nGrow extent until all reference terminals are inside the cut-out.  False\ninclude_pingroups\nbool\nEnsure complete pin-groups are included (requires check_terminals).  False\nsimple_pad_check\nbool\nUse fast center-point padstack check instead of bounding-box.  True\nkeep_lines_as_path\nbool\nRetain clipped traces as Path objects (3D Layout only).  False\nextent_defeature\nfloat\nDefeature tolerance for conformal extent.  0\ninclude_partial_instances\nbool\nKeep padstacks that only partially overlap the clip polygon.  False\nkeep_voids\nbool\nRetain voids that intersect the clip polygon.  True\nComplete parameter reference\nedb.cutout\n*_units\nsignal_nets\nlist[str]\nreference_nets\nlist[str]\nexpansion_size\nfloat | str\nextent_type\nstr\nuse_round_corner\nbool\ncustom_extent\nlist[tuple[float,float]] | None\n[(x1,y1), …]\ncustom_extent_units\nstr\ninclude_voids_in_extents\nbool\nopen_cutout_at_end\nbool\nedb\noutput_file\nstr\nuse_pyaedt_cutout\nbool\nsmart\\_cutout\nbool\nexpansion_factor\nfloat\nmaximum_iterations\nint\nnumber_of_threads\nint\nremove_single_pin_components\nbool\npreserve_components_with_model\nbool\ncheck\\_terminals\nbool\ninclude_pingroups\nbool\nsimple_pad_check\nbool\nkeep_lines_as_path\nbool\nextent_defeature\nfloat\ninclude_partial_instances\nbool\nkeep_voids\nbool"
    },
    {
        "objectID": "workflows/utilities/cutout",
        "href": "workflows/utilities/cutout.html#extent-strategies",
        "title": "EDB Cutout > Extent strategies",
        "section": "Extent strategies",
        "text": "The cut-out boundary can be generated with three built-in algorithms:\nConvexHull (default)–convex hull of selected objects plus expansion\nConforming–tight follow of geometry contours\nBounding–simple bounding box\nAdditional options control corner rounding, void inclusion, multi-threading,\nsmart expansion, and user-supplied boundary polygons.\nExtent strategies\nConvexHull\nConforming\nBounding"
    },
    {
        "objectID": "workflows/utilities/cutout",
        "href": "workflows/utilities/cutout.html#api-reference",
        "title": "EDB Cutout > API reference",
        "section": "API reference",
        "text": "Cutout\n\nalias of <module ‘pyedb.workflows.utilities.cutout’ from ‘/home/runner/work/pyedb/pyedb/.venv/lib/python3.10/site-packages/pyedb/workflows/utilities/cutout.py’>\nAPI reference\nCutout"
    },
    {
        "objectID": "workflows/utilities/cutout",
        "href": "workflows/utilities/cutout.html#pyedb.workflows.utilities.cutout",
        "title": "EDB Cutout > API reference > cutout",
        "section": "API reference > cutout",
        "text": "pyedb.workflows.utilities.cutout\n\nalias of <module ‘pyedb.workflows.utilities.cutout’ from ‘/home/runner/work/pyedb/pyedb/.venv/lib/python3.10/site-packages/pyedb/workflows/utilities/cutout.py’>"
    },
    {
        "objectID": "workflows/utilities/cutout",
        "href": "workflows/utilities/cutout.html#legacy-notice",
        "title": "EDB Cutout > Legacy notice",
        "section": "Legacy notice",
        "text": "The DotNetCutout class is exposed solely for backward compatibility.\nNew code must use the gRPC-based Cutout class—or the edb.cutout convenience\nmethod—to ensure future support.\nLegacy notice\nDotNetCutout\nCutout\nedb.cutout"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_post_init",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nmodel_post_init"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_post_init",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_post_init.html#pyedb.grpc.database.definition.materials.MaterialProperties.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "MaterialProperties.model_post_init(context: Any, /) -> None\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.html#layoutvalidation",
        "title": "LayoutValidation",
        "section": "LayoutValidation",
        "text": "Manages all layout validation capabilities\nLayoutValidation.dc_shorts([net_list, fix])\nFind DC shorts on layout.\nLayoutValidation.delete_empty_pin_groups()\n\nLayoutValidation.disjoint_nets([net_list, ...])\nFind and fix disjoint nets from a given netlist.\nLayoutValidation.fix_self_intersections([...])\nFind and fix self intersections from a given netlist.\nLayoutValidation.illegal_net_names([fix])\nFind and fix illegal net names.\nLayoutValidation.illegal_rlc_values([fix])\nFind and fix RLC illegal values.\nLayoutValidation.padstacks_no_name([fix])\nFind and fix padstacks without aedt_name.\nLayoutValidation\nLayoutValidation.dc_shorts\nLayoutValidation.delete_empty_pin_groups\nLayoutValidation.disjoint_nets\nLayoutValidation.fix_self_intersections\nLayoutValidation.illegal_net_names\nLayoutValidation.illegal_rlc_values\nLayoutValidation.padstacks_no_name"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.html#pyedb.dotnet.database.layout_validation.LayoutValidation",
        "title": "LayoutValidation > LayoutValidation > LayoutValidation",
        "section": "LayoutValidation > LayoutValidation",
        "text": "class pyedb.dotnet.database.layout_validation.LayoutValidation(pedb)\n\nManages all layout validation capabilities\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nLayoutValidation.dc_shorts([net_list, fix])\n\nFind DC shorts on layout.\n\nLayoutValidation.delete_empty_pin_groups()\n\n\n\nLayoutValidation.disjoint_nets([net_list, ...])\n\nFind and fix disjoint nets from a given netlist.\n\nLayoutValidation.fix_self_intersections([...])\n\nFind and fix self intersections from a given netlist.\n\nLayoutValidation.illegal_net_names([fix])\n\nFind and fix illegal net names.\n\nLayoutValidation.illegal_rlc_values([fix])\n\nFind and fix RLC illegal values.\n\nLayoutValidation.padstacks_no_name([fix])\n\nFind and fix padstacks without aedt_name.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.load_amat",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.load_amat.html#load_amat",
        "title": "load_amat",
        "section": "load_amat",
        "text": "Load materials from an AMAT file.\nFull path to the AMAT file to read and add to the Edb.\nload_amat\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.load_amat",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.load_amat.html#pyedb.grpc.database.definition.materials.Materials.load_amat",
        "title": "load_amat > load_amat > load_amat",
        "section": "load_amat > load_amat",
        "text": "Materials.load_amat(amat_file) -> bool\n\nLoad materials from an AMAT file.\n\nParameters\n\namat_file\n\npython:str\n\nFull path to the AMAT file to read and add to the Edb.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_material_from_control_file",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_material_from_control_file.html#import_material_from_control_file",
        "title": "import_material_from_control_file",
        "section": "import_material_from_control_file",
        "text": "Import materials from the provided control file.\nControl file name with full path.\nSchema file path.\nTrue if the existing materials in Database are kept. False to remove existing materials in database.\nimport_material_from_control_file\npython:str\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_material_from_control_file",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_material_from_control_file.html#pyedb.grpc.edb.Edb.import_material_from_control_file",
        "title": "import_material_from_control_file > import_material_from_control_file > import_material_from_control_file",
        "section": "import_material_from_control_file > import_material_from_control_file",
        "text": "Edb.import_material_from_control_file(control_file, schema_dir=None, append=True)\n\nImport materials from the provided control file.\n\nParameters\n\ncontrol_file\n\npython:str\n\nControl file name with full path.\n\nschema_dir\n\npython:str\n\nSchema file path.\n\nappend\n\nbool\n\nTrue if the existing materials in Database are kept. False to remove existing materials in database.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_json_schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias: Whether to use attribute aliases or not.\nref_template: The reference template.\nunion_format: The format to use when combining schemas from unions together. Can be one of:\n‘any_of’: Use the [anyOf](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\nkeyword to combine schemas (the default).\n- ‘primitive_type_array’: Use the [type](https://json-schema.org/understanding-json-schema/reference/type)\nkeyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\ntype (string, boolean, null, integer or number) or contains constraints/metadata, falls back to\nany_of.\nGenerateJsonSchema with your desired modifications\nmode: The mode in which to generate the schema.\nThe JSON schema for the given model class.\nmodel_json_schema"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_json_schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_json_schema.html#pyedb.workflows.drc.drc.CopperBalance.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod CopperBalance.model_json_schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}', schema_generator: type[~pydantic.json_schema.GenerateJsonSchema] = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: ~typing.Literal['validation', 'serialization'] = 'validation', *, union_format: ~typing.Literal['any_of', 'primitive_type_array'] = 'any_of') -> dict[str, Any]\n\nGenerates a JSON schema for a model class.\n\nArgs:\n\nby_alias: Whether to use attribute aliases or not.\nref_template: The reference template.\nunion_format: The format to use when combining schemas from unions together. Can be one of:\n\n‘any_of’: Use the [anyOf](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n\nkeyword to combine schemas (the default).\n- ‘primitive_type_array’: Use the [type](https://json-schema.org/understanding-json-schema/reference/type)\nkeyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\ntype (string, boolean, null, integer or number) or contains constraints/metadata, falls back to\nany_of.\n\nschema_generator: To override the logic used to generate the JSON schema, as a subclass of\n\nGenerateJsonSchema with your desired modifications\n\nmode: The mode in which to generate the schema.\n\nReturns:\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.reduce_via_by_density",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.reduce_via_by_density.html#reduce_via_by_density",
        "title": "reduce_via_by_density",
        "section": "reduce_via_by_density",
        "text": "Reduce the number of vias by density. Keep only one via which is closest to the center of the cell. The cells\nare automatically populated based on the input vias.\nList of padstack ids to be reduced.\nWidth of each grid cell (default is 1e-3).\nHeight of each grid cell (default is 1e-3).\nIf True, delete vias that are not kept (default is False).\nIDs of vias kept after reduction.\ncoordinates for grid lines (for plotting).\nreduce_via_by_density\npython:float\npython:float\nList\npython:int\nList\nList\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.reduce_via_by_density",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.reduce_via_by_density.html#pyedb.grpc.database.padstacks.Padstacks.reduce_via_by_density",
        "title": "reduce_via_by_density > reduce_via_by_density > reduce_via_by_density",
        "section": "reduce_via_by_density > reduce_via_by_density",
        "text": "Padstacks.reduce_via_by_density(padstacks: List[int], cell_size_x: float = 0.001, cell_size_y: float = 0.001, delete: bool = False) -> tuple[List[int], List[List[List[float]]]]\n\nReduce the number of vias by density. Keep only one via which is closest to the center of the cell. The cells\nare automatically populated based on the input vias.\n\nParameters\n\npadstacks: List[int]\n\nList of padstack ids to be reduced.\n\ncell_size_x\n\npython:float\n\nWidth of each grid cell (default is 1e-3).\n\ncell_size_y\n\npython:float\n\nHeight of each grid cell (default is 1e-3).\n\ndelete: bool\n\nIf True, delete vias that are not kept (default is False).\n\nReturns\n\nList[python:int]\n\nIDs of vias kept after reduction.\n\nList[List[python:float]]\n\ncoordinates for grid lines (for plotting).\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.delete_rlc",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.delete_rlc.html#delete_rlc",
        "title": "delete_rlc",
        "section": "delete_rlc",
        "text": "Delete the RLC value for a pin pair.\ndelete_rlc\npython:tuple\npython:str\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.delete_rlc",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.delete_rlc.html#pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.delete_rlc",
        "title": "delete_rlc > delete_rlc > delete_rlc",
        "section": "delete_rlc > delete_rlc",
        "text": "PinPairModel.delete_rlc(pin_pair)\n\nDelete the RLC value for a pin pair.\n\nParameters\n\npin_pair\n\npython:tuple[python:str, python:str]\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.point_3d",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.point_3d.html#point_3d",
        "title": "point_3d",
        "section": "point_3d",
        "text": "Compute the Edb 3d Point Data.\nX value.\nY value.\nZ value.\npoint_3d\npython:float\npython:int\npython:str\npython:float\npython:int\npython:str\npython:float\npython:int\npython:str\noptional\nGeometry.Point3DData"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.point_3d",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.point_3d.html#pyedb.dotnet.edb.Edb.point_3d",
        "title": "point_3d > point_3d > point_3d",
        "section": "point_3d > point_3d",
        "text": "Edb.point_3d(x, y, z=0.0)\n\nCompute the Edb 3d Point Data.\n\nParameters\n\nx\n\npython:float, python:int or python:str\n\nX value.\n\ny\n\npython:float, python:int or python:str\n\nY value.\n\nz\n\npython:float, python:int or python:str, optional\n\nZ value.\n\nReturns\n\nGeometry.Point3DData.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.short_component_pins",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.short_component_pins.html#short_component_pins",
        "title": "short_component_pins",
        "section": "short_component_pins",
        "text": "Short pins of component with a trace.\nName of the component.\nList of pins to short. If None, all pins will be shorted.\nShort Trace width. It will be used in trace computation algorithm\nTrue when successful, False when failed.\nshort_component_pins\npython:str\npython:list\noptional\npython:float\noptional\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.short_component_pins",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.short_component_pins.html#pyedb.dotnet.database.components.Components.short_component_pins",
        "title": "short_component_pins > short_component_pins > short_component_pins",
        "section": "short_component_pins > short_component_pins",
        "text": "Components.short_component_pins(component_name, pins_to_short=None, width=0.001)\n\nShort pins of component with a trace.\n\nParameters\n\ncomponent_name\n\npython:str\n\nName of the component.\n\npins_to_short\n\npython:list, optional\n\nList of pins to short. If None, all pins will be shorted.\n\nwidth\n\npython:float, optional\n\nShort Trace width. It will be used in trace computation algorithm\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\")\n>>> edbapp.components.short_component_pins(\"J4A2\", [\"G4\", \"9\", \"3\"])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.add_void",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.add_void.html#add_void",
        "title": "add_void",
        "section": "add_void",
        "text": "Add a void to the primitive.\nVoid to add.\nadd_void\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.add_void",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.add_void.html#pyedb.grpc.database.primitive.bondwire.Bondwire.add_void",
        "title": "add_void > add_void > add_void",
        "section": "add_void > add_void",
        "text": "Bondwire.add_void(hole)\n\nAdd a void to the primitive.\n\nParameters\n\nhole\n\nPrimitive\n\nVoid to add.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.convert_to_polygon",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.convert_to_polygon.html#convert_to_polygon",
        "title": "convert_to_polygon",
        "section": "convert_to_polygon",
        "text": "Convert path to polygon.\nPolygon when successful, False when failed.\nconvert_to_polygon\nPolygon\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.convert_to_polygon",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.convert_to_polygon.html#pyedb.grpc.database.primitive.rectangle.Rectangle.convert_to_polygon",
        "title": "convert_to_polygon > convert_to_polygon > convert_to_polygon",
        "section": "convert_to_polygon > convert_to_polygon",
        "text": "Rectangle.convert_to_polygon()\n\nConvert path to polygon.\n\nReturns\n\nPolygon\n\nPolygon when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_edge_port_horizontal",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_edge_port_horizontal.html#create_edge_port_horizontal",
        "title": "create_edge_port_horizontal",
        "section": "create_edge_port_horizontal",
        "text": "Create a horizontal edge port.\nPrimitive ID.\nCoordinate of the point to define the edge terminal.\nThe point must be on the target edge but not on the two\nends of the edge.\nReference primitive ID. The default is None.\nCoordinate of the point to define the reference edge\nterminal. The point must be on the target edge but not\non the two ends of the edge. The default is None.\nName of the port. The default is None.\nImpedance of the port. The default value is 50.\nLayer alignment. The default value is Upper. Options are \"Upper\", \"Lower\".\nName of the port.\ncreate_edge_port_horizontal\npython:int\npython:list\npython:int\noptional\nNone\npython:list\noptional\nNone\npython:str\noptional\nNone\npython:int\npython:float\noptional\n50\npython:str\noptional\nUpper\n\"Upper\"\n\"Lower\"\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_edge_port_horizontal",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_edge_port_horizontal.html#pyedb.dotnet.database.hfss.EdbHfss.create_edge_port_horizontal",
        "title": "create_edge_port_horizontal > create_edge_port_horizontal > create_edge_port_horizontal",
        "section": "create_edge_port_horizontal > create_edge_port_horizontal",
        "text": "EdbHfss.create_edge_port_horizontal(prim_id, point_on_edge, ref_prim_id=None, point_on_ref_edge=None, port_name=None, impedance=50, layer_alignment='Upper')\n\nCreate a horizontal edge port.\n\nParameters\n\nprim_id\n\npython:int\n\nPrimitive ID.\n\npoint_on_edge\n\npython:list\n\nCoordinate of the point to define the edge terminal.\nThe point must be on the target edge but not on the two\nends of the edge.\n\nref_prim_id\n\npython:int, optional\n\nReference primitive ID. The default is None.\n\npoint_on_ref_edge\n\npython:list, optional\n\nCoordinate of the point to define the reference edge\nterminal. The point must be on the target edge but not\non the two ends of the edge. The default is None.\n\nport_name\n\npython:str, optional\n\nName of the port. The default is None.\n\nimpedance\n\npython:int, python:float, optional\n\nImpedance of the port. The default value is 50.\n\nlayer_alignment\n\npython:str, optional\n\nLayer alignment. The default value is Upper. Options are \"Upper\", \"Lower\".\n\nReturns\n\npython:str\n\nName of the port.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.layout_obj_type.html#pyedb.grpc.database.hierarchy.component.Component.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "Component.layout_obj_type = 8\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/stackup_layer",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/stackup_layer.html#stackup-layer",
        "title": "Stackup Layer",
        "section": "Stackup Layer",
        "text": "This class is managing EDB stackup layer.\nStackupLayer\n\nStackup Layer\nStackupLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.html#voltageregulator",
        "title": "VoltageRegulator",
        "section": "VoltageRegulator",
        "text": "Class managing voltage regulator.\nVoltageRegulator.add_power_module(power_module)\nAdd a power module to the voltage regulator.\nVoltageRegulator.add_power_modules(power_modules)\nAdd multiple power modules to the voltage regulator.\nVoltageRegulator.cast()\nCast the ConnObj object to the correct concrete type.\nVoltageRegulator.create(layout, name, ...)\nCreate a voltage regulator.\nVoltageRegulator.create_3d_comp()\nCreate a 3D composite model from an MCAD file.\nVoltageRegulator.create_hfss()\nCreate an HFSS model from an MCAD file.\nVoltageRegulator.create_stride()\nCreate a Stride model from an MCAD file.\nVoltageRegulator.delete()\nDelete the layout object.\nVoltageRegulator.find_by_id(layout, uid)\nFind a Connectable object by database ID in a given layout.\nVoltageRegulator.get_all_power_modules()\nGet all power modules in the voltage regulator.\nVoltageRegulator.get_power_module(...)\nGet the power module for a given component group name.\nVoltageRegulator.get_product_property(...)\nGet the product property of the layout object for a given product ID and attribute ID.\nVoltageRegulator.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nVoltageRegulator.remove_all_power_modules()\nRemove all power modules in the voltage regulator.\nVoltageRegulator.remove_power_module(name)\nRemove a power module from the voltage regulator.\nVoltageRegulator.remove_power_modules(names)\nRemove multiple power modules from the voltage regulator.\nVoltageRegulator.set_product_property(...)\nSet the product property of the layout object for a given product ID and attribute ID.\nVoltageRegulator.layout_obj_type\n\nVoltageRegulator\nVoltageRegulator.add_power_module\nVoltageRegulator.add_power_modules\nVoltageRegulator.cast\nVoltageRegulator.create\nVoltageRegulator.create_3d_comp\nVoltageRegulator.create_hfss\nVoltageRegulator.create_stride\nVoltageRegulator.delete\nVoltageRegulator.find_by_id\nVoltageRegulator.get_all_power_modules\nVoltageRegulator.get_power_module\nVoltageRegulator.get_product_property\nVoltageRegulator.get_product_property_ids\nVoltageRegulator.remove_all_power_modules\nVoltageRegulator.remove_power_module\nVoltageRegulator.remove_power_modules\nVoltageRegulator.set_product_property\nVoltageRegulator.layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.html#pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator",
        "title": "VoltageRegulator > VoltageRegulator > VoltageRegulator",
        "section": "VoltageRegulator > VoltageRegulator",
        "text": "class pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator(pedb, edb_object)\n\nClass managing voltage regulator.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nVoltageRegulator.add_power_module(power_module)\n\nAdd a power module to the voltage regulator.\n\nVoltageRegulator.add_power_modules(power_modules)\n\nAdd multiple power modules to the voltage regulator.\n\nVoltageRegulator.cast()\n\nCast the ConnObj object to the correct concrete type.\n\nVoltageRegulator.create(layout, name, ...)\n\nCreate a voltage regulator.\n\nVoltageRegulator.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nVoltageRegulator.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nVoltageRegulator.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nVoltageRegulator.delete()\n\nDelete the layout object.\n\nVoltageRegulator.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nVoltageRegulator.get_all_power_modules()\n\nGet all power modules in the voltage regulator.\n\nVoltageRegulator.get_power_module(...)\n\nGet the power module for a given component group name.\n\nVoltageRegulator.get_product_property(...)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nVoltageRegulator.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nVoltageRegulator.remove_all_power_modules()\n\nRemove all power modules in the voltage regulator.\n\nVoltageRegulator.remove_power_module(name)\n\nRemove a power module from the voltage regulator.\n\nVoltageRegulator.remove_power_modules(names)\n\nRemove multiple power modules from the voltage regulator.\n\nVoltageRegulator.set_product_property(...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\n\n\nAttributes\n\n\n\n\n\n\n\nVoltageRegulator.layout_obj_type\n\n\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/adaptive_frequency_data",
        "href": "dotnet_api/dotnet/sim_setup_data/data/adaptive_frequency_data.html#adaptive-frequency-data",
        "title": "Adaptive frequency data",
        "section": "Adaptive frequency data",
        "text": "This class is the container of HFSS adaptive frequency data.\nAdaptiveFrequencyData\nManages EDB methods for adaptive frequency data.\nAdaptive frequency data\nAdaptiveFrequencyData"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.DifferentialTLine.Optional",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.DifferentialTLine.Optional.html#optional",
        "title": "Optional",
        "section": "Optional",
        "text": "Optional"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.DifferentialTLine.Optional",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.DifferentialTLine.Optional.html#pyedb.libraries.rf_libraries.base_functions.DifferentialTLine.Optional",
        "title": "Optional > Optional > Optional",
        "section": "Optional > Optional",
        "text": "DifferentialTLine.Optional = typing.Optional\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_outline_layer",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_outline_layer.html#add_outline_layer",
        "title": "add_outline_layer",
        "section": "add_outline_layer",
        "text": "Add an outline layer named \"Outline\" if it is not present.\n“True” if successful, False if failed.\nadd_outline_layer\n\"Outline\"\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_outline_layer",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_outline_layer.html#pyedb.dotnet.database.stackup.Stackup.add_outline_layer",
        "title": "add_outline_layer > add_outline_layer > add_outline_layer",
        "section": "add_outline_layer > add_outline_layer",
        "text": "Stackup.add_outline_layer(outline_name='Outline')\n\nAdd an outline layer named \"Outline\" if it is not present.\n\nReturns\n\nbool\n\n“True” if successful, False if failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_port_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_port_terminal.html#create_port_terminal",
        "title": "create_port_terminal",
        "section": "create_port_terminal",
        "text": "Create port terminal.\nPort impedance, default value 50.\nPin group terminal.\ncreate_port_terminal\npython:float\noptional\n50\nPinGroupTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_port_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_port_terminal.html#pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_port_terminal",
        "title": "create_port_terminal > create_port_terminal > create_port_terminal",
        "section": "create_port_terminal > create_port_terminal",
        "text": "PinGroup.create_port_terminal(impedance=50) -> PinGroupTerminal\n\nCreate port terminal.\n\nParameters\n\nimpedance\n\npython:float, optional\n\nPort impedance, default value 50.\n\nReturns\n\nPinGroupTerminal.\n\nPin group terminal.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create_3d_comp.html#create_3d_comp",
        "title": "create_3d_comp",
        "section": "create_3d_comp",
        "text": "Create a 3D composite model from an MCAD file.\n3D composite model created.\ncreate_3d_comp\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create_3d_comp.html#pyedb.grpc.database.hierarchy.component.Component.create_3d_comp",
        "title": "create_3d_comp > create_3d_comp > create_3d_comp",
        "section": "create_3d_comp > create_3d_comp",
        "text": "Component.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nReturns\n\nMcadModel\n\n3D composite model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_fields.html#pyedb.workflows.drc.drc.Rules.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "Rules.model_fields = {'back_drill_stub_length': FieldInfo(annotation=List[BackDrillStubLength], required=False, default=[]), 'copper_balance': FieldInfo(annotation=List[CopperBalance], required=False, default=[]), 'diff_pair_length_match': FieldInfo(annotation=List[DiffPairLengthMatch], required=False, default=[]), 'min_annular_ring': FieldInfo(annotation=List[MinAnnularRing], required=False, default=[]), 'min_clearance': FieldInfo(annotation=List[MinClearance], required=False, default=[]), 'min_line_width': FieldInfo(annotation=List[MinLineWidth], required=False, default=[])}\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.asin",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.asin.html#asin",
        "title": "asin",
        "section": "asin",
        "text": "Arcsine of the value.\nasin"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.asin",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.asin.html#pyedb.grpc.database.utility.value.Value.asin",
        "title": "asin > asin > asin",
        "section": "asin > asin",
        "text": "Value.asin()\n\nArcsine of the value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.create",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a bundle terminal.\ncreate\npython:list\nof\nTerminal\nBundleTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.create",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.create.html#pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod BundleTerminal.create(terminals)\n\nCreate a bundle terminal.\n\nParameters\n\nterminals\n\npython:list of Terminal\n\n\n\nReturns\n\nBundleTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the layout object.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.delete.html#pyedb.grpc.database.ports.ports.BundleWavePort.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "BundleWavePort.delete()\n\nDelete the layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.duplicate",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.duplicate.html#duplicate",
        "title": "duplicate",
        "section": "duplicate",
        "text": "Duplicate a material from the database.\nName of the existing material.\nName of the new duplicated material.\nduplicate\npython:str\npython:str\npyedb.dotnet.database.materials.Material"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.duplicate",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.duplicate.html#pyedb.dotnet.database.materials.Materials.duplicate",
        "title": "duplicate > duplicate > duplicate",
        "section": "duplicate > duplicate",
        "text": "Materials.duplicate(material_name, new_material_name)\n\nDuplicate a material from the database.\n\nParameters\n\nmaterial_name\n\npython:str\n\nName of the existing material.\n\nnew_material_name\n\npython:str\n\nName of the new duplicated material.\n\nReturns\n\npyedb.dotnet.database.materials.Material\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.html#components",
        "title": "Components",
        "section": "Components",
        "text": "Manages EDB components and related method accessible from Edb.components property.\nComponents.add_port_on_rlc_component([...])\nDeactivate RLC component and replace it with a circuit port.\nComponents.add_rlc_boundary([component, ...])\nAdd RLC gap boundary on component and replace it with a circuit port.\nComponents.create(pins[, component_name, ...])\nCreate a component from pins.\nComponents.create_pingroup_from_pins(pins[, ...])\nCreate a pin group on a component.\nComponents.create_port_on_component(...[, ...])\nCreate ports on a component.\nComponents.create_port_on_pins(refdes, pins, ...)\nCreate circuit port between pins and reference ones.\nComponents.create_rlc_component(pins[, ...])\nCreate physical Rlc component.\nComponents.create_source_on_component([sources])\nCreate voltage, current source, or resistor on component.\nComponents.deactivate_rlc_component([...])\nDeactivate RLC component with a possibility to convert it to a circuit port.\nComponents.delete(component_name)\nDelete a component.\nComponents.delete_single_pin_rlc([...])\nDelete all RLC components with a single pin.\nComponents.disable_rlc_component(component_name)\nDisable a RLC component.\nComponents.export_bom(bom_file[, delimiter])\nExport Bom file from layout.\nComponents.export_definition(file_path)\nExport component definitions to json file.\nComponents.find_by_reference_designator(...)\nFind a component.\nComponents.get_aedt_pin_name(pin)\nRetrieve the pin name that is shown in AEDT.\nComponents.get_component_by_name(name)\nRetrieve a component by name.\nComponents.get_component_net_connection_info(refdes)\nRetrieve net connection information.\nComponents.get_component_placement_vector(...)\nGet the placement vector between 2 components.\nComponents.get_components_from_nets([netlist])\nRetrieve components from a net list.\nComponents.get_nets_from_pin_list(PinList)\nRetrieve nets with one or more pins.\nComponents.get_pin_from_component(component)\nRetrieve the pins of a component.\nComponents.get_pin_position(pin)\nRetrieve the pin position in meters.\nComponents.get_pins(reference_designator[, ...])\nGet component pins.\nComponents.get_pins_name_from_net(net_name)\nRetrieve pins belonging to a net.\nComponents.get_rats()\nRetrieve a list of dictionaries of the reference designator, pin names, and net names.\nComponents.get_solder_ball_height(cmp)\nGet component solder ball height.\nComponents.get_through_resistor_list([threshold])\nRetrieve through resistors.\nComponents.get_vendor_libraries()\nRetrieve all capacitors and inductors libraries from ANSYS installation (used by Siwave).\nComponents.import_bom(bom_file[, delimiter, ...])\nLoad external BOM file.\nComponents.import_definition(file_path)\nImport component definition from json file.\nComponents.refresh_components()\nRefresh the component dictionary.\nComponents.replace_rlc_by_gap_boundaries([...])\nReplace RLC component by RLC gap boundaries.\nComponents.set_component_model(componentname)\nAssign a Spice or Touchstone model to a component.\nComponents.set_component_rlc(componentname)\nUpdate values for an RLC component.\nComponents.set_solder_ball([component, ...])\nSet cylindrical solder balls on a given component.\nComponents.short_component_pins(component_name)\nShort pins of component with a trace.\nComponents.update_rlc_from_bom(bom_file[, ...])\nUpdate the EDC core component values (RLCs) with values coming from a BOM file.\nComponents\npyedb.dotnet.edb.Edb\nComponents.add_port_on_rlc_component\nComponents.add_rlc_boundary\nComponents.create\nComponents.create_pingroup_from_pins\nComponents.create_port_on_component\nComponents.create_port_on_pins\nComponents.create_rlc_component\nComponents.create_source_on_component\nComponents.deactivate_rlc_component\nComponents.delete\nComponents.delete_single_pin_rlc\nComponents.disable_rlc_component\nComponents.export_bom\nComponents.export_definition\nComponents.find_by_reference_designator\nComponents.get_aedt_pin_name\nComponents.get_component_by_name\nComponents.get_component_net_connection_info\nComponents.get_component_placement_vector\nComponents.get_components_from_nets\nComponents.get_nets_from_pin_list\nComponents.get_pin_from_component\nComponents.get_pin_position\nComponents.get_pins\nComponents.get_pins_name_from_net\nComponents.get_rats\nComponents.get_solder_ball_height\nComponents.get_through_resistor_list\nComponents.get_vendor_libraries\nComponents.import_bom\nComponents.import_definition\nComponents.refresh_components\nComponents.replace_rlc_by_gap_boundaries\nComponents.set_component_model\nComponents.set_component_rlc\nComponents.set_solder_ball\nComponents.short_component_pins\nComponents.update_rlc_from_bom"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.html#pyedb.dotnet.database.components.Components",
        "title": "Components > Components > Components",
        "section": "Components > Components",
        "text": "class pyedb.dotnet.database.components.Components(p_edb)\n\nManages EDB components and related method accessible from Edb.components property.\n\nParameters\n\nedb_class\n\npyedb.dotnet.edb.Edb\n\n\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\")\n>>> edbapp.components\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nComponents.add_port_on_rlc_component([...])\n\nDeactivate RLC component and replace it with a circuit port.\n\nComponents.add_rlc_boundary([component, ...])\n\nAdd RLC gap boundary on component and replace it with a circuit port.\n\nComponents.create(pins[, component_name, ...])\n\nCreate a component from pins.\n\nComponents.create_pingroup_from_pins(pins[, ...])\n\nCreate a pin group on a component.\n\nComponents.create_port_on_component(...[, ...])\n\nCreate ports on a component.\n\nComponents.create_port_on_pins(refdes, pins, ...)\n\nCreate circuit port between pins and reference ones.\n\nComponents.create_rlc_component(pins[, ...])\n\nCreate physical Rlc component.\n\nComponents.create_source_on_component([sources])\n\nCreate voltage, current source, or resistor on component.\n\nComponents.deactivate_rlc_component([...])\n\nDeactivate RLC component with a possibility to convert it to a circuit port.\n\nComponents.delete(component_name)\n\nDelete a component.\n\nComponents.delete_single_pin_rlc([...])\n\nDelete all RLC components with a single pin.\n\nComponents.disable_rlc_component(component_name)\n\nDisable a RLC component.\n\nComponents.export_bom(bom_file[, delimiter])\n\nExport Bom file from layout.\n\nComponents.export_definition(file_path)\n\nExport component definitions to json file.\n\nComponents.find_by_reference_designator(...)\n\nFind a component.\n\nComponents.get_aedt_pin_name(pin)\n\nRetrieve the pin name that is shown in AEDT.\n\nComponents.get_component_by_name(name)\n\nRetrieve a component by name.\n\nComponents.get_component_net_connection_info(refdes)\n\nRetrieve net connection information.\n\nComponents.get_component_placement_vector(...)\n\nGet the placement vector between 2 components.\n\nComponents.get_components_from_nets([netlist])\n\nRetrieve components from a net list.\n\nComponents.get_nets_from_pin_list(PinList)\n\nRetrieve nets with one or more pins.\n\nComponents.get_pin_from_component(component)\n\nRetrieve the pins of a component.\n\nComponents.get_pin_position(pin)\n\nRetrieve the pin position in meters.\n\nComponents.get_pins(reference_designator[, ...])\n\nGet component pins.\n\nComponents.get_pins_name_from_net(net_name)\n\nRetrieve pins belonging to a net.\n\nComponents.get_rats()\n\nRetrieve a list of dictionaries of the reference designator, pin names, and net names.\n\nComponents.get_solder_ball_height(cmp)\n\nGet component solder ball height.\n\nComponents.get_through_resistor_list([threshold])\n\nRetrieve through resistors.\n\nComponents.get_vendor_libraries()\n\nRetrieve all capacitors and inductors libraries from ANSYS installation (used by Siwave).\n\nComponents.import_bom(bom_file[, delimiter, ...])\n\nLoad external BOM file.\n\nComponents.import_definition(file_path)\n\nImport component definition from json file.\n\nComponents.refresh_components()\n\nRefresh the component dictionary.\n\nComponents.replace_rlc_by_gap_boundaries([...])\n\nReplace RLC component by RLC gap boundaries.\n\nComponents.set_component_model(componentname)\n\nAssign a Spice or Touchstone model to a component.\n\nComponents.set_component_rlc(componentname)\n\nUpdate values for an RLC component.\n\nComponents.set_solder_ball([component, ...])\n\nSet cylindrical solder balls on a given component.\n\nComponents.short_component_pins(component_name)\n\nShort pins of component with a trace.\n\nComponents.update_rlc_from_bom(bom_file[, ...])\n\nUpdate the EDC core component values (RLCs) with values coming from a BOM file.\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.compare",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.compare.html#compare",
        "title": "compare",
        "section": "compare",
        "text": "Compares current open database with another one.\nDo not execute this function with untrusted function argument, environment\nvariables or pyedb global settings.\nSee the security guide for details.\nPath to the edb file.\nPath to directory in which results will be saved. If no path is given, a new “_compare_results”\ndirectory will be created with the same naming and path as the .aedb folder.\nTrue when successful, False when failed.\ncompare\npython:str\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.compare",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.compare.html#pyedb.dotnet.edb.Edb.compare",
        "title": "compare > compare > compare",
        "section": "compare > compare",
        "text": "Edb.compare(input_file, results='')\n\nCompares current open database with another one.\n\nDo not execute this function with untrusted function argument, environment\nvariables or pyedb global settings.\nSee the security guide for details.\n\nParameters\n\ninput_file\n\npython:str\n\nPath to the edb file.\n\nresults: str, optional\n\nPath to directory in which results will be saved. If no path is given, a new “_compare_results”\ndirectory will be created with the same naming and path as the .aedb folder.\n\nReturns\n\n\n\n——-\n\n\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the layout object.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.delete.html#pyedb.grpc.database.primitive.bondwire.Bondwire.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "Bondwire.delete()\n\nDelete the layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_connected_object_id_set",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_connected_object_id_set.html#get_connected_object_id_set",
        "title": "get_connected_object_id_set",
        "section": "get_connected_object_id_set",
        "text": "Produce a list of all geometries physically connected to a given layout object.\nFound connected objects IDs with Layout object.\nget_connected_object_id_set\nList\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_connected_object_id_set",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_connected_object_id_set.html#pyedb.grpc.database.primitive.path.Path.get_connected_object_id_set",
        "title": "get_connected_object_id_set > get_connected_object_id_set > get_connected_object_id_set",
        "section": "get_connected_object_id_set > get_connected_object_id_set",
        "text": "Path.get_connected_object_id_set() -> list[int]\n\nProduce a list of all geometries physically connected to a given layout object.\n\nReturns\n\nList[python:int]\n\nFound connected objects IDs with Layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.remove_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.remove_hfss_prop.html#remove_hfss_prop",
        "title": "remove_hfss_prop",
        "section": "remove_hfss_prop",
        "text": "Remove HFSS properties.\nremove_hfss_prop"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.remove_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.remove_hfss_prop.html#pyedb.grpc.database.primitive.path.Path.remove_hfss_prop",
        "title": "remove_hfss_prop > remove_hfss_prop > remove_hfss_prop",
        "section": "remove_hfss_prop > remove_hfss_prop",
        "text": "Path.remove_hfss_prop()\n\nRemove HFSS properties.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.area",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.area.html#area",
        "title": "area",
        "section": "area",
        "text": "Return the total area.\nEither if the voids have to be included in computation.\nThe default value is True.\narea\noptional\nTrue\npython:float"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.area",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.area.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.area",
        "title": "area > area > area",
        "section": "area > area",
        "text": "EdbPolygon.area(include_voids=True)\n\nReturn the total area.\n\nParameters\n\ninclude_voids\n\nbool, optional\n\nEither if the voids have to be included in computation.\nThe default value is True.\n\nReturns\n\npython:float\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.intersect",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.intersect.html#intersect",
        "title": "intersect",
        "section": "intersect",
        "text": "Intersect active primitive with one or more primitives.\nList of Primitive objects.\nintersect\nList\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.intersect",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.intersect.html#pyedb.grpc.database.primitive.polygon.Polygon.intersect",
        "title": "intersect > intersect > intersect",
        "section": "intersect > intersect",
        "text": "Polygon.intersect(primitives) -> list[any]\n\nIntersect active primitive with one or more primitives.\n\nParameters\n\nprimitives :class:`Primitives <pyedb.grpc.database.primitive.primitive.Primitive>`\n\n\n\nor: List[:class:`Primitives <pyedb.grpc.database.primitive.primitive.Primitive>`]\n\n\n\nor: class:`PolygonData <ansys.edb.core.geometry.polygon_data.PolygonData>`\n\n\n\nReturns\n\nList[Primitive]\n\nList of Primitive objects.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData.html#edbdifferentialpairdata",
        "title": "EDBDifferentialPairData",
        "section": "EDBDifferentialPairData",
        "text": "Manages EDB functionalities for a primitive.\nIt inherits EDB object properties.\nEDBDifferentialPairData.add_net(name)\nAdd a new net.\nEDBDifferentialPairData.api_create(name)\nEdb Dotnet Api Database Edb.DifferentialPair.Create.\nEDBDifferentialPairData.delete()\nEdb Dotnet Api Database Delete.\nEDBDifferentialPairData.find_by_name(layout, net)\nEdb Dotnet Api Database Edb.DifferentialPair.FindByName.\nEDBDifferentialPairData\nEDBDifferentialPairData.add_net\nEDBDifferentialPairData.api_create\nEDBDifferentialPairData.delete\nEDBDifferentialPairData.find_by_name"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData.html#pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData",
        "title": "EDBDifferentialPairData > EDBDifferentialPairData > EDBDifferentialPairData",
        "section": "EDBDifferentialPairData > EDBDifferentialPairData",
        "text": "class pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData(core_app, api_object=None)\n\nManages EDB functionalities for a primitive.\nIt inherits EDB object properties.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb(myedb, edbversion=\"2021.2\")\n>>> diff_pair = edb.differential_pairs[\"DQ4\"]\n>>> diff_pair.positive_net\n>>> diff_pair.negative_net\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nEDBDifferentialPairData.add_net(name)\n\nAdd a new net.\n\nEDBDifferentialPairData.api_create(name)\n\nEdb Dotnet Api Database Edb.DifferentialPair.Create.\n\nEDBDifferentialPairData.delete()\n\nEdb Dotnet Api Database Delete.\n\nEDBDifferentialPairData.find_by_name(layout, net)\n\nEdb Dotnet Api Database Edb.DifferentialPair.FindByName.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.conductivity",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.conductivity.html#conductivity",
        "title": "conductivity",
        "section": "conductivity",
        "text": "conductivity"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.conductivity",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.conductivity.html#pyedb.grpc.database.definition.materials.MaterialProperties.conductivity",
        "title": "conductivity > conductivity > conductivity",
        "section": "conductivity > conductivity",
        "text": "MaterialProperties.conductivity: Annotated[float, Gt(gt=0)] | None\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.hex",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.hex.html#hex",
        "title": "hex",
        "section": "hex",
        "text": "Return a hexadecimal representation of a floating-point number.\nhex"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.hex",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.hex.html#pyedb.grpc.database.utility.value.Value.hex",
        "title": "hex > hex > hex",
        "section": "hex > hex",
        "text": "Value.hex(/)\n\nReturn a hexadecimal representation of a floating-point number.\n\n>>> (-0.1).hex()\n'-0x1.999999999999ap-4'\n>>> 3.14159.hex()\n'0x1.921f9f01b866ep+1'\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_solution_multi_frequencies",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_solution_multi_frequencies.html#set_solution_multi_frequencies",
        "title": "set_solution_multi_frequencies",
        "section": "set_solution_multi_frequencies",
        "text": "Set multi-frequency solution.\nList or tuple of adaptive frequencies. The default is 5GHz.\nMaximum number of passes. Default is 10.\nMaximum delta S. The default is 0.02.\nset_solution_multi_frequencies\npython:list\npython:tuple\noptional\n5GHz\npython:int\noptional\n10\npython:float\noptional\n0.02"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_solution_multi_frequencies",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_solution_multi_frequencies.html#pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_solution_multi_frequencies",
        "title": "set_solution_multi_frequencies > set_solution_multi_frequencies > set_solution_multi_frequencies",
        "section": "set_solution_multi_frequencies > set_solution_multi_frequencies",
        "text": "HfssSimulationSetup.set_solution_multi_frequencies(frequencies=('5Ghz', '10Ghz'), max_num_passes=10, max_delta_s='0.02')\n\nSet multi-frequency solution.\n\nParameters\n\nfrequencies\n\npython:list, python:tuple, optional\n\nList or tuple of adaptive frequencies. The default is 5GHz.\n\nmax_num_passes\n\npython:int, optional\n\nMaximum number of passes. Default is 10.\n\nmax_delta_s\n\npython:float, optional\n\nMaximum delta S. The default is 0.02.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create_stride.html#create_stride",
        "title": "create_stride",
        "section": "create_stride",
        "text": "Create a Stride model from an MCAD file.\nStride model created.\ncreate_stride\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create_stride.html#pyedb.grpc.database.primitive.path.Path.create_stride",
        "title": "create_stride > create_stride > create_stride",
        "section": "create_stride > create_stride",
        "text": "Path.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nReturns\n\nMcadModel\n\nStride model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_hole",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_hole.html#is_hole",
        "title": "is_hole",
        "section": "is_hole",
        "text": "Determine whether the polygon is a hole.\nTrue when the polygon is a hole, False otherwise.\nis_hole\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_hole",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_hole.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.is_hole",
        "title": "is_hole > is_hole > is_hole",
        "section": "is_hole > is_hole",
        "text": "PolygonData.is_hole() -> bool\n\nDetermine whether the polygon is a hole.\n\nReturns\n\nbool\n\nTrue when the polygon is a hole, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/component",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/component.html#component",
        "title": "Component",
        "section": "Component",
        "text": "This class is managing EDB component.\nComponent\nManages EDB functionalities for components.\nICDieProperty\n\nComponent\nComponent\nICDieProperty"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.html#rules",
        "title": "Rules",
        "section": "Rules",
        "text": "Centralised, serialisable container for all design-rule categories\nsupported by the PyEDB DRC engine.\nThe class is a thin pydantic model that provides:\nJSON/YAML round-trip via parse_file, parse_obj, model_dump,\nmodel_dump_json.\nType-safe, API to incrementally build rule decks without\nmanipulating raw dictionaries.\nMinimum acceptable trace width per layer or globally.\nSpacing requirements between nets (wild-cards allowed).\nMinimum annular ring for drilled holes.\nLength-matching constraints for differential pairs.\nMaximum allowed back-drill stub length.\nCopper-density balance limits per layer or zone.\nRules.add_back_drill_stub_length(name, value)\nAppend a maximum-allowed back-drill stub-length rule.\nRules.add_copper_balance(name, max_percent, ...)\nAppend a copper-density balance rule.\nRules.add_diff_pair_length_match(name, ...)\nAppend a length-matching rule for differential pairs.\nRules.add_min_annular_ring(name, value)\nAppend a minimum-annular-ring rule for drilled holes.\nRules.add_min_clearance(name, value, net1, net2)\nAppend a minimum-clearance rule between two nets (wild-cards allowed).\nRules.add_min_line_width(name, value[, layers])\nAppend a minimum-line-width rule.\nRules.construct([_fields_set])\n\nRules.copy(*[, include, exclude, update, deep])\nReturns a copy of the model.\nRules.dict(*[, include, exclude, by_alias, ...])\n\nRules.from_dict(data)\nAlias for model_validate.\nRules.from_orm(obj)\n\nRules.json(*[, include, exclude, by_alias, ...])\n\nRules.model_construct([_fields_set])\nCreates a new instance of the Model class with validated data.\nRules.model_copy(*[, update, deep])\n!!! abstract \"Usage Documentation\"\nRules.model_dump(*[, mode, include, ...])\n!!! abstract \"Usage Documentation\"\nRules.model_dump_json(*[, indent, ...])\n!!! abstract \"Usage Documentation\"\nRules.model_json_schema([by_alias, ...])\nGenerates a JSON schema for a model class.\nRules.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nRules.model_post_init(context, /)\nOverride this method to perform additional initialization after __init__ and model_construct.\nRules.model_rebuild(*[, force, ...])\nTry to rebuild the pydantic-core schema for the model.\nRules.model_validate(obj, *[, strict, ...])\nValidate a pydantic model instance.\nRules.model_validate_json(json_data, *[, ...])\n!!! abstract \"Usage Documentation\"\nRules.model_validate_strings(obj, *[, ...])\nValidate the given object with string data against the Pydantic model.\nRules.parse_file(path, *[, content_type, ...])\n\nRules.parse_obj(obj)\n\nRules.parse_raw(b, *[, content_type, ...])\n\nRules.schema([by_alias, ref_template])\n\nRules.schema_json(*[, by_alias, ref_template])\n\nRules.to_dict()\nAlias for model_dump.\nRules.update_forward_refs(**localns)\n\nRules.validate(value)\n\nRules.model_computed_fields\n\nRules.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nRules.model_fields\n\nRules.min_line_width\n\nRules.min_clearance\n\nRules.min_annular_ring\n\nRules.diff_pair_length_match\n\nRules.back_drill_stub_length\n\nRules.copper_balance\n\nRules\npydantic\nparse_file\nparse_obj\nmodel_dump\nmodel_dump_json\nList\nMinLineWidth\nList\nMinClearance\nList\nMinAnnularRing\nList\nDiffPairLengthMatch\nList\nBackDrillStubLength\nList\nCopperBalance\nRules.add_back_drill_stub_length\nRules.add_copper_balance\nRules.add_diff_pair_length_match\nRules.add_min_annular_ring\nRules.add_min_clearance\nRules.add_min_line_width\nRules.construct\nRules.copy\nRules.dict\nRules.from_dict\nmodel_validate\nRules.from_orm\nRules.json\nRules.model_construct\nRules.model_copy\nRules.model_dump\nRules.model_dump_json\nRules.model_json_schema\nRules.model_parametrized_name\nRules.model_post_init\nRules.model_rebuild\nRules.model_validate\nRules.model_validate_json\nRules.model_validate_strings\nRules.parse_file\nRules.parse_obj\nRules.parse_raw\nRules.schema\nRules.schema_json\nRules.to_dict\nmodel_dump\nRules.update_forward_refs\nRules.validate\nRules.model_computed_fields\nRules.model_config\nRules.model_fields\nRules.min_line_width\nRules.min_clearance\nRules.min_annular_ring\nRules.diff_pair_length_match\nRules.back_drill_stub_length\nRules.copper_balance"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.html#pyedb.workflows.drc.drc.Rules",
        "title": "Rules > Rules > Rules",
        "section": "Rules > Rules",
        "text": "class pyedb.workflows.drc.drc.Rules(*, min_line_width: List[MinLineWidth] = [], min_clearance: List[MinClearance] = [], min_annular_ring: List[MinAnnularRing] = [], diff_pair_length_match: List[DiffPairLengthMatch] = [], back_drill_stub_length: List[BackDrillStubLength] = [], copper_balance: List[CopperBalance] = [])\n\nCentralised, serialisable container for all design-rule categories\nsupported by the PyEDB DRC engine.\n\nThe class is a thin pydantic model that provides:\n\nJSON/YAML round-trip via parse_file, parse_obj, model_dump,\nmodel_dump_json.\n\nType-safe, API to incrementally build rule decks without\nmanipulating raw dictionaries.\n\nExamples\n\n>>> from pyedb.workflows.drc.drc import Rules\n>>>\n>>> rules = (\n...     Rules()\n...     .add_min_line_width(\"pwr\", \"15 mil\")\n...     .add_min_clearance(\"clk2data\", \"4 mil\", \"CLK*\", \"DATA*\")\n...     .add_min_annular_ring(\"via5\", \"5 mil\")\n...     .add_diff_pair_length_match(\"usb\", tolerance=\"0.1 mm\", pairs=[(\"USB_P\", \"USB_N\")])\n...     .add_copper_balance(\"top_bal\", max_percent=10, layers=[\"TOP\"])\n... )\n>>> rules.model_dump_json(indent=2)\n>>> rules.write_json(\"my_rules.json\")\n\nAttributes\n\nmin_line_width\n\nList[MinLineWidth]\n\nMinimum acceptable trace width per layer or globally.\n\nmin_clearance\n\nList[MinClearance]\n\nSpacing requirements between nets (wild-cards allowed).\n\nmin_annular_ring\n\nList[MinAnnularRing]\n\nMinimum annular ring for drilled holes.\n\ndiff_pair_length_match\n\nList[DiffPairLengthMatch]\n\nLength-matching constraints for differential pairs.\n\nback_drill_stub_length\n\nList[BackDrillStubLength]\n\nMaximum allowed back-drill stub length.\n\ncopper_balance\n\nList[CopperBalance]\n\nCopper-density balance limits per layer or zone.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nRules.add_back_drill_stub_length(name, value)\n\nAppend a maximum-allowed back-drill stub-length rule.\n\nRules.add_copper_balance(name, max_percent, ...)\n\nAppend a copper-density balance rule.\n\nRules.add_diff_pair_length_match(name, ...)\n\nAppend a length-matching rule for differential pairs.\n\nRules.add_min_annular_ring(name, value)\n\nAppend a minimum-annular-ring rule for drilled holes.\n\nRules.add_min_clearance(name, value, net1, net2)\n\nAppend a minimum-clearance rule between two nets (wild-cards allowed).\n\nRules.add_min_line_width(name, value[, layers])\n\nAppend a minimum-line-width rule.\n\nRules.construct([_fields_set])\n\n\n\nRules.copy(*[, include, exclude, update, deep])\n\nReturns a copy of the model.\n\nRules.dict(*[, include, exclude, by_alias, ...])\n\n\n\nRules.from_dict(data)\n\nAlias for model_validate.\n\nRules.from_orm(obj)\n\n\n\nRules.json(*[, include, exclude, by_alias, ...])\n\n\n\nRules.model_construct([_fields_set])\n\nCreates a new instance of the Model class with validated data.\n\nRules.model_copy(*[, update, deep])\n\n!!! abstract \"Usage Documentation\"\n\nRules.model_dump(*[, mode, include, ...])\n\n!!! abstract \"Usage Documentation\"\n\nRules.model_dump_json(*[, indent, ...])\n\n!!! abstract \"Usage Documentation\"\n\nRules.model_json_schema([by_alias, ...])\n\nGenerates a JSON schema for a model class.\n\nRules.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nRules.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nRules.model_rebuild(*[, force, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nRules.model_validate(obj, *[, strict, ...])\n\nValidate a pydantic model instance.\n\nRules.model_validate_json(json_data, *[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nRules.model_validate_strings(obj, *[, ...])\n\nValidate the given object with string data against the Pydantic model.\n\nRules.parse_file(path, *[, content_type, ...])\n\n\n\nRules.parse_obj(obj)\n\n\n\nRules.parse_raw(b, *[, content_type, ...])\n\n\n\nRules.schema([by_alias, ref_template])\n\n\n\nRules.schema_json(*[, by_alias, ref_template])\n\n\n\nRules.to_dict()\n\nAlias for model_dump.\n\nRules.update_forward_refs(**localns)\n\n\n\nRules.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nRules.model_computed_fields\n\n\n\nRules.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nRules.model_fields\n\n\n\nRules.min_line_width\n\n\n\nRules.min_clearance\n\n\n\nRules.min_annular_ring\n\n\n\nRules.diff_pair_length_match\n\n\n\nRules.back_drill_stub_length\n\n\n\nRules.copper_balance\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_computed_fields",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_computed_fields",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_computed_fields.html#pyedb.grpc.database.definition.materials.MaterialProperties.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "MaterialProperties.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileStackup.add_layer",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileStackup.add_layer.html#add_layer",
        "title": "add_layer",
        "section": "add_layer",
        "text": "Add a new layer.\nLayer name.\nLayer elevation.\nMaterial for the layer.\nGDS type assigned on the layer. The value must be the same as in the GDS file otherwise geometries won’t be\nimported.\nLayer name assigned in EDB or HFSS 3D layout after import.\nLayer thickness\nDefine the layer type, default value for a layer is \"conductor\"\nWhen True solver will solve inside metal, and not id False. Default value is True.\nDictionary with key and  property value.\nadd_layer\npython:str\npython:float\npython:str\npython:int\npython:str\npython:float\npython:str\n\"conductor\"\nTrue\nFalse\nTrue\npython:dict\npyedb.dotnet.database.edb_data.control_file.ControlFileLayer"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileStackup.add_layer",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileStackup.add_layer.html#pyedb.dotnet.database.edb_data.control_file.ControlFileStackup.add_layer",
        "title": "add_layer > add_layer > add_layer",
        "section": "add_layer > add_layer",
        "text": "ControlFileStackup.add_layer(layer_name, elevation=0.0, material='', gds_type=0, target_layer='', thickness=0.0, layer_type='conductor', solve_inside=True, properties=None)\n\nAdd a new layer.\n\nParameters\n\nlayer_name\n\npython:str\n\nLayer name.\n\nelevation\n\npython:float\n\nLayer elevation.\n\nmaterial\n\npython:str\n\nMaterial for the layer.\n\ngds_type\n\npython:int\n\nGDS type assigned on the layer. The value must be the same as in the GDS file otherwise geometries won’t be\nimported.\n\ntarget_layer\n\npython:str\n\nLayer name assigned in EDB or HFSS 3D layout after import.\n\nthickness\n\npython:float\n\nLayer thickness\n\nlayer_type\n\npython:str\n\nDefine the layer type, default value for a layer is \"conductor\"\n\nsolve_inside\n\nbool\n\nWhen True solver will solve inside metal, and not id False. Default value is True.\n\nproperties\n\npython:dict\n\nDictionary with key and  property value.\n\nReturns\n\npyedb.dotnet.database.edb_data.control_file.ControlFileLayer\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_connected_objects",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_connected_objects.html#get_connected_objects",
        "title": "get_connected_objects",
        "section": "get_connected_objects",
        "text": "Get connected objects.\nget_connected_objects\nList\nLayoutObjInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_connected_objects",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_connected_objects.html#pyedb.grpc.database.primitive.path.Path.get_connected_objects",
        "title": "get_connected_objects > get_connected_objects > get_connected_objects",
        "section": "get_connected_objects > get_connected_objects",
        "text": "Path.get_connected_objects()\n\nGet connected objects.\n\nReturns\n\nList[LayoutObjInstance]\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNets",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNets.html#extendednets",
        "title": "ExtendedNets",
        "section": "ExtendedNets",
        "text": "ExtendedNets.auto_identify_power([...])\nGet all extended power nets and their associated components.\nExtendedNets.auto_identify_signal([...])\nGet extended signal net and associated components.\nExtendedNets.create(name, net)\nCreate a new Extended net.\nExtendedNets.generate_extended_nets([...])\nGet extended net and associated components.\nExtendedNets\nExtendedNets.auto_identify_power\nExtendedNets.auto_identify_signal\nExtendedNets.create\nExtendedNets.generate_extended_nets"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNets",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNets.html#pyedb.grpc.database.net.extended_net.ExtendedNets",
        "title": "ExtendedNets > ExtendedNets > ExtendedNets",
        "section": "ExtendedNets > ExtendedNets",
        "text": "class pyedb.grpc.database.net.extended_net.ExtendedNets(pedb)\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nExtendedNets.auto_identify_power([...])\n\nGet all extended power nets and their associated components.\n\nExtendedNets.auto_identify_signal([...])\n\nGet extended signal net and associated components.\n\nExtendedNets.create(name, net)\n\nCreate a new Extended net.\n\nExtendedNets.generate_extended_nets([...])\n\nGet extended net and associated components.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.product_solver_names",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.product_solver_names.html#product_solver_names",
        "title": "product_solver_names",
        "section": "product_solver_names",
        "text": "Get the list of solver names.\nID of the product.\nproduct_solver_names\nProductIdType\npython:list\nof\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.product_solver_names",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.product_solver_names.html#pyedb.grpc.database.ports.ports.GapPort.product_solver_names",
        "title": "product_solver_names > product_solver_names > product_solver_names",
        "section": "product_solver_names > product_solver_names",
        "text": "GapPort.product_solver_names(product_id)\n\nGet the list of solver names.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nReturns\n\npython:list of python:str\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.add_design_variable",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.add_design_variable.html#add_design_variable",
        "title": "add_design_variable",
        "section": "add_design_variable",
        "text": "Add a variable to edb. The variable can be a design one or a project variable (using $ prefix).\nUser can use also the setitem to create or assign a variable. See example below.\nName of the variable. To added the variable as a project variable, the name\nmust begin with $.\nValue of the variable with units.\nWhether to add the variable as a local variable. The default is False.\nWhen True, the variable is added as a parameter default.\nDescription of the variable.\nTuple containing the AddVariable result and variable server.\nadd_design_variable\n$\npython:str\n$\npython:str\npython:float\noptional\nFalse\nTrue\npython:str\noptional\nAddVariable"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.add_design_variable",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.add_design_variable.html#pyedb.dotnet.edb.Edb.add_design_variable",
        "title": "add_design_variable > add_design_variable > add_design_variable",
        "section": "add_design_variable > add_design_variable",
        "text": "Edb.add_design_variable(variable_name, variable_value, is_parameter=False, description='')\n\nAdd a variable to edb. The variable can be a design one or a project variable (using $ prefix).\n\n..note::\n\nUser can use also the setitem to create or assign a variable. See example below.\n\nParameters\n\nvariable_name\n\npython:str\n\nName of the variable. To added the variable as a project variable, the name\nmust begin with $.\n\nvariable_value\n\npython:str, python:float\n\nValue of the variable with units.\n\nis_parameter\n\nbool, optional\n\nWhether to add the variable as a local variable. The default is False.\nWhen True, the variable is added as a parameter default.\n\ndescription\n\npython:str, optional\n\nDescription of the variable.\n\nReturns\n\n\n\n——-\n\n\n\ntuple\n\nTuple containing the AddVariable result and variable server.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb_app = Edb()\n>>> boolean_1, ant_length = edb_app.add_design_variable(\"my_local_variable\", \"1cm\")\n>>> print(edb_app[\"my_local_variable\"])  # using getitem\n>>> edb_app[\"my_local_variable\"] = \"1cm\"  # using setitem\n>>> boolean_2, para_length = edb_app.change_design_variable_value(\"my_parameter\", \"1m\", is_parameter=True\n>>> boolean_3, project_length = edb_app.change_design_variable_value(\"$my_project_variable\", \"1m\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the layout object.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.delete.html#pyedb.grpc.database.terminal.point_terminal.PointTerminal.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "PointTerminal.delete()\n\nDelete the layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.type.html#type",
        "title": "type",
        "section": "type",
        "text": "type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.type.html#pyedb.grpc.database.terminal.terminal.Terminal.type",
        "title": "type > type > type",
        "section": "type > type",
        "text": "Terminal.type = None\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.AdaptiveType.SingleFrequency",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.AdaptiveType.SingleFrequency.html#singlefrequency",
        "title": "SingleFrequency",
        "section": "SingleFrequency",
        "text": "SingleFrequency"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.AdaptiveType.SingleFrequency",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.AdaptiveType.SingleFrequency.html#pyedb.dotnet.database.utilities.simulation_setup.AdaptiveType.SingleFrequency",
        "title": "SingleFrequency > SingleFrequency > SingleFrequency",
        "section": "SingleFrequency > SingleFrequency",
        "text": "AdaptiveType.SingleFrequency = 0\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileComponents",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileComponents.html#controlfilecomponents",
        "title": "ControlFileComponents",
        "section": "ControlFileComponents",
        "text": "Class for component management.\nControlFileComponents.add_component(ref_des, ...)\nCreate a new component.\nControlFileComponents\nControlFileComponents.add_component"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileComponents",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileComponents.html#pyedb.grpc.database.utility.xml_control_file.ControlFileComponents",
        "title": "ControlFileComponents > ControlFileComponents > ControlFileComponents",
        "section": "ControlFileComponents > ControlFileComponents",
        "text": "class pyedb.grpc.database.utility.xml_control_file.ControlFileComponents\n\nClass for component management.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nControlFileComponents.add_component(ref_des, ...)\n\nCreate a new component.\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_primitives",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_primitives.html#get_primitives",
        "title": "get_primitives",
        "section": "get_primitives",
        "text": "Get primitives by conditions.\nSet filter on net_name. Default is None.\nSet filter on layer_name. Default is None.\nSet filter on primitive type. Default is None.\nSet filter on is_void. Default is ‘False’\nList of filtered primitives\nget_primitives\npython:str\noptional\npython:str\noptional\npython:str\noptional"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_primitives",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_primitives.html#pyedb.dotnet.database.modeler.Modeler.get_primitives",
        "title": "get_primitives > get_primitives > get_primitives",
        "section": "get_primitives > get_primitives",
        "text": "Modeler.get_primitives(net_name=None, layer_name=None, prim_type=None, is_void=False)\n\nGet primitives by conditions.\n\nParameters\n\nnet_name\n\npython:str, optional\n\nSet filter on net_name. Default is None.\n\nlayer_name\n\npython:str, optional\n\nSet filter on layer_name. Default is None.\n\nprim_type\n\npython:str, optional\n\nSet filter on primitive type. Default is None.\n\nis_void\n\nbool\n\nSet filter on is_void. Default is ‘False’\n\nReturns\n\n\n\n——-\n\n\n\nlist\n\nList of filtered primitives\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_rectangle",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_rectangle.html#create_rectangle",
        "title": "create_rectangle",
        "section": "create_rectangle",
        "text": "Create rectangle primitive.\nLayer name.\nAssociated net name.\n[x,y] lower left point.\n[x,y] upper right point.\n[x,y] center point.\nRectangle width.\nRectangle height.\n“lower_left_upper_right” or “center_width_height”.\nCorner radius with units.\nRotation angle with units.\nRectangle object if created, False otherwise.\ncreate_rectangle\npython:str\npython:str\noptional\npython:list\noptional\npython:list\noptional\npython:list\noptional\npython:str\npython:float\noptional\npython:str\npython:float\noptional\npython:str\noptional\npython:str\noptional\npython:str\noptional\npyedb.dotnet.database.edb_data.primitives_data.Rectangle"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_rectangle",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_rectangle.html#pyedb.grpc.database.modeler.Modeler.create_rectangle",
        "title": "create_rectangle > create_rectangle > create_rectangle",
        "section": "create_rectangle > create_rectangle",
        "text": "Modeler.create_rectangle(layer_name: str, net_name: str = '', lower_left_point: str = '', upper_right_point: str = '', center_point: str = '', width: str | float = '', height: str | float = '', representation_type: str = 'lower_left_upper_right', corner_radius: str = '0mm', rotation: str = '0deg') -> Primitive | None\n\nCreate rectangle primitive.\n\nParameters\n\nlayer_name\n\npython:str\n\nLayer name.\n\nnet_name\n\npython:str, optional\n\nAssociated net name.\n\nlower_left_point\n\npython:list, optional\n\n[x,y] lower left point.\n\nupper_right_point\n\npython:list, optional\n\n[x,y] upper right point.\n\ncenter_point\n\npython:list, optional\n\n[x,y] center point.\n\nwidth\n\npython:str or python:float, optional\n\nRectangle width.\n\nheight\n\npython:str or python:float, optional\n\nRectangle height.\n\nrepresentation_type\n\npython:str, optional\n\n“lower_left_upper_right” or “center_width_height”.\n\ncorner_radius\n\npython:str, optional\n\nCorner radius with units.\n\nrotation\n\npython:str, optional\n\nRotation angle with units.\n\nReturns\n\npyedb.dotnet.database.edb_data.primitives_data.Rectangle or bool\n\nRectangle object if created, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.create_hfss.html#create_hfss",
        "title": "create_hfss",
        "section": "create_hfss",
        "text": "Create an HFSS model from an MCAD file.\nHFSS model created.\ncreate_hfss\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.create_hfss.html#pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.create_hfss",
        "title": "create_hfss > create_hfss > create_hfss",
        "section": "create_hfss > create_hfss",
        "text": "BundleTerminal.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nReturns\n\nMcadModel\n\nHFSS model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the material definition.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.delete.html#pyedb.grpc.database.definition.materials.Material.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "Material.delete()\n\nDelete the material definition.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef.find_by_name",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef.find_by_name.html#find_by_name",
        "title": "find_by_name",
        "section": "find_by_name",
        "text": "Find a padstack definition by name in a given database.\nDatabase to search for the padstack definition.\nName of the padstack definition.\nPadstack definition found.\nfind_by_name\nDatabase\npython:str\nPadstackDef"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef.find_by_name",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef.find_by_name.html#pyedb.grpc.database.definition.padstack_def.PadstackDef.find_by_name",
        "title": "find_by_name > find_by_name > find_by_name",
        "section": "find_by_name > find_by_name",
        "text": "classmethod PadstackDef.find_by_name(db, name)\n\nFind a padstack definition by name in a given database.\n\nParameters\n\ndb\n\nDatabase.\n\nDatabase to search for the padstack definition.\n\nname\n\npython:str\n\nName of the padstack definition.\n\nReturns\n\nPadstackDef\n\nPadstack definition found.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.set_product_property.html#pyedb.grpc.database.ports.ports.GapPort.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "GapPort.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_via_instance_from_net",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_via_instance_from_net.html#get_via_instance_from_net",
        "title": "get_via_instance_from_net",
        "section": "get_via_instance_from_net",
        "text": "Get via instances by net names.\nNet name(s) for filtering. Returns all vias if None.\nList of via instances.\nget_via_instance_from_net\npython:str\npython:list\noptional\nNone\npython:list\npyedb.grpc.database.primitive.padstack_instance.PadstackInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_via_instance_from_net",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_via_instance_from_net.html#pyedb.grpc.database.padstacks.Padstacks.get_via_instance_from_net",
        "title": "get_via_instance_from_net > get_via_instance_from_net > get_via_instance_from_net",
        "section": "get_via_instance_from_net > get_via_instance_from_net",
        "text": "Padstacks.get_via_instance_from_net(net_list: str | List[str] | None = None) -> List[PadstackInstance]\n\nGet via instances by net names.\n\nParameters\n\nnet_list\n\npython:str or python:list, optional\n\nNet name(s) for filtering. Returns all vias if None.\n\nReturns\n\npython:list[pyedb.grpc.database.primitive.padstack_instance.PadstackInstance]\n\nList of via instances.\n\nExamples\n\n>>> vias = edb_padstacks.get_via_instance_from_net(\"GND\")\n>>> vias = edb_padstacks.get_via_instance_from_net([\"GND\", \"PWR\"])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.value",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.value.html#value",
        "title": "value",
        "section": "value",
        "text": "Convert a value into a pyedb value.\nvalue"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.value",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.value.html#pyedb.grpc.edb.Edb.value",
        "title": "value > value > value",
        "section": "value > value",
        "text": "Edb.value(val) -> float\n\nConvert a value into a pyedb value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_edge_port_vertical",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_edge_port_vertical.html#create_edge_port_vertical",
        "title": "create_edge_port_vertical",
        "section": "create_edge_port_vertical",
        "text": "Create a vertical edge port.\nPrimitive ID.\nCoordinate of the point to define the edge terminal.\nThe point must be on the target edge but not on the two\nends of the edge.\nName of the port. The default is None.\nImpedance of the port. The default value is 50.\nReference layer of the port. The default is None.\nType of the port. The default value is \"Gap\". Options are \"Gap\", \"Wave\".\nHorizontal extent factor. The default value is 5.\nVertical extent factor. The default value is 3.\nRadial extent factor. The default value is 0.\nLaunch Width of PEC. The default value is \"0.01mm\".\nPort name.\ncreate_edge_port_vertical\npython:int\npython:list\npython:str\noptional\nNone\npython:int\npython:float\noptional\n50\npython:str\noptional\nNone\npython:str\noptional\n\"Gap\"\n\"Gap\"\n\"Wave\"\npython:int\npython:float\noptional\n5\npython:int\npython:float\noptional\n3\npython:int\npython:float\noptional\n0\npython:str\noptional\n\"0.01mm\"\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_edge_port_vertical",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_edge_port_vertical.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_edge_port_vertical",
        "title": "create_edge_port_vertical > create_edge_port_vertical > create_edge_port_vertical",
        "section": "create_edge_port_vertical > create_edge_port_vertical",
        "text": "SourceExcitation.create_edge_port_vertical(prim_id: int, point_on_edge: List[float], port_name: str | None = None, impedance: int | float = 50, reference_layer: str | None = None, hfss_type: str = 'Gap', horizontal_extent_factor: int | float = 5, vertical_extent_factor: int | float = 3, pec_launch_width: str = '0.01mm') -> str\n\nCreate a vertical edge port.\n\nParameters\n\nprim_id\n\npython:int\n\nPrimitive ID.\n\npoint_on_edge\n\npython:list\n\nCoordinate of the point to define the edge terminal.\nThe point must be on the target edge but not on the two\nends of the edge.\n\nport_name\n\npython:str, optional\n\nName of the port. The default is None.\n\nimpedance\n\npython:int, python:float, optional\n\nImpedance of the port. The default value is 50.\n\nreference_layer\n\npython:str, optional\n\nReference layer of the port. The default is None.\n\nhfss_type\n\npython:str, optional\n\nType of the port. The default value is \"Gap\". Options are \"Gap\", \"Wave\".\n\nhorizontal_extent_factor\n\npython:int, python:float, optional\n\nHorizontal extent factor. The default value is 5.\n\nvertical_extent_factor\n\npython:int, python:float, optional\n\nVertical extent factor. The default value is 3.\n\nradial_extent_factor\n\npython:int, python:float, optional\n\nRadial extent factor. The default value is 0.\n\npec_launch_width\n\npython:str, optional\n\nLaunch Width of PEC. The default value is \"0.01mm\".\n\nReturns\n\npython:str\n\nPort name.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> term = edb.source_excitation.create_edge_port_vertical(0, [0, 0], reference_layer=\"TopLayer\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.tan",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.tan.html#tan",
        "title": "tan",
        "section": "tan",
        "text": "Tangent of the value.\ntan"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.tan",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.tan.html#pyedb.grpc.database.utility.value.Value.tan",
        "title": "tan > tan > tan",
        "section": "tan > tan",
        "text": "Value.tan()\n\nTangent of the value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.set_product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.set_product_solver_option.html#set_product_solver_option",
        "title": "set_product_solver_option",
        "section": "set_product_solver_option",
        "text": "Set the product solver option.\nID of the product.\nName of the solver.\nName of the product solver option.\nset_product_solver_option\nProductIdType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.set_product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.set_product_solver_option.html#pyedb.grpc.database.terminal.point_terminal.PointTerminal.set_product_solver_option",
        "title": "set_product_solver_option > set_product_solver_option > set_product_solver_option",
        "section": "set_product_solver_option > set_product_solver_option",
        "text": "PointTerminal.set_product_solver_option(product_id, solver_name, option)\n\nSet the product solver option.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nsolver_name\n\nobj:str\n\nName of the solver.\n\noption\n\nobj:str\n\nName of the product solver option.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/Variables",
        "href": "dotnet_api/dotnet/edb_data/Variables.html#variables",
        "title": "Variables",
        "section": "Variables",
        "text": "Class managing EDB Variables.\nVariable\nManages EDB methods for variable accessible from Edb.Utility.VariableServer property.\nVariables\nVariable"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.create_hfss.html#create_hfss",
        "title": "create_hfss",
        "section": "create_hfss",
        "text": "Create an HFSS model from an MCAD file.\nAbsolute path of the MCAD file.\nDesign name.\nHFSS model created.\ncreate_hfss\npython:str\npython:str\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.create_hfss.html#pyedb.grpc.database.layout.layout.Layout.create_hfss",
        "title": "create_hfss > create_hfss > create_hfss",
        "section": "create_hfss > create_hfss",
        "text": "Layout.create_hfss(filename: str, design: str) -> McadModel\n\nCreate an HFSS model from an MCAD file.\n\nParameters\n\nfilename\n\npython:str\n\nAbsolute path of the MCAD file.\n\ndesign\n\npython:str\n\nDesign name.\n\nReturns\n\nMcadModel\n\nHFSS model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.add_void",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.add_void.html#add_void",
        "title": "add_void",
        "section": "add_void",
        "text": "Add a void to the primitive.\nVoid to add.\nadd_void\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.add_void",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.add_void.html#pyedb.grpc.database.primitive.polygon.Polygon.add_void",
        "title": "add_void > add_void > add_void",
        "section": "add_void > add_void",
        "text": "Polygon.add_void(polygon)\n\nAdd a void to the primitive.\n\nParameters\n\nhole\n\nPrimitive\n\nVoid to add.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.name.html#name",
        "title": "name",
        "section": "name",
        "text": "name"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.name.html#pyedb.workflows.drc.drc.MinAnnularRing.name",
        "title": "name > name > name",
        "section": "name > name",
        "text": "MinAnnularRing.name: str\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.html#gapport",
        "title": "GapPort",
        "section": "GapPort",
        "text": "Manages gap port properties.\nEDB object from the Edblib library.\nEdge terminal instance from EDB.\nThis example shows how to access the GapPort class.\n>>> from pyedb import Edb\n>>> edb = Edb(“myaedb.aedb”)\n>>> gap_port = edb.ports[“gap_port”]\nGapPort.cast([term_type])\nCast the terminal object to the correct concrete type, fetching the type if necessary.\nGapPort.couple_ports(port)\nCreate a bundle wave port.\nGapPort.create(layout, name, edges[, net, ...])\nCreate an edge terminal.\nGapPort.create_3d_comp()\nCreate a 3D composite model from an MCAD file.\nGapPort.create_hfss()\nCreate an HFSS model from an MCAD file.\nGapPort.create_stride()\nCreate a Stride model from an MCAD file.\nGapPort.delete()\nDelete the layout object.\nGapPort.find(layout, name)\nFind a terminal by name in a given layout.\nGapPort.find_by_id(layout, uid)\nFind a Connectable object by database ID in a given layout.\nGapPort.get_product_property(prod_id, attr_id)\nGet the product property of the layout object for a given product ID and attribute ID.\nGapPort.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nGapPort.product_solver_names(product_id)\nGet the list of solver names.\nGapPort.product_solver_option(product_id, ...)\nGet the name of the product solver option.\nGapPort.set_product_property(prod_id, ...)\nSet the product property of the layout object for a given product ID and attribute ID.\nGapPort.set_product_solver_option(...)\nSet the product solver option.\nGapPort.layout_obj_type\n\nGapPort.type\n\nGapPort\npyedb.edb.Edb\nEdblib\nAnsys.Ansoft.Edb.Cell.Terminal.EdgeTerminal\nGapPort\nGapPort.cast\nGapPort.couple_ports\nGapPort.create\nGapPort.create_3d_comp\nGapPort.create_hfss\nGapPort.create_stride\nGapPort.delete\nGapPort.find\nGapPort.find_by_id\nGapPort.get_product_property\nGapPort.get_product_property_ids\nGapPort.product_solver_names\nGapPort.product_solver_option\nGapPort.set_product_property\nGapPort.set_product_solver_option\nGapPort.layout_obj_type\nGapPort.type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.html#pyedb.grpc.database.ports.ports.GapPort",
        "title": "GapPort > GapPort > GapPort",
        "section": "GapPort > GapPort",
        "text": "class pyedb.grpc.database.ports.ports.GapPort(pedb, edb_object)\n\nManages gap port properties.\n\nParameters\n\npedb\n\npyedb.edb.Edb\n\nEDB object from the Edblib library.\n\nedb_object\n\nAnsys.Ansoft.Edb.Cell.Terminal.EdgeTerminal\n\nEdge terminal instance from EDB.\n\nExamples\n\nThis example shows how to access the GapPort class.\n>>> from pyedb import Edb\n>>> edb = Edb(“myaedb.aedb”)\n>>> gap_port = edb.ports[“gap_port”]\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nGapPort.cast([term_type])\n\nCast the terminal object to the correct concrete type, fetching the type if necessary.\n\nGapPort.couple_ports(port)\n\nCreate a bundle wave port.\n\nGapPort.create(layout, name, edges[, net, ...])\n\nCreate an edge terminal.\n\nGapPort.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nGapPort.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nGapPort.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nGapPort.delete()\n\nDelete the layout object.\n\nGapPort.find(layout, name)\n\nFind a terminal by name in a given layout.\n\nGapPort.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nGapPort.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nGapPort.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nGapPort.product_solver_names(product_id)\n\nGet the list of solver names.\n\nGapPort.product_solver_option(product_id, ...)\n\nGet the name of the product solver option.\n\nGapPort.set_product_property(prod_id, ...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nGapPort.set_product_solver_option(...)\n\nSet the product solver option.\n\n\n\nAttributes\n\n\n\n\n\n\n\nGapPort.layout_obj_type\n\n\n\nGapPort.type\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_pin_group_terminal_reference_pin",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_pin_group_terminal_reference_pin.html#get_pin_group_terminal_reference_pin",
        "title": "get_pin_group_terminal_reference_pin",
        "section": "get_pin_group_terminal_reference_pin",
        "text": "Return a list of pins and serves terminals connected to pingroups.\nPreferred reference net name.\nget_pin_group_terminal_reference_pin\npython:str\noptional\nPadstackInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_pin_group_terminal_reference_pin",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_pin_group_terminal_reference_pin.html#pyedb.grpc.database.terminal.terminal.Terminal.get_pin_group_terminal_reference_pin",
        "title": "get_pin_group_terminal_reference_pin > get_pin_group_terminal_reference_pin > get_pin_group_terminal_reference_pin",
        "section": "get_pin_group_terminal_reference_pin > get_pin_group_terminal_reference_pin",
        "text": "Terminal.get_pin_group_terminal_reference_pin(gnd_net_name_preference=None) -> PadstackInstance\n\nReturn a list of pins and serves terminals connected to pingroups.\n\nParameters\n\ngnd_net_name_preference\n\npython:str, optional\n\nPreferred reference net name.\n\nReturns\n\nPadstackInstance\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/models.md#model-copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nbefore creating the new model. You should trust this data.\ndeep: Set to True to make a deep copy of the model.\nNew model instance.\nmodel_copy"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_copy.html#pyedb.workflows.drc.drc.BackDrillStubLength.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "BackDrillStubLength.model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -> Self\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/models.md#model-copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nArgs:\n\nupdate: Values to change/add in the new model. Note: the data is not validated\n\nbefore creating the new model. You should trust this data.\n\ndeep: Set to True to make a deep copy of the model.\n\nReturns:\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadProperties",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadProperties.html#edbpadproperties",
        "title": "EDBPadProperties",
        "section": "EDBPadProperties",
        "text": "Manages EDB functionalities for pad properties.\nName of the layer.\nType of the pad.\nInherited AEDT object.\nEDBPadProperties.int_to_geometry_type([val])\nConvert an integer to an EDB.PadGeometryType.\nEDBPadProperties.int_to_pad_type([val])\nConvert an integer to an EDB.PadGeometryType.\nEDBPadProperties\npython:str\npython:str\nEDBPadProperties.int_to_geometry_type\nEDBPadProperties.int_to_pad_type"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadProperties",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadProperties.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadProperties",
        "title": "EDBPadProperties > EDBPadProperties > EDBPadProperties",
        "section": "EDBPadProperties > EDBPadProperties",
        "text": "class pyedb.dotnet.database.edb_data.padstacks_data.EDBPadProperties(edb_padstack, layer_name, pad_type, p_edb_padstack)\n\nManages EDB functionalities for pad properties.\n\nParameters\n\nedb_padstack\n\n\n\nlayer_name\n\npython:str\n\nName of the layer.\n\npad_type\n\nType of the pad.\n\npedbpadstack\n\npython:str\n\nInherited AEDT object.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb(myedb, edbversion=\"2021.2\")\n>>> edb_pad_properties = edb.padstacks.definitions[\"MyPad\"].pad_by_layer[\"TOP\"]\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nEDBPadProperties.int_to_geometry_type([val])\n\nConvert an integer to an EDB.PadGeometryType.\n\nEDBPadProperties.int_to_pad_type([val])\n\nConvert an integer to an EDB.PadGeometryType.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.html#terminal",
        "title": "Terminal",
        "section": "Terminal",
        "text": "Terminal.cast([term_type])\nCast the terminal object to the correct concrete type, fetching the type if necessary.\nTerminal.create_3d_comp()\nCreate a 3D composite model from an MCAD file.\nTerminal.create_hfss()\nCreate an HFSS model from an MCAD file.\nTerminal.create_stride()\nCreate a Stride model from an MCAD file.\nTerminal.delete()\nDelete the layout object.\nTerminal.find(layout, name)\nFind a terminal by name in a given layout.\nTerminal.find_by_id(layout, uid)\nFind a Connectable object by database ID in a given layout.\nTerminal.get_edge_terminal_reference_primitive()\nCheck and return a primitive instance that serves Edge ports, wave-ports and coupled-edge ports that are directly connected to primitives.\nTerminal.get_pad_edge_terminal_reference_pin([...])\nGet the closest pin padstack instances and serves any edge terminal connected to a pad.\nTerminal.get_padstack_terminal_reference_pin([...])\nGet a list of pad stacks instances and serves Coax wave ports, pingroup terminals, PadEdge terminals.\nTerminal.get_pin_group_terminal_reference_pin([...])\nReturn a list of pins and serves terminals connected to pingroups.\nTerminal.get_point_terminal_reference_primitive()\nFind and return the primitive reference for the point terminal or the padstack instance.\nTerminal.get_product_property(prod_id, attr_id)\nGet the product property of the layout object for a given product ID and attribute ID.\nTerminal.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nTerminal.product_solver_names(product_id)\nGet the list of solver names.\nTerminal.product_solver_option(product_id, ...)\nGet the name of the product solver option.\nTerminal.set_product_property(prod_id, ...)\nSet the product property of the layout object for a given product ID and attribute ID.\nTerminal.set_product_solver_option(...)\nSet the product solver option.\nTerminal.layout_obj_type\n\nTerminal.type\n\nTerminal\nTerminal.cast\nTerminal.create_3d_comp\nTerminal.create_hfss\nTerminal.create_stride\nTerminal.delete\nTerminal.find\nTerminal.find_by_id\nTerminal.get_edge_terminal_reference_primitive\nTerminal.get_pad_edge_terminal_reference_pin\nTerminal.get_padstack_terminal_reference_pin\nTerminal.get_pin_group_terminal_reference_pin\nTerminal.get_point_terminal_reference_primitive\nTerminal.get_product_property\nTerminal.get_product_property_ids\nTerminal.product_solver_names\nTerminal.product_solver_option\nTerminal.set_product_property\nTerminal.set_product_solver_option\nTerminal.layout_obj_type\nTerminal.type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.html#pyedb.grpc.database.terminal.terminal.Terminal",
        "title": "Terminal > Terminal > Terminal",
        "section": "Terminal > Terminal",
        "text": "class pyedb.grpc.database.terminal.terminal.Terminal(pedb, edb_object)\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nTerminal.cast([term_type])\n\nCast the terminal object to the correct concrete type, fetching the type if necessary.\n\nTerminal.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nTerminal.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nTerminal.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nTerminal.delete()\n\nDelete the layout object.\n\nTerminal.find(layout, name)\n\nFind a terminal by name in a given layout.\n\nTerminal.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nTerminal.get_edge_terminal_reference_primitive()\n\nCheck and return a primitive instance that serves Edge ports, wave-ports and coupled-edge ports that are directly connected to primitives.\n\nTerminal.get_pad_edge_terminal_reference_pin([...])\n\nGet the closest pin padstack instances and serves any edge terminal connected to a pad.\n\nTerminal.get_padstack_terminal_reference_pin([...])\n\nGet a list of pad stacks instances and serves Coax wave ports, pingroup terminals, PadEdge terminals.\n\nTerminal.get_pin_group_terminal_reference_pin([...])\n\nReturn a list of pins and serves terminals connected to pingroups.\n\nTerminal.get_point_terminal_reference_primitive()\n\nFind and return the primitive reference for the point terminal or the padstack instance.\n\nTerminal.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nTerminal.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nTerminal.product_solver_names(product_id)\n\nGet the list of solver names.\n\nTerminal.product_solver_option(product_id, ...)\n\nGet the name of the product solver option.\n\nTerminal.set_product_property(prod_id, ...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nTerminal.set_product_solver_option(...)\n\nSet the product solver option.\n\n\n\nAttributes\n\n\n\n\n\n\n\nTerminal.layout_obj_type\n\n\n\nTerminal.type\n\n\n\n"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues: Trusted or pre-validated data dictionary.\nA new instance of the Model class with validated data.\nmodel_construct"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_construct.html#pyedb.workflows.drc.drc.Rules.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod Rules.model_construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nArgs:\n\n_fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues: Trusted or pre-validated data dictionary.\n\nReturns:\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.defeature",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.defeature.html#defeature",
        "title": "defeature",
        "section": "defeature",
        "text": "Defeature a polygon.\nTolerance.\ndefeature\npython:float\nPolygonData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.defeature",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.defeature.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.defeature",
        "title": "defeature > defeature > defeature",
        "section": "defeature > defeature",
        "text": "PolygonData.defeature(tol: float = 1e-09) -> PolygonData\n\nDefeature a polygon.\n\nParameters\n\ntol\n\npython:float, default: 1e-9\n\nTolerance.\n\nReturns\n\nPolygonData\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.delete",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete current simulation setup.\ndelete"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.delete",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.delete.html#pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "HfssSimulationSetup.delete()\n\nDelete current simulation setup.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.from_orm",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "from_orm"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.from_orm",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.from_orm.html#pyedb.grpc.database.definition.materials.MaterialProperties.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod MaterialProperties.from_orm(obj: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/models.md#model-copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nbefore creating the new model. You should trust this data.\ndeep: Set to True to make a deep copy of the model.\nNew model instance.\nmodel_copy"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_copy.html#pyedb.workflows.drc.drc.MinLineWidth.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "MinLineWidth.model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -> Self\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/models.md#model-copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nArgs:\n\nupdate: Values to change/add in the new model. Note: the data is not validated\n\nbefore creating the new model. You should trust this data.\n\ndeep: Set to True to make a deep copy of the model.\n\nReturns:\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/index",
        "href": "grpc_api/index.html#api-reference",
        "title": "API reference",
        "section": "API reference",
        "text": "This section describes EDB functions, classes, and methods\nfor EDB gRPC applications and modules. Use the search feature or click links\nto view API documentation.\nThe PyEDB API includes classes for apps and modules. You must initialize the\nEdb class to get access to all modules and methods. All other classes and\nmethods are inherited into the Edb class.\nIf EDB is launched within the HfssdLayout class, EDB is accessible in read-only mode.\nPyEDB is now supporting gRPC\nStarting ANSYS release 2025.2 PyEDB is compatible with gRPC.\nThe two main advantages are:\n- Better compatibility with Linux\n- PyEDB becomes ready to remote - client services\nIf you want to know more about gRPC.\nPyEDB gRPC is providing backward compatibility with previous versions.\nThe default grpc flag value is False so by default uses PyEDB DotNet.\nPyEDB gRPC becomes the long term supported version and new features are only implemented\ninto this one. Therefore users are highly encouraged migrating to gRPC when possible to get the\nbest user experience.\nIf you want to access the legacy DotNet API please refer to the archive section.\nTo enable PyEDB gRPC you have two options.\n- Explicit import\n- Using grpc flag\nAPI reference\nEdb\nEdb\nHfssdLayout"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.name.html#name",
        "title": "name",
        "section": "name",
        "text": "name"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.name.html#pyedb.workflows.drc.drc.MinClearance.name",
        "title": "name > name > name",
        "section": "name > name",
        "text": "MinClearance.name: str\n\n"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.delete",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete a database at the specified file location.\nPath to top-level database folder.\ndelete\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.delete",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.delete.html#pyedb.grpc.edb.Edb.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "Edb.delete(db_path)\n\nDelete a database at the specified file location.\n\nParameters\n\ndb_path\n\npython:str\n\nPath to top-level database folder.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_hfss_prop",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_hfss_prop.html#get_hfss_prop",
        "title": "get_hfss_prop",
        "section": "get_hfss_prop",
        "text": "Get HFSS properties.\nMaterial property name.\nIf solve inside.\nget_hfss_prop\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_hfss_prop",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_hfss_prop.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_hfss_prop",
        "title": "get_hfss_prop > get_hfss_prop > get_hfss_prop",
        "section": "get_hfss_prop > get_hfss_prop",
        "text": "EdbPolygon.get_hfss_prop()\n\nGet HFSS properties.\n\nReturns\n\nmaterial\n\npython:str\n\nMaterial property name.\n\nsolve_inside\n\nbool\n\nIf solve inside.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.parse_raw",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "parse_raw"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.parse_raw",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.parse_raw.html#pyedb.workflows.drc.drc.CopperBalance.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod CopperBalance.parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.points",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.points.html#points",
        "title": "points",
        "section": "points",
        "text": "Return the list of points with arcs converted to segments.\nNumber of facets to convert an arc. Default is 6.\nThe tuple contains 2 lists made of X and Y points coordinates.\npoints\npython:int\npython:tuple"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.points",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.points.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.points",
        "title": "points > points > points",
        "section": "points > points",
        "text": "EdbPolygon.points(arc_segments=6)\n\nReturn the list of points with arcs converted to segments.\n\nParameters\n\narc_segments\n\npython:int\n\nNumber of facets to convert an arc. Default is 6.\n\nReturns\n\npython:tuple\n\nThe tuple contains 2 lists made of X and Y points coordinates.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the primitive object to the correct concrete type.\ncast\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.cast.html#pyedb.grpc.database.primitive.circle.Circle.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "Circle.cast() -> Primitive | None\n\nCast the primitive object to the correct concrete type.\n\nReturns\n\nPrimitive\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.residual_copper_area_per_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.residual_copper_area_per_layer.html#residual_copper_area_per_layer",
        "title": "residual_copper_area_per_layer",
        "section": "residual_copper_area_per_layer",
        "text": "Report residual copper area per layer in percentage.\nDictionary of copper area per layer.\nresidual_copper_area_per_layer\npython:dict"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.residual_copper_area_per_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.residual_copper_area_per_layer.html#pyedb.grpc.database.stackup.Stackup.residual_copper_area_per_layer",
        "title": "residual_copper_area_per_layer > residual_copper_area_per_layer > residual_copper_area_per_layer",
        "section": "residual_copper_area_per_layer > residual_copper_area_per_layer",
        "text": "Stackup.residual_copper_area_per_layer() -> Dict[str, float]\n\nReport residual copper area per layer in percentage.\n\nReturns\n\npython:dict\n\nDictionary of copper area per layer.\n\nExamples\n\n>>> edb = Edb(edbpath=targetfile1, edbversion=\"2021.2\")\n>>> edb.stackup.residual_copper_area_per_layer()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.load_configuration",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.load_configuration.html#load_configuration",
        "title": "load_configuration",
        "section": "load_configuration",
        "text": "Load configuration settings from a configure file.Import\nPath to the configuration file.\nload_configuration\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.load_configuration",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.load_configuration.html#pyedb.siwave.Siwave.load_configuration",
        "title": "load_configuration > load_configuration > load_configuration",
        "section": "load_configuration > load_configuration",
        "text": "Siwave.load_configuration(file_path: str)\n\nLoad configuration settings from a configure file.Import\n\nParameters\n\nfile_path\n\npython:str\n\nPath to the configuration file.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.set_product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.set_product_solver_option.html#set_product_solver_option",
        "title": "set_product_solver_option",
        "section": "set_product_solver_option",
        "text": "Set the product solver option.\nID of the product.\nName of the solver.\nName of the product solver option.\nset_product_solver_option\nProductIdType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.set_product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.set_product_solver_option.html#pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.set_product_solver_option",
        "title": "set_product_solver_option > set_product_solver_option > set_product_solver_option",
        "section": "set_product_solver_option > set_product_solver_option",
        "text": "BundleTerminal.set_product_solver_option(product_id, solver_name, option)\n\nSet the product solver option.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nsolver_name\n\nobj:str\n\nName of the solver.\n\noption\n\nobj:str\n\nName of the product solver option.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.clone",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.clone.html#clone",
        "title": "clone",
        "section": "clone",
        "text": "Create a clone of the layer.\nID of the layer to clone.\nLayer cloned.\nclone\nLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.clone",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.clone.html#pyedb.grpc.database.layers.stackup_layer.StackupLayer.clone",
        "title": "clone > clone > clone",
        "section": "clone > clone",
        "text": "StackupLayer.clone(copy_id=True)\n\nCreate a clone of the layer.\n\nParameters\n\ncopy_id\n\nbool\n\nID of the layer to clone.\n\nReturns\n\nLayer\n\nLayer cloned.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.clone",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.clone.html#clone",
        "title": "clone",
        "section": "clone",
        "text": "Clone a model.\nclone\nModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.clone",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.clone.html#pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.clone",
        "title": "clone > clone > clone",
        "section": "clone > clone",
        "text": "PinPairModel.clone()\n\nClone a model.\n\nReturns\n\nModel cloned.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/adaptive_frequency",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/adaptive_frequency.html#adaptive-frequency",
        "title": "Adaptive frequency",
        "section": "Adaptive frequency",
        "text": "This class is managing EDB adaptive frequency.\nAdaptiveFrequency\nEDB-core Adaptive Frequency class.\nAdaptive frequency\nAdaptiveFrequency"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_current_source_on_pin_group",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_current_source_on_pin_group.html#create_current_source_on_pin_group",
        "title": "create_current_source_on_pin_group",
        "section": "create_current_source_on_pin_group",
        "text": "Create current source between two pin groups.\nName of the positive pin group.\nName of the negative pin group.\nMagnitude of the source.\nPhase of the source\ncreate_current_source_on_pin_group\npython:str\npython:str\npython:int\npython:float\noptional\npython:int\npython:float\noptional"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_current_source_on_pin_group",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_current_source_on_pin_group.html#pyedb.dotnet.database.siwave.EdbSiwave.create_current_source_on_pin_group",
        "title": "create_current_source_on_pin_group > create_current_source_on_pin_group > create_current_source_on_pin_group",
        "section": "create_current_source_on_pin_group > create_current_source_on_pin_group",
        "text": "EdbSiwave.create_current_source_on_pin_group(pos_pin_group_name, neg_pin_group_name, magnitude=1, phase=0, name=None)\n\nCreate current source between two pin groups.\n\nParameters\n\npos_pin_group_name\n\npython:str\n\nName of the positive pin group.\n\nneg_pin_group_name\n\npython:str\n\nName of the negative pin group.\n\nmagnitude\n\npython:int, python:float, optional\n\nMagnitude of the source.\n\nphase\n\npython:int, python:float, optional\n\nPhase of the source\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_voltage_source_on_pin",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_voltage_source_on_pin.html#create_voltage_source_on_pin",
        "title": "create_voltage_source_on_pin",
        "section": "create_voltage_source_on_pin",
        "text": "Create a voltage source.\nPositive Pin.\nNegative Pin.\nValue for the voltage. The default is 3.3.\nValue for the phase. The default is 0.\nName of the source. The default is \"\".\nSource Name.\ncreate_voltage_source_on_pin\nObject\nObject\npython:float\noptional\n3.3\noptional\n0\npython:str\noptional\n\"\"\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_voltage_source_on_pin",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_voltage_source_on_pin.html#pyedb.dotnet.database.hfss.EdbHfss.create_voltage_source_on_pin",
        "title": "create_voltage_source_on_pin > create_voltage_source_on_pin > create_voltage_source_on_pin",
        "section": "create_voltage_source_on_pin > create_voltage_source_on_pin",
        "text": "EdbHfss.create_voltage_source_on_pin(pos_pin, neg_pin, voltage_value=3.3, phase_value=0, source_name='')\n\nCreate a voltage source.\n\nParameters\n\npos_pin\n\nObject\n\nPositive Pin.\n\nneg_pin\n\nObject\n\nNegative Pin.\n\nvoltage_value\n\npython:float, optional\n\nValue for the voltage. The default is 3.3.\n\nphase_value\n\noptional\n\nValue for the phase. The default is 0.\n\nsource_name\n\npython:str, optional\n\nName of the source. The default is \"\".\n\nReturns\n\npython:str\n\nSource Name.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", \"project name\", \"release version\")\n>>> pins = edbapp.components.get_pin_from_component(\"U2A5\")\n>>> edbapp.hfss.create_voltage_source_on_pin(pins[0], pins[1], 50, \"source_name\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_through_resistor_list",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_through_resistor_list.html#get_through_resistor_list",
        "title": "get_through_resistor_list",
        "section": "get_through_resistor_list",
        "text": "Get through resistors below threshold.\nResistance threshold.\nList of component names.\nget_through_resistor_list\npython:float\noptional\npython:list\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_through_resistor_list",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_through_resistor_list.html#pyedb.grpc.database.components.Components.get_through_resistor_list",
        "title": "get_through_resistor_list > get_through_resistor_list > get_through_resistor_list",
        "section": "get_through_resistor_list > get_through_resistor_list",
        "text": "Components.get_through_resistor_list(threshold: float = 1) -> List[str]\n\nGet through resistors below threshold.\n\nParameters\n\nthreshold\n\npython:float, optional\n\nResistance threshold.\n\nReturns\n\npython:list[python:str]\n\nList of component names.\n\nExamples\n\n>>> resistors = edbapp.components.get_through_resistor_list(1)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_start_elevation",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_start_elevation.html#set_start_elevation",
        "title": "set_start_elevation",
        "section": "set_start_elevation",
        "text": "Set the start elevation of the bondwire.\nStart cell context of the bondwire. None means top-level.\nStart layer of the bondwire.\nset_start_elevation\nCellInstance\nNone"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_start_elevation",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_start_elevation.html#pyedb.grpc.database.primitive.bondwire.Bondwire.set_start_elevation",
        "title": "set_start_elevation > set_start_elevation > set_start_elevation",
        "section": "set_start_elevation > set_start_elevation",
        "text": "Bondwire.set_start_elevation(start_context: CellInstance, layer: LayerLike)\n\nSet the start elevation of the bondwire.\n\nParameters\n\nstart_context\n\nCellInstance\n\nStart cell context of the bondwire. None means top-level.\n\nlayer\n\nLayerLike\n\nStart layer of the bondwire.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCAdvancedSettings.restore_default",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCAdvancedSettings.restore_default.html#restore_default",
        "title": "restore_default",
        "section": "restore_default",
        "text": "restore_default"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCAdvancedSettings.restore_default",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCAdvancedSettings.restore_default.html#pyedb.dotnet.database.sim_setup_data.io.siwave.DCAdvancedSettings.restore_default",
        "title": "restore_default > restore_default > restore_default",
        "section": "restore_default > restore_default",
        "text": "DCAdvancedSettings.restore_default()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.load_amat",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.load_amat.html#load_amat",
        "title": "load_amat",
        "section": "load_amat",
        "text": "Load materials from an AMAT file.\nFull path to the AMAT file to read and add to the Edb.\nload_amat\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.load_amat",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.load_amat.html#pyedb.dotnet.database.materials.Materials.load_amat",
        "title": "load_amat > load_amat > load_amat",
        "section": "load_amat > load_amat",
        "text": "Materials.load_amat(amat_file)\n\nLoad materials from an AMAT file.\n\nParameters\n\namat_file\n\npython:str\n\nFull path to the AMAT file to read and add to the Edb.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileImportOptions",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileImportOptions.html#controlfileimportoptions",
        "title": "ControlFileImportOptions",
        "section": "ControlFileImportOptions",
        "text": "Import Options.\nControlFileImportOptions"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileImportOptions",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileImportOptions.html#pyedb.dotnet.database.edb_data.control_file.ControlFileImportOptions",
        "title": "ControlFileImportOptions > ControlFileImportOptions > ControlFileImportOptions",
        "section": "ControlFileImportOptions > ControlFileImportOptions",
        "text": "class pyedb.dotnet.database.edb_data.control_file.ControlFileImportOptions\n\nImport Options.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.s_parameter_model.SparamModel",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.s_parameter_model.SparamModel.html#sparammodel",
        "title": "SparamModel",
        "section": "SparamModel",
        "text": "Manage SParameterModel\nSparamModel.clone()\nClone a model.\nSparamModel.create(name, ref_net)\nCreate an S-parameter model.\nSparamModel\nSParameterModel\nSparamModel.clone\nSparamModel.create"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.s_parameter_model.SparamModel",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.s_parameter_model.SparamModel.html#pyedb.grpc.database.hierarchy.s_parameter_model.SparamModel",
        "title": "SparamModel > SparamModel > SparamModel",
        "section": "SparamModel > SparamModel",
        "text": "class pyedb.grpc.database.hierarchy.s_parameter_model.SparamModel(edb_object)\n\nManage SParameterModel\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nSparamModel.clone()\n\nClone a model.\n\nSparamModel.create(name, ref_net)\n\nCreate an S-parameter model.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_layer_bottom",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_layer_bottom.html#add_layer_bottom",
        "title": "add_layer_bottom",
        "section": "add_layer_bottom",
        "text": "Add a layer at the bottom of the stackup.\nName of the layer.\nType of the layer. The default is \"signal\". Options are \"signal\" and \"dielectric\".\nAdditional keyword arguments. Possible keys are:\n- thickness : float, layer thickness.\n- material : str, layer material.\n- fill_material : str, fill material.\nLayer object created.\nadd_layer_bottom\npython:str\npython:str\noptional\n\"signal\"\n\"signal\"\n\"dielectric\"\npython:dict\noptional\nthickness\nmaterial\nfill_material\npyedb.grpc.database.layers.stackup_layer.StackupLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_layer_bottom",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_layer_bottom.html#pyedb.grpc.database.stackup.LayerCollection.add_layer_bottom",
        "title": "add_layer_bottom > add_layer_bottom > add_layer_bottom",
        "section": "add_layer_bottom > add_layer_bottom",
        "text": "LayerCollection.add_layer_bottom(name: str, layer_type: str = 'signal', **kwargs) -> Layer | None\n\nAdd a layer at the bottom of the stackup.\n\nParameters\n\nname\n\npython:str\n\nName of the layer.\n\nlayer_type\n\npython:str, optional\n\nType of the layer. The default is \"signal\". Options are \"signal\" and \"dielectric\".\n\n**kwargs\n\npython:dict, optional\n\nAdditional keyword arguments. Possible keys are:\n- thickness : float, layer thickness.\n- material : str, layer material.\n- fill_material : str, fill material.\n\nReturns\n\npyedb.grpc.database.layers.stackup_layer.StackupLayer\n\nLayer object created.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> bot_layer = edb.stackup.add_layer_bottom(\n...     \"NewBottomLayer\", layer_type=\"signal\", thickness=\"0.1mm\", material=\"copper\"\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_json_schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias: Whether to use attribute aliases or not.\nref_template: The reference template.\nunion_format: The format to use when combining schemas from unions together. Can be one of:\n‘any_of’: Use the [anyOf](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\nkeyword to combine schemas (the default).\n- ‘primitive_type_array’: Use the [type](https://json-schema.org/understanding-json-schema/reference/type)\nkeyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\ntype (string, boolean, null, integer or number) or contains constraints/metadata, falls back to\nany_of.\nGenerateJsonSchema with your desired modifications\nmode: The mode in which to generate the schema.\nThe JSON schema for the given model class.\nmodel_json_schema"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_json_schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_json_schema.html#pyedb.workflows.drc.drc.MinLineWidth.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod MinLineWidth.model_json_schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}', schema_generator: type[~pydantic.json_schema.GenerateJsonSchema] = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: ~typing.Literal['validation', 'serialization'] = 'validation', *, union_format: ~typing.Literal['any_of', 'primitive_type_array'] = 'any_of') -> dict[str, Any]\n\nGenerates a JSON schema for a model class.\n\nArgs:\n\nby_alias: Whether to use attribute aliases or not.\nref_template: The reference template.\nunion_format: The format to use when combining schemas from unions together. Can be one of:\n\n‘any_of’: Use the [anyOf](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n\nkeyword to combine schemas (the default).\n- ‘primitive_type_array’: Use the [type](https://json-schema.org/understanding-json-schema/reference/type)\nkeyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\ntype (string, boolean, null, integer or number) or contains constraints/metadata, falls back to\nany_of.\n\nschema_generator: To override the logic used to generate the JSON schema, as a subclass of\n\nGenerateJsonSchema with your desired modifications\n\nmode: The mode in which to generate the schema.\n\nReturns:\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.illegal_net_names",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.illegal_net_names.html#illegal_net_names",
        "title": "illegal_net_names",
        "section": "illegal_net_names",
        "text": "Find and fix illegal net names.\nillegal_net_names"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.illegal_net_names",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.illegal_net_names.html#pyedb.dotnet.database.layout_validation.LayoutValidation.illegal_net_names",
        "title": "illegal_net_names > illegal_net_names > illegal_net_names",
        "section": "illegal_net_names > illegal_net_names",
        "text": "LayoutValidation.illegal_net_names(fix=False)\n\nFind and fix illegal net names.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.schema_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "schema_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.schema_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.schema_json.html#pyedb.workflows.drc.drc.Rules.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod Rules.schema_json(*, by_alias: bool = True, ref_template: str = '#/$defs/{model}', **dumps_kwargs: Any) -> str\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_vertical_circuit_port_on_clipped_traces",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_vertical_circuit_port_on_clipped_traces.html#create_vertical_circuit_port_on_clipped_traces",
        "title": "create_vertical_circuit_port_on_clipped_traces",
        "section": "create_vertical_circuit_port_on_clipped_traces",
        "text": "Create an edge port on clipped signal traces.\nString of one net or EDB net or a list of multiple nets or EDB nets.\nName or EDB reference net.\nUse this point list or PolygonData object to check if ports are at this polygon border.\nNested list of str, with net name as first value, X value for point at border, Y value for point at border,\nand terminal name.\ncreate_vertical_circuit_port_on_clipped_traces\npython:list\noptional\npython:str\nEdb\nx\ny\nEDB\nPolygonData\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_vertical_circuit_port_on_clipped_traces",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_vertical_circuit_port_on_clipped_traces.html#pyedb.dotnet.database.hfss.EdbHfss.create_vertical_circuit_port_on_clipped_traces",
        "title": "create_vertical_circuit_port_on_clipped_traces > create_vertical_circuit_port_on_clipped_traces > create_vertical_circuit_port_on_clipped_traces",
        "section": "create_vertical_circuit_port_on_clipped_traces > create_vertical_circuit_port_on_clipped_traces",
        "text": "EdbHfss.create_vertical_circuit_port_on_clipped_traces(nets=None, reference_net=None, user_defined_extent=None)\n\nCreate an edge port on clipped signal traces.\n\nParameters\n\nnets\n\npython:list, optional\n\nString of one net or EDB net or a list of multiple nets or EDB nets.\n\nreference_net\n\npython:str, Edb net.\n\nName or EDB reference net.\n\nuser_defined_extent\n\n[x, y], EDB PolygonData\n\nUse this point list or PolygonData object to check if ports are at this polygon border.\n\nReturns\n\n[[python:str]]\n\nNested list of str, with net name as first value, X value for point at border, Y value for point at border,\nand terminal name.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete this primitive.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.delete.html#pyedb.grpc.database.ports.ports.ExcitationSources.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "ExcitationSources.delete()\n\nDelete this primitive.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create_stride.html#create_stride",
        "title": "create_stride",
        "section": "create_stride",
        "text": "Create a Stride model from an MCAD file.\nStride model created.\ncreate_stride\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create_stride.html#pyedb.grpc.database.hierarchy.component.Component.create_stride",
        "title": "create_stride > create_stride > create_stride",
        "section": "create_stride > create_stride",
        "text": "Component.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nReturns\n\nMcadModel\n\nStride model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_validate_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data: The JSON data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nThe validated Pydantic model.\nValidationError: If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_validate_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_validate_json.html#pyedb.workflows.drc.drc.MinAnnularRing.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod MinAnnularRing.model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n\njson_data: The JSON data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nReturns:\n\nThe validated Pydantic model.\n\nRaises:\n\nValidationError: If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.expand",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.expand.html#expand",
        "title": "expand",
        "section": "expand",
        "text": "Expand the polygon shape by an absolute value in all direction.\nOffset can be negative for negative expansion.\nOffset value in meters.\nTolerance in meters.\nWhether to round corners or not.\nIf True, use rounded corners in the expansion otherwise use straight edges (can be degenerate).\nThe maximum corner extension (when round corners are not used) at which point the corner is clipped.\nexpand\npython:float\noptional\npython:float\noptional\noptional\npython:float\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.expand",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.expand.html#pyedb.grpc.database.primitive.primitive.Primitive.expand",
        "title": "expand > expand > expand",
        "section": "expand > expand",
        "text": "Primitive.expand(offset=0.001, tolerance=1e-12, round_corners=True, maximum_corner_extension=0.001) -> list[any]\n\nExpand the polygon shape by an absolute value in all direction.\nOffset can be negative for negative expansion.\n\nParameters\n\noffset\n\npython:float, optional\n\nOffset value in meters.\n\ntolerance\n\npython:float, optional\n\nTolerance in meters.\n\nround_corners\n\nbool, optional\n\nWhether to round corners or not.\nIf True, use rounded corners in the expansion otherwise use straight edges (can be degenerate).\n\nmaximum_corner_extension\n\npython:float, optional\n\nThe maximum corner extension (when round corners are not used) at which point the corner is clipped.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.SpiralInductor",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.SpiralInductor.html#spiralinductor",
        "title": "SpiralInductor",
        "section": "SpiralInductor",
        "text": "Square spiral inductor with an optional under-pass bridge.\nNumber of half-turns (4.5 = 4 full turns + 1 half turn).\nWidth of the spiral trace.\nGap between successive turns.\nSide length of the innermost square.\nLayer on which the spiral is drawn.\nLayer used for the under-pass.\nVia layer connecting spiral end to the under-pass.\nNet name.\nAbsolute centre coordinates of the structure.\nSide length of the square via pad.\nWidth of the under-pass trace.\nDielectric clearance under the bridge.\nLength of the under-pass beyond the via.\nLayer on which the ground plane is drawn.\nSpiralInductor.create()\n\nSpiralInductor\npython:float\ndefault\npython:float\ndefault\npython:float\ndefault\npython:float\ndefault\npython:str\ndefault\npython:str\ndefault\npython:str\ndefault\npython:str\ndefault\npython:tuple\npython:float\npython:float\ndefault\npython:float\ndefault\npython:float\ndefault\npython:float\ndefault\npython:float\ndefault\npython:str\ndefault\nSpiralInductor.create"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.SpiralInductor",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.SpiralInductor.html#pyedb.libraries.rf_libraries.base_functions.SpiralInductor",
        "title": "SpiralInductor > SpiralInductor > SpiralInductor",
        "section": "SpiralInductor > SpiralInductor",
        "text": "class pyedb.libraries.rf_libraries.base_functions.SpiralInductor(edb_cell: Edb | None = None, turns: int | float = 4.5, trace_width: str | float = 2e-05, spacing: str | float = 1.2e-05, inner_diameter: str | float = 6e-05, layer: str = 'M1', bridge_layer: str = 'M2', via_layer: str = 'M3', net: str = 'IN', inductor_center: Tuple[str | float, str | float] = (0, 0), via_size: str | float = 2.5e-05, bridge_width: str | float = 1.2e-05, bridge_clearance: str | float = 6e-06, bridge_length: str | float = 0.0002, ground_layer: str = 'GND')\n\nSquare spiral inductor with an optional under-pass bridge.\n\nParameters\n\nturns\n\npython:float, default 4.5\n\nNumber of half-turns (4.5 = 4 full turns + 1 half turn).\n\ntrace_width\n\npython:float, default 20 µm\n\nWidth of the spiral trace.\n\nspacing\n\npython:float, default 12 µm\n\nGap between successive turns.\n\ninner_diameter\n\npython:float, default 60 µm\n\nSide length of the innermost square.\n\nlayer\n\npython:str, default “M1”\n\nLayer on which the spiral is drawn.\n\nbridge_layer\n\npython:str, default “M2”\n\nLayer used for the under-pass.\n\nvia_layer\n\npython:str, default “M3”\n\nVia layer connecting spiral end to the under-pass.\n\nnet\n\npython:str, default “IN”\n\nNet name.\n\ninductor_center\n\npython:tuple[python:float, python:float], default (0, 0)\n\nAbsolute centre coordinates of the structure.\n\nvia_size\n\npython:float, default 25 µm\n\nSide length of the square via pad.\n\nbridge_width\n\npython:float, default 12 µm\n\nWidth of the under-pass trace.\n\nbridge_clearance\n\npython:float, default 6 µm\n\nDielectric clearance under the bridge.\n\nbridge_length\n\npython:float, default 200 µm\n\nLength of the under-pass beyond the via.\n\nground_layer\n\npython:str, default “GND”\n\nLayer on which the ground plane is drawn.\n\nExamples\n\n>>> sp = SpiralInductor(turns=3.5, trace_width=25e-6, inner_diameter=80e-6)\n>>> edb = Edb(\"spiral.aedb\")\n>>> sp._pedb = edb\n>>> sp.create()\n>>> f\"{sp.inductance_nh:.1f} nH\"\n'3.4 nH'\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nSpiralInductor.create()\n\n\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCAdvancedSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCAdvancedSettings.html#dcadvancedsettings",
        "title": "DCAdvancedSettings",
        "section": "DCAdvancedSettings",
        "text": "DCAdvancedSettings.get_configurations()\nGet all attributes.\nDCAdvancedSettings.restore_default()\n\nDCAdvancedSettings.set_dc_slider(value)\n\nDCAdvancedSettings\nDCAdvancedSettings.get_configurations\nDCAdvancedSettings.restore_default\nDCAdvancedSettings.set_dc_slider"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCAdvancedSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCAdvancedSettings.html#pyedb.dotnet.database.sim_setup_data.io.siwave.DCAdvancedSettings",
        "title": "DCAdvancedSettings > DCAdvancedSettings > DCAdvancedSettings",
        "section": "DCAdvancedSettings > DCAdvancedSettings",
        "text": "class pyedb.dotnet.database.sim_setup_data.io.siwave.DCAdvancedSettings(parent)\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nDCAdvancedSettings.get_configurations()\n\nGet all attributes.\n\nDCAdvancedSettings.restore_default()\n\n\n\nDCAdvancedSettings.set_dc_slider(value)\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_connected_objects",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_connected_objects.html#get_connected_objects",
        "title": "get_connected_objects",
        "section": "get_connected_objects",
        "text": "Get connected objects.\nget_connected_objects\nList\nLayoutObjInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_connected_objects",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_connected_objects.html#pyedb.grpc.database.primitive.polygon.Polygon.get_connected_objects",
        "title": "get_connected_objects > get_connected_objects > get_connected_objects",
        "section": "get_connected_objects > get_connected_objects",
        "text": "Polygon.get_connected_objects()\n\nGet connected objects.\n\nReturns\n\nList[LayoutObjInstance]\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.html#sweepdata",
        "title": "SweepData",
        "section": "SweepData",
        "text": "Manages EDB methods for a frequency sweep.\nName of the frequency sweep.\nEDB object. The default is None.\nSweepData.add(sweep_type, start, stop, increment)\n\nSweepData.add_frequencies(frequencies)\n\nSweepData.clear()\n\nSweepData.set_frequencies([frequency_list, ...])\nSet frequency list to the sweep frequencies.\nSweepData.set_frequencies_linear_count([...])\nSet a linear count frequency sweep.\nSweepData.set_frequencies_linear_scale([...])\nSet a linear scale frequency sweep.\nSweepData.set_frequencies_log_scale([start, ...])\nSet a log-count frequency sweep.\nSweepData\npyedb.dotnet.database.edb_data.siwave_simulation_setup_data.SiwaveSYZSimulationSetup\npython:str\noptional\nAnsys.Ansoft.Edb.Utility.SIWDCIRSimulationSettings\noptional\nNone\nSweepData.add\nSweepData.add_frequencies\nSweepData.clear\nSweepData.set_frequencies\nSweepData.set_frequencies_linear_count\nSweepData.set_frequencies_linear_scale\nSweepData.set_frequencies_log_scale"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.html#pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData",
        "title": "SweepData > SweepData > SweepData",
        "section": "SweepData > SweepData",
        "text": "class pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData(pedb, edb_object=None, name: str | None = None, sim_setup=None)\n\nManages EDB methods for a frequency sweep.\n\nParameters\n\nsim_setup\n\npyedb.dotnet.database.edb_data.siwave_simulation_setup_data.SiwaveSYZSimulationSetup\n\n\n\nname\n\npython:str, optional\n\nName of the frequency sweep.\n\nedb_object\n\nAnsys.Ansoft.Edb.Utility.SIWDCIRSimulationSettings, optional\n\nEDB object. The default is None.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nSweepData.add(sweep_type, start, stop, increment)\n\n\n\nSweepData.add_frequencies(frequencies)\n\n\n\nSweepData.clear()\n\n\n\nSweepData.set_frequencies([frequency_list, ...])\n\nSet frequency list to the sweep frequencies.\n\nSweepData.set_frequencies_linear_count([...])\n\nSet a linear count frequency sweep.\n\nSweepData.set_frequencies_linear_scale([...])\n\nSet a linear scale frequency sweep.\n\nSweepData.set_frequencies_log_scale([start, ...])\n\nSet a log-count frequency sweep.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.points",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.points.html#points",
        "title": "points",
        "section": "points",
        "text": "Return the list of points with arcs converted to segments.\nNumber of facets to convert an arc. Default is 6.\n(X, Y).\npoints\npython:int\npython:tuple\npython:float\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.points",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.points.html#pyedb.grpc.database.primitive.primitive.Primitive.points",
        "title": "points > points > points",
        "section": "points > points",
        "text": "Primitive.points(arc_segments=6) -> tuple[float, float]\n\nReturn the list of points with arcs converted to segments.\n\nParameters\n\narc_segments\n\npython:int\n\nNumber of facets to convert an arc. Default is 6.\n\nReturns\n\npython:tuple(python:float, python:float)\n\n(X, Y).\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.get_properties",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.get_properties.html#get_properties",
        "title": "get_properties",
        "section": "get_properties",
        "text": "get_properties"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.get_properties",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.get_properties.html#pyedb.grpc.database.definition.component_def.ComponentDef.get_properties",
        "title": "get_properties > get_properties > get_properties",
        "section": "get_properties > get_properties",
        "text": "ComponentDef.get_properties()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_json_schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias: Whether to use attribute aliases or not.\nref_template: The reference template.\nunion_format: The format to use when combining schemas from unions together. Can be one of:\n‘any_of’: Use the [anyOf](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\nkeyword to combine schemas (the default).\n- ‘primitive_type_array’: Use the [type](https://json-schema.org/understanding-json-schema/reference/type)\nkeyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\ntype (string, boolean, null, integer or number) or contains constraints/metadata, falls back to\nany_of.\nGenerateJsonSchema with your desired modifications\nmode: The mode in which to generate the schema.\nThe JSON schema for the given model class.\nmodel_json_schema"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_json_schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_json_schema.html#pyedb.workflows.drc.drc.DiffPair.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod DiffPair.model_json_schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}', schema_generator: type[~pydantic.json_schema.GenerateJsonSchema] = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: ~typing.Literal['validation', 'serialization'] = 'validation', *, union_format: ~typing.Literal['any_of', 'primitive_type_array'] = 'any_of') -> dict[str, Any]\n\nGenerates a JSON schema for a model class.\n\nArgs:\n\nby_alias: Whether to use attribute aliases or not.\nref_template: The reference template.\nunion_format: The format to use when combining schemas from unions together. Can be one of:\n\n‘any_of’: Use the [anyOf](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n\nkeyword to combine schemas (the default).\n- ‘primitive_type_array’: Use the [type](https://json-schema.org/understanding-json-schema/reference/type)\nkeyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\ntype (string, boolean, null, integer or number) or contains constraints/metadata, falls back to\nany_of.\n\nschema_generator: To override the logic used to generate the JSON schema, as a subclass of\n\nGenerateJsonSchema with your desired modifications\n\nmode: The mode in which to generate the schema.\n\nReturns:\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.disable_rlc_component",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.disable_rlc_component.html#disable_rlc_component",
        "title": "disable_rlc_component",
        "section": "disable_rlc_component",
        "text": "Disable a RLC component.\nName of the RLC component.\nTrue when successful, False when failed.\ndisable_rlc_component\npython:str\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.disable_rlc_component",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.disable_rlc_component.html#pyedb.dotnet.database.components.Components.disable_rlc_component",
        "title": "disable_rlc_component > disable_rlc_component > disable_rlc_component",
        "section": "disable_rlc_component > disable_rlc_component",
        "text": "Components.disable_rlc_component(component_name)\n\nDisable a RLC component.\n\nParameters\n\ncomponent_name\n\npython:str\n\nName of the RLC component.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\")\n>>> edbapp.components.disable_rlc_component(\"A1\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the terminal object to the correct concrete type, fetching the type if necessary.\ncast\nTerminalType\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.cast.html#pyedb.grpc.database.ports.ports.WavePort.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "WavePort.cast(term_type=None)\n\nCast the terminal object to the correct concrete type, fetching the type if necessary.\n\nParameters\n\nterm_type\n\nTerminalType\n\n\n\nReturns\n\nTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_circuit_port_on_pin",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_circuit_port_on_pin.html#create_circuit_port_on_pin",
        "title": "create_circuit_port_on_pin",
        "section": "create_circuit_port_on_pin",
        "text": "Create Circuit Port on Pin.\nEdb Pin\nEdb Pin\nPort Impedance\nPort Name\nPort Name.\ncreate_circuit_port_on_pin\nObject\nObject\npython:float\npython:str\noptional\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_circuit_port_on_pin",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_circuit_port_on_pin.html#pyedb.dotnet.database.hfss.EdbHfss.create_circuit_port_on_pin",
        "title": "create_circuit_port_on_pin > create_circuit_port_on_pin > create_circuit_port_on_pin",
        "section": "create_circuit_port_on_pin > create_circuit_port_on_pin",
        "text": "EdbHfss.create_circuit_port_on_pin(pos_pin, neg_pin, impedance=50, port_name=None)\n\nCreate Circuit Port on Pin.\n\nParameters\n\npos_pin\n\nObject\n\nEdb Pin\n\nneg_pin\n\nObject\n\nEdb Pin\n\nimpedance\n\npython:float\n\nPort Impedance\n\nport_name\n\npython:str, optional\n\nPort Name\n\n>>> from pyedb import Edb\n\n\n\n>>> edbapp = Edb(“myaedbfolder”, “project name”, “release version”)\n\n\n\n>>> pins = edbapp.components.get_pin_from_component(“U2A5”)\n\n\n\n>>> edbapp.hfss.create_circuit_port_on_pin(pins[0], pins[1], 50, “port_name”)\n\n\n\nReturns\n\npython:str\n\nPort Name.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.add_frequency_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.add_frequency_sweep.html#add_frequency_sweep",
        "title": "add_frequency_sweep",
        "section": "add_frequency_sweep",
        "text": "Add frequency sweep.\nName of the frequency sweep. The default is None.\nList of frequency points. The default is None.\nadd_frequency_sweep\npython:str\noptional\nNone\npython:list\noptional\nNone\npyedb.dotnet.database.edb_data.simulation_setup_data.EdbFrequencySweep"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.add_frequency_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.add_frequency_sweep.html#pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.add_frequency_sweep",
        "title": "add_frequency_sweep > add_frequency_sweep > add_frequency_sweep",
        "section": "add_frequency_sweep > add_frequency_sweep",
        "text": "HFSSPISimulationSetup.add_frequency_sweep(name=None, frequency_sweep=None)\n\nAdd frequency sweep.\n\nParameters\n\nname\n\npython:str, optional\n\nName of the frequency sweep. The default is None.\n\nfrequency_sweep\n\npython:list, optional\n\nList of frequency points. The default is None.\n\nReturns\n\npyedb.dotnet.database.edb_data.simulation_setup_data.EdbFrequencySweep\n\n\n\nExamples\n\n>>> setup1 = edbapp.create_siwave_syz_setup(\"setup1\")\n>>> setup1.add_frequency_sweep(\n...     frequency_sweep=[\n...         [\"linear count\", \"0\", \"1kHz\", 1],\n...         [\"log scale\", \"1kHz\", \"0.1GHz\", 10],\n...         [\"linear scale\", \"0.1GHz\", \"10GHz\", \"0.1GHz\"],\n...     ]\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.find",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.find.html#find",
        "title": "find",
        "section": "find",
        "text": "Find a cell in a database by either name or ID.\nDatabase to search for the cell.\nType of the cell.\nName of the cell. The default is None, in which case a name\nis automatically assigned.\nID of the cell. The default is None, in which case an ID\nis automatically assigned.\nCell that was found, None otherwise.\nfind\nDatabase\nCellType\npython:str\noptional\nNone\npython:int\noptional\nNone\nCell\nNone"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.find",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.find.html#pyedb.grpc.database.layout.cell.Cell.find",
        "title": "find > find > find",
        "section": "find > find",
        "text": "classmethod Cell.find(database, cell_type, name=None, cell_id=None)\n\nFind a cell in a database by either name or ID.\n\nParameters\n\ndatabase\n\nDatabase\n\nDatabase to search for the cell.\n\ncell_type\n\nCellType\n\nType of the cell.\n\nname\n\npython:str, optional\n\nName of the cell. The default is None, in which case a name\nis automatically assigned.\n\ncell_id\n\npython:int, optional\n\nID of the cell. The default is None, in which case an ID\nis automatically assigned.\n\nReturns\n\nCell\n\nCell that was found, None otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "construct"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.construct.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod DiffPairLengthMatch.construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_backdrill_bottom",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_backdrill_bottom.html#set_backdrill_bottom",
        "title": "set_backdrill_bottom",
        "section": "set_backdrill_bottom",
        "text": "Set backdrill from bottom.\n.deprecated: 0.55.0\nUse: method:set_back_drill_by_depth instead.\nName of the drill to layer.\nDiameter of backdrill size.\noffset with respect to the layer to drill to.\nTrue if success, False otherwise.\nset_backdrill_bottom\npython:str\npython:float\npython:str\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_backdrill_bottom",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_backdrill_bottom.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_backdrill_bottom",
        "title": "set_backdrill_bottom > set_backdrill_bottom > set_backdrill_bottom",
        "section": "set_backdrill_bottom > set_backdrill_bottom",
        "text": "PadstackInstance.set_backdrill_bottom(drill_depth, drill_diameter, offset=0.0)\n\nSet backdrill from bottom.\n\n.deprecated: 0.55.0\nUse: method:set_back_drill_by_depth instead.\n\nParameters\n\ndrill_depth\n\npython:str\n\nName of the drill to layer.\n\ndrill_diameter\n\npython:float, python:str\n\nDiameter of backdrill size.\n\noffset\n\npython:str, optional.\n\noffset with respect to the layer to drill to.\n\nReturns\n\nbool\n\nTrue if success, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.duplicate_across_layers",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.duplicate_across_layers.html#duplicate_across_layers",
        "title": "duplicate_across_layers",
        "section": "duplicate_across_layers",
        "text": "Duplicate across layer a primitive object.\nParameters:\nlist of str, with layer names\nTrue when successful, False when failed.\nduplicate_across_layers\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.duplicate_across_layers",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.duplicate_across_layers.html#pyedb.grpc.database.primitive.polygon.Polygon.duplicate_across_layers",
        "title": "duplicate_across_layers > duplicate_across_layers > duplicate_across_layers",
        "section": "duplicate_across_layers > duplicate_across_layers",
        "text": "Polygon.duplicate_across_layers(layers) -> bool\n\nDuplicate across layer a primitive object.\n\nParameters:\n\nlayers: list\n\nlist of str, with layer names\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_edge_terminal_reference_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_edge_terminal_reference_primitive.html#get_edge_terminal_reference_primitive",
        "title": "get_edge_terminal_reference_primitive",
        "section": "get_edge_terminal_reference_primitive",
        "text": "Check and return a primitive instance that serves Edge ports,\nwave-ports and coupled-edge ports that are directly connected to primitives.\nget_edge_terminal_reference_primitive\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_edge_terminal_reference_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_edge_terminal_reference_primitive.html#pyedb.grpc.database.terminal.terminal.Terminal.get_edge_terminal_reference_primitive",
        "title": "get_edge_terminal_reference_primitive > get_edge_terminal_reference_primitive > get_edge_terminal_reference_primitive",
        "section": "get_edge_terminal_reference_primitive > get_edge_terminal_reference_primitive",
        "text": "Terminal.get_edge_terminal_reference_primitive() -> any\n\nCheck and return a primitive instance that serves Edge ports,\nwave-ports and coupled-edge ports that are directly connected to primitives.\n\nReturns\n\nPrimitive\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.save_edb",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.save_edb.html#save_edb",
        "title": "save_edb",
        "section": "save_edb",
        "text": "Save the EDB file.\n. deprecated:: pyedb 0.47.0\nUse: func:save instead.\nTrue when successful, False when failed.\nsave_edb\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.save_edb",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.save_edb.html#pyedb.dotnet.edb.Edb.save_edb",
        "title": "save_edb > save_edb > save_edb",
        "section": "save_edb > save_edb",
        "text": "Edb.save_edb()\n\nSave the EDB file.\n\n. deprecated:: pyedb 0.47.0\nUse: func:save instead.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the package definition.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.delete.html#pyedb.grpc.database.definition.package_def.PackageDef.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "PackageDef.delete()\n\nDelete the package definition.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPairs",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPairs.html#differentialpairs",
        "title": "DifferentialPairs",
        "section": "DifferentialPairs",
        "text": "DifferentialPairs.auto_identify([...])\nAuto identify differential pairs by naming conversion.\nDifferentialPairs.create(name, net_p, net_n)\n\nDifferentialPairs\nDifferentialPairs.auto_identify\nDifferentialPairs.create"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPairs",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPairs.html#pyedb.grpc.database.net.differential_pair.DifferentialPairs",
        "title": "DifferentialPairs > DifferentialPairs > DifferentialPairs",
        "section": "DifferentialPairs > DifferentialPairs",
        "text": "class pyedb.grpc.database.net.differential_pair.DifferentialPairs(pedb)\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nDifferentialPairs.auto_identify([...])\n\nAuto identify differential pairs by naming conversion.\n\nDifferentialPairs.create(name, net_p, net_n)\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.create_hfss.html#create_hfss",
        "title": "create_hfss",
        "section": "create_hfss",
        "text": "Create an HFSS model from an MCAD file.\nHFSS model created.\ncreate_hfss\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.create_hfss.html#pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.create_hfss",
        "title": "create_hfss > create_hfss > create_hfss",
        "section": "create_hfss > create_hfss",
        "text": "VoltageRegulator.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nReturns\n\nMcadModel\n\nHFSS model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/CoreEdb",
        "href": "dotnet_api/dotnet/CoreEdb.html#edb-manager",
        "title": "EDB manager",
        "section": "EDB manager",
        "text": "An AEDB database is a folder that contains the database representing any part of a PCB.\nIt can be opened and edited using the Edb class.\nedb.Edb([edbpath, cellname, isreadonly, ...])\nProvides the EDB application interface.\nEDB manager\nEdb\nedb.Edb"
    },
    {
        "objectID": "dotnet_api/dotnet/CoreEdb",
        "href": "dotnet_api/dotnet/CoreEdb.html#edb-modules",
        "title": "EDB manager > EDB modules",
        "section": "EDB modules",
        "text": "This section lists the core EDB modules for reading and writing information\nto AEDB files.\ncomponents.Components\nManages EDB components and related method accessible from Edb.components property.\nhfss.EdbHfss\nManages EDB method to configure Hfss setup accessible from Edb.hfss property.\nlayout_validation.LayoutValidation\nManages all layout validation capabilities\nmaterials.Materials\nManages EDB methods for material management accessible from Edb.materials property.\nmodeler.Modeler\nManages EDB methods for primitives management accessible from Edb.modeler property.\nnets.EdbNets\nManages EDB methods for nets management accessible from Edb.nets property.\nedb_data.padstacks_data.EDBPadstack\nManages EDB functionalities for a padstack.\nsiwave.EdbSiwave\nManages EDB methods related to Siwave Setup accessible from Edb.siwave property.\nstackup.Stackup\nManages EDB methods for stackup accessible from Edb.stackup property.\nEDB modules\ncomponents.Components\nhfss.EdbHfss\nlayout_validation.LayoutValidation\nmaterials.Materials\nmodeler.Modeler\nnets.EdbNets\nedb_data.padstacks_data.EDBPadstack\nsiwave.EdbSiwave\nstackup.Stackup"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_edge_port_on_polygon",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_edge_port_on_polygon.html#create_edge_port_on_polygon",
        "title": "create_edge_port_on_polygon",
        "section": "create_edge_port_on_polygon",
        "text": "Create lumped port between two edges from two different polygons. Can also create a vertical port when\nthe reference layer name is only provided. When a port is created between two edge from two polygons which don’t\nbelong to the same layer, a circuit port will be automatically created instead of lumped. To enforce the circuit\nport instead of lumped,use the boolean force_circuit_port.\nEdb.Cell.Primitive.Polygon object.\nEdb.Cell.Primitive.Polygon object.\nlist[float, float] with values provided in meter.\nlist[float, float] with values provided in meter.\nstr the layer name.\nstr.\nfloat, impedance value.\ncreate_edge_port_on_polygon\nThe\nEDB\npolygon\nobject\nused\nto\nassign\nthe\nThe\nEDB\npolygon\nobject\nused\nto\ndefine\nthe\nport\nThe\ncoordinate\nof\nthe\npoint\nto\ndefine\nthe\nedge\nterminal\nof\nthe\nThis\npoint\nmust\nbe\nsame\nas\nterminal_point\nbut\nused\nfor\ndefining\nthe\nreference\nlocation\non\nthe\nName\nused\nto\ndefine\nport\nreference\nfor\nvertical\nName\nof\nthe\nport\nimpedance\nDefault\nvalue\nis"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_edge_port_on_polygon",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_edge_port_on_polygon.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_edge_port_on_polygon",
        "title": "create_edge_port_on_polygon > create_edge_port_on_polygon > create_edge_port_on_polygon",
        "section": "create_edge_port_on_polygon > create_edge_port_on_polygon",
        "text": "SourceExcitation.create_edge_port_on_polygon(polygon: Primitive | None = None, reference_polygon: Primitive | None = None, terminal_point: List[float] | None = None, reference_point: List[float] | None = None, reference_layer: str | StackupLayer | None = None, port_name: str | None = None, port_impedance: int | float = 50.0, force_circuit_port: bool = False) -> str | None\n\nCreate lumped port between two edges from two different polygons. Can also create a vertical port when\nthe reference layer name is only provided. When a port is created between two edge from two polygons which don’t\nbelong to the same layer, a circuit port will be automatically created instead of lumped. To enforce the circuit\nport instead of lumped,use the boolean force_circuit_port.\n\nParameters\n\npolygon\n\nThe EDB polygon object used to assign the port.\n\nEdb.Cell.Primitive.Polygon object.\n\nreference_polygon\n\nThe EDB polygon object used to define the port reference.\n\nEdb.Cell.Primitive.Polygon object.\n\nterminal_point\n\nThe coordinate of the point to define the edge terminal of the port. This point must be\n\n\n\nlocated on the edge of the polygon where the port has to be placed. For instance taking the middle point\n\n\n\nof an edge is a good practice but any point of the edge should be valid. Taking a corner might cause unwanted\n\n\n\nport location.\n\nlist[float, float] with values provided in meter.\n\nreference_point\n\nsame as terminal_point but used for defining the reference location on the edge.\n\nlist[float, float] with values provided in meter.\n\nreference_layer\n\nName used to define port reference for vertical ports.\n\nstr the layer name.\n\nport_name\n\nName of the port.\n\nstr.\n\nport_impedance\n\nport impedance value. Default value is 50 Ohms.\n\nfloat, impedance value.\n\nforce_circuit_port ; used to force circuit port creation instead of lumped. Works for vertical and coplanar\n\n\n\nports.\n\n\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> poly = edb.modeler.primitives[0]\n>>> ref_poly = edb.modeler.primitives[1]\n>>> edb.source_excitation.create_edge_port_on_polygon(poly, ref_poly, [0, 0], [0.1, 0])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.get_product_property_ids.html#pyedb.grpc.database.hierarchy.pingroup.PinGroup.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "PinGroup.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create_hfss.html#create_hfss",
        "title": "create_hfss",
        "section": "create_hfss",
        "text": "Create an HFSS model from an MCAD file.\nHFSS model created.\ncreate_hfss\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create_hfss.html#pyedb.grpc.database.hierarchy.component.Component.create_hfss",
        "title": "create_hfss > create_hfss > create_hfss",
        "section": "create_hfss > create_hfss",
        "text": "Component.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nReturns\n\nMcadModel\n\nHFSS model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.get_product_property.html#pyedb.grpc.database.ports.ports.CircuitPort.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "CircuitPort.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.layer_data.LayerEdbClass",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.layer_data.LayerEdbClass.html#layeredbclass",
        "title": "LayerEdbClass",
        "section": "LayerEdbClass",
        "text": "Manages Edb Layers. Replaces EDBLayer.\nLayerEdbClass.update(**kwargs)\n\nLayerEdbClass\nLayerEdbClass.update"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.layer_data.LayerEdbClass",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.layer_data.LayerEdbClass.html#pyedb.dotnet.database.edb_data.layer_data.LayerEdbClass",
        "title": "LayerEdbClass > LayerEdbClass > LayerEdbClass",
        "section": "LayerEdbClass > LayerEdbClass",
        "text": "class pyedb.dotnet.database.edb_data.layer_data.LayerEdbClass(pedb, edb_object=None, name='', layer_type='undefined', **kwargs)\n\nManages Edb Layers. Replaces EDBLayer.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nLayerEdbClass.update(**kwargs)\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_port",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_port.html#create_port",
        "title": "create_port",
        "section": "create_port",
        "text": "Create a port on the padstack instance.\nName of the port. The default is None, in which case a name is automatically assigned.\nNegative terminal of the port.\nWhether it is a circuit port.\nPort terminal.\ncreate_port\npython:str\noptional\nNone\nreference\nnet\npingroup\noptional\noptional\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_port",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_port.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_port",
        "title": "create_port > create_port > create_port",
        "section": "create_port > create_port",
        "text": "PadstackInstance.create_port(name=None, reference=None, is_circuit_port=False)\n\nCreate a port on the padstack instance.\n\nParameters\n\nname\n\npython:str, optional\n\nName of the port. The default is None, in which case a name is automatically assigned.\n\nreference\n\nreference net or pingroup  optional\n\nNegative terminal of the port.\n\nis_circuit_port\n\nbool, optional\n\nWhether it is a circuit port.\n\nReturns\n\nTerminal\n\nPort terminal.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.mass_density",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.mass_density.html#mass_density",
        "title": "mass_density",
        "section": "mass_density",
        "text": "mass_density"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.mass_density",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.mass_density.html#pyedb.grpc.database.definition.materials.MaterialProperties.mass_density",
        "title": "mass_density > mass_density > mass_density",
        "section": "mass_density > mass_density",
        "text": "MaterialProperties.mass_density: Annotated[float, Gt(gt=0)] | None\n\n"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.schema_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "schema_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.schema_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.schema_json.html#pyedb.workflows.drc.drc.MinLineWidth.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod MinLineWidth.schema_json(*, by_alias: bool = True, ref_template: str = '#/$defs/{model}', **dumps_kwargs: Any) -> str\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.place_in_layout",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.place_in_layout.html#place_in_layout",
        "title": "place_in_layout",
        "section": "place_in_layout",
        "text": "Place current cell into another cell using layer placement method.\nFlip the current layer stackup of a layout if requested.\nTarget Edb object.\nRotation angle in degrees. The default is 0.0.\nX offset value. The default is 0.0.\nY offset value. The default is 0.0.\nWhether to flip the current layout. The default is True.\nWhether to place the current layout on top of the destination layout. The default is True.\nTrue when successful.\nplace_in_layout\npyedb.Edb\npython:float\noptional\n0.0\npython:float\noptional\n0.0\npython:float\noptional\n0.0\noptional\nTrue\noptional\nTrue\nTrue"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.place_in_layout",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.place_in_layout.html#pyedb.grpc.database.stackup.Stackup.place_in_layout",
        "title": "place_in_layout > place_in_layout > place_in_layout",
        "section": "place_in_layout > place_in_layout",
        "text": "Stackup.place_in_layout(edb: Edb, angle: float = 0.0, offset_x: float = 0.0, offset_y: float = 0.0, flipped_stackup: bool = True, place_on_top: bool = True) -> bool\n\nPlace current cell into another cell using layer placement method.\n\nFlip the current layer stackup of a layout if requested.\n\nParameters\n\nedb\n\npyedb.Edb\n\nTarget Edb object.\n\nangle\n\npython:float, optional\n\nRotation angle in degrees. The default is 0.0.\n\noffset_x\n\npython:float, optional\n\nX offset value. The default is 0.0.\n\noffset_y\n\npython:float, optional\n\nY offset value. The default is 0.0.\n\nflipped_stackup\n\nbool, optional\n\nWhether to flip the current layout. The default is True.\n\nplace_on_top\n\nbool, optional\n\nWhether to place the current layout on top of the destination layout. The default is True.\n\nReturns\n\nbool\n\nTrue when successful.\n\nExamples\n\n>>> edb1 = Edb(edbpath=targetfile1, edbversion=\"2021.2\")\n>>> edb2 = Edb(edbpath=targetfile2, edbversion=\"2021.2\")\n\n>>> hosting_cmp = edb1.components.get_component_by_name(\"U100\")\n>>> mounted_cmp = edb2.components.get_component_by_name(\"BGA\")\n\n>>> vector, rotation, solder_ball_height = edb1.components.get_component_placement_vector(\n...     mounted_component=mounted_cmp,\n...     hosting_component=hosting_cmp,\n...     mounted_component_pin1=\"A12\",\n...     mounted_component_pin2=\"A14\",\n...     hosting_component_pin1=\"A12\",\n...     hosting_component_pin2=\"A14\",\n... )\n>>> edb2.stackup.place_in_layout(\n...     edb1.active_cell,\n...     angle=0.0,\n...     offset_x=vector[0],\n...     offset_y=vector[1],\n...     flipped_stackup=False,\n...     place_on_top=True,\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_post_init",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nmodel_post_init"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_post_init",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_post_init.html#pyedb.workflows.drc.drc.MinAnnularRing.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "MinAnnularRing.model_post_init(context: Any, /) -> None\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileBoundaries",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileBoundaries.html#controlfileboundaries",
        "title": "ControlFileBoundaries",
        "section": "ControlFileBoundaries",
        "text": "Boundaries management.\nControlFileBoundaries.add_extent([type, ...])\nAdd a new extent.\nControlFileBoundaries.add_port(name, x1, y1, ...)\nAdd a new port to the gds.\nControlFileBoundaries\nControlFileBoundaries.add_extent\nControlFileBoundaries.add_port"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileBoundaries",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileBoundaries.html#pyedb.grpc.database.utility.xml_control_file.ControlFileBoundaries",
        "title": "ControlFileBoundaries > ControlFileBoundaries > ControlFileBoundaries",
        "section": "ControlFileBoundaries > ControlFileBoundaries",
        "text": "class pyedb.grpc.database.utility.xml_control_file.ControlFileBoundaries(units='um')\n\nBoundaries management.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nControlFileBoundaries.add_extent([type, ...])\n\nAdd a new extent.\n\nControlFileBoundaries.add_port(name, x1, y1, ...)\n\nAdd a new port to the gds.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.make_zone_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.make_zone_primitive.html#make_zone_primitive",
        "title": "make_zone_primitive",
        "section": "make_zone_primitive",
        "text": "Make the primitive a zone primitive with a zone specified by the provided ID.\nID of the zone primitive to use.\nmake_zone_primitive\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.make_zone_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.make_zone_primitive.html#pyedb.grpc.database.primitive.polygon.Polygon.make_zone_primitive",
        "title": "make_zone_primitive > make_zone_primitive > make_zone_primitive",
        "section": "make_zone_primitive > make_zone_primitive",
        "text": "Polygon.make_zone_primitive(zone_id: int)\n\nMake the primitive a zone primitive with a zone specified by the provided ID.\n\nParameters\n\nzone_id\n\npython:int\n\nID of the zone primitive to use.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.move",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.move.html#move",
        "title": "move",
        "section": "move",
        "text": "Move polygon along a vector.\nTrue when successful, False when failed.\nmove\nList\nof\npython:float\npython:str\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.move",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.move.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.move",
        "title": "move > move > move",
        "section": "move > move",
        "text": "EdbPolygon.move(vector)\n\nMove polygon along a vector.\n\nParameters\n\nvector\n\nList of python:float or python:str [x,y].\n\n\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> edbapp = ansys.aedt.core.Edb(\"myproject.aedb\")\n>>> top_layer_polygon = [poly for poly in edbapp.modeler.polygons if poly.layer_name == \"Top Layer\"]\n>>> for polygon in top_layer_polygon:\n>>>     polygon.move(vector=[\"2mm\", \"100um\"])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.unite",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.unite.html#unite",
        "title": "unite",
        "section": "unite",
        "text": "Unite active primitive with one or more primitives.\nList of Primitive objects.\nunite\nPrimitives\nList\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.unite",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.unite.html#pyedb.grpc.database.primitive.polygon.Polygon.unite",
        "title": "unite > unite > unite",
        "section": "unite > unite",
        "text": "Polygon.unite(primitives) -> list[any]\n\nUnite active primitive with one or more primitives.\n\nParameters\n\nprimitives\n\nPrimitives\n\n\n\nor: List[:class:`Primitives <pyedb.grpc.database.primitive.primitive.Primitive>`]\n\n\n\nor: class:`PolygonData <ansys.edb.core.geometry.polygon_data.PolygonData>`\n\n\n\nReturns\n\nList[Primitive]\n\nList of Primitive objects.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.move_layer",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.move_layer.html#move_layer",
        "title": "move_layer",
        "section": "move_layer",
        "text": "Move polygon to given layer.\nlayer name.\nTrue when successful, False when failed.\nmove_layer\npython:str\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.move_layer",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.move_layer.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.move_layer",
        "title": "move_layer > move_layer > move_layer",
        "section": "move_layer > move_layer",
        "text": "EdbPolygon.move_layer(layer)\n\nMove polygon to given layer.\n\nParameters\n\nlayer\n\npython:str\n\nlayer name.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.get_smallest_trace_width",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.get_smallest_trace_width.html#get_smallest_trace_width",
        "title": "get_smallest_trace_width",
        "section": "get_smallest_trace_width",
        "text": "Retrieve the smallest trace width from paths.\nTrace smallest width.\nget_smallest_trace_width\npython:float"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.get_smallest_trace_width",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.get_smallest_trace_width.html#pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.get_smallest_trace_width",
        "title": "get_smallest_trace_width > get_smallest_trace_width > get_smallest_trace_width",
        "section": "get_smallest_trace_width > get_smallest_trace_width",
        "text": "EDBNetsData.get_smallest_trace_width()\n\nRetrieve the smallest trace width from paths.\n\nReturns\n\npython:float\n\nTrace smallest width.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.set_sim_setup_info",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.set_sim_setup_info.html#set_sim_setup_info",
        "title": "set_sim_setup_info",
        "section": "set_sim_setup_info",
        "text": "set_sim_setup_info"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.set_sim_setup_info",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.set_sim_setup_info.html#pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.set_sim_setup_info",
        "title": "set_sim_setup_info > set_sim_setup_info > set_sim_setup_info",
        "section": "set_sim_setup_info > set_sim_setup_info",
        "text": "SimulationSetup.set_sim_setup_info(sim_setup_info)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.edb_exception",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.edb_exception.html#edb_exception",
        "title": "edb_exception",
        "section": "edb_exception",
        "text": "Log Python exceptions to EDB logger.\nException value.\nTraceback object.\nedb_exception\nException\ntraceback"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.edb_exception",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.edb_exception.html#pyedb.grpc.edb.Edb.edb_exception",
        "title": "edb_exception > edb_exception > edb_exception",
        "section": "edb_exception > edb_exception",
        "text": "Edb.edb_exception(ex_value, tb_data)\n\nLog Python exceptions to EDB logger.\n\nParameters\n\nex_value\n\nException\n\nException value.\n\ntb_data\n\ntraceback\n\nTraceback object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.create",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a bondwire.\nLayout to create the bondwire in.\nType of the bondwire. Options are kAPDBondWire and kJDECBondWire.\nBondwire definition name.\nLayer name to create the bondwire on.\nBondwire width.\nBondwire material name.\nStart context None means top-level,.\nName of the start layer.\nX value of the start point.\nY value of the start point.\nEnd content None means top-level.\nName of the end layer.\nX value of the end point.\nY value of the end point.\nNet of the bondwire.\nBondwire object created.\ncreate\nLayout\nBondwireType\nkAPDBondWire\nkJDECBondWire\npython:str\npython:str\npython:str\nCellInstance\nNone\npython:str\nCellInstance\nNone\npython:str\npython:None\nBondwire"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.create",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.create.html#pyedb.grpc.database.primitive.bondwire.Bondwire.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod Bondwire.create(layout: Layout, bondwire_type: BondwireType, definition_name: str, placement_layer: str, width: ValueLike, material: str, start_context: CellInstance, start_layer_name: str, start_x: ValueLike, start_y: ValueLike, end_context: CellInstance, end_layer_name: str, end_x: ValueLike, end_y: ValueLike, net: NetLike | None) -> Bondwire\n\nCreate a bondwire.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to create the bondwire in.\n\nbondwire_type\n\nBondwireType\n\nType of the bondwire. Options are kAPDBondWire and kJDECBondWire.\n\ndefinition_name\n\npython:str\n\nBondwire definition name.\n\nplacement_layer\n\npython:str\n\nLayer name to create the bondwire on.\n\nwidth\n\nValueLike\n\nBondwire width.\n\nmaterial\n\npython:str\n\nBondwire material name.\n\nstart_context\n\nCellInstance\n\nStart context None means top-level,.\n\nstart_layer_name\n\npython:str\n\nName of the start layer.\n\nstart_x\n\nValueLike\n\nX value of the start point.\n\nstart_y\n\nValueLike\n\nY value of the start point.\n\nend_context\n\nCellInstance\n\nEnd content None means top-level.\n\nend_layer_name\n\npython:str\n\nName of the end layer.\n\nend_x\n\nValueLike\n\nX value of the end point.\n\nend_y\n\nValueLike\n\nY value of the end point.\n\nnet\n\nNetLike or python:None\n\nNet of the bondwire.\n\nReturns\n\nBondwire\n\nBondwire object created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.html#edbhfss",
        "title": "EdbHfss",
        "section": "EdbHfss",
        "text": "Manages EDB method to configure Hfss setup accessible from Edb.hfss property.\nEdbHfss.add_setup([name])\nAdding method for grpc compatibility\nEdbHfss.configure_hfss_analysis_setup([...])\nConfigure HFSS analysis setup.\nEdbHfss.configure_hfss_extents([...])\nConfigure the HFSS extent box.\nEdbHfss.create_bundle_wave_port(...[, ...])\nCreate a bundle wave port.\nEdbHfss.create_circuit_port_on_net(...[, ...])\nCreate a circuit port on a NET.\nEdbHfss.create_circuit_port_on_pin(pos_pin, ...)\nCreate Circuit Port on Pin.\nEdbHfss.create_coax_port_on_component(...[, ...])\nCreate a coaxial port on a component or component list on a net or net list.\nEdbHfss.create_current_source_on_net(...[, ...])\nCreate a current source.\nEdbHfss.create_current_source_on_pin(...[, ...])\nCreate a current source.\nEdbHfss.create_differential_wave_port(...[, ...])\nCreate a differential wave port.\nEdbHfss.create_edge_port_horizontal(prim_id, ...)\nCreate a horizontal edge port.\nEdbHfss.create_edge_port_on_polygon([...])\nCreate lumped port between two edges from two different polygons.\nEdbHfss.create_edge_port_vertical(prim_id, ...)\nCreate a vertical edge port.\nEdbHfss.create_hfss_ports_on_padstack(pinpos)\nCreate an HFSS port on a padstack.\nEdbHfss.create_lumped_port_on_net([nets, ...])\nCreate an edge port on nets.\nEdbHfss.create_resistor_on_pin(pos_pin, neg_pin)\nCreate a Resistor boundary between two given pins.\nEdbHfss.create_rlc_boundary_on_pins([...])\nCreate hfss rlc boundary on pins.\nEdbHfss.create_vertical_circuit_port_on_clipped_traces([...])\nCreate an edge port on clipped signal traces.\nEdbHfss.create_voltage_source_on_net(...[, ...])\nCreate a voltage source.\nEdbHfss.create_voltage_source_on_pin(...[, ...])\nCreate a voltage source.\nEdbHfss.create_wave_port(prim_id, point_on_edge)\nCreate a wave port.\nEdbHfss.get_layout_bounding_box([layout, ...])\nEvaluate the layout bounding box.\nEdbHfss.get_ports_number()\nReturn the total number of excitation ports in a layout.\nEdbHfss.get_trace_width_for_traces_with_ports()\nRetrieve the trace width for traces with ports.\nEdbHfss.layout_defeaturing([simulation_setup])\nDefeature the layout by reducing the number of points for polygons based on surface deviation criteria.\nEdbHfss.set_coax_port_attributes([...])\nSet coaxial port attribute with forcing default impedance to 50 Ohms and adjusting the coaxial extent radius.\nEdbHfss.trim_component_reference_size([...])\nTrim the common component reference to the minimally acceptable size.\nEdbHfss\nEdbHfss.add_setup\nEdbHfss.configure_hfss_analysis_setup\nEdbHfss.configure_hfss_extents\nEdbHfss.create_bundle_wave_port\nEdbHfss.create_circuit_port_on_net\nEdbHfss.create_circuit_port_on_pin\nEdbHfss.create_coax_port_on_component\nEdbHfss.create_current_source_on_net\nEdbHfss.create_current_source_on_pin\nEdbHfss.create_differential_wave_port\nEdbHfss.create_edge_port_horizontal\nEdbHfss.create_edge_port_on_polygon\nEdbHfss.create_edge_port_vertical\nEdbHfss.create_hfss_ports_on_padstack\nEdbHfss.create_lumped_port_on_net\nEdbHfss.create_resistor_on_pin\nEdbHfss.create_rlc_boundary_on_pins\nEdbHfss.create_vertical_circuit_port_on_clipped_traces\nEdbHfss.create_voltage_source_on_net\nEdbHfss.create_voltage_source_on_pin\nEdbHfss.create_wave_port\nEdbHfss.get_layout_bounding_box\nEdbHfss.get_ports_number\nEdbHfss.get_trace_width_for_traces_with_ports\nEdbHfss.layout_defeaturing\nEdbHfss.set_coax_port_attributes\nEdbHfss.trim_component_reference_size"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.html#pyedb.dotnet.database.hfss.EdbHfss",
        "title": "EdbHfss > EdbHfss > EdbHfss",
        "section": "EdbHfss > EdbHfss",
        "text": "class pyedb.dotnet.database.hfss.EdbHfss(p_edb)\n\nManages EDB method to configure Hfss setup accessible from Edb.hfss property.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\")\n>>> edb_hfss = edb_3dedbapp.hfss\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nEdbHfss.add_setup([name])\n\nAdding method for grpc compatibility\n\nEdbHfss.configure_hfss_analysis_setup([...])\n\nConfigure HFSS analysis setup.\n\nEdbHfss.configure_hfss_extents([...])\n\nConfigure the HFSS extent box.\n\nEdbHfss.create_bundle_wave_port(...[, ...])\n\nCreate a bundle wave port.\n\nEdbHfss.create_circuit_port_on_net(...[, ...])\n\nCreate a circuit port on a NET.\n\nEdbHfss.create_circuit_port_on_pin(pos_pin, ...)\n\nCreate Circuit Port on Pin.\n\nEdbHfss.create_coax_port_on_component(...[, ...])\n\nCreate a coaxial port on a component or component list on a net or net list.\n\nEdbHfss.create_current_source_on_net(...[, ...])\n\nCreate a current source.\n\nEdbHfss.create_current_source_on_pin(...[, ...])\n\nCreate a current source.\n\nEdbHfss.create_differential_wave_port(...[, ...])\n\nCreate a differential wave port.\n\nEdbHfss.create_edge_port_horizontal(prim_id, ...)\n\nCreate a horizontal edge port.\n\nEdbHfss.create_edge_port_on_polygon([...])\n\nCreate lumped port between two edges from two different polygons.\n\nEdbHfss.create_edge_port_vertical(prim_id, ...)\n\nCreate a vertical edge port.\n\nEdbHfss.create_hfss_ports_on_padstack(pinpos)\n\nCreate an HFSS port on a padstack.\n\nEdbHfss.create_lumped_port_on_net([nets, ...])\n\nCreate an edge port on nets.\n\nEdbHfss.create_resistor_on_pin(pos_pin, neg_pin)\n\nCreate a Resistor boundary between two given pins.\n\nEdbHfss.create_rlc_boundary_on_pins([...])\n\nCreate hfss rlc boundary on pins.\n\nEdbHfss.create_vertical_circuit_port_on_clipped_traces([...])\n\nCreate an edge port on clipped signal traces.\n\nEdbHfss.create_voltage_source_on_net(...[, ...])\n\nCreate a voltage source.\n\nEdbHfss.create_voltage_source_on_pin(...[, ...])\n\nCreate a voltage source.\n\nEdbHfss.create_wave_port(prim_id, point_on_edge)\n\nCreate a wave port.\n\nEdbHfss.get_layout_bounding_box([layout, ...])\n\nEvaluate the layout bounding box.\n\nEdbHfss.get_ports_number()\n\nReturn the total number of excitation ports in a layout.\n\nEdbHfss.get_trace_width_for_traces_with_ports()\n\nRetrieve the trace width for traces with ports.\n\nEdbHfss.layout_defeaturing([simulation_setup])\n\nDefeature the layout by reducing the number of points for polygons based on surface deviation criteria.\n\nEdbHfss.set_coax_port_attributes([...])\n\nSet coaxial port attribute with forcing default impedance to 50 Ohms and adjusting the coaxial extent radius.\n\nEdbHfss.trim_component_reference_size([...])\n\nTrim the common component reference to the minimally acceptable size.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileStackup",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileStackup.html#controlfilestackup",
        "title": "ControlFileStackup",
        "section": "ControlFileStackup",
        "text": "Manages stackup information for the control file.\nLength units (e.g., “mm”, “um”). Default is “mm”.\nControlFileStackup.add_dielectric(layer_name)\nAdd a new dielectric layer.\nControlFileStackup.add_layer(layer_name[, ...])\nAdd a new layer.\nControlFileStackup.add_material(material_name)\nAdd a new material.\nControlFileStackup.add_via(layer_name[, ...])\nAdd a new via layer.\nControlFileStackup\npython:str\noptional\nControlFileStackup.add_dielectric\nControlFileStackup.add_layer\nControlFileStackup.add_material\nControlFileStackup.add_via"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileStackup",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileStackup.html#pyedb.grpc.database.control_file.ControlFileStackup",
        "title": "ControlFileStackup > ControlFileStackup > ControlFileStackup",
        "section": "ControlFileStackup > ControlFileStackup",
        "text": "class pyedb.grpc.database.control_file.ControlFileStackup(units: str = 'mm')\n\nManages stackup information for the control file.\n\nParameters\n\nunits\n\npython:str, optional\n\nLength units (e.g., “mm”, “um”). Default is “mm”.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nControlFileStackup.add_dielectric(layer_name)\n\nAdd a new dielectric layer.\n\nControlFileStackup.add_layer(layer_name[, ...])\n\nAdd a new layer.\n\nControlFileStackup.add_material(material_name)\n\nAdd a new material.\n\nControlFileStackup.add_via(layer_name[, ...])\n\nAdd a new via layer.\n\n"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.from_orm",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "from_orm"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.from_orm",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.from_orm.html#pyedb.workflows.drc.drc.Rules.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod Rules.from_orm(obj: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.circle_intersect",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.circle_intersect.html#circle_intersect",
        "title": "circle_intersect",
        "section": "circle_intersect",
        "text": "Determine whether the circle intersects with a polygon.\nCenter.\nRadius.\nTrue if the circle intersects with a polygon, False otherwise.\ncircle_intersect\npython:float\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.circle_intersect",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.circle_intersect.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.circle_intersect",
        "title": "circle_intersect > circle_intersect > circle_intersect",
        "section": "circle_intersect > circle_intersect",
        "text": "PolygonData.circle_intersect(center: PointLike, radius: float) -> bool\n\nDetermine whether the circle intersects with a polygon.\n\nParameters\n\ncenter\n\nPoint2DLike\n\nCenter.\n\nradius\n\npython:float\n\nRadius.\n\nReturns\n\nbool\n\nTrue if the circle intersects with a polygon, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.remove_self_intersections",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.remove_self_intersections.html#remove_self_intersections",
        "title": "remove_self_intersections",
        "section": "remove_self_intersections",
        "text": "Remove self-intersections from this polygon.\nTolerance.\nA list of non self-intersecting polygons.\nremove_self_intersections\npython:float\npython:list\nof\nPolygonData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.remove_self_intersections",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.remove_self_intersections.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.remove_self_intersections",
        "title": "remove_self_intersections > remove_self_intersections > remove_self_intersections",
        "section": "remove_self_intersections > remove_self_intersections",
        "text": "PolygonData.remove_self_intersections(tol: float = 1e-09) -> list[PolygonData]\n\nRemove self-intersections from this polygon.\n\nParameters\n\ntol\n\npython:float, default: 1e-9\n\nTolerance.\n\nReturns\n\npython:list of PolygonData\n\nA list of non self-intersecting polygons.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.parse_raw",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "parse_raw"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.parse_raw",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.parse_raw.html#pyedb.workflows.drc.drc.MinLineWidth.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod MinLineWidth.parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.set_backdrill_top",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.set_backdrill_top.html#set_backdrill_top",
        "title": "set_backdrill_top",
        "section": "set_backdrill_top",
        "text": "Set backdrill from top.\nName of the drill to layer.\nDiameter of backdrill size.\nOffset for the backdrill. The default is 0.0. If the value is other than the\ndefault, the stub does not stop at the layer. In AEDT, this parameter is called\n“Mfg stub length”.\nTrue if success, False otherwise.\nset_backdrill_top\npython:str\npython:float\npython:str\npython:float\npython:str\n0.0"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.set_backdrill_top",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.set_backdrill_top.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.set_backdrill_top",
        "title": "set_backdrill_top > set_backdrill_top > set_backdrill_top",
        "section": "set_backdrill_top > set_backdrill_top",
        "text": "EDBPadstackInstance.set_backdrill_top(drill_depth, drill_diameter, offset=0.0)\n\nSet backdrill from top.\n\nParameters\n\ndrill_depth\n\npython:str\n\nName of the drill to layer.\n\ndrill_diameter\n\npython:float, python:str\n\nDiameter of backdrill size.\n\noffset\n\npython:float, python:str\n\nOffset for the backdrill. The default is 0.0. If the value is other than the\ndefault, the stub does not stop at the layer. In AEDT, this parameter is called\n“Mfg stub length”.\n\nReturns\n\nbool\n\nTrue if success, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.type",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.type.html#type",
        "title": "type",
        "section": "type",
        "text": "type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.type",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.type.html#pyedb.grpc.database.ports.ports.GapPort.type",
        "title": "type > type > type",
        "section": "type > type",
        "text": "GapPort.type = 0\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_hfss_ports_on_padstack",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_hfss_ports_on_padstack.html#create_hfss_ports_on_padstack",
        "title": "create_hfss_ports_on_padstack",
        "section": "create_hfss_ports_on_padstack",
        "text": "Create an HFSS port on a padstack.\nPosition of the pin.\nName of the port. The default is None.\nTrue when successful, False when failed.\ncreate_hfss_ports_on_padstack\npython:str\noptional\nNone\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_hfss_ports_on_padstack",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_hfss_ports_on_padstack.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_hfss_ports_on_padstack",
        "title": "create_hfss_ports_on_padstack > create_hfss_ports_on_padstack > create_hfss_ports_on_padstack",
        "section": "create_hfss_ports_on_padstack > create_hfss_ports_on_padstack",
        "text": "SourceExcitation.create_hfss_ports_on_padstack(pinpos: PadstackInstance, portname: str | None = None) -> bool\n\nCreate an HFSS port on a padstack.\n\nParameters\n\npinpos\n\nPosition of the pin.\n\nportname\n\npython:str, optional\n\nName of the port. The default is None.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> pin = edb.padstacks.instances[0]\n>>> edb.source_excitation.create_hfss_ports_on_padstack(pin, \"Port1\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "index",
        "href": "index.html#welcome-to-pyedb-062dev0",
        "title": "Welcome to PyEDB 0.62.dev0",
        "section": "Welcome to PyEDB 0.62.dev0",
        "text": "Architecture Notice: Standalone gRPC Service\nPyEDB is a standalone Python client library that connects to the ansys-edb-core gRPC service.\nThe dotnet module is deprecated and archived with Ansys release 2026R1. Access the archived code and migration guide here.\nPyEDB is a Python client library that provides a high-level interface to create, modify, and analyze PCB designs by communicating with the ansys-edb-core gRPC service.\nWelcome to PyEDB 0.62.dev0\nFor users of the legacy pyedb.dotnet API\nansys-edb-core\ndotnet\nansys-edb-core"
    },
    {
        "objectID": "index",
        "href": "index.html#getting-started",
        "title": "Welcome to PyEDB 0.62.dev0 > Getting Started",
        "section": "Getting Started",
        "text": "Getting Started"
    },
    {
        "objectID": "index",
        "href": "index.html#reference",
        "title": "Welcome to PyEDB 0.62.dev0 > Reference",
        "section": "Reference",
        "text": "Reference"
    },
    {
        "objectID": "index",
        "href": "index.html#project",
        "title": "Welcome to PyEDB 0.62.dev0 > Project",
        "section": "Project",
        "text": "genindex\nProject"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_pins",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_pins.html#get_pins",
        "title": "get_pins",
        "section": "get_pins",
        "text": "Get component pins.\nReference designator of the component.\nName of the net.\nName of the pin.\nget_pins\npython:str\npython:str\noptional\npython:str\noptional"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_pins",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_pins.html#pyedb.dotnet.database.components.Components.get_pins",
        "title": "get_pins > get_pins > get_pins",
        "section": "get_pins > get_pins",
        "text": "Components.get_pins(reference_designator, net_name=None, pin_name=None)\n\nGet component pins.\n\nParameters\n\nreference_designator\n\npython:str\n\nReference designator of the component.\n\nnet_name\n\npython:str, optional\n\nName of the net.\n\npin_name\n\npython:str, optional\n\nName of the pin.\n\nReturns\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_post_init",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nmodel_post_init"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_post_init",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_post_init.html#pyedb.workflows.drc.drc.CopperBalance.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "CopperBalance.model_post_init(context: Any, /) -> None\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_circuit_port_on_pin",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_circuit_port_on_pin.html#create_circuit_port_on_pin",
        "title": "create_circuit_port_on_pin",
        "section": "create_circuit_port_on_pin",
        "text": "Create a circuit port on a pin.\nEdb Pin\nEdb Pin\nPort Impedance\nPort Name\nPort Name.\ncreate_circuit_port_on_pin\nObject\nObject\npython:float\npython:str\noptional\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_circuit_port_on_pin",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_circuit_port_on_pin.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_circuit_port_on_pin",
        "title": "create_circuit_port_on_pin > create_circuit_port_on_pin > create_circuit_port_on_pin",
        "section": "create_circuit_port_on_pin > create_circuit_port_on_pin",
        "text": "SourceExcitation.create_circuit_port_on_pin(pos_pin: str | PadstackInstance, neg_pin: str | PadstackInstance, impedance: int | float = 50, port_name: str | None = None) -> str | None\n\nCreate a circuit port on a pin.\n\nParameters\n\npos_pin\n\nObject\n\nEdb Pin\n\nneg_pin\n\nObject\n\nEdb Pin\n\nimpedance\n\npython:float\n\nPort Impedance\n\nport_name\n\npython:str, optional\n\nPort Name\n\nReturns\n\npython:str\n\nPort Name.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", \"project name\", \"release version\")\n>>> pins = edbapp.components.get_pin_from_component(\"U2A5\")\n>>> edbapp.siwave.create_circuit_port_on_pin(pins[0], pins[1], 50, \"port_name\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOperation",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOperation.html#meshoperation",
        "title": "MeshOperation",
        "section": "MeshOperation",
        "text": "Mesh Operation Class.\nMeshOperation"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOperation",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOperation.html#pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOperation",
        "title": "MeshOperation > MeshOperation > MeshOperation",
        "section": "MeshOperation > MeshOperation",
        "text": "class pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOperation(parent, edb_object)\n\nMesh Operation Class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_config",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_config",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_config.html#pyedb.workflows.drc.drc.CopperBalance.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "CopperBalance.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.parse_obj",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "parse_obj"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.parse_obj",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.parse_obj.html#pyedb.workflows.drc.drc.MinLineWidth.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod MinLineWidth.parse_obj(obj: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.set_sim_setup_info",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.set_sim_setup_info.html#set_sim_setup_info",
        "title": "set_sim_setup_info",
        "section": "set_sim_setup_info",
        "text": "set_sim_setup_info"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.set_sim_setup_info",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.set_sim_setup_info.html#pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.set_sim_setup_info",
        "title": "set_sim_setup_info > set_sim_setup_info > set_sim_setup_info",
        "section": "set_sim_setup_info > set_sim_setup_info",
        "text": "SiwaveDCSimulationSetup.set_sim_setup_info(sim_setup_info)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.from_orm",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "from_orm"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.from_orm",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.from_orm.html#pyedb.workflows.drc.drc.MinClearance.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod MinClearance.from_orm(obj: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.set_end_cap_style",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.set_end_cap_style.html#set_end_cap_style",
        "title": "set_end_cap_style",
        "section": "set_end_cap_style",
        "text": "Set end cap styles for the path.\nEnd cap style for the start of the path.\nEnd cap style for the end of the path.\nset_end_cap_style\nPathEndCapType\nPathEndCapType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.set_end_cap_style",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.set_end_cap_style.html#pyedb.grpc.database.primitive.path.Path.set_end_cap_style",
        "title": "set_end_cap_style > set_end_cap_style > set_end_cap_style",
        "section": "set_end_cap_style > set_end_cap_style",
        "text": "Path.set_end_cap_style(end_cap1: PathEndCapType, end_cap2: PathEndCapType)\n\nSet end cap styles for the path.\n\nParameters\n\nend_cap1\n\nPathEndCapType\n\nEnd cap style for the start of the path.\n\nend_cap2\n\nPathEndCapType\n\nEnd cap style for the end of the path.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.Dielectric",
        "href": "libraries/_autosummary/pyedb.libraries.common.Dielectric.html#dielectric",
        "title": "Dielectric",
        "section": "Dielectric",
        "text": "Dielectric material with relative permittivity and loss tangent.\nActive EDB session.\nMaterial name.\nRelative permittivity (εᵣ).  Default is 11.9 (Silicon).\nLoss tangent (tan δ).  Default is 0.02.\nDielectric\nansys.edb.core.database.Database\npython:str\npython:float\noptional\npython:float\noptional"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.Dielectric",
        "href": "libraries/_autosummary/pyedb.libraries.common.Dielectric.html#pyedb.libraries.common.Dielectric",
        "title": "Dielectric > Dielectric > Dielectric",
        "section": "Dielectric > Dielectric",
        "text": "class pyedb.libraries.common.Dielectric(pedb, name: str, permittivity: float = 11.9, loss_tg: float = 0.02)\n\nDielectric material with relative permittivity and loss tangent.\n\nParameters\n\npedb\n\nansys.edb.core.database.Database\n\nActive EDB session.\n\nname\n\npython:str\n\nMaterial name.\n\npermittivity\n\npython:float, optional\n\nRelative permittivity (εᵣ).  Default is 11.9 (Silicon).\n\nloss_tg\n\npython:float, optional\n\nLoss tangent (tan δ).  Default is 0.02.\n\nExamples\n\n>>> sub = Dielectric(edb, \"Silicon\", permittivity=11.9, loss_tg=0.01)\n>>> sub.permittivity\n11.9\n>>> sub.loss_tg = 0.005\n>>> edb.materials[\"Silicon\"].loss_tangent\n0.005\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.spice_model.SpiceModel.add_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.spice_model.SpiceModel.add_terminal.html#add_terminal",
        "title": "add_terminal",
        "section": "add_terminal",
        "text": "Add a terminal with a pin number.\nTerminal name to associate with the pin.\nPin number.\nadd_terminal\npython:str\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.spice_model.SpiceModel.add_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.spice_model.SpiceModel.add_terminal.html#pyedb.grpc.database.hierarchy.spice_model.SpiceModel.add_terminal",
        "title": "add_terminal > add_terminal > add_terminal",
        "section": "add_terminal > add_terminal",
        "text": "SpiceModel.add_terminal(terminal, pin)\n\nAdd a terminal with a pin number.\n\nParameters\n\nterminal\n\npython:str\n\nTerminal name to associate with the pin.\n\npin\n\npython:str\n\nPin number.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.find_by_id.html#find_by_id",
        "title": "find_by_id",
        "section": "find_by_id",
        "text": "Find a Connectable object by database ID in a given layout.\nLayout to search for the Connectable object.\nDatabase ID.\nConnectable object with the given database ID.\nfind_by_id\nLayout\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.find_by_id.html#pyedb.grpc.database.hierarchy.pingroup.PinGroup.find_by_id",
        "title": "find_by_id > find_by_id > find_by_id",
        "section": "find_by_id > find_by_id",
        "text": "classmethod PinGroup.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the Connectable object.\n\nuid\n\npython:int\n\nDatabase ID.\n\nReturns\n\nConnectable\n\nConnectable object with the given database ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "validate"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.validate.html#pyedb.workflows.drc.drc.MinLineWidth.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod MinLineWidth.validate(value: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.illegal_net_names",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.illegal_net_names.html#illegal_net_names",
        "title": "illegal_net_names",
        "section": "illegal_net_names",
        "text": "Find and fix illegal net names.\nillegal_net_names"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.illegal_net_names",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.illegal_net_names.html#pyedb.grpc.database.layout_validation.LayoutValidation.illegal_net_names",
        "title": "illegal_net_names > illegal_net_names > illegal_net_names",
        "section": "illegal_net_names > illegal_net_names",
        "text": "LayoutValidation.illegal_net_names(fix: bool = False) -> None\n\nFind and fix illegal net names.\n\nExamples\n\n>>> edb = Edb(\"edb_file\")\n>>> # Identify illegal net names\n>>> edb.layout_validation.illegal_net_names()\n>>>\n>>> # Find and automatically fix illegal names\n>>> edb.layout_validation.illegal_net_names(fix=True)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.create_hfss.html#create_hfss",
        "title": "create_hfss",
        "section": "create_hfss",
        "text": "Create an HFSS model from an MCAD file.\nHFSS model created.\ncreate_hfss\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.create_hfss.html#pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.create_hfss",
        "title": "create_hfss > create_hfss > create_hfss",
        "section": "create_hfss > create_hfss",
        "text": "EdgeTerminal.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nReturns\n\nMcadModel\n\nHFSS model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.parse_obj",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "parse_obj"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.parse_obj",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.parse_obj.html#pyedb.workflows.drc.drc.DiffPair.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod DiffPair.parse_obj(obj: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.is_parameter",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.is_parameter.html#is_parameter",
        "title": "is_parameter",
        "section": "is_parameter",
        "text": "Determine if the variable is a parameter.\nVariable name.\nTrue if the variable is a parameter, False otherwise.\nis_parameter\npython:str\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.is_parameter",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.is_parameter.html#pyedb.grpc.database.layout.cell.Cell.is_parameter",
        "title": "is_parameter > is_parameter > is_parameter",
        "section": "is_parameter > is_parameter",
        "text": "Cell.is_parameter(name)\n\nDetermine if the variable is a parameter.\n\nParameters\n\nname\n\npython:str\n\nVariable name.\n\nReturns\n\nbool\n\nTrue if the variable is a parameter, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.create_stride.html#create_stride",
        "title": "create_stride",
        "section": "create_stride",
        "text": "Create a Stride model from an MCAD file.\nStride model created.\ncreate_stride\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.create_stride.html#pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.create_stride",
        "title": "create_stride > create_stride > create_stride",
        "section": "create_stride > create_stride",
        "text": "EdgeTerminal.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nReturns\n\nMcadModel\n\nStride model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCSettings.get_configurations",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCSettings.get_configurations.html#get_configurations",
        "title": "get_configurations",
        "section": "get_configurations",
        "text": "Get all attributes.\nget_configurations\npython:dict"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCSettings.get_configurations",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCSettings.get_configurations.html#pyedb.dotnet.database.sim_setup_data.io.siwave.DCSettings.get_configurations",
        "title": "get_configurations > get_configurations > get_configurations",
        "section": "get_configurations > get_configurations",
        "text": "DCSettings.get_configurations()\n\nGet all attributes.\n\nReturns\n\npython:dict\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_current_source_on_pin_group",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_current_source_on_pin_group.html#create_current_source_on_pin_group",
        "title": "create_current_source_on_pin_group",
        "section": "create_current_source_on_pin_group",
        "text": "Create current source between two pin groups.\nName of the positive pin group.\nName of the negative pin group.\nMagnitude of the source.\nPhase of the source\ncreate_current_source_on_pin_group\npython:str\npython:str\npython:int\npython:float\noptional\npython:int\npython:float\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_current_source_on_pin_group",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_current_source_on_pin_group.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_current_source_on_pin_group",
        "title": "create_current_source_on_pin_group > create_current_source_on_pin_group > create_current_source_on_pin_group",
        "section": "create_current_source_on_pin_group > create_current_source_on_pin_group",
        "text": "SourceExcitation.create_current_source_on_pin_group(pos_pin_group_name: str, neg_pin_group_name: str, magnitude: int | float = 1, phase: int | float = 0, name: str | None = None) -> bool\n\nCreate current source between two pin groups.\n\nParameters\n\npos_pin_group_name\n\npython:str\n\nName of the positive pin group.\n\nneg_pin_group_name\n\npython:str\n\nName of the negative pin group.\n\nmagnitude\n\npython:int, python:float, optional\n\nMagnitude of the source.\n\nphase\n\npython:int, python:float, optional\n\nPhase of the source\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.remove_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.remove_hfss_prop.html#remove_hfss_prop",
        "title": "remove_hfss_prop",
        "section": "remove_hfss_prop",
        "text": "Remove HFSS properties.\nremove_hfss_prop"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.remove_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.remove_hfss_prop.html#pyedb.grpc.database.primitive.primitive.Primitive.remove_hfss_prop",
        "title": "remove_hfss_prop > remove_hfss_prop > remove_hfss_prop",
        "section": "remove_hfss_prop > remove_hfss_prop",
        "text": "Primitive.remove_hfss_prop()\n\nRemove HFSS properties.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_json_schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias: Whether to use attribute aliases or not.\nref_template: The reference template.\nunion_format: The format to use when combining schemas from unions together. Can be one of:\n‘any_of’: Use the [anyOf](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\nkeyword to combine schemas (the default).\n- ‘primitive_type_array’: Use the [type](https://json-schema.org/understanding-json-schema/reference/type)\nkeyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\ntype (string, boolean, null, integer or number) or contains constraints/metadata, falls back to\nany_of.\nGenerateJsonSchema with your desired modifications\nmode: The mode in which to generate the schema.\nThe JSON schema for the given model class.\nmodel_json_schema"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_json_schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_json_schema.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod DiffPairLengthMatch.model_json_schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}', schema_generator: type[~pydantic.json_schema.GenerateJsonSchema] = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: ~typing.Literal['validation', 'serialization'] = 'validation', *, union_format: ~typing.Literal['any_of', 'primitive_type_array'] = 'any_of') -> dict[str, Any]\n\nGenerates a JSON schema for a model class.\n\nArgs:\n\nby_alias: Whether to use attribute aliases or not.\nref_template: The reference template.\nunion_format: The format to use when combining schemas from unions together. Can be one of:\n\n‘any_of’: Use the [anyOf](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n\nkeyword to combine schemas (the default).\n- ‘primitive_type_array’: Use the [type](https://json-schema.org/understanding-json-schema/reference/type)\nkeyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\ntype (string, boolean, null, integer or number) or contains constraints/metadata, falls back to\nany_of.\n\nschema_generator: To override the logic used to generate the JSON schema, as a subclass of\n\nGenerateJsonSchema with your desired modifications\n\nmode: The mode in which to generate the schema.\n\nReturns:\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileBoundaries.add_extent",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileBoundaries.add_extent.html#add_extent",
        "title": "add_extent",
        "section": "add_extent",
        "text": "Add a new extent.\nadd_extent"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileBoundaries.add_extent",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileBoundaries.add_extent.html#pyedb.grpc.database.utility.xml_control_file.ControlFileBoundaries.add_extent",
        "title": "add_extent > add_extent > add_extent",
        "section": "add_extent > add_extent",
        "text": "ControlFileBoundaries.add_extent(type='bbox', dieltype='bbox', diel_hactor=0.25, airbox_hfactor=0.25, airbox_vr_p=0.25, airbox_vr_n=0.25, useradiation=True, honor_primitives=True, truncate_at_gnd=True)\n\nAdd a new extent.\n\nParameters\n\ntype\n\n\n\ndieltype\n\n\n\ndiel_hactor\n\n\n\nairbox_hfactor\n\n\n\nairbox_vr_p\n\n\n\nairbox_vr_n\n\n\n\nuseradiation\n\n\n\nhonor_primitives\n\n\n\ntruncate_at_gnd\n\n\n\nReturns\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.set_product_property.html#pyedb.grpc.database.net.differential_pair.DifferentialPair.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "DifferentialPair.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kTransient",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kTransient.html#ktransient",
        "title": "kTransient",
        "section": "kTransient",
        "text": "kTransient"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kTransient",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kTransient.html#pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kTransient",
        "title": "kTransient > kTransient > kTransient",
        "section": "kTransient > kTransient",
        "text": "SimulationSetupType.kTransient = 'transient'\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.rotate",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.rotate.html#rotate",
        "title": "rotate",
        "section": "rotate",
        "text": "Rotate a point at a given center by a given angle.\nAngle in radians.\nCenter.\nPointData after rotating or None if either point is an arc.\nrotate\npython:float\nPointData\nNone\nNone"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.rotate",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.rotate.html#pyedb.grpc.database.geometry.point_data.PointData.rotate",
        "title": "rotate > rotate > rotate",
        "section": "rotate > rotate",
        "text": "PointData.rotate(angle: float, center: PointLike) -> PointData | None\n\nRotate a point at a given center by a given angle.\n\nParameters\n\nangle\n\npython:float\n\nAngle in radians.\n\ncenter\n\nPoint2DLike\n\nCenter.\n\nReturns\n\nPointData or None\n\nPointData after rotating or None if either point is an arc.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.update",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.update.html#update",
        "title": "update",
        "section": "update",
        "text": "update"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.update",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.update.html#pyedb.grpc.database.layers.stackup_layer.StackupLayer.update",
        "title": "update > update > update",
        "section": "update > update",
        "text": "StackupLayer.update(**kwargs)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/hfss_dcr_settings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/hfss_dcr_settings.html#hfss-dcr-settings",
        "title": "HFSS dcr settings",
        "section": "HFSS dcr settings",
        "text": "This class is managing EDB HFSS dcr settings.\nHFSSDCRSettings\nPyEDB-core HFSS DC settings class.\nHFSS dcr settings\nHFSSDCRSettings"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_validate_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data: The JSON data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nThe validated Pydantic model.\nValidationError: If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_validate_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_validate_json.html#pyedb.workflows.drc.drc.MinClearance.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod MinClearance.model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n\njson_data: The JSON data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nReturns:\n\nThe validated Pydantic model.\n\nRaises:\n\nValidationError: If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_parametrized_name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nString representing the new class where params are passed to cls as type variables.\nTypeError: Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_parametrized_name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_parametrized_name.html#pyedb.workflows.drc.drc.CopperBalance.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod CopperBalance.model_parametrized_name(params: tuple[type[Any], ...]) -> str\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n\nparams: Tuple of types of the class. Given a generic class\n\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturns:\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises:\n\nTypeError: Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.configure_hfss_extents",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.configure_hfss_extents.html#configure_hfss_extents",
        "title": "configure_hfss_extents",
        "section": "configure_hfss_extents",
        "text": "Configure the HFSS extent box.\nEdb_DATA.SimulationConfiguration object\nTrue when succeeded, False when failed.\nconfigure_hfss_extents"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.configure_hfss_extents",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.configure_hfss_extents.html#pyedb.dotnet.database.hfss.EdbHfss.configure_hfss_extents",
        "title": "configure_hfss_extents > configure_hfss_extents > configure_hfss_extents",
        "section": "configure_hfss_extents > configure_hfss_extents",
        "text": "EdbHfss.configure_hfss_extents(simulation_setup=None)\n\nConfigure the HFSS extent box.\n\nParameters\n\nsimulation_setup\n\nEdb_DATA.SimulationConfiguration object\n\nReturns\n\nbool\n\nTrue when succeeded, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileComponents.add_component",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileComponents.add_component.html#add_component",
        "title": "add_component",
        "section": "add_component",
        "text": "Add a new component.\nReference designator.\nPart name.\nComponent type (“IC”, “IO”, or “Other”).\nDie type (“None”, “Flip chip”, or “Wire bond”). Default is “None”.\nSolderball shape (“None”, “Cylinder”, or “Spheroid”). Default is “None”.\nCreated component object.\nadd_component\npython:str\npython:str\npython:str\npython:str\noptional\npython:str\noptional\nControlFileComponent"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileComponents.add_component",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileComponents.add_component.html#pyedb.grpc.database.control_file.ControlFileComponents.add_component",
        "title": "add_component > add_component > add_component",
        "section": "add_component > add_component",
        "text": "ControlFileComponents.add_component(ref_des: str, partname: str, component_type: str, die_type: str = 'None', solderball_shape: str = 'None') -> ControlFileComponent\n\nAdd a new component.\n\nParameters\n\nref_des\n\npython:str\n\nReference designator.\n\npartname\n\npython:str\n\nPart name.\n\ncomponent_type\n\npython:str\n\nComponent type (“IC”, “IO”, or “Other”).\n\ndie_type\n\npython:str, optional\n\nDie type (“None”, “Flip chip”, or “Wire bond”). Default is “None”.\n\nsolderball_shape\n\npython:str, optional\n\nSolderball shape (“None”, “Cylinder”, or “Spheroid”). Default is “None”.\n\nReturns\n\nControlFileComponent\n\nCreated component object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.dict",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "dict"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.dict",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.dict.html#pyedb.workflows.drc.drc.Rules.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "Rules.dict(*, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Dict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.magnitude",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.magnitude.html#magnitude",
        "title": "magnitude",
        "section": "magnitude",
        "text": "Get the magnitude of the point vector.\nMagnitude of the point vector.\nmagnitude\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.magnitude",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.magnitude.html#pyedb.grpc.database.geometry.point_data.PointData.magnitude",
        "title": "magnitude > magnitude > magnitude",
        "section": "magnitude > magnitude",
        "text": "PointData.magnitude() -> float\n\nGet the magnitude of the point vector.\n\nReturns\n\npython:float\n\nMagnitude of the point vector.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.add_frequencies",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.add_frequencies.html#add_frequencies",
        "title": "add_frequencies",
        "section": "add_frequencies",
        "text": "add_frequencies"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.add_frequencies",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.add_frequencies.html#pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.add_frequencies",
        "title": "add_frequencies > add_frequencies > add_frequencies",
        "section": "add_frequencies > add_frequencies",
        "text": "SweepData.add_frequencies(frequencies)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.has_holes",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.has_holes.html#has_holes",
        "title": "has_holes",
        "section": "has_holes",
        "text": "Determine whether the polygon contains any holes.\nTrue when the polygon contains holes, False otherwise.\nhas_holes\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.has_holes",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.has_holes.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.has_holes",
        "title": "has_holes > has_holes > has_holes",
        "section": "has_holes > has_holes",
        "text": "PolygonData.has_holes() -> bool\n\nDetermine whether the polygon contains any holes.\n\nReturns\n\nbool\n\nTrue when the polygon contains holes, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.synchronize_bend_manager",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.synchronize_bend_manager.html#synchronize_bend_manager",
        "title": "synchronize_bend_manager",
        "section": "synchronize_bend_manager",
        "text": "Synchronize the bend manager.\nMost operations related to bends require this to be called first. If changes are made to the geometry\nin the design, it may be necessary to call this method again to ensure all bend related data is\nsynchronized correctly.\nsynchronize_bend_manager"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.synchronize_bend_manager",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.synchronize_bend_manager.html#pyedb.grpc.database.layout.layout.Layout.synchronize_bend_manager",
        "title": "synchronize_bend_manager > synchronize_bend_manager > synchronize_bend_manager",
        "section": "synchronize_bend_manager > synchronize_bend_manager",
        "text": "Layout.synchronize_bend_manager()\n\nSynchronize the bend manager.\n\nNotes\n\nMost operations related to bends require this to be called first. If changes are made to the geometry\nin the design, it may be necessary to call this method again to ensure all bend related data is\nsynchronized correctly.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.json.html#json",
        "title": "json",
        "section": "json",
        "text": "json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.json.html#pyedb.workflows.drc.drc.MinClearance.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "MinClearance.json(*, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -> str\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.set_product_property.html#pyedb.grpc.database.terminal.point_terminal.PointTerminal.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "PointTerminal.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.create_hfss.html#create_hfss",
        "title": "create_hfss",
        "section": "create_hfss",
        "text": "Create an HFSS model from an MCAD file.\nHFSS model created.\ncreate_hfss\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.create_hfss.html#pyedb.grpc.database.primitive.circle.Circle.create_hfss",
        "title": "create_hfss > create_hfss > create_hfss",
        "section": "create_hfss > create_hfss",
        "text": "Circle.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nReturns\n\nMcadModel\n\nHFSS model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/pingroup_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/pingroup_terminal.html#pingroup-terminal",
        "title": "Pingroup terminal",
        "section": "Pingroup terminal",
        "text": "This class is managing EDB pingroup terminal.\nPinGroupTerminal\nManages pin group terminal properties.\nPingroup terminal\nPinGroupTerminal"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_connected_objects",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_connected_objects.html#get_connected_objects",
        "title": "get_connected_objects",
        "section": "get_connected_objects",
        "text": "Get connected objects.\nget_connected_objects\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_connected_objects",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_connected_objects.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_connected_objects",
        "title": "get_connected_objects > get_connected_objects > get_connected_objects",
        "section": "get_connected_objects > get_connected_objects",
        "text": "EdbPolygon.get_connected_objects()\n\nGet connected objects.\n\nReturns\n\npython:list\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.DielectricLayer",
        "href": "libraries/_autosummary/pyedb.libraries.common.DielectricLayer.html#dielectriclayer",
        "title": "DielectricLayer",
        "section": "DielectricLayer",
        "text": "Convenience wrapper for dielectric layers.\nAutomatically creates a Dielectric material.\nActive EDB session.\nLayer name.\nThickness in meters.  Default is 1 µm.\nName of the dielectric material.  Default is \"FR4\".\nDielectricLayer\nDielectric\nansys.edb.core.database.Database\npython:str\npython:float\noptional\npython:str\noptional\n\"FR4\""
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.DielectricLayer",
        "href": "libraries/_autosummary/pyedb.libraries.common.DielectricLayer.html#pyedb.libraries.common.DielectricLayer",
        "title": "DielectricLayer > DielectricLayer > DielectricLayer",
        "section": "DielectricLayer > DielectricLayer",
        "text": "class pyedb.libraries.common.DielectricLayer(pedb, name, thickness=1e-06, material: str = 'FR4')\n\nConvenience wrapper for dielectric layers.\n\nAutomatically creates a Dielectric material.\n\nParameters\n\npedb\n\nansys.edb.core.database.Database\n\nActive EDB session.\n\nname\n\npython:str\n\nLayer name.\n\nthickness\n\npython:float, optional\n\nThickness in meters.  Default is 1 µm.\n\nmaterial\n\npython:str, optional\n\nName of the dielectric material.  Default is \"FR4\".\n\nExamples\n\n>>> core = DielectricLayer(edb, \"Core\", thickness=100e-6, material=\"FR4\")\n>>> core.material.permittivity\n4.4\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.set_backdrill_bottom",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.set_backdrill_bottom.html#set_backdrill_bottom",
        "title": "set_backdrill_bottom",
        "section": "set_backdrill_bottom",
        "text": "Set backdrill from bottom.\nName of the drill to layer.\nDiameter of the backdrill size.\nOffset for the backdrill. The default is 0.0. If the value is other than the\ndefault, the stub does not stop at the layer. In AEDT, this parameter is called\n“Mfg stub length”.\nTrue if success, False otherwise.\nset_backdrill_bottom\npython:str\npython:float\npython:str\npython:float\npython:str\noptional\n0.0"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.set_backdrill_bottom",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.set_backdrill_bottom.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.set_backdrill_bottom",
        "title": "set_backdrill_bottom > set_backdrill_bottom > set_backdrill_bottom",
        "section": "set_backdrill_bottom > set_backdrill_bottom",
        "text": "EDBPadstackInstance.set_backdrill_bottom(drill_depth, drill_diameter, offset=0.0)\n\nSet backdrill from bottom.\n\nParameters\n\ndrill_depth\n\npython:str\n\nName of the drill to layer.\n\ndrill_diameter\n\npython:float, python:str\n\nDiameter of the backdrill size.\n\noffset\n\npython:float, python:str, optional\n\nOffset for the backdrill. The default is 0.0. If the value is other than the\ndefault, the stub does not stop at the layer. In AEDT, this parameter is called\n“Mfg stub length”.\n\nReturns\n\nbool\n\nTrue if success, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs for a given product ID for the layer.\nProduct ID.\nList of attribute IDs.\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.get_product_property_ids.html#pyedb.grpc.database.layers.layer.Layer.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "Layer.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs for a given product ID for the layer.\n\nParameters\n\nprod_id\n\nProductIdType\n\nProduct ID.\n\nReturns\n\npython:list[python:int]\n\nList of attribute IDs.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.add_frequency_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.add_frequency_sweep.html#add_frequency_sweep",
        "title": "add_frequency_sweep",
        "section": "add_frequency_sweep",
        "text": "Add frequency sweep.\nName of the frequency sweep. The default is None.\nList of frequency points. The default is None.\nadd_frequency_sweep\npython:str\noptional\nNone\npython:list\noptional\nNone\npyedb.dotnet.database.edb_data.simulation_setup_data.EdbFrequencySweep"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.add_frequency_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.add_frequency_sweep.html#pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.add_frequency_sweep",
        "title": "add_frequency_sweep > add_frequency_sweep > add_frequency_sweep",
        "section": "add_frequency_sweep > add_frequency_sweep",
        "text": "HfssSimulationSetup.add_frequency_sweep(name=None, frequency_sweep=None)\n\nAdd frequency sweep.\n\nParameters\n\nname\n\npython:str, optional\n\nName of the frequency sweep. The default is None.\n\nfrequency_sweep\n\npython:list, optional\n\nList of frequency points. The default is None.\n\nReturns\n\npyedb.dotnet.database.edb_data.simulation_setup_data.EdbFrequencySweep\n\n\n\nExamples\n\n>>> setup1 = edbapp.create_siwave_syz_setup(\"setup1\")\n>>> setup1.add_frequency_sweep(\n...     frequency_sweep=[\n...         [\"linear count\", \"0\", \"1kHz\", 1],\n...         [\"log scale\", \"1kHz\", \"0.1GHz\", 10],\n...         [\"linear scale\", \"0.1GHz\", \"10GHz\", \"0.1GHz\"],\n...     ]\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_product_property.html#pyedb.grpc.database.primitive.bondwire.Bondwire.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "Bondwire.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_differential_wave_port",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_differential_wave_port.html#create_differential_wave_port",
        "title": "create_differential_wave_port",
        "section": "create_differential_wave_port",
        "text": "Create a differential wave port.\nPrimitive ID of the positive terminal.\nCoordinate of the point to define the edge terminal.\nThe point must be close to the target edge but not on the two\nends of the edge.\nPrimitive ID of the negative terminal.\nCoordinate of the point to define the edge terminal.\nThe point must be close to the target edge but not on the two\nends of the edge.\nName of the port. The default is None.\nHorizontal extent factor. The default value is 5.\nVertical extent factor. The default value is 3.\nLaunch Width of PEC. The default value is \"0.01mm\".\nThe tuple contains: (port_name, pyedb.dotnet.database.edb_data.sources.ExcitationDifferential).\ncreate_differential_wave_port\npython:int\nEDBPrimitives\npython:list\npython:int\nEDBPrimitives\npython:list\npython:str\noptional\nNone\npython:int\npython:float\noptional\n5\npython:int\npython:float\noptional\n3\npython:str\noptional\n\"0.01mm\"\npython:tuple"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_differential_wave_port",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_differential_wave_port.html#pyedb.dotnet.database.hfss.EdbHfss.create_differential_wave_port",
        "title": "create_differential_wave_port > create_differential_wave_port > create_differential_wave_port",
        "section": "create_differential_wave_port > create_differential_wave_port",
        "text": "EdbHfss.create_differential_wave_port(positive_primitive_id, positive_points_on_edge, negative_primitive_id, negative_points_on_edge, port_name=None, horizontal_extent_factor=5, vertical_extent_factor=3, pec_launch_width='0.01mm')\n\nCreate a differential wave port.\n\nParameters\n\npositive_primitive_id\n\npython:int, EDBPrimitives\n\nPrimitive ID of the positive terminal.\n\npositive_points_on_edge\n\npython:list\n\nCoordinate of the point to define the edge terminal.\nThe point must be close to the target edge but not on the two\nends of the edge.\n\nnegative_primitive_id\n\npython:int, EDBPrimitives\n\nPrimitive ID of the negative terminal.\n\nnegative_points_on_edge\n\npython:list\n\nCoordinate of the point to define the edge terminal.\nThe point must be close to the target edge but not on the two\nends of the edge.\n\nport_name\n\npython:str, optional\n\nName of the port. The default is None.\n\nhorizontal_extent_factor\n\npython:int, python:float, optional\n\nHorizontal extent factor. The default value is 5.\n\nvertical_extent_factor\n\npython:int, python:float, optional\n\nVertical extent factor. The default value is 3.\n\npec_launch_width\n\npython:str, optional\n\nLaunch Width of PEC. The default value is \"0.01mm\".\n\nReturns\n\npython:tuple\n\nThe tuple contains: (port_name, pyedb.dotnet.database.edb_data.sources.ExcitationDifferential).\n\nExamples\n\n>>> edb.hfss.create_differential_wave_port(0, [\"-50mm\", \"-0mm\"], 1, [\"-50mm\", \"-0.2mm\"])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.create_stride.html#create_stride",
        "title": "create_stride",
        "section": "create_stride",
        "text": "Create a Stride model from an MCAD file.\nStride model created.\ncreate_stride\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.create_stride.html#pyedb.grpc.database.primitive.bondwire.Bondwire.create_stride",
        "title": "create_stride > create_stride > create_stride",
        "section": "create_stride > create_stride",
        "text": "Bondwire.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nReturns\n\nMcadModel\n\nStride model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.bbox",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.bbox.html#bbox",
        "title": "bbox",
        "section": "bbox",
        "text": "Compute the bounding box.\nbbox\npython:tuple\nof\nPointData\nPointData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.bbox",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.bbox.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.bbox",
        "title": "bbox > bbox > bbox",
        "section": "bbox > bbox",
        "text": "PolygonData.bbox() -> tuple[PointData, PointData]\n\nCompute the bounding box.\n\nReturns\n\npython:tuple of (PointData, PointData)\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the layout object.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.delete.html#pyedb.grpc.database.ports.ports.CoaxPort.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "CoaxPort.delete()\n\nDelete the layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.fix_self_intersections",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.fix_self_intersections.html#fix_self_intersections",
        "title": "fix_self_intersections",
        "section": "fix_self_intersections",
        "text": "Remove self intersections if they exists.\nAll new polygons created from the removal operation.\nfix_self_intersections\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.fix_self_intersections",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.fix_self_intersections.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.fix_self_intersections",
        "title": "fix_self_intersections > fix_self_intersections > fix_self_intersections",
        "section": "fix_self_intersections > fix_self_intersections",
        "text": "EdbPolygon.fix_self_intersections()\n\nRemove self intersections if they exists.\n\nReturns\n\npython:list\n\nAll new polygons created from the removal operation.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.DcrSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.DcrSettings.html#dcrsettings",
        "title": "DcrSettings",
        "section": "DcrSettings",
        "text": "Manages EDB methods for DCR settings.\nDcrSettings"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.DcrSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.DcrSettings.html#pyedb.dotnet.database.sim_setup_data.data.settings.DcrSettings",
        "title": "DcrSettings > DcrSettings > DcrSettings",
        "section": "DcrSettings > DcrSettings",
        "text": "class pyedb.dotnet.database.sim_setup_data.data.settings.DcrSettings(parent)\n\nManages EDB methods for DCR settings.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.without_arcs",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.without_arcs.html#without_arcs",
        "title": "without_arcs",
        "section": "without_arcs",
        "text": "Get polygon data with all arcs removed.\nwithout_arcs\npython:float\npython:float\nmath.pi\npython:int\nPolygonData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.without_arcs",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.without_arcs.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.without_arcs",
        "title": "without_arcs > without_arcs > without_arcs",
        "section": "without_arcs > without_arcs",
        "text": "PolygonData.without_arcs(max_chord_error: float = 0, max_arc_angle: float = 0.5235987755982988, max_points: int = 8) -> PolygonData\n\nGet polygon data with all arcs removed.\n\nParameters\n\nmax_chord_error\n\npython:float, default: 0\n\n\n\nmax_arc_angle\n\npython:float, default: math.pi\n\n\n\nmax_points\n\npython:int, default: 8\n\n\n\nReturns\n\nPolygonData\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.create_3d_comp.html#create_3d_comp",
        "title": "create_3d_comp",
        "section": "create_3d_comp",
        "text": "Create a 3D composite model from an MCAD file.\n3D composite model created.\ncreate_3d_comp\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.create_3d_comp.html#pyedb.grpc.database.primitive.circle.Circle.create_3d_comp",
        "title": "create_3d_comp > create_3d_comp > create_3d_comp",
        "section": "create_3d_comp > create_3d_comp",
        "text": "Circle.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nReturns\n\nMcadModel\n\n3D composite model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.heat_sink.HeatSink",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.heat_sink.HeatSink.html#heatsink",
        "title": "HeatSink",
        "section": "HeatSink",
        "text": "Heatsink model description.\nInherited object.\nHeatSink\nEdb"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.heat_sink.HeatSink",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.heat_sink.HeatSink.html#pyedb.grpc.database.utility.heat_sink.HeatSink",
        "title": "HeatSink > HeatSink > HeatSink",
        "section": "HeatSink > HeatSink",
        "text": "class pyedb.grpc.database.utility.heat_sink.HeatSink(pedb, edb_object)\n\nHeatsink model description.\n\nParameters\n\npedb\n\nEdb\n\nInherited object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_rectangle",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_rectangle.html#create_rectangle",
        "title": "create_rectangle",
        "section": "create_rectangle",
        "text": "Create rectangle.\nName of the layer on which to create the rectangle.\nName of the net. The default is \"\".\nLower left point when representation_type=\"LowerLeftUpperRight\". The default is \"\".\nUpper right point when representation_type=\"LowerLeftUpperRight\". The default is \"\".\nCenter point when representation_type=\"CenterWidthHeight\". The default is \"\".\nWidth of the rectangle when representation_type=\"CenterWidthHeight\". The default is \"\".\nHeight of the rectangle when representation_type=\"CenterWidthHeight\". The default is \"\".\nType of the rectangle representation. The default is LowerLeftUpperRight. Options are\n\"LowerLeftUpperRight\" and \"CenterWidthHeight\".\nRadius of the rectangle corner. The default is \"0mm\".\nRotation of the rectangle. The default is \"0deg\".\nRectangle when successful, False when failed.\ncreate_rectangle\npython:str\npython:str\n\"\"\npython:list\nrepresentation_type=\"LowerLeftUpperRight\"\n\"\"\npython:list\nrepresentation_type=\"LowerLeftUpperRight\"\n\"\"\npython:list\nrepresentation_type=\"CenterWidthHeight\"\n\"\"\npython:str\nrepresentation_type=\"CenterWidthHeight\"\n\"\"\npython:str\nrepresentation_type=\"CenterWidthHeight\"\n\"\"\npython:str\noptional\nLowerLeftUpperRight\n\"LowerLeftUpperRight\"\n\"CenterWidthHeight\"\npython:str\noptional\n\"0mm\"\npython:str\noptional\n\"0deg\"\npyedb.dotnet.database.edb_data.primitives_data.Primitive\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_rectangle",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_rectangle.html#pyedb.dotnet.database.modeler.Modeler.create_rectangle",
        "title": "create_rectangle > create_rectangle > create_rectangle",
        "section": "create_rectangle > create_rectangle",
        "text": "Modeler.create_rectangle(layer_name, net_name='', lower_left_point='', upper_right_point='', center_point='', width='', height='', representation_type='LowerLeftUpperRight', corner_radius='0mm', rotation='0deg')\n\nCreate rectangle.\n\nParameters\n\nlayer_name\n\npython:str\n\nName of the layer on which to create the rectangle.\n\nnet_name\n\npython:str\n\nName of the net. The default is \"\".\n\nlower_left_point\n\npython:list\n\nLower left point when representation_type=\"LowerLeftUpperRight\". The default is \"\".\n\nupper_right_point\n\npython:list\n\nUpper right point when representation_type=\"LowerLeftUpperRight\". The default is \"\".\n\ncenter_point\n\npython:list\n\nCenter point when representation_type=\"CenterWidthHeight\". The default is \"\".\n\nwidth\n\npython:str\n\nWidth of the rectangle when representation_type=\"CenterWidthHeight\". The default is \"\".\n\nheight\n\npython:str\n\nHeight of the rectangle when representation_type=\"CenterWidthHeight\". The default is \"\".\n\nrepresentation_type\n\npython:str, optional\n\nType of the rectangle representation. The default is LowerLeftUpperRight. Options are\n\"LowerLeftUpperRight\" and \"CenterWidthHeight\".\n\ncorner_radius\n\npython:str, optional\n\nRadius of the rectangle corner. The default is \"0mm\".\n\nrotation\n\npython:str, optional\n\nRotation of the rectangle. The default is \"0deg\".\n\nReturns\n\npyedb.dotnet.database.edb_data.primitives_data.Primitive\n\nRectangle when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.set_solder_ball",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.set_solder_ball.html#set_solder_ball",
        "title": "set_solder_ball",
        "section": "set_solder_ball",
        "text": "Set solder ball properties for a component.\nComponent name or instance.\nSolder ball diameter.\nSolder ball height.\nSolder ball shape (“Cylinder” or “Spheroid”).\nSolder ball mid diameter.\nChip orientation (“chip_down” or “chip_up”).\nUse auto reference size.\nReference size X.\nReference size Y.\nReference height.\nTrue if successful, False otherwise.\nset_solder_ball\npython:str\npyedb.grpc.database.hierarchy.component.Component\noptional\npython:float\noptional\npython:float\noptional\npython:str\noptional\npython:float\noptional\npython:str\noptional\noptional\npython:float\noptional\npython:float\noptional\npython:float\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.set_solder_ball",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.set_solder_ball.html#pyedb.grpc.database.components.Components.set_solder_ball",
        "title": "set_solder_ball > set_solder_ball > set_solder_ball",
        "section": "set_solder_ball > set_solder_ball",
        "text": "Components.set_solder_ball(component: str | Component = '', sball_diam: float | None = None, sball_height: float | None = None, shape: str = 'Cylinder', sball_mid_diam: float | None = None, chip_orientation: str = 'chip_down', auto_reference_size: bool = True, reference_size_x: float = 0, reference_size_y: float = 0, reference_height: float = 0) -> bool\n\nSet solder ball properties for a component.\n\nParameters\n\ncomponent\n\npython:str or pyedb.grpc.database.hierarchy.component.Component, optional\n\nComponent name or instance.\n\nsball_diam\n\npython:float, optional\n\nSolder ball diameter.\n\nsball_height\n\npython:float, optional\n\nSolder ball height.\n\nshape\n\npython:str, optional\n\nSolder ball shape (“Cylinder” or “Spheroid”).\n\nsball_mid_diam\n\npython:float, optional\n\nSolder ball mid diameter.\n\nchip_orientation\n\npython:str, optional\n\nChip orientation (“chip_down” or “chip_up”).\n\nauto_reference_size\n\nbool, optional\n\nUse auto reference size.\n\nreference_size_x\n\npython:float, optional\n\nReference size X.\n\nreference_size_y\n\npython:float, optional\n\nReference size Y.\n\nreference_height\n\npython:float, optional\n\nReference height.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\nExamples\n\n>>> edbapp.components.set_solder_ball(\"U1\", sball_diam=0.5e-3)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_pin_group_terminal_reference_pin",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_pin_group_terminal_reference_pin.html#get_pin_group_terminal_reference_pin",
        "title": "get_pin_group_terminal_reference_pin",
        "section": "get_pin_group_terminal_reference_pin",
        "text": "Return a list of pins and serves terminals connected to pingroups.\nPreferred reference net name.\nget_pin_group_terminal_reference_pin\npython:str\noptional\ndotnet.database.edb_data.padstack_data.EDBPadstackInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_pin_group_terminal_reference_pin",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_pin_group_terminal_reference_pin.html#pyedb.grpc.database.ports.ports.ExcitationSources.get_pin_group_terminal_reference_pin",
        "title": "get_pin_group_terminal_reference_pin > get_pin_group_terminal_reference_pin > get_pin_group_terminal_reference_pin",
        "section": "get_pin_group_terminal_reference_pin > get_pin_group_terminal_reference_pin",
        "text": "ExcitationSources.get_pin_group_terminal_reference_pin(gnd_net_name_preference=None)\n\nReturn a list of pins and serves terminals connected to pingroups.\n\nParameters\n\ngnd_net_name_preference\n\npython:str, optional\n\nPreferred reference net name.\n\nReturns\n\ndotnet.database.edb_data.padstack_data.EDBPadstackInstance\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_closest_arc_midpoint",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_closest_arc_midpoint.html#get_closest_arc_midpoint",
        "title": "get_closest_arc_midpoint",
        "section": "get_closest_arc_midpoint",
        "text": "Get the closest arc midpoint of the primitive to the input data.\n[x, y].\nget_closest_arc_midpoint\nList\npython:float\nor\nList\nPointData\nLIst\npython:float\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_closest_arc_midpoint",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_closest_arc_midpoint.html#pyedb.grpc.database.primitive.rectangle.Rectangle.get_closest_arc_midpoint",
        "title": "get_closest_arc_midpoint > get_closest_arc_midpoint > get_closest_arc_midpoint",
        "section": "get_closest_arc_midpoint > get_closest_arc_midpoint",
        "text": "Rectangle.get_closest_arc_midpoint(point) -> list[float]\n\nGet the closest arc midpoint of the primitive to the input data.\n\nParameters\n\npoint\n\nList[python:float] or List[PointData]\n\n\n\nReturns\n\nLIst[python:float, python:float]\n\n[x, y].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_voltage_source_on_pin",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_voltage_source_on_pin.html#create_voltage_source_on_pin",
        "title": "create_voltage_source_on_pin",
        "section": "create_voltage_source_on_pin",
        "text": "Create a voltage source.\nPositive Pin.\nNegative Pin.\nValue for the voltage. The default is 3.3.\nValue for the phase. The default is 0.\nName of the source. The default is \"\".\nSource Name.\ncreate_voltage_source_on_pin\nObject\nObject\npython:float\noptional\n3.3\noptional\n0\npython:str\noptional\n\"\"\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_voltage_source_on_pin",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_voltage_source_on_pin.html#pyedb.dotnet.database.siwave.EdbSiwave.create_voltage_source_on_pin",
        "title": "create_voltage_source_on_pin > create_voltage_source_on_pin > create_voltage_source_on_pin",
        "section": "create_voltage_source_on_pin > create_voltage_source_on_pin",
        "text": "EdbSiwave.create_voltage_source_on_pin(pos_pin, neg_pin, voltage_value=3.3, phase_value=0, source_name='')\n\nCreate a voltage source.\n\nParameters\n\npos_pin\n\nObject\n\nPositive Pin.\n\nneg_pin\n\nObject\n\nNegative Pin.\n\nvoltage_value\n\npython:float, optional\n\nValue for the voltage. The default is 3.3.\n\nphase_value\n\noptional\n\nValue for the phase. The default is 0.\n\nsource_name\n\npython:str, optional\n\nName of the source. The default is \"\".\n\nReturns\n\npython:str\n\nSource Name.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", \"project name\", \"release version\")\n>>> pins = edbapp.components.get_pin_from_component(\"U2A5\")\n>>> edbapp.siwave.create_voltage_source_on_pin(pins[0], pins[1], 50, \"source_name\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.MIMCapacitor.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.MIMCapacitor.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create the top plate, bottom plate and assign variables.\nTrue on success.\ncreate"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.MIMCapacitor.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.MIMCapacitor.create.html#pyedb.libraries.rf_libraries.base_functions.MIMCapacitor.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "MIMCapacitor.create() -> bool\n\nCreate the top plate, bottom plate and assign variables.\n\nReturns\n\nbool\n\nTrue on success.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the layout object.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.delete.html#pyedb.grpc.database.ports.ports.WavePort.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "WavePort.delete()\n\nDelete the layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_stride.html#create_stride",
        "title": "create_stride",
        "section": "create_stride",
        "text": "Create a Stride model from an MCAD file.\nStride model created.\ncreate_stride\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_stride.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_stride",
        "title": "create_stride > create_stride > create_stride",
        "section": "create_stride > create_stride",
        "text": "PadstackInstance.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nReturns\n\nMcadModel\n\nStride model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.parametrize_polygon",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.parametrize_polygon.html#parametrize_polygon",
        "title": "parametrize_polygon",
        "section": "parametrize_polygon",
        "text": "Parametrize pieces of a polygon based on another polygon.\nName of the polygon.\nPolygon to use as a filter.\nName of the offset to create.  The default is \"offsetx\".\nList of the X and Y origins, which impacts the vector\ncomputation and is needed to determine expansion direction.\nThe default is None, in which case the vector is\ncomputed from the polygon’s center.\nTrue when successful, False when failed.\nparametrize_polygon\npython:str\noptional\n\"offsetx\"\npython:list\noptional\nNone\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.parametrize_polygon",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.parametrize_polygon.html#pyedb.dotnet.database.modeler.Modeler.parametrize_polygon",
        "title": "parametrize_polygon > parametrize_polygon > parametrize_polygon",
        "section": "parametrize_polygon > parametrize_polygon",
        "text": "Modeler.parametrize_polygon(polygon, selection_polygon, offset_name='offsetx', origin=None)\n\nParametrize pieces of a polygon based on another polygon.\n\nParameters\n\npolygon\n\nName of the polygon.\n\nselection_polygon\n\nPolygon to use as a filter.\n\noffset_name\n\npython:str, optional\n\nName of the offset to create.  The default is \"offsetx\".\n\norigin\n\npython:list, optional\n\nList of the X and Y origins, which impacts the vector\ncomputation and is needed to determine expansion direction.\nThe default is None, in which case the vector is\ncomputed from the polygon’s center.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.find_by_id.html#find_by_id",
        "title": "find_by_id",
        "section": "find_by_id",
        "text": "Find a Connectable object by database ID in a given layout.\nLayout to search for the Connectable object.\nDatabase ID.\nConnectable object with the given database ID.\nfind_by_id\nLayout\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.find_by_id.html#pyedb.grpc.database.primitive.primitive.Primitive.find_by_id",
        "title": "find_by_id > find_by_id > find_by_id",
        "section": "find_by_id > find_by_id",
        "text": "classmethod Primitive.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the Connectable object.\n\nuid\n\npython:int\n\nDatabase ID.\n\nReturns\n\nConnectable\n\nConnectable object with the given database ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.remove_component_model",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.remove_component_model.html#remove_component_model",
        "title": "remove_component_model",
        "section": "remove_component_model",
        "text": "Remove a component model from this component def.\nComponent Model to be removed.\nOnce a component model is added to one component def, it cannot be added to any other, even when removed.\nremove_component_model\nComponent Model"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.remove_component_model",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.remove_component_model.html#pyedb.grpc.database.definition.component_def.ComponentDef.remove_component_model",
        "title": "remove_component_model > remove_component_model > remove_component_model",
        "section": "remove_component_model > remove_component_model",
        "text": "ComponentDef.remove_component_model(value)\n\nRemove a component model from this component def.\n\nParameters\n\nvalue\n\nComponent Model\n\nComponent Model to be removed.\n\nNotes\n\nOnce a component model is added to one component def, it cannot be added to any other, even when removed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.create_stride.html#create_stride",
        "title": "create_stride",
        "section": "create_stride",
        "text": "Create a Stride model from an MCAD file.\nStride model created.\ncreate_stride\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.create_stride.html#pyedb.grpc.database.terminal.point_terminal.PointTerminal.create_stride",
        "title": "create_stride > create_stride > create_stride",
        "section": "create_stride > create_stride",
        "text": "PointTerminal.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nReturns\n\nMcadModel\n\nStride model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.add_sweep",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.add_sweep.html#add_sweep",
        "title": "add_sweep",
        "section": "add_sweep",
        "text": "Add frequency sweep.\nName of the frequency sweep. The default is None.\nAdded for grpc compatibility.\nAdded for rpc compatibility.\nAdded for grpc compatibility.\nAdded for grpc compatibility.\nList of frequency points. The default is None.\nSweep type. The default is \"interpolation\". Options are \"discrete\",”discrete”``.\nadd_sweep\npython:str\noptional\nNone\npython:str\noptional\npython:str\noptional\npython:str\noptional\noptional\npython:list\noptional\nNone\npython:str\noptional\n\"interpolation\"\n\"discrete\""
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.add_sweep",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.add_sweep.html#pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.add_sweep",
        "title": "add_sweep > add_sweep > add_sweep",
        "section": "add_sweep > add_sweep",
        "text": "RaptorXSimulationSetup.add_sweep(name: str | None = None, distribution: str | None = None, start_freq: str | None = None, stop_freq: str | None = None, step=None, frequency_set: list | None = None, sweep_type: str = 'interpolation', **kwargs)\n\nAdd frequency sweep.\n\nParameters\n\nname\n\npython:str, optional\n\nName of the frequency sweep. The default is None.\n\ndistribution\n\npython:str, optional\n\nAdded for grpc compatibility.\n\nstart_freq\n\npython:str, optional\n\nAdded for rpc compatibility.\n\nstop_freq\n\npython:str, optional\n\nAdded for grpc compatibility.\n\nstep\n\noptional\n\nAdded for grpc compatibility.\n\nfrequency_set\n\npython:list, optional\n\nList of frequency points. The default is None.\n\nsweep_type\n\npython:str, optional\n\nSweep type. The default is \"interpolation\". Options are \"discrete\",”discrete”``.\n\nReturns\n\n\n\n——-\n\n\n\nExamples\n\n>>> setup1 = edbapp.create_siwave_syz_setup(\"setup1\")\n>>> setup1.add_sweep(name=\"sw1\", frequency_set=[\"linear count\", \"1MHz\", \"100MHz\", 10])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_config",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_config",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_config.html#pyedb.workflows.drc.drc.Rules.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "Rules.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.create_3d_comp.html#create_3d_comp",
        "title": "create_3d_comp",
        "section": "create_3d_comp",
        "text": "Create a 3D composite model from an MCAD file.\n3D composite model created.\ncreate_3d_comp\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.create_3d_comp.html#pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.create_3d_comp",
        "title": "create_3d_comp > create_3d_comp > create_3d_comp",
        "section": "create_3d_comp > create_3d_comp",
        "text": "BundleTerminal.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nReturns\n\nMcadModel\n\n3D composite model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.delete",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete one or more nets from the layout.\nNet name or list of net names to delete.\nNames of nets that were deleted.\ndelete\npython:str\npython:list\npython:str\npython:list\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.delete",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.delete.html#pyedb.grpc.database.nets.Nets.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "Nets.delete(netlist: str | List[str]) -> List[str]\n\nDelete one or more nets from the layout.\n\nParameters\n\nnetlist\n\npython:str | python:list[python:str]\n\nNet name or list of net names to delete.\n\nReturns\n\npython:list[python:str]\n\nNames of nets that were deleted.\n\nExamples\n\n>>> deleted_nets = database.nets.delete([\"Net1\", \"Net2\"])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_product_property.html#pyedb.grpc.database.primitive.path.Path.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "Path.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.get_product_property.html#pyedb.grpc.database.net.extended_net.ExtendedNet.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "ExtendedNet.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.delete_frequency_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.delete_frequency_sweep.html#delete_frequency_sweep",
        "title": "delete_frequency_sweep",
        "section": "delete_frequency_sweep",
        "text": "Delete a frequency sweep.\ndelete_frequency_sweep"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.delete_frequency_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.delete_frequency_sweep.html#pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.delete_frequency_sweep",
        "title": "delete_frequency_sweep > delete_frequency_sweep > delete_frequency_sweep",
        "section": "delete_frequency_sweep > delete_frequency_sweep",
        "text": "SimulationSetup.delete_frequency_sweep(sweep_data)\n\nDelete a frequency sweep.\n\nParameters\n\nsweep_data\n\nEdbFrequencySweep.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.set_product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.set_product_solver_option.html#set_product_solver_option",
        "title": "set_product_solver_option",
        "section": "set_product_solver_option",
        "text": "Set the product solver option.\nID of the product.\nName of the solver.\nName of the product solver option.\nset_product_solver_option\nProductIdType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.set_product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.set_product_solver_option.html#pyedb.grpc.database.terminal.terminal.Terminal.set_product_solver_option",
        "title": "set_product_solver_option > set_product_solver_option > set_product_solver_option",
        "section": "set_product_solver_option > set_product_solver_option",
        "text": "Terminal.set_product_solver_option(product_id, solver_name, option)\n\nSet the product solver option.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nsolver_name\n\nobj:str\n\nName of the solver.\n\noption\n\nobj:str\n\nName of the product solver option.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/pingroup",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/pingroup.html#pingroup",
        "title": "Pingroup",
        "section": "Pingroup",
        "text": "This class is managing EDB pingroup.\nPinGroup\nManages pin groups.\nPingroup\nPinGroup"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.reduce_via_in_bounding_box",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.reduce_via_in_bounding_box.html#reduce_via_in_bounding_box",
        "title": "reduce_via_in_bounding_box",
        "section": "reduce_via_in_bounding_box",
        "text": "reduce the number of vias intersecting bounding box and nets by x and y samples.\nbounding box, [x1, y1, x2, y2]\nnet name of list of nets name applying filtering on pad-stack instances selection. If None is provided\nall instances are included in the index. Default value is None.\nTrue when succeeded False when failed.\nreduce_via_in_bounding_box\npython:tuple\npython:int\npython:int\npython:str\npython:list\noptional\nNone\nNone\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.reduce_via_in_bounding_box",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.reduce_via_in_bounding_box.html#pyedb.grpc.database.padstacks.Padstacks.reduce_via_in_bounding_box",
        "title": "reduce_via_in_bounding_box > reduce_via_in_bounding_box > reduce_via_in_bounding_box",
        "section": "reduce_via_in_bounding_box > reduce_via_in_bounding_box",
        "text": "Padstacks.reduce_via_in_bounding_box(bounding_box: List[float], x_samples: int, y_samples: int, nets: str | List[str] | None = None) -> bool\n\nreduce the number of vias intersecting bounding box and nets by x and y samples.\n\nParameters\n\nbounding_box\n\npython:tuple or list.\n\nbounding box, [x1, y1, x2, y2]\n\nx_samples\n\npython:int\n\n\n\ny_samples\n\npython:int\n\n\n\nnets\n\npython:str or python:list, optional\n\nnet name of list of nets name applying filtering on pad-stack instances selection. If None is provided\nall instances are included in the index. Default value is None.\n\nReturns\n\nbool\n\nTrue when succeeded False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_port_on_component",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_port_on_component.html#create_port_on_component",
        "title": "create_port_on_component",
        "section": "create_port_on_component",
        "text": "Create ports on a component.\nEDB component or str component name.\nList of nets where ports must be created on the component.\nIf the net is not part of the component, this parameter is skipped.\nType of port to create. coax_port generates solder balls.\ncircuit_port generates circuit ports on pins belonging to the net list.\nTrue activate pingroup during port creation (only used with combination of CircPort),\nFalse will take the closest reference pin and generate one port per signal pin.\nlist of the reference net.\nPort name for overwriting the default port-naming convention,\nwhich is [component][net][pin]. The port name must be unique.\nIf a port with the specified name already exists, the\ndefault naming convention is used so that port creation does\nnot fail.\nSolder balls height used for the component. When provided default value is overwritten and must be\nprovided in meter.\nSolder balls diameter. When provided auto evaluation based on padstack size will be disabled.\nSolder balls mid-diameter. When provided if value is different than solder balls size, spheroid shape will\nbe switched.\nWhen no reference pins are found on the component extend the pins search with taking the closest one. If\ndo_pingroup is True will be set to False. Default value is False.\nSalder ball height vale, False when failed.\ncreate_port_on_component\npython:str\nComponent\npython:str\npython:list\nof\npython:str\noptional\ncoax_port\ncircuit_port\npython:str\npython:list\nof\npython:str\n[component][net][pin]\npython:float\noptional\npython:float\noptional\npython:float\noptional\ndouble\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_port_on_component",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_port_on_component.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_port_on_component",
        "title": "create_port_on_component > create_port_on_component > create_port_on_component",
        "section": "create_port_on_component > create_port_on_component",
        "text": "SourceExcitation.create_port_on_component(component: str | Component, net_list: str | List[str], port_type: str = 'coax_port', do_pingroup: bool | None = True, reference_net: str | None = None, port_name: List[str] | None = None, solder_balls_height: float | str | None = None, solder_balls_size: float | str | None = None, solder_balls_mid_size: float | str | None = None, extend_reference_pins_outside_component: bool | None = False) -> List[str]\n\nCreate ports on a component.\n\nParameters\n\ncomponent\n\npython:str or Component\n\nEDB component or str component name.\n\nnet_list\n\npython:str or python:list of string.\n\nList of nets where ports must be created on the component.\nIf the net is not part of the component, this parameter is skipped.\n\nport_type\n\npython:str, optional\n\nType of port to create. coax_port generates solder balls.\ncircuit_port generates circuit ports on pins belonging to the net list.\n\ndo_pingroup\n\nbool\n\nTrue activate pingroup during port creation (only used with combination of CircPort),\nFalse will take the closest reference pin and generate one port per signal pin.\n\nreference_net\n\npython:str or python:list of string.\n\nlist of the reference net.\n\nport_name\n\npython:str\n\nPort name for overwriting the default port-naming convention,\nwhich is [component][net][pin]. The port name must be unique.\nIf a port with the specified name already exists, the\ndefault naming convention is used so that port creation does\nnot fail.\n\nsolder_balls_height\n\npython:float, optional\n\nSolder balls height used for the component. When provided default value is overwritten and must be\nprovided in meter.\n\nsolder_balls_size\n\npython:float, optional\n\nSolder balls diameter. When provided auto evaluation based on padstack size will be disabled.\n\nsolder_balls_mid_size\n\npython:float, optional\n\nSolder balls mid-diameter. When provided if value is different than solder balls size, spheroid shape will\nbe switched.\n\nextend_reference_pins_outside_component\n\nbool\n\nWhen no reference pins are found on the component extend the pins search with taking the closest one. If\ndo_pingroup is True will be set to False. Default value is False.\n\nReturns\n\ndouble, bool\n\nSalder ball height vale, False when failed.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\")\n>>> net_list = [\"M_DQ<1>\", \"M_DQ<2>\", \"M_DQ<3>\", \"M_DQ<4>\", \"M_DQ<5>\"]\n>>> edbapp.excitations.create_port_on_component(cmp=\"U2A5\", net_list=net_list,\n>>> port_type=SourceType.CoaxPort, do_pingroup=False, refnet=\"GND\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_closest_arc_midpoint",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_closest_arc_midpoint.html#get_closest_arc_midpoint",
        "title": "get_closest_arc_midpoint",
        "section": "get_closest_arc_midpoint",
        "text": "Get the closest arc midpoint of the primitive to the input data.\n[x, y].\nget_closest_arc_midpoint\nList\npython:float\nor\nList\nPointData\nLIst\npython:float\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_closest_arc_midpoint",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_closest_arc_midpoint.html#pyedb.grpc.database.primitive.polygon.Polygon.get_closest_arc_midpoint",
        "title": "get_closest_arc_midpoint > get_closest_arc_midpoint > get_closest_arc_midpoint",
        "section": "get_closest_arc_midpoint > get_closest_arc_midpoint",
        "text": "Polygon.get_closest_arc_midpoint(point) -> list[float]\n\nGet the closest arc midpoint of the primitive to the input data.\n\nParameters\n\npoint\n\nList[python:float] or List[PointData]\n\n\n\nReturns\n\nLIst[python:float, python:float]\n\n[x, y].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.create",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a differential pair.\nYou must either provide both nets or omit both nets.\nLayout to create the differential pair in.\nName of the new differential pair.\nPositive net or name of the positive net.\nNegative net or the name of negative net.\nDifferential pair created.\ncreate\nLayout\npython:str\nNet\npython:str\npython:None\nNet\npython:str\npython:None\nDifferentialPair"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.create",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.create.html#pyedb.grpc.database.net.differential_pair.DifferentialPair.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod DifferentialPair.create(layout, name, pos_net=None, neg_net=None)\n\nCreate a differential pair.\n\nYou must either provide both nets or omit both nets.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to create the differential pair in.\n\nname\n\npython:str\n\nName of the new differential pair.\n\npos_net\n\nNet or python:str, default: python:None\n\nPositive net or name of the positive net.\n\nneg_net\n\nNet or python:str, default: python:None\n\nNegative net or the name of negative net.\n\nReturns\n\nDifferentialPair\n\nDifferential pair created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_rebuild",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce: Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors: Whether to raise errors, defaults to True.\n_parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n_types_namespace: The types namespace, defaults to None.\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_rebuild",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_rebuild.html#pyedb.workflows.drc.drc.Rules.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod Rules.model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -> bool | None\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n\nforce: Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors: Whether to raise errors, defaults to True.\n_parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n_types_namespace: The types namespace, defaults to None.\n\nReturns:\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.subtract",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.subtract.html#subtract",
        "title": "subtract",
        "section": "subtract",
        "text": "Subtract active primitive with one or more primitives.\nor: List[Primitives]\nor: class:PolygonData <ansys.edb.core.geometry.polygon_data.PolygonData>\nList of Primitive objects.\nsubtract\nPrimitives\nPrimitives\nList\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.subtract",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.subtract.html#pyedb.grpc.database.primitive.primitive.Primitive.subtract",
        "title": "subtract > subtract > subtract",
        "section": "subtract > subtract",
        "text": "Primitive.subtract(primitives) -> list[any]\n\nSubtract active primitive with one or more primitives.\n\nParameters\n\nprimitives\n\nPrimitives\n\nor: List[Primitives]\nor: class:PolygonData <ansys.edb.core.geometry.polygon_data.PolygonData>\n\nReturns\n\nList[Primitive]\n\nList of Primitive objects.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.find_by_name",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.find_by_name.html#find_by_name",
        "title": "find_by_name",
        "section": "find_by_name",
        "text": "Find an extended net by name in a given layout.\nLayout to search for the extended net.\nName of the extended net.\nExtended net that was found. Check the is_null\nproperty of the extended net to see if it exists.\nfind_by_name\nLayout\npython:str\nExtendedNet\nis_null"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.find_by_name",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.find_by_name.html#pyedb.grpc.database.net.extended_net.ExtendedNet.find_by_name",
        "title": "find_by_name > find_by_name > find_by_name",
        "section": "find_by_name > find_by_name",
        "text": "classmethod ExtendedNet.find_by_name(layout, name)\n\nFind an extended net by name in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the extended net.\n\nname\n\npython:str\n\nName of the extended net.\n\nReturns\n\nExtendedNet\n\nExtended net that was found. Check the is_null\nproperty of the extended net to see if it exists.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_computed_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_computed_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_computed_fields.html#pyedb.workflows.drc.drc.MinLineWidth.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "MinLineWidth.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.set_product_property.html#pyedb.grpc.database.hierarchy.component.Component.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "Component.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.get_product_property.html#pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "PadstackInstanceTerminal.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.add_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.add_sweep.html#add_sweep",
        "title": "add_sweep",
        "section": "add_sweep",
        "text": "Add frequency sweep.\nName of the frequency sweep. The default is None.\nList of frequency points. The default is None.\nSweep type. The default is \"interpolation\". Options are \"discrete\",”discrete”``.\nadd_sweep\npython:str\noptional\nNone\npython:list\noptional\nNone\npython:str\noptional\n\"interpolation\"\n\"discrete\""
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.add_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.add_sweep.html#pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.add_sweep",
        "title": "add_sweep > add_sweep > add_sweep",
        "section": "add_sweep > add_sweep",
        "text": "SiwaveSimulationSetup.add_sweep(name: str | None = None, frequency_set: list | None = None, sweep_type: str = 'interpolation', **kwargs)\n\nAdd frequency sweep.\n\nParameters\n\nname\n\npython:str, optional\n\nName of the frequency sweep. The default is None.\n\nfrequency_set\n\npython:list, optional\n\nList of frequency points. The default is None.\n\nsweep_type\n\npython:str, optional\n\nSweep type. The default is \"interpolation\". Options are \"discrete\",”discrete”``.\n\nReturns\n\n\n\n——-\n\n\n\nExamples\n\n>>> setup1 = edbapp.create_siwave_syz_setup(\"setup1\")\n>>> setup1.add_sweep(name=\"sw1\", frequency_set=[\"linear count\", \"1MHz\", \"100MHz\", 10])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.create",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a net.\nLayout to create the net in.\nName of the net.\nNet created.\ncreate\nLayout\npython:str\nNet"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.create",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.create.html#pyedb.grpc.database.net.net.Net.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod Net.create(layout, name)\n\nCreate a net.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to create the net in.\n\nname\n\npython:str\n\nName of the net.\n\nReturns\n\nNet\n\nNet created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "construct"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.construct.html#pyedb.workflows.drc.drc.MinAnnularRing.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod MinAnnularRing.construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.get_product_property_ids.html#pyedb.grpc.database.ports.ports.CircuitPort.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "CircuitPort.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/xml_control_file",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/xml_control_file.html#xml-control-file",
        "title": "XML control file",
        "section": "XML control file",
        "text": "This class is managing EDB xml control file.\nControlProperty\n\nControlFileMaterial\n\nControlFileDielectric\n\nControlFileLayer\n\nControlFileVia\n\nControlFileStackup\nClass that manages the Stackup info.\nControlFileImportOptions\nImport Options.\nControlExtent\nExtent options.\nControlCircuitPt\nCircuit Port.\nControlFileComponent\nComponents.\nControlFileComponents\nClass for component management.\nControlFileBoundaries\nBoundaries management.\nControlFileSweep\n\nControlFileMeshOp\n\nControlFileSetup\nSetup Class.\nControlFileSetups\nSetup manager class.\nControlFile\nControl File Class.\nXML control file\nControlProperty\nControlFileMaterial\nControlFileDielectric\nControlFileLayer\nControlFileVia\nControlFileStackup\nControlFileImportOptions\nControlExtent\nControlCircuitPt\nControlFileComponent\nControlFileComponents\nControlFileBoundaries\nControlFileSweep\nControlFileMeshOp\nControlFileSetup\nControlFileSetups\nControlFile"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.padstacks_no_name",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.padstacks_no_name.html#padstacks_no_name",
        "title": "padstacks_no_name",
        "section": "padstacks_no_name",
        "text": "Identify and fix padstacks without names.\npadstacks_no_name"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.padstacks_no_name",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.padstacks_no_name.html#pyedb.grpc.database.layout_validation.LayoutValidation.padstacks_no_name",
        "title": "padstacks_no_name > padstacks_no_name > padstacks_no_name",
        "section": "padstacks_no_name > padstacks_no_name",
        "text": "LayoutValidation.padstacks_no_name(fix: bool = False) -> None\n\nIdentify and fix padstacks without names.\n\nExamples\n\n>>> edb = Edb(\"edb_file\")\n>>> # Report unnamed padstacks\n>>> edb.layout_validation.padstacks_no_name()\n>>>\n>>> # Automatically assign names to unnamed padstacks\n>>> edb.layout_validation.padstacks_no_name(fix=True)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.get_all_power_modules",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.get_all_power_modules.html#get_all_power_modules",
        "title": "get_all_power_modules",
        "section": "get_all_power_modules",
        "text": "Get all power modules in the voltage regulator.\nList of all power modules.\nget_all_power_modules\npython:list\nPowerModule"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.get_all_power_modules",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.get_all_power_modules.html#pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.get_all_power_modules",
        "title": "get_all_power_modules > get_all_power_modules > get_all_power_modules",
        "section": "get_all_power_modules > get_all_power_modules",
        "text": "VoltageRegulator.get_all_power_modules()\n\nGet all power modules in the voltage regulator.\n\nReturns\n\npython:list[PowerModule]\n\nList of all power modules.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.split_to_microvias",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.split_to_microvias.html#split_to_microvias",
        "title": "split_to_microvias",
        "section": "split_to_microvias",
        "text": "Convert actual padstack definition to multiple microvias definitions.\nsplit_to_microvias\nList\nof\npyedb.dotnet.database.padstackEDBPadstack"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.split_to_microvias",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.split_to_microvias.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.split_to_microvias",
        "title": "split_to_microvias > split_to_microvias > split_to_microvias",
        "section": "split_to_microvias > split_to_microvias",
        "text": "EDBPadstack.split_to_microvias()\n\nConvert actual padstack definition to multiple microvias definitions.\n\nReturns\n\nList of pyedb.dotnet.database.padstackEDBPadstack\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNets.auto_identify_signal",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNets.auto_identify_signal.html#auto_identify_signal",
        "title": "auto_identify_signal",
        "section": "auto_identify_signal",
        "text": "Get extended signal net and associated components.\nThreshold for the resistor value. Search the extended net across resistors that\nhave a value lower than the threshold.\nThreshold for the inductor value. Search the extended net across inductances\nthat have a value lower than the threshold.\nThreshold for the capacitor value. Search the extended net across capacitors\nthat have a value higher than the threshold.\nList of components to bypass when performing threshold checks. Components\nin the list are considered as serial components. The default is None.\nList of all extended nets.\nauto_identify_signal\npython:int\npython:float\noptional\npython:int\npython:float\noptional\npython:int\npython:float\noptional\npython:list\noptional\nNone\nList\nExtendedNet"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNets.auto_identify_signal",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNets.auto_identify_signal.html#pyedb.grpc.database.net.extended_net.ExtendedNets.auto_identify_signal",
        "title": "auto_identify_signal > auto_identify_signal > auto_identify_signal",
        "section": "auto_identify_signal > auto_identify_signal",
        "text": "ExtendedNets.auto_identify_signal(resistor_below: int | float = 10, inductor_below: int | float = 1, capacitor_above: int | float = 1e-09, exception_list: list | None = None) -> list[ExtendedNet]\n\nGet extended signal net and associated components.\n\nParameters\n\nresistor_below\n\npython:int, python:float, optional\n\nThreshold for the resistor value. Search the extended net across resistors that\nhave a value lower than the threshold.\n\ninductor_below\n\npython:int, python:float, optional\n\nThreshold for the inductor value. Search the extended net across inductances\nthat have a value lower than the threshold.\n\ncapacitor_above\n\npython:int, python:float, optional\n\nThreshold for the capacitor value. Search the extended net across capacitors\nthat have a value higher than the threshold.\n\nexception_list\n\npython:list, optional\n\nList of components to bypass when performing threshold checks. Components\nin the list are considered as serial components. The default is None.\n\nReturns\n\nList[ExtendedNet]\n\nList of all extended nets.\n\nExamples\n\n>>> from pyedb import Edb\n>>> app = Edb()\n>>> app.extended_nets.auto_identify_signal()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_definition_name",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_definition_name.html#set_definition_name",
        "title": "set_definition_name",
        "section": "set_definition_name",
        "text": "Set the definition name of a bondwire.\nBondwire definition name to set.\nset_definition_name\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_definition_name",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_definition_name.html#pyedb.grpc.database.primitive.bondwire.Bondwire.set_definition_name",
        "title": "set_definition_name > set_definition_name > set_definition_name",
        "section": "set_definition_name > set_definition_name",
        "text": "Bondwire.set_definition_name(definition_name: str)\n\nSet the definition name of a bondwire.\n\nParameters\n\ndefinition_name\n\npython:str\n\nBondwire definition name to set.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.layout_obj_type.html#pyedb.grpc.database.layers.stackup_layer.StackupLayer.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "StackupLayer.layout_obj_type = 5\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_stackup_layer_at_elevation",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_stackup_layer_at_elevation.html#add_stackup_layer_at_elevation",
        "title": "add_stackup_layer_at_elevation",
        "section": "add_stackup_layer_at_elevation",
        "text": "Add a stackup layer at a user-specified elevation.\nThis method doe not change the elevenation of other stackup layers.\nadd_stackup_layer_at_elevation\nStackupLayer\nStackupLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_stackup_layer_at_elevation",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_stackup_layer_at_elevation.html#pyedb.grpc.database.stackup.LayerCollection.add_stackup_layer_at_elevation",
        "title": "add_stackup_layer_at_elevation > add_stackup_layer_at_elevation > add_stackup_layer_at_elevation",
        "section": "add_stackup_layer_at_elevation > add_stackup_layer_at_elevation",
        "text": "LayerCollection.add_stackup_layer_at_elevation(stackup_layer_to_add)\n\nAdd a stackup layer at a user-specified elevation.\n\nThis method doe not change the elevenation of other stackup layers.\n\nParameters\n\nstackup_layer_to_add\n\nStackupLayer\n\n\n\nReturns\n\nStackupLayer\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_product_property_ids.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "PadstackInstance.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layer for a given product ID and attribute ID.\nProduct ID.\nAttribute ID.\nNew product property value.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.set_product_property.html#pyedb.grpc.database.layers.layer.Layer.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "Layer.set_product_property(prod_id, attr_it, prop_value)\n\nSet the product property of the layer for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nProduct ID.\n\nattr_it\n\npython:int\n\nAttribute ID.\n\nprop_value\n\npython:str\n\nNew product property value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_dump_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#json-mode)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent: Indentation to use in the JSON output. If None is passed, the output will be compact.\nensure_ascii: If True, the output is guaranteed to have all incoming non-ASCII characters escaped.\nIf False (the default), these characters will be output as-is.\ninclude: Field(s) to include in the JSON output.\nexclude: Field(s) to exclude from the JSON output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to serialize using field aliases.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\nA JSON string representation of the model.\nmodel_dump_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_dump_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_dump_json.html#pyedb.workflows.drc.drc.MinAnnularRing.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "MinAnnularRing.model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -> str\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#json-mode)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nArgs:\n\nindent: Indentation to use in the JSON output. If None is passed, the output will be compact.\nensure_ascii: If True, the output is guaranteed to have all incoming non-ASCII characters escaped.\n\nIf False (the default), these characters will be output as-is.\n\ninclude: Field(s) to include in the JSON output.\nexclude: Field(s) to exclude from the JSON output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to serialize using field aliases.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\n\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\n\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback: A function to call when an unknown value is encountered. If not provided,\n\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.html#waveport",
        "title": "WavePort",
        "section": "WavePort",
        "text": "Manages wave port properties.\nEDB object from the Edblib library.\nEdge terminal instance from EDB.\nThis example shows how to access the WavePort class.\nWavePort.cast([term_type])\nCast the terminal object to the correct concrete type, fetching the type if necessary.\nWavePort.couple_ports(port)\nCreate a bundle wave port.\nWavePort.create(layout, name, edges[, net, ...])\nCreate an edge terminal.\nWavePort.create_3d_comp()\nCreate a 3D composite model from an MCAD file.\nWavePort.create_hfss()\nCreate an HFSS model from an MCAD file.\nWavePort.create_stride()\nCreate a Stride model from an MCAD file.\nWavePort.delete()\nDelete the layout object.\nWavePort.find(layout, name)\nFind a terminal by name in a given layout.\nWavePort.find_by_id(layout, uid)\nFind a Connectable object by database ID in a given layout.\nWavePort.get_product_property(prod_id, attr_id)\nGet the product property of the layout object for a given product ID and attribute ID.\nWavePort.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nWavePort.product_solver_names(product_id)\nGet the list of solver names.\nWavePort.product_solver_option(product_id, ...)\nGet the name of the product solver option.\nWavePort.set_product_property(prod_id, ...)\nSet the product property of the layout object for a given product ID and attribute ID.\nWavePort.set_product_solver_option(...)\nSet the product solver option.\nWavePort.layout_obj_type\n\nWavePort.type\n\nWavePort\npyedb.edb.Edb\nEdblib\nAnsys.Ansoft.Edb.Cell.Terminal.EdgeTerminal\nWavePort\nWavePort.cast\nWavePort.couple_ports\nWavePort.create\nWavePort.create_3d_comp\nWavePort.create_hfss\nWavePort.create_stride\nWavePort.delete\nWavePort.find\nWavePort.find_by_id\nWavePort.get_product_property\nWavePort.get_product_property_ids\nWavePort.product_solver_names\nWavePort.product_solver_option\nWavePort.set_product_property\nWavePort.set_product_solver_option\nWavePort.layout_obj_type\nWavePort.type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.html#pyedb.grpc.database.ports.ports.WavePort",
        "title": "WavePort > WavePort > WavePort",
        "section": "WavePort > WavePort",
        "text": "class pyedb.grpc.database.ports.ports.WavePort(pedb, edb_terminal)\n\nManages wave port properties.\n\nParameters\n\npedb\n\npyedb.edb.Edb\n\nEDB object from the Edblib library.\n\nedb_object\n\nAnsys.Ansoft.Edb.Cell.Terminal.EdgeTerminal\n\nEdge terminal instance from EDB.\n\nExamples\n\nThis example shows how to access the WavePort class.\n\n>>> from pyedb import Edb\n>>> edb = Edb(\"myaedb.aedb\")\n>>> exc = edb.ports\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nWavePort.cast([term_type])\n\nCast the terminal object to the correct concrete type, fetching the type if necessary.\n\nWavePort.couple_ports(port)\n\nCreate a bundle wave port.\n\nWavePort.create(layout, name, edges[, net, ...])\n\nCreate an edge terminal.\n\nWavePort.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nWavePort.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nWavePort.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nWavePort.delete()\n\nDelete the layout object.\n\nWavePort.find(layout, name)\n\nFind a terminal by name in a given layout.\n\nWavePort.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nWavePort.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nWavePort.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nWavePort.product_solver_names(product_id)\n\nGet the list of solver names.\n\nWavePort.product_solver_option(product_id, ...)\n\nGet the name of the product solver option.\n\nWavePort.set_product_property(prod_id, ...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nWavePort.set_product_solver_option(...)\n\nSet the product solver option.\n\n\n\nAttributes\n\n\n\n\n\n\n\nWavePort.layout_obj_type\n\n\n\nWavePort.type\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.thermal_conductivity",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.thermal_conductivity.html#thermal_conductivity",
        "title": "thermal_conductivity",
        "section": "thermal_conductivity",
        "text": "thermal_conductivity"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.thermal_conductivity",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.thermal_conductivity.html#pyedb.grpc.database.definition.materials.MaterialProperties.thermal_conductivity",
        "title": "thermal_conductivity > thermal_conductivity > thermal_conductivity",
        "section": "thermal_conductivity > thermal_conductivity",
        "text": "MaterialProperties.thermal_conductivity: Annotated[float, Gt(gt=0)] | None\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.scale",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.scale.html#scale",
        "title": "scale",
        "section": "scale",
        "text": "Scales the polygon relative to a center point by a factor.\nScaling factor.\nIf None scaling is done from polygon center.\nTrue when successful, False when failed.\nscale\npython:float\nList\nof\npython:float\npython:str\noptional\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.scale",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.scale.html#pyedb.grpc.database.primitive.path.Path.scale",
        "title": "scale > scale > scale",
        "section": "scale > scale",
        "text": "Path.scale(factor, center=None) -> bool\n\nScales the polygon relative to a center point by a factor.\n\nParameters\n\nfactor\n\npython:float\n\nScaling factor.\n\ncenter\n\nList of python:float or python:str [x,y], optional\n\nIf None scaling is done from polygon center.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#release-notes",
        "title": "Release notes",
        "section": "Release notes",
        "text": "This document contains the release notes for the project.\nRelease notes"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#0620---october-28-2025",
        "title": "Release notes > 0.62.0 - October 28, 2025",
        "section": "0.62.0 - October 28, 2025",
        "text": "Add functionality for geometry swapping from DXF file\n#1529\nAdding DRC inside pyedb\n#1600\nLayout file warnings\n#1602\nDesign mode\n#1607\nJob manager lsf support\n#1609\nBump actions/labeler from 5.0.0 to 6.0.1\n#1578\nBump actions/download-artifact from 5.0.0 to 6.0.0\n#1610\nBump actions/upload-artifact from 4.6.2 to 5.0.0\n#1611\nAdd the changelog feature\n#1593\nJob manager default values\n#1597\nAdding artifact attestations and fix warnings related to coverage upload\n#1601\n0.62.0 - October 28, 2025"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#changelog",
        "title": "Release notes > Changelog",
        "section": "Changelog",
        "text": "All notable changes to PyEDB are documented in this file.\nThe format is based on Keep a Changelog,\nand this project adheres to Semantic Versioning.\nChangelog"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#unreleased",
        "title": "Release notes > [Unreleased]",
        "section": "[Unreleased]",
        "text": "### Added\n-\n### Changed\n-\n### Deprecated\n-\n### Fixed\n-\n### Removed\n-\n[Unreleased]"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#090---2024-xx-yy",
        "title": "Release notes > [0.9.0] - 2024-XX-YY",
        "section": "[0.9.0] - 2024-XX-YY",
        "text": "### Added\n- Initial release of the gRPC-based PyEDB client.\n- Comprehensive documentation including user guides, migration guide, and examples.\n- Core functionality for EDB creation, modification, and simulation setup.\n### Removed\n- Legacy pyedb.dotnet module (moved to archived branch).\n[0.9.0] - 2024-XX-YY"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.clone",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.clone.html#clone",
        "title": "clone",
        "section": "clone",
        "text": "Create a clone of the layer.\nID of the layer to clone.\nLayer cloned.\nclone\nLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.clone",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.clone.html#pyedb.grpc.database.layers.layer.Layer.clone",
        "title": "clone > clone > clone",
        "section": "clone > clone",
        "text": "Layer.clone(copy_id=True)\n\nCreate a clone of the layer.\n\nParameters\n\ncopy_id\n\nbool\n\nID of the layer to clone.\n\nReturns\n\nLayer\n\nLayer cloned.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/s_parameter_model",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/s_parameter_model.html#s-parameter-model",
        "title": "S-Parameter model",
        "section": "S-Parameter model",
        "text": "This class is managing EDB s-parameter model.\nSparamModel\nManage SParameterModel\nS-Parameter model\nSparamModel\nSParameterModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/index",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/index.html#primitive-classes",
        "title": "Primitive classes",
        "section": "Primitive classes",
        "text": "This section describes EDB primitive classes.\nPrimitive classes"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.dict",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "dict"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.dict",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.dict.html#pyedb.workflows.drc.drc.DiffPair.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "DiffPair.dict(*, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Dict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.import_bom",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.import_bom.html#import_bom",
        "title": "import_bom",
        "section": "import_bom",
        "text": "Load external BOM file.\nFull path to the BOM file, which is a delimited text file.\nValue to use for the delimiter. The default is \",\".\nColumn index of reference designator. The default is \"0\".\nColumn index of part name. The default is \"1\". Set to None if\nthe column does not exist.\nColumn index of component type. The default is \"2\".\nColumn index of value. The default is \"3\". Set to None\nif the column does not exist.\nimport_bom\npython:str\npython:str\noptional\n\",\"\npython:int\noptional\n\"0\"\npython:int\noptional\n\"1\"\nNone\npython:int\noptional\n\"2\"\npython:int\noptional\n\"3\"\nNone"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.import_bom",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.import_bom.html#pyedb.dotnet.database.components.Components.import_bom",
        "title": "import_bom > import_bom > import_bom",
        "section": "import_bom > import_bom",
        "text": "Components.import_bom(bom_file, delimiter=',', refdes_col=0, part_name_col=1, comp_type_col=2, value_col=3)\n\nLoad external BOM file.\n\nParameters\n\nbom_file\n\npython:str\n\nFull path to the BOM file, which is a delimited text file.\n\ndelimiter\n\npython:str, optional\n\nValue to use for the delimiter. The default is \",\".\n\nrefdes_col\n\npython:int, optional\n\nColumn index of reference designator. The default is \"0\".\n\npart_name_col\n\npython:int, optional\n\nColumn index of part name. The default is \"1\". Set to None if\nthe column does not exist.\n\ncomp_type_col\n\npython:int, optional\n\nColumn index of component type. The default is \"2\".\n\nvalue_col\n\npython:int, optional\n\nColumn index of value. The default is \"3\". Set to None\nif the column does not exist.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_rlc_boundary_on_pins",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_rlc_boundary_on_pins.html#create_rlc_boundary_on_pins",
        "title": "create_rlc_boundary_on_pins",
        "section": "create_rlc_boundary_on_pins",
        "text": "Create hfss rlc boundary on pins.\nEdb.Cell.Primitive.PadstackInstance\nEdb.Cell.Primitive.PadstackInstance\nTrue when successful, False when failed.\ncreate_rlc_boundary_on_pins\nPositive\nNegative\nResistance\nvalue\nInductance\nvalue\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_rlc_boundary_on_pins",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_rlc_boundary_on_pins.html#pyedb.dotnet.database.hfss.EdbHfss.create_rlc_boundary_on_pins",
        "title": "create_rlc_boundary_on_pins > create_rlc_boundary_on_pins > create_rlc_boundary_on_pins",
        "section": "create_rlc_boundary_on_pins > create_rlc_boundary_on_pins",
        "text": "EdbHfss.create_rlc_boundary_on_pins(positive_pin=None, negative_pin=None, rvalue=0.0, lvalue=0.0, cvalue=0.0)\n\nCreate hfss rlc boundary on pins.\n\nParameters\n\npositive_pin\n\nPositive pin.\n\nEdb.Cell.Primitive.PadstackInstance\n\nnegative_pin\n\nNegative pin.\n\nEdb.Cell.Primitive.PadstackInstance\n\nrvalue\n\nResistance value\n\n\n\nlvalue\n\nInductance value\n\n\n\ncvalue . Capacitance value.\n\n\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_zone_to_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_zone_to_layer.html#add_zone_to_layer",
        "title": "add_zone_to_layer",
        "section": "add_zone_to_layer",
        "text": "Set the zone to the layer and update the layer in the collection.\nadd_zone_to_layer\nLayer\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_zone_to_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_zone_to_layer.html#pyedb.grpc.database.stackup.LayerCollection.add_zone_to_layer",
        "title": "add_zone_to_layer > add_zone_to_layer > add_zone_to_layer",
        "section": "add_zone_to_layer > add_zone_to_layer",
        "text": "LayerCollection.add_zone_to_layer(layer, zone, in_zone)\n\nSet the zone to the layer and update the layer in the collection.\n\nParameters\n\nlayer\n\nLayer\n\n\n\nzone\n\npython:int\n\n\n\nin_zone\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetClassData.add_net",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetClassData.add_net.html#add_net",
        "title": "add_net",
        "section": "add_net",
        "text": "Add a new net.\nThe name of the net to be added.\nadd_net\npython:str\nobject"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetClassData.add_net",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetClassData.add_net.html#pyedb.dotnet.database.edb_data.nets_data.EDBNetClassData.add_net",
        "title": "add_net > add_net > add_net",
        "section": "add_net > add_net",
        "text": "EDBNetClassData.add_net(name)\n\nAdd a new net.\n\nParameters\n\nname\n\npython:str\n\nThe name of the net to be added.\n\nReturns\n\nobject\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_current_source_on_pin",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_current_source_on_pin.html#create_current_source_on_pin",
        "title": "create_current_source_on_pin",
        "section": "create_current_source_on_pin",
        "text": "Create a voltage source.\nPositive Pin.\nNegative Pin.\nValue for the voltage. The default is 3.3.\nValue for the phase. The default is 0.\nName of the source. The default is \"\".\nSource Name.\ncreate_current_source_on_pin\nObject\nObject\npython:float\noptional\n3.3\noptional\n0\npython:str\noptional\n\"\"\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_current_source_on_pin",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_current_source_on_pin.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_current_source_on_pin",
        "title": "create_current_source_on_pin > create_current_source_on_pin > create_current_source_on_pin",
        "section": "create_current_source_on_pin > create_current_source_on_pin",
        "text": "SourceExcitation.create_current_source_on_pin(pos_pin: str | PadstackInstance, neg_pin: str | PadstackInstance, current_value: int | float = 0, phase_value: int | float = 0, source_name: str | None = None) -> str | None\n\nCreate a voltage source.\n\nParameters\n\npos_pin\n\nObject\n\nPositive Pin.\n\nneg_pin\n\nObject\n\nNegative Pin.\n\nvoltage_value\n\npython:float, optional\n\nValue for the voltage. The default is 3.3.\n\nphase_value\n\noptional\n\nValue for the phase. The default is 0.\n\nsource_name\n\npython:str, optional\n\nName of the source. The default is \"\".\n\nReturns\n\npython:str\n\nSource Name.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> pin1 = edb.components[\"U1\"].pins[\"IN\"]\n>>> pin2 = edb.components[\"U1\"].pins[\"GND\"]\n>>> edb.source_excitation.create_current_source_on_pin(pin1, pin2, 0.1, name=\"ISource1\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/net_class",
        "href": "grpc_api/grpc/database/pyedb_lib/net/net_class.html#net-class",
        "title": "Net Class",
        "section": "Net Class",
        "text": "This class is managing EDB net class.\nNetClass\nManages EDB functionalities for a primitives.\nNet Class\nNetClass"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/point_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/point_terminal.html#point-terminal",
        "title": "Point terminal",
        "section": "Point terminal",
        "text": "This class is managing EDB point terminal.\nPointTerminal\nManages point terminal properties.\nPoint terminal\nPointTerminal"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues: Trusted or pre-validated data dictionary.\nA new instance of the Model class with validated data.\nmodel_construct"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_construct.html#pyedb.workflows.drc.drc.MinAnnularRing.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod MinAnnularRing.model_construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nArgs:\n\n_fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues: Trusted or pre-validated data dictionary.\n\nReturns:\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_bundle_wave_port",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_bundle_wave_port.html#create_bundle_wave_port",
        "title": "create_bundle_wave_port",
        "section": "create_bundle_wave_port",
        "text": "Create a bundle wave port.\nPrimitive ID of the positive terminal.\nCoordinate of the point to define the edge terminal.\nThe point must be close to the target edge but not on the two\nends of the edge.\nName of the port. The default is None.\nHorizontal extent factor. The default value is 5.\nVertical extent factor. The default value is 3.\nLaunch Width of PEC. The default value is \"0.01mm\".\nThe tuple contains: (port_name, pyedb.egacy.database.edb_data.sources.ExcitationDifferential).\ncreate_bundle_wave_port\npython:list\npython:list\npython:str\noptional\nNone\npython:int\npython:float\noptional\n5\npython:int\npython:float\noptional\n3\npython:str\noptional\n\"0.01mm\"\npython:tuple"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_bundle_wave_port",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_bundle_wave_port.html#pyedb.dotnet.database.hfss.EdbHfss.create_bundle_wave_port",
        "title": "create_bundle_wave_port > create_bundle_wave_port > create_bundle_wave_port",
        "section": "create_bundle_wave_port > create_bundle_wave_port",
        "text": "EdbHfss.create_bundle_wave_port(primitives_id, points_on_edge, port_name=None, horizontal_extent_factor=5, vertical_extent_factor=3, pec_launch_width='0.01mm')\n\nCreate a bundle wave port.\n\nParameters\n\nprimitives_id\n\npython:list\n\nPrimitive ID of the positive terminal.\n\npoints_on_edge\n\npython:list\n\nCoordinate of the point to define the edge terminal.\nThe point must be close to the target edge but not on the two\nends of the edge.\n\nport_name\n\npython:str, optional\n\nName of the port. The default is None.\n\nhorizontal_extent_factor\n\npython:int, python:float, optional\n\nHorizontal extent factor. The default value is 5.\n\nvertical_extent_factor\n\npython:int, python:float, optional\n\nVertical extent factor. The default value is 3.\n\npec_launch_width\n\npython:str, optional\n\nLaunch Width of PEC. The default value is \"0.01mm\".\n\nReturns\n\npython:tuple\n\nThe tuple contains: (port_name, pyedb.egacy.database.edb_data.sources.ExcitationDifferential).\n\nExamples\n\n>>> edb.hfss.create_bundle_wave_port(0, [\"-50mm\", \"-0mm\"], 1, [\"-50mm\", \"-0.2mm\"])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_stackup_layer_at_elevation",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_stackup_layer_at_elevation.html#add_stackup_layer_at_elevation",
        "title": "add_stackup_layer_at_elevation",
        "section": "add_stackup_layer_at_elevation",
        "text": "Add a stackup layer at a user-specified elevation.\nThis method doe not change the elevenation of other stackup layers.\nadd_stackup_layer_at_elevation\nStackupLayer\nStackupLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_stackup_layer_at_elevation",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_stackup_layer_at_elevation.html#pyedb.grpc.database.stackup.Stackup.add_stackup_layer_at_elevation",
        "title": "add_stackup_layer_at_elevation > add_stackup_layer_at_elevation > add_stackup_layer_at_elevation",
        "section": "add_stackup_layer_at_elevation > add_stackup_layer_at_elevation",
        "text": "Stackup.add_stackup_layer_at_elevation(stackup_layer_to_add)\n\nAdd a stackup layer at a user-specified elevation.\n\nThis method doe not change the elevenation of other stackup layers.\n\nParameters\n\nstackup_layer_to_add\n\nStackupLayer\n\n\n\nReturns\n\nStackupLayer\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.parametrize_polygon",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.parametrize_polygon.html#parametrize_polygon",
        "title": "parametrize_polygon",
        "section": "parametrize_polygon",
        "text": "Parametrize polygon points based on another polygon.\nPolygon to parametrize.\nPolygon used for selection.\nName of offset parameter.\n[x, y] origin point for vector calculation.\nTrue if successful, False otherwise.\nparametrize_polygon\npyedb.dotnet.database.edb_data.primitives_data.Primitive\npyedb.dotnet.database.edb_data.primitives_data.Primitive\npython:str\noptional\npython:list\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.parametrize_polygon",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.parametrize_polygon.html#pyedb.grpc.database.modeler.Modeler.parametrize_polygon",
        "title": "parametrize_polygon > parametrize_polygon > parametrize_polygon",
        "section": "parametrize_polygon > parametrize_polygon",
        "text": "Modeler.parametrize_polygon(polygon, selection_polygon, offset_name='offsetx', origin=None) -> bool\n\nParametrize polygon points based on another polygon.\n\nParameters\n\npolygon\n\npyedb.dotnet.database.edb_data.primitives_data.Primitive\n\nPolygon to parametrize.\n\nselection_polygon\n\npyedb.dotnet.database.edb_data.primitives_data.Primitive\n\nPolygon used for selection.\n\noffset_name\n\npython:str, optional\n\nName of offset parameter.\n\norigin\n\npython:list, optional\n\n[x, y] origin point for vector calculation.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_simulation_setup.SiwaveSimulationSetup.add_sweep",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_simulation_setup.SiwaveSimulationSetup.add_sweep.html#add_sweep",
        "title": "add_sweep",
        "section": "add_sweep",
        "text": "Add a HFSS frequency sweep.\nSweep name.\nType of the sweep. The default is “linear”. Options are:\n- “linear”\n- “linear_count”\n- “decade_count”\n- “octave_count”\n- “exponential”\nStarting frequency. The default is 1.\nStopping frequency. The default is 1e9.\nFrequency step. The default is 1e6. or used for “decade_count”, “linear_count”, “octave_count”\ndistribution. Must be integer in that case.\nWhether the sweep is discrete. The default is False.\nFrequency set is a list adding one or more frequency sweeps. If frequency_set is provided, the other\narguments are ignored except discrete. Default value is None.\nexample of frequency_set : [[‘linear_scale’, ‘50MHz’, ‘200MHz’, ‘10MHz’]].\nadd_sweep\npython:str\noptional\npython:str\noptional\npython:str\npython:float\noptional\n1\npython:str\npython:float\noptional\n1e9\npython:str\npython:float\npython:int\noptional\n1e6\noptional\nFalse\nList\noptional\nfrequency_set\ndiscrete\nNone"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_simulation_setup.SiwaveSimulationSetup.add_sweep",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_simulation_setup.SiwaveSimulationSetup.add_sweep.html#pyedb.grpc.database.simulation_setup.siwave_simulation_setup.SiwaveSimulationSetup.add_sweep",
        "title": "add_sweep > add_sweep > add_sweep",
        "section": "add_sweep > add_sweep",
        "text": "SiwaveSimulationSetup.add_sweep(name=None, distribution='linear', start_freq='0GHz', stop_freq='20GHz', step='10MHz', discrete=False, frequency_set=None) -> bool\n\nAdd a HFSS frequency sweep.\n\nParameters\n\nname\n\npython:str, optional\n\nSweep name.\n\ndistribution\n\npython:str, optional\n\nType of the sweep. The default is “linear”. Options are:\n- “linear”\n- “linear_count”\n- “decade_count”\n- “octave_count”\n- “exponential”\n\nstart_freq\n\npython:str, python:float, optional\n\nStarting frequency. The default is 1.\n\nstop_freq\n\npython:str, python:float, optional\n\nStopping frequency. The default is 1e9.\n\nstep\n\npython:str, python:float, python:int, optional\n\nFrequency step. The default is 1e6. or used for “decade_count”, “linear_count”, “octave_count”\ndistribution. Must be integer in that case.\n\ndiscrete\n\nbool, optional\n\nWhether the sweep is discrete. The default is False.\n\nfrequency_set\n\nList, optional\n\nFrequency set is a list adding one or more frequency sweeps. If frequency_set is provided, the other\narguments are ignored except discrete. Default value is None.\nexample of frequency_set : [[‘linear_scale’, ‘50MHz’, ‘200MHz’, ‘10MHz’]].\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSweep",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSweep.html#controlfilesweep",
        "title": "ControlFileSweep",
        "section": "ControlFileSweep",
        "text": "Represents a frequency sweep.\nSweep name.\nStart frequency.\nStop frequency.\nFrequency step/count.\nSweep type (“Discrete” or “Interpolating”).\nStep type (“LinearStep”, “DecadeCount”, or “LinearCount”).\nWhether to use Q3D for DC point.\nControlFileSweep\npython:str\npython:str\npython:str\npython:str\npython:str\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSweep",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSweep.html#pyedb.grpc.database.control_file.ControlFileSweep",
        "title": "ControlFileSweep > ControlFileSweep > ControlFileSweep",
        "section": "ControlFileSweep > ControlFileSweep",
        "text": "class pyedb.grpc.database.control_file.ControlFileSweep(name: str, start: str, stop: str, step: str, sweep_type: str, step_type: str, use_q3d: bool)\n\nRepresents a frequency sweep.\n\nParameters\n\nname\n\npython:str\n\nSweep name.\n\nstart\n\npython:str\n\nStart frequency.\n\nstop\n\npython:str\n\nStop frequency.\n\nstep\n\npython:str\n\nFrequency step/count.\n\nsweep_type\n\npython:str\n\nSweep type (“Discrete” or “Interpolating”).\n\nstep_type\n\npython:str\n\nStep type (“LinearStep”, “DecadeCount”, or “LinearCount”).\n\nuse_q3d\n\nbool\n\nWhether to use Q3D for DC point.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.plot",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.plot.html#plot",
        "title": "plot",
        "section": "plot",
        "text": "Plot the current polygon on matplotlib.\nWhether if plot the entire net or only the selected polygon. Default is False.\nWhether if show the plot or not. Default is True.\nSave the plot path.\nMatplotlib ax and figures.\nplot\noptional\nFalse\noptional\nTrue\npython:str\noptional\nax\nfig"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.plot",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.plot.html#pyedb.grpc.database.primitive.primitive.Primitive.plot",
        "title": "plot > plot > plot",
        "section": "plot > plot",
        "text": "Primitive.plot(plot_net=False, show=True, save_plot=None)\n\nPlot the current polygon on matplotlib.\n\nParameters\n\nplot_net\n\nbool, optional\n\nWhether if plot the entire net or only the selected polygon. Default is False.\n\nshow\n\nbool, optional\n\nWhether if show the plot or not. Default is True.\n\nsave_plot\n\npython:str, optional\n\nSave the plot path.\n\nReturns\n\n(ax, fig)\n\nMatplotlib ax and figures.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.limits",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.limits.html#limits",
        "title": "limits",
        "section": "limits",
        "text": "Retrieve stackup limits.\nWhether to retrieve only metals. The default is False.\nTrue when successful, False when failed.\nlimits\noptional\nFalse\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.limits",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.limits.html#pyedb.dotnet.database.stackup.Stackup.limits",
        "title": "limits > limits > limits",
        "section": "limits > limits",
        "text": "Stackup.limits(only_metals=False)\n\nRetrieve stackup limits.\n\nParameters\n\nonly_metals\n\nbool, optional\n\nWhether to retrieve only metals. The default is False.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_config",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_config",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_config.html#pyedb.workflows.drc.drc.MinClearance.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "MinClearance.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSweep",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSweep.html#controlfilesweep",
        "title": "ControlFileSweep",
        "section": "ControlFileSweep",
        "text": "ControlFileSweep"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSweep",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSweep.html#pyedb.grpc.database.utility.xml_control_file.ControlFileSweep",
        "title": "ControlFileSweep > ControlFileSweep > ControlFileSweep",
        "section": "ControlFileSweep > ControlFileSweep",
        "text": "class pyedb.grpc.database.utility.xml_control_file.ControlFileSweep(name, start, stop, step, sweep_type, step_type, use_q3d)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/spice_model",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/spice_model.html#spice-model",
        "title": "Spice Model",
        "section": "Spice Model",
        "text": "This class is managing EDB spice model.\nSpiceModel\nManage SpiceModel\nSpice Model\nSpiceModel\nSpiceModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_cpa_simulation_setup.SIWaveCPASimulationSetup",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_cpa_simulation_setup.SIWaveCPASimulationSetup.html#siwavecpasimulationsetup",
        "title": "SIWaveCPASimulationSetup",
        "section": "SIWaveCPASimulationSetup",
        "text": "Represents the setup configuration for SIwave CPA simulations.\n_pedb: The database object representing the active cell.\n_channel_setup (ChannelSetup): The channel setup configuration.\n_solver_options (SolverOptions): The solver options configuration.\nSIWaveCPASimulationSetup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_cpa_simulation_setup.SIWaveCPASimulationSetup",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_cpa_simulation_setup.SIWaveCPASimulationSetup.html#pyedb.grpc.database.simulation_setup.siwave_cpa_simulation_setup.SIWaveCPASimulationSetup",
        "title": "SIWaveCPASimulationSetup > SIWaveCPASimulationSetup > SIWaveCPASimulationSetup",
        "section": "SIWaveCPASimulationSetup > SIWaveCPASimulationSetup",
        "text": "class pyedb.grpc.database.simulation_setup.siwave_cpa_simulation_setup.SIWaveCPASimulationSetup(pedb, name=None, siwave_cpa_setup_class=None)\n\nRepresents the setup configuration for SIwave CPA simulations.\n\nAttributes:\n\n_pedb: The database object representing the active cell.\n_channel_setup (ChannelSetup): The channel setup configuration.\n_solver_options (SolverOptions): The solver options configuration.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.schema_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "schema_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.schema_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.schema_json.html#pyedb.workflows.drc.drc.MinClearance.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod MinClearance.schema_json(*, by_alias: bool = True, ref_template: str = '#/$defs/{model}', **dumps_kwargs: Any) -> str\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.get_simulation_settings",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.get_simulation_settings.html#get_simulation_settings",
        "title": "get_simulation_settings",
        "section": "get_simulation_settings",
        "text": "get_simulation_settings"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.get_simulation_settings",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.get_simulation_settings.html#pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.get_simulation_settings",
        "title": "get_simulation_settings > get_simulation_settings > get_simulation_settings",
        "section": "get_simulation_settings > get_simulation_settings",
        "text": "RaptorXSimulationSetup.get_simulation_settings()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.merge_nets_polygons",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.merge_nets_polygons.html#merge_nets_polygons",
        "title": "merge_nets_polygons",
        "section": "merge_nets_polygons",
        "text": "Merge polygons for specified nets on each layer.\nNet name or list of net names.\nTrue if successful, False otherwise.\nmerge_nets_polygons\npython:str\npython:list\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.merge_nets_polygons",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.merge_nets_polygons.html#pyedb.grpc.database.nets.Nets.merge_nets_polygons",
        "title": "merge_nets_polygons > merge_nets_polygons > merge_nets_polygons",
        "section": "merge_nets_polygons > merge_nets_polygons",
        "text": "Nets.merge_nets_polygons(net_names_list: str | List[str]) -> bool\n\nMerge polygons for specified nets on each layer.\n\nParameters\n\nnet_names_list\n\npython:str | python:list[python:str]\n\nNet name or list of net names.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\nExamples\n\n>>> merged = edb_nets.merge_nets_polygons([\"VDD_CPU\", \"VDD_MEM\"])\n>>> print(\"Merge successful:\", merged)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.update_rlc_from_bom",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.update_rlc_from_bom.html#update_rlc_from_bom",
        "title": "update_rlc_from_bom",
        "section": "update_rlc_from_bom",
        "text": "Update the EDC core component values (RLCs) with values coming from a BOM file.\nFull path to the BOM file, which is a delimited text file.\nHeader values needed inside the BOM reader must\nbe explicitly set if different from the defaults.\nValue to use for the delimiter. The default is \";\".\nField header containing the value of the component. The default is \"Func des\".\nThe value for this parameter must being with the value of the component\nfollowed by a space and then the rest of the value. For example, \"22pF\".\nField header containing the type of component. The default is \"Prod name\". For\nexample, you might enter \"Inductor\".\nField header containing the reference designator of the component. The default is\n\"Pos / Place\". For example, you might enter \"C100\".\nTrue if the file contains the header and it is correctly parsed. True is\nreturned even if no values are assigned.\nupdate_rlc_from_bom\npython:str\npython:str\noptional\n\";\"\npython:str\noptional\n\"Func des\"\n\"22pF\"\npython:str\noptional\n\"Prod name\"\n\"Inductor\"\npython:str\noptional\n\"Pos / Place\"\n\"C100\"\nTrue\nTrue"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.update_rlc_from_bom",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.update_rlc_from_bom.html#pyedb.dotnet.database.components.Components.update_rlc_from_bom",
        "title": "update_rlc_from_bom > update_rlc_from_bom > update_rlc_from_bom",
        "section": "update_rlc_from_bom > update_rlc_from_bom",
        "text": "Components.update_rlc_from_bom(bom_file, delimiter=';', valuefield='Func des', comptype='Prod name', refdes='Pos / Place')\n\nUpdate the EDC core component values (RLCs) with values coming from a BOM file.\n\nParameters\n\nbom_file\n\npython:str\n\nFull path to the BOM file, which is a delimited text file.\nHeader values needed inside the BOM reader must\nbe explicitly set if different from the defaults.\n\ndelimiter\n\npython:str, optional\n\nValue to use for the delimiter. The default is \";\".\n\nvaluefield\n\npython:str, optional\n\nField header containing the value of the component. The default is \"Func des\".\nThe value for this parameter must being with the value of the component\nfollowed by a space and then the rest of the value. For example, \"22pF\".\n\ncomptype\n\npython:str, optional\n\nField header containing the type of component. The default is \"Prod name\". For\nexample, you might enter \"Inductor\".\n\nrefdes\n\npython:str, optional\n\nField header containing the reference designator of the component. The default is\n\"Pos / Place\". For example, you might enter \"C100\".\n\nReturns\n\nbool\n\nTrue if the file contains the header and it is correctly parsed. True is\nreturned even if no values are assigned.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.distance",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.distance.html#distance",
        "title": "distance",
        "section": "distance",
        "text": "Compute the shortest distance from the point to a line segment when an end point is given.         Otherwise, compute the distance between this point and another point.\nStart point of the line segment.\nEnd point of the line segment.\ndistance\npython:None\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.distance",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.distance.html#pyedb.grpc.database.geometry.point_data.PointData.distance",
        "title": "distance > distance > distance",
        "section": "distance > distance",
        "text": "PointData.distance(start: PointLike, end: PointLike = None) -> float\n\nCompute the shortest distance from the point to a line segment when an end point is given.         Otherwise, compute the distance between this point and another point.\n\nParameters\n\nstart\n\nPoint2DLike\n\nStart point of the line segment.\n\nend\n\nPoint2DLike, default: python:None\n\nEnd point of the line segment.\n\nReturns\n\npython:float\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.fix_self_intersections",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.fix_self_intersections.html#fix_self_intersections",
        "title": "fix_self_intersections",
        "section": "fix_self_intersections",
        "text": "Remove self intersections if they exist.\nAll new polygons created from the removal operation.\nfix_self_intersections\nList\nPolygon"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.fix_self_intersections",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.fix_self_intersections.html#pyedb.grpc.database.primitive.polygon.Polygon.fix_self_intersections",
        "title": "fix_self_intersections > fix_self_intersections > fix_self_intersections",
        "section": "fix_self_intersections > fix_self_intersections",
        "text": "Polygon.fix_self_intersections() -> list[any]\n\nRemove self intersections if they exist.\n\nReturns\n\nList[Polygon]\n\nAll new polygons created from the removal operation.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileStackup.add_via",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileStackup.add_via.html#add_via",
        "title": "add_via",
        "section": "add_via",
        "text": "Add a new via layer.\nLayer name.\nDefine the material for this layer.\nDefine the gds type.\nTarget layer used after layout import in EDB and HFSS 3D layout.\nDefine the start layer for the via\nDefine the stop layer for the via.\nWhen True solve inside this layer is anbled. Default value is True.\nDefine the via group method, default value is \"proximity\"\nDefine the via group tolerance.\nWhen True activated otherwise when False``is deactivated. Default value is ``True.\nDefine the via group method, default value is \"distance\"\nDefine the via group tolerance, default value is 10e-9.\nDictionary with key and  property value.\nadd_via\npython:str\npython:str\npython:int\npython:str\npython:str\npython:str\nTrue\nTrue\npython:str\n\"proximity\"\npython:float\nTrue\nFalse``is deactivated. Default value is ``True\npython:str\n\"distance\"\npython:float\npython:dict\npyedb.dotnet.database.edb_data.control_file.ControlFileVia"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileStackup.add_via",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileStackup.add_via.html#pyedb.dotnet.database.edb_data.control_file.ControlFileStackup.add_via",
        "title": "add_via > add_via > add_via",
        "section": "add_via > add_via",
        "text": "ControlFileStackup.add_via(layer_name, material='', gds_type=0, target_layer='', start_layer='', stop_layer='', solve_inside=True, via_group_method='proximity', via_group_tol=1e-06, via_group_persistent=True, snap_via_group_method='distance', snap_via_group_tol=1e-08, properties=None)\n\nAdd a new via layer.\n\nParameters\n\nlayer_name\n\npython:str\n\nLayer name.\n\nmaterial\n\npython:str\n\nDefine the material for this layer.\n\ngds_type\n\npython:int\n\nDefine the gds type.\n\ntarget_layer\n\npython:str\n\nTarget layer used after layout import in EDB and HFSS 3D layout.\n\nstart_layer\n\npython:str\n\nDefine the start layer for the via\n\nstop_layer\n\npython:str\n\nDefine the stop layer for the via.\n\nsolve_inside\n\nbool\n\nWhen True solve inside this layer is anbled. Default value is True.\n\nvia_group_method\n\npython:str\n\nDefine the via group method, default value is \"proximity\"\n\nvia_group_tol\n\npython:float\n\nDefine the via group tolerance.\n\nvia_group_persistent\n\nbool\n\nWhen True activated otherwise when False``is deactivated. Default value is ``True.\n\nsnap_via_group_method\n\npython:str\n\nDefine the via group method, default value is \"distance\"\n\nsnap_via_group_tol\n\npython:float\n\nDefine the via group tolerance, default value is 10e-9.\n\nproperties\n\npython:dict\n\nDictionary with key and  property value.\n\nReturns\n\npyedb.dotnet.database.edb_data.control_file.ControlFileVia\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/index",
        "href": "grpc_api/grpc/database/pyedb_lib/net/index.html#net-classes",
        "title": "Net classes",
        "section": "Net classes",
        "text": "This section describes EDB net classes.\nNet classes"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.html#componentdef",
        "title": "ComponentDef",
        "section": "ComponentDef",
        "text": "Manages EDB functionalities for component definitions.\nInherited AEDT object.\nEdb ComponentDef Object\nComponentDef.add_component_model(value)\nAdd a component model to this component def.\nComponentDef.add_n_port_model(fpath[, name])\nAdd N-port model.\nComponentDef.assign_rlc_model([res, ind, ...])\nAssign RLC to all components under this part name.\nComponentDef.assign_s_param_model(file_path)\nAssign S-parameter to all components under this part name.\nComponentDef.assign_spice_model(file_path[, ...])\nAssign Spice model to all components under this part name.\nComponentDef.create(db, comp_def_name, fp)\nCreate a component definition in a given database.\nComponentDef.find(db, comp_def_name)\nFind a component definition in a given database.\nComponentDef.get_product_property(prod_id, ...)\nGet the product property for a given product ID and attribute ID.\nComponentDef.get_product_property_ids(prod_id)\nGet the list of property IDs for a given property ID.\nComponentDef.get_properties()\n\nComponentDef.remove_component_model(value)\nRemove a component model from this component def.\nComponentDef.remove_pin(pin_to_remove)\nRemove the provided component pin from the component definition.\nComponentDef.reorder_pins(reordered_pins)\nReorders the existing pins in the components definition to be in the same order         as in the provided list.\nComponentDef.set_product_property(prod_id, ...)\nSet the product property for the given product ID and attribute ID.\nComponentDef.set_properties(**kwargs)\n\nComponentDef\nEdb\nobject\nComponentDef.add_component_model\nComponentDef.add_n_port_model\nComponentDef.assign_rlc_model\nComponentDef.assign_s_param_model\nComponentDef.assign_spice_model\nComponentDef.create\nComponentDef.find\nComponentDef.get_product_property\nComponentDef.get_product_property_ids\nComponentDef.get_properties\nComponentDef.remove_component_model\nComponentDef.remove_pin\nComponentDef.reorder_pins\nComponentDef.set_product_property\nComponentDef.set_properties"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.html#pyedb.grpc.database.definition.component_def.ComponentDef",
        "title": "ComponentDef > ComponentDef > ComponentDef",
        "section": "ComponentDef > ComponentDef",
        "text": "class pyedb.grpc.database.definition.component_def.ComponentDef(pedb, edb_object)\n\nManages EDB functionalities for component definitions.\n\nParameters\n\npedb\n\nEdb\n\nInherited AEDT object.\n\nedb_object\n\nobject\n\nEdb ComponentDef Object\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nComponentDef.add_component_model(value)\n\nAdd a component model to this component def.\n\nComponentDef.add_n_port_model(fpath[, name])\n\nAdd N-port model.\n\nComponentDef.assign_rlc_model([res, ind, ...])\n\nAssign RLC to all components under this part name.\n\nComponentDef.assign_s_param_model(file_path)\n\nAssign S-parameter to all components under this part name.\n\nComponentDef.assign_spice_model(file_path[, ...])\n\nAssign Spice model to all components under this part name.\n\nComponentDef.create(db, comp_def_name, fp)\n\nCreate a component definition in a given database.\n\nComponentDef.find(db, comp_def_name)\n\nFind a component definition in a given database.\n\nComponentDef.get_product_property(prod_id, ...)\n\nGet the product property for a given product ID and attribute ID.\n\nComponentDef.get_product_property_ids(prod_id)\n\nGet the list of property IDs for a given property ID.\n\nComponentDef.get_properties()\n\n\n\nComponentDef.remove_component_model(value)\n\nRemove a component model from this component def.\n\nComponentDef.remove_pin(pin_to_remove)\n\nRemove the provided component pin from the component definition.\n\nComponentDef.reorder_pins(reordered_pins)\n\nReorders the existing pins in the components definition to be in the same order         as in the provided list.\n\nComponentDef.set_product_property(prod_id, ...)\n\nSet the product property for the given product ID and attribute ID.\n\nComponentDef.set_properties(**kwargs)\n\n\n\n"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "validate"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.validate.html#pyedb.workflows.drc.drc.Rules.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod Rules.validate(value: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.merge_via_along_lines",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.merge_via_along_lines.html#merge_via_along_lines",
        "title": "merge_via_along_lines",
        "section": "merge_via_along_lines",
        "text": "Replace padstack instances along lines into a single polygon.\nDetect all pad-stack instances that are placed along lines and replace them by a single polygon based one\nforming a wall shape. This method is designed to simplify meshing on via fence usually added to shield RF traces\non PCB.\nNet name used for detected pad-stack instances. Default value is \"GND\".\nIf two points in a line are separated by a distance larger than distance_threshold,\nthe line is divided in two parts. Default is 5e-3 (5mm), in which case the control is not performed.\nThe minimum number of points that a line must contain. Default is 6.\nSpecify angle in degrees to detected, for instance [0, 180] is only detecting horizontal and vertical lines.\nOther values can be assigned like 45 degrees. When None is provided all lines are detected. Default value\nis None.\nList of pad-stack instances ID’s to include. If None, the algorithm will scan all pad-stack\ninstances belonging to the specified net. Default value is None.\nmerge_via_along_lines\npython:str\n\"GND\"\npython:float\npython:None\noptional\n5e-3\npython:int\noptional\n6\npython:list\npython:int\npython:float\nList\npython:int\nList\npython:int\npython:list\nof\ncreated\ninstances"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.merge_via_along_lines",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.merge_via_along_lines.html#pyedb.grpc.database.padstacks.Padstacks.merge_via_along_lines",
        "title": "merge_via_along_lines > merge_via_along_lines > merge_via_along_lines",
        "section": "merge_via_along_lines > merge_via_along_lines",
        "text": "Padstacks.merge_via_along_lines(net_name: str = 'GND', distance_threshold: float = 0.005, minimum_via_number: int = 6, selected_angles: List[float] | None = None, padstack_instances_id: List[int] | None = None) -> List[str]\n\nReplace padstack instances along lines into a single polygon.\n\nDetect all pad-stack instances that are placed along lines and replace them by a single polygon based one\nforming a wall shape. This method is designed to simplify meshing on via fence usually added to shield RF traces\non PCB.\n\nParameters\n\nnet_name\n\npython:str\n\nNet name used for detected pad-stack instances. Default value is \"GND\".\n\ndistance_threshold\n\npython:float, python:None, optional\n\nIf two points in a line are separated by a distance larger than distance_threshold,\nthe line is divided in two parts. Default is 5e-3 (5mm), in which case the control is not performed.\n\nminimum_via_number\n\npython:int, optional\n\nThe minimum number of points that a line must contain. Default is 6.\n\nselected_angles\n\npython:list[python:int, python:float]\n\nSpecify angle in degrees to detected, for instance [0, 180] is only detecting horizontal and vertical lines.\nOther values can be assigned like 45 degrees. When None is provided all lines are detected. Default value\nis None.\n\npadstack_instances_id\n\nList[python:int]\n\nList of pad-stack instances ID’s to include. If None, the algorithm will scan all pad-stack\ninstances belonging to the specified net. Default value is None.\n\nReturns\n\nList[python:int], python:list of created pad-stack instances id.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.import_vlctech_stackup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.import_vlctech_stackup.html#import_vlctech_stackup",
        "title": "import_vlctech_stackup",
        "section": "import_vlctech_stackup",
        "text": "Import a vlc.tech file and generate an edb.def file in the working directory containing only the stackup.\nFull path to the technology stackup file. It must be vlc.tech.\nDirectory in which to create the aedb folder. The name given to the AEDB file\nis the same as the name of the board file.\nExport technology file in XML control file format.\nimport_vlctech_stackup\nedb.def\npython:str\npython:str\noptional\naedb\npython:str\noptional\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.import_vlctech_stackup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.import_vlctech_stackup.html#pyedb.dotnet.edb.Edb.import_vlctech_stackup",
        "title": "import_vlctech_stackup > import_vlctech_stackup > import_vlctech_stackup",
        "section": "import_vlctech_stackup > import_vlctech_stackup",
        "text": "Edb.import_vlctech_stackup(vlctech_file, working_dir='', export_xml=None)\n\nImport a vlc.tech file and generate an edb.def file in the working directory containing only the stackup.\n\nParameters\n\nvlctech_file\n\npython:str\n\nFull path to the technology stackup file. It must be vlc.tech.\n\nworking_dir\n\npython:str, optional\n\nDirectory in which to create the aedb folder. The name given to the AEDB file\nis the same as the name of the board file.\n\nexport_xml\n\npython:str, optional\n\nExport technology file in XML control file format.\n\nReturns\n\nFull path to the AEDB file\n\npython:str\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.reconstruct_arcs",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.reconstruct_arcs.html#reconstruct_arcs",
        "title": "reconstruct_arcs",
        "section": "reconstruct_arcs",
        "text": "Reconstruct arcs of polygons on a layer.\nLayers to reconstruct arcs on.\nTolerance.\nreconstruct_arcs\npython:list\nof\nValue"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.reconstruct_arcs",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.reconstruct_arcs.html#pyedb.grpc.database.layout.layout.Layout.reconstruct_arcs",
        "title": "reconstruct_arcs > reconstruct_arcs > reconstruct_arcs",
        "section": "reconstruct_arcs > reconstruct_arcs",
        "text": "Layout.reconstruct_arcs(layer: LayerListLike, tolerance: Value)\n\nReconstruct arcs of polygons on a layer.\n\nParameters\n\nlayer\n\nLayerLike or python:list of LayerLike\n\nLayers to reconstruct arcs on.\n\ntolerance\n\nValue\n\nTolerance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPairs.create",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPairs.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Name of the differential pair.\nName of the positive net.\nName of the negative net.\ncreate\npython:str\npython:str\npython:str\npyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPairs.create",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPairs.create.html#pyedb.grpc.database.net.differential_pair.DifferentialPairs.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "DifferentialPairs.create(name: str, net_p: str, net_n: str) -> DifferentialPair\n\nParameters\n\nname\n\npython:str\n\nName of the differential pair.\n\nnet_p\n\npython:str\n\nName of the positive net.\n\nnet_n\n\npython:str\n\nName of the negative net.\n\nReturns\n\npyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.find",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.find.html#find",
        "title": "find",
        "section": "find",
        "text": "Find a terminal by name in a given layout.\nLayout to search for the terminal.\nName of the terminal.\nfind\nLayout\nstr\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.find",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.find.html#pyedb.grpc.database.ports.ports.WavePort.find",
        "title": "find > find > find",
        "section": "find > find",
        "text": "classmethod WavePort.find(layout, name)\n\nFind a terminal by name in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the terminal.\n\nname\n\nstr\n\nName of the terminal.\n\nReturns\n\nTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.variables.Variable",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.variables.Variable.html#variable",
        "title": "Variable",
        "section": "Variable",
        "text": "Manages EDB methods for variable accessible from Edb.Utility.VariableServer property.\nVariable.delete()\nDelete this variable.\nVariable\nVariable.delete"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.variables.Variable",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.variables.Variable.html#pyedb.dotnet.database.edb_data.variables.Variable",
        "title": "Variable > Variable > Variable",
        "section": "Variable > Variable",
        "text": "class pyedb.dotnet.database.edb_data.variables.Variable(pedb, name)\n\nManages EDB methods for variable accessible from Edb.Utility.VariableServer property.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nVariable.delete()\n\nDelete this variable.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFile.parse_layer_map",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFile.parse_layer_map.html#parse_layer_map",
        "title": "parse_layer_map",
        "section": "parse_layer_map",
        "text": "Parse layer map and adds info to the stackup info.\nThis operation must be performed after a tech file is imported.\nFull path to “.map” file.\nparse_layer_map\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFile.parse_layer_map",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFile.parse_layer_map.html#pyedb.grpc.database.utility.xml_control_file.ControlFile.parse_layer_map",
        "title": "parse_layer_map > parse_layer_map > parse_layer_map",
        "section": "parse_layer_map > parse_layer_map",
        "text": "ControlFile.parse_layer_map(layer_map)\n\nParse layer map and adds info to the stackup info.\nThis operation must be performed after a tech file is imported.\n\nParameters\n\nlayer_map\n\npython:str\n\nFull path to “.map” file.\n\nReturns\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.set_variable_desc",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.set_variable_desc.html#set_variable_desc",
        "title": "set_variable_desc",
        "section": "set_variable_desc",
        "text": "Set a variable to have a new description.\nVariable name.\nNew variable description.\nset_variable_desc\npython:str\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.set_variable_desc",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.set_variable_desc.html#pyedb.grpc.database.layout.cell.Cell.set_variable_desc",
        "title": "set_variable_desc > set_variable_desc > set_variable_desc",
        "section": "set_variable_desc > set_variable_desc",
        "text": "Cell.set_variable_desc(name, desc)\n\nSet a variable to have a new description.\n\nParameters\n\nname\n\npython:str\n\nVariable name.\n\ndesc\n\npython:str\n\nNew variable description.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.find",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.find.html#find",
        "title": "find",
        "section": "find",
        "text": "Find a terminal by name in a given layout.\nLayout to search for the terminal.\nName of the terminal.\nfind\nLayout\nstr\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.find",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.find.html#pyedb.grpc.database.ports.ports.BundleWavePort.find",
        "title": "find > find > find",
        "section": "find > find",
        "text": "classmethod BundleWavePort.find(layout, name)\n\nFind a terminal by name in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the terminal.\n\nname\n\nstr\n\nName of the terminal.\n\nReturns\n\nTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_hfss_prop.html#get_hfss_prop",
        "title": "get_hfss_prop",
        "section": "get_hfss_prop",
        "text": "Get HFSS properties.\nReturns a tuple in this format:\n(material, solve_inside)\nmaterial :  Name of the material property.\nsolve_inside : Whether to solve inside.\nget_hfss_prop\npython:tuple\nof\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_hfss_prop.html#pyedb.grpc.database.primitive.rectangle.Rectangle.get_hfss_prop",
        "title": "get_hfss_prop > get_hfss_prop > get_hfss_prop",
        "section": "get_hfss_prop > get_hfss_prop",
        "text": "Rectangle.get_hfss_prop() -> tuple[str, bool]\n\nGet HFSS properties.\n\nReturns\n\npython:tuple of (python:str, bool)\n\nReturns a tuple in this format:\n\n(material, solve_inside)\n\nmaterial :  Name of the material property.\n\nsolve_inside : Whether to solve inside.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_dump_json",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#json-mode)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent: Indentation to use in the JSON output. If None is passed, the output will be compact.\nensure_ascii: If True, the output is guaranteed to have all incoming non-ASCII characters escaped.\nIf False (the default), these characters will be output as-is.\ninclude: Field(s) to include in the JSON output.\nexclude: Field(s) to exclude from the JSON output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to serialize using field aliases.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\nA JSON string representation of the model.\nmodel_dump_json"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_dump_json",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_dump_json.html#pyedb.grpc.database.definition.materials.MaterialProperties.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "MaterialProperties.model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -> str\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#json-mode)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nArgs:\n\nindent: Indentation to use in the JSON output. If None is passed, the output will be compact.\nensure_ascii: If True, the output is guaranteed to have all incoming non-ASCII characters escaped.\n\nIf False (the default), these characters will be output as-is.\n\ninclude: Field(s) to include in the JSON output.\nexclude: Field(s) to exclude from the JSON output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to serialize using field aliases.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\n\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\n\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback: A function to call when an unknown value is encountered. If not provided,\n\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.set_rlc",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.set_rlc.html#set_rlc",
        "title": "set_rlc",
        "section": "set_rlc",
        "text": "Set the RLC value for a pin pair.\nset_rlc\npython:tuple\npython:str\npython:str\nRlc"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.set_rlc",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.set_rlc.html#pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.set_rlc",
        "title": "set_rlc > set_rlc > set_rlc",
        "section": "set_rlc > set_rlc",
        "text": "PinPairModel.set_rlc(pin_pair, rlc)\n\nSet the RLC value for a pin pair.\n\nParameters\n\npin_pair\n\npython:tuple[python:str, python:str]\n\n\n\nrlc\n\nRlc\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_port",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_port.html#create_port",
        "title": "create_port",
        "section": "create_port",
        "text": "Create a port.\nclass:pyedb.grpc.database.terminals.PadstackInstanceTerminal,\nclass:pyedb.grpc.database.terminals.PointTerminal,\nclass:pyedb.grpc.database.terminals.PinGroupTerminal,\nPositive terminal of the port.\nclass:pyedb.grpc.database.terminals.PadstackInstanceTerminal,\nclass:pyedb.grpc.database.terminals.PointTerminal,\nclass:pyedb.grpc.database.terminals.PinGroupTerminal,\noptional\nNegative terminal of the port.\nWhether it is a circuit port. The default is False.\nName of the created port. The default is None, a random name is generated.\nWavePort].\ncreate_port\noptional\nFalse\nWavePort"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_port",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_port.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_port",
        "title": "create_port > create_port > create_port",
        "section": "create_port > create_port",
        "text": "SourceExcitation.create_port(terminal: Terminal, ref_terminal: Terminal | None = None, is_circuit_port: bool = False, name: str | None = None) -> Any\n\nCreate a port.\n\nParameters\n\nterminal\n\nclass:pyedb.dotnet.database.edb_data.terminals.EdgeTerminal,\n\nclass:pyedb.grpc.database.terminals.PadstackInstanceTerminal,\nclass:pyedb.grpc.database.terminals.PointTerminal,\nclass:pyedb.grpc.database.terminals.PinGroupTerminal,\nPositive terminal of the port.\n\nref_terminal\n\nclass:pyedb.grpc.database.terminals.EdgeTerminal,\n\nclass:pyedb.grpc.database.terminals.PadstackInstanceTerminal,\nclass:pyedb.grpc.database.terminals.PointTerminal,\nclass:pyedb.grpc.database.terminals.PinGroupTerminal,\noptional\nNegative terminal of the port.\n\nis_circuit_port\n\nbool, optional\n\nWhether it is a circuit port. The default is False.\n\nname: str, optional\n\nName of the created port. The default is None, a random name is generated.\n\nReturns\n\n\n\n——-\n\n\n\nlist: [:class:`GapPort <pyedb.grpc.database.ports.ports.GapPort`>,\n\nWavePort].\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> term = edb.terminals[\"MyTerminal\"]\n>>> ref_term = edb.terminals[\"RefTerminal\"]\n>>> port = edb.source_excitation.create_port(term, ref_term, name=\"Port1\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFile.write_xml",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFile.write_xml.html#write_xml",
        "title": "write_xml",
        "section": "write_xml",
        "text": "Write xml to output file\nPath to the output xml file.\nwrite_xml\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFile.write_xml",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFile.write_xml.html#pyedb.grpc.database.utility.xml_control_file.ControlFile.write_xml",
        "title": "write_xml > write_xml > write_xml",
        "section": "write_xml > write_xml",
        "text": "ControlFile.write_xml(xml_output)\n\nWrite xml to output file\n\nParameters\n\nxml_output\n\npython:str\n\nPath to the output xml file.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the layout object.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.delete.html#pyedb.grpc.database.ports.ports.CircuitPort.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "CircuitPort.delete()\n\nDelete the layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileStackup.add_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileStackup.add_layer.html#add_layer",
        "title": "add_layer",
        "section": "add_layer",
        "text": "Add a new layer.\nLayer name.\nLayer elevation (Z-position).\nMaterial name.\nGDS data type for layer.\nTarget layer name in EDB/HFSS.\nLayer thickness.\nLayer type (“conductor”, “signal”, etc.). Default is “conductor”.\nWhether to solve inside metal. Default is True.\nAdditional layer properties. Overrides default parameters.\nCreated layer object.\nadd_layer\npython:str\npython:float\npython:str\npython:int\npython:str\npython:float\npython:str\noptional\noptional\nTrue\npython:dict\noptional\nControlFileLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileStackup.add_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileStackup.add_layer.html#pyedb.grpc.database.control_file.ControlFileStackup.add_layer",
        "title": "add_layer > add_layer > add_layer",
        "section": "add_layer > add_layer",
        "text": "ControlFileStackup.add_layer(layer_name: str, elevation: float = 0.0, material: str = '', gds_type: int = 0, target_layer: str = '', thickness: float = 0.0, layer_type: str = 'conductor', solve_inside: bool = True, properties: Dict[str, Any] | None = None) -> ControlFileLayer\n\nAdd a new layer.\n\nParameters\n\nlayer_name\n\npython:str\n\nLayer name.\n\nelevation\n\npython:float\n\nLayer elevation (Z-position).\n\nmaterial\n\npython:str\n\nMaterial name.\n\ngds_type\n\npython:int\n\nGDS data type for layer.\n\ntarget_layer\n\npython:str\n\nTarget layer name in EDB/HFSS.\n\nthickness\n\npython:float\n\nLayer thickness.\n\nlayer_type\n\npython:str, optional\n\nLayer type (“conductor”, “signal”, etc.). Default is “conductor”.\n\nsolve_inside\n\nbool, optional\n\nWhether to solve inside metal. Default is True.\n\nproperties\n\npython:dict, optional\n\nAdditional layer properties. Overrides default parameters.\n\nReturns\n\nControlFileLayer\n\nCreated layer object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.plot",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.plot.html#plot",
        "title": "plot",
        "section": "plot",
        "text": "Plot the net using Matplotlib.\nLayer name(s) to include. If None, uses all signal layers.\nEnable legend display. Default: True.\nFull path to save the plot image. If specified, overrides show.\nOutline points for plot boundary.\nImage dimensions in pixels (width, height). Default: (2000, 1000).\nDisplay the plot. Default: True.\nPlot title. Uses net name if None. Default: None.\nplot\npython:str\npython:list\npython:str\noptional\nNone\noptional\nTrue\npython:str\noptional\nshow\npython:list\noptional\npython:tuple\noptional\noptional\nTrue\npython:str\noptional\nNone\nNone"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.plot",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.plot.html#pyedb.grpc.database.net.net.Net.plot",
        "title": "plot > plot > plot",
        "section": "plot > plot",
        "text": "Net.plot(layers=None, show_legend=True, save_plot=None, outline=None, size=(2000, 1000), show=True, title=None)\n\nPlot the net using Matplotlib.\n\nParameters\n\nlayers\n\npython:str or python:list[python:str], optional\n\nLayer name(s) to include. If None, uses all signal layers.\n\nshow_legend\n\nbool, optional\n\nEnable legend display. Default: True.\n\nsave_plot\n\npython:str, optional\n\nFull path to save the plot image. If specified, overrides show.\n\noutline\n\npython:list, optional\n\nOutline points for plot boundary.\n\nsize\n\npython:tuple, optional\n\nImage dimensions in pixels (width, height). Default: (2000, 1000).\n\nshow\n\nbool, optional\n\nDisplay the plot. Default: True.\n\ntitle\n\npython:str, optional\n\nPlot title. Uses net name if None. Default: None.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.remove_power_modules",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.remove_power_modules.html#remove_power_modules",
        "title": "remove_power_modules",
        "section": "remove_power_modules",
        "text": "Remove multiple power modules from the voltage regulator.\nList of component group names of each power module to remove.\nremove_power_modules\npython:list\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.remove_power_modules",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.remove_power_modules.html#pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.remove_power_modules",
        "title": "remove_power_modules > remove_power_modules > remove_power_modules",
        "section": "remove_power_modules > remove_power_modules",
        "text": "VoltageRegulator.remove_power_modules(names)\n\nRemove multiple power modules from the voltage regulator.\n\nParameters\n\nnames\n\npython:list[python:str]\n\nList of component group names of each power module to remove.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.use_s_parameter_model",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.use_s_parameter_model.html#use_s_parameter_model",
        "title": "use_s_parameter_model",
        "section": "use_s_parameter_model",
        "text": "Use S-parameter model on the component.\nName of the S-parameter model.\nReference net of the model.\nTrue when successful, False when failed.\nuse_s_parameter_model\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.use_s_parameter_model",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.use_s_parameter_model.html#pyedb.grpc.database.hierarchy.component.Component.use_s_parameter_model",
        "title": "use_s_parameter_model > use_s_parameter_model > use_s_parameter_model",
        "section": "use_s_parameter_model > use_s_parameter_model",
        "text": "Component.use_s_parameter_model(name, reference_net=None) -> bool\n\nUse S-parameter model on the component.\n\nParameters\n\nname: str\n\nName of the S-parameter model.\n\nreference_net: str, optional\n\nReference net of the model.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> edbapp = Edb()\n>>>comp_def = edbapp.definitions.components[\"CAPC3216X180X55ML20T25\"]\n>>>comp_def.add_n_port_model(\"c:GRM32_DC0V_25degC_series.s2p\", \"GRM32_DC0V_25degC_series\")\n>>>edbapp.components[\"C200\"].use_s_parameter_model(\"GRM32_DC0V_25degC_series\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/pin_pair_model",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/pin_pair_model.html#pin-pair-model",
        "title": "Pin Pair Model",
        "section": "Pin Pair Model",
        "text": "This class is managing EDB pin pair model.\nPinPairModel\nManage pin-pair model.\nPin Pair Model\nPinPairModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.area",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.area.html#area",
        "title": "area",
        "section": "area",
        "text": "Return the total area.\nEither if the voids have to be included in computation.\nThe default value is True.\narea\noptional\nTrue\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.area",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.area.html#pyedb.grpc.database.primitive.circle.Circle.area",
        "title": "area > area > area",
        "section": "area > area",
        "text": "Circle.area(include_voids=True) -> float\n\nReturn the total area.\n\nParameters\n\ninclude_voids\n\nbool, optional\n\nEither if the voids have to be included in computation.\nThe default value is True.\n\nReturns\n\npython:float\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.type.html#type",
        "title": "type",
        "section": "type",
        "text": "type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.type.html#pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.type",
        "title": "type > type > type",
        "section": "type > type",
        "text": "PinGroupTerminal.type = 5\n\n"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.cutout",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.cutout.html#cutout",
        "title": "cutout",
        "section": "cutout",
        "text": "Create a cutout using an approach entirely based on PyAEDT.\nThis method replaces all legacy cutout methods in PyAEDT.\nIt does in sequence:\n- delete all nets not in list,\n- create a extent of the nets,\n- check and delete all vias not in the extent,\n- check and delete all the primitives not in extent,\n- check and intersect all the primitives that intersect the extent.\nList of signal strings.\nList of references to add. The default is [\"GND\"].\nType of the extension. Options are \"Conforming\", \"ConvexHull\", and\n\"Bounding\". The default is \"Conforming\".\nExpansion size ratio in meters. The default is 0.002.\nWhether to use round corners. The default is False.\nFull path and name for the new AEDB file. If None, then current aedb will be cutout.\nWhether to open the cutout at the end. The default is True.\nWhether to use new PyAEDT cutout method or EDB API method.\nNew method is faster than native API method since it benefits of multithread.\nNumber of thread to use. Default is 4. Valid only if use_pyaedt_cutout is set to True.\nWhether to use legacy extent computing (experimental) or EDB API.\nDefeature the cutout before applying it to produce simpler geometry for mesh (Experimental).\nIt applies only to Conforming bounding box. Default value is 0 which disable it.\nRemove all Single Pin RLC after the cutout is completed. Default is False.\nPoints list defining the cutout shape. This setting will override extent_type field.\nUnits of the point list. The default is \"mm\". Valid only if custom_extend is provided.\nWhether to include padstack instances that have bounding boxes intersecting with point list polygons.\nThis operation may slow down the cutout export.Valid only if custom_extend and\nuse_pyaedt_cutout is provided.\nBoolean used for keep or not the voids intersecting the polygon used for clipping the layout.\nDefault value is True, False will remove the voids.Valid only if custom_extend is provided.\nWhether to check for all reference terminals and increase extent to include them into the cutout.\nThis applies to components which have a model (spice, touchstone or netlist) associated.\nWhether to check for all pingroups terminals and increase extent to include them into the cutout.\nIt requires check_terminals.\nThe method computes a float representing the largest number between\nthe dielectric thickness or trace width multiplied by the expansion_factor factor.\nThe trace width search is limited to nets with ports attached. Works only if use_pyaedt_cutout.\nDefault is 0 to disable the search.\nMaximum number of iterations before stopping a search for a cutout with an error.\nDefault is 10.\nWhether to preserve all pins of components that have associated models (Spice or NPort).\nThis parameter is applicable only for a PyAEDT cutout (except point list).\nWhether to use the center of the pad to find the intersection with extent or use the bounding box.\nSecond method is much slower and requires to disable multithread on padstack removal.\nDefault is True.\nWhether to keep the lines as Path after they are cutout or convert them to PolygonData.\nThis feature works only in Electronics Desktop (3D Layout).\nIf the flag is set to True it can cause issues in SiWave once the Edb is imported.\nDefault is False to generate PolygonData of cut lines.\nWhether to compute and include voids in pyaedt extent before the cutout. Cutout time can be affected.\nIt works only with Conforming cutout.\nDefault is False to generate extent without voids.\nList of coordinate points defining the extent used for clipping the design. If it failed return an empty\nlist.\ncutout\npython:list\npython:list\noptional\n[\"GND\"]\npython:str\noptional\n\"Conforming\"\n\"ConvexHull\"\n\"Bounding\"\n\"Conforming\"\npython:float\npython:str\noptional\n0.002\noptional\nFalse\npython:str\noptional\noptional\nTrue\noptional\npython:int\noptional\nuse_pyaedt_cutout\nTrue\noptional\npython:float\noptional\n0\noptional\npython:list\npython:str\n\"mm\"\noptional\nTrue\nFalse\noptional\noptional\ncheck_terminals\npython:int\noptional\npython:int\noptional\noptional\noptional\noptional\nTrue\nFalse\noptional\nFalse\nList"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.cutout",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.cutout.html#pyedb.grpc.edb.Edb.cutout",
        "title": "cutout > cutout > cutout",
        "section": "cutout > cutout",
        "text": "Edb.cutout(signal_nets=None, reference_nets=None, extent_type='ConvexHull', expansion_size=0.002, use_round_corner=False, output_aedb_path=None, open_cutout_at_end=True, use_pyaedt_cutout=True, number_of_threads=1, use_pyaedt_extent_computing=True, extent_defeature=0, remove_single_pin_components=False, custom_extent=None, custom_extent_units='mm', include_partial_instances=False, keep_voids=True, check_terminals=False, include_pingroups=False, expansion_factor=0, maximum_iterations=10, preserve_components_with_model=False, simple_pad_check=True, keep_lines_as_path=False, include_voids_in_extents=False)\n\nCreate a cutout using an approach entirely based on PyAEDT.\nThis method replaces all legacy cutout methods in PyAEDT.\nIt does in sequence:\n- delete all nets not in list,\n- create a extent of the nets,\n- check and delete all vias not in the extent,\n- check and delete all the primitives not in extent,\n- check and intersect all the primitives that intersect the extent.\n\nParameters\n\nsignal_nets\n\npython:list\n\nList of signal strings.\n\nreference_nets\n\npython:list, optional\n\nList of references to add. The default is [\"GND\"].\n\nextent_type\n\npython:str, optional\n\nType of the extension. Options are \"Conforming\", \"ConvexHull\", and\n\"Bounding\". The default is \"Conforming\".\n\nexpansion_size\n\npython:float, python:str, optional\n\nExpansion size ratio in meters. The default is 0.002.\n\nuse_round_corner\n\nbool, optional\n\nWhether to use round corners. The default is False.\n\noutput_aedb_path\n\npython:str, optional\n\nFull path and name for the new AEDB file. If None, then current aedb will be cutout.\n\nopen_cutout_at_end\n\nbool, optional\n\nWhether to open the cutout at the end. The default is True.\n\nuse_pyaedt_cutout\n\nbool, optional\n\nWhether to use new PyAEDT cutout method or EDB API method.\nNew method is faster than native API method since it benefits of multithread.\n\nnumber_of_threads\n\npython:int, optional\n\nNumber of thread to use. Default is 4. Valid only if use_pyaedt_cutout is set to True.\n\nuse_pyaedt_extent_computing\n\nbool, optional\n\nWhether to use legacy extent computing (experimental) or EDB API.\n\nextent_defeature\n\npython:float, optional\n\nDefeature the cutout before applying it to produce simpler geometry for mesh (Experimental).\nIt applies only to Conforming bounding box. Default value is 0 which disable it.\n\nremove_single_pin_components\n\nbool, optional\n\nRemove all Single Pin RLC after the cutout is completed. Default is False.\n\ncustom_extent\n\npython:list\n\nPoints list defining the cutout shape. This setting will override extent_type field.\n\ncustom_extent_units\n\npython:str\n\nUnits of the point list. The default is \"mm\". Valid only if custom_extend is provided.\n\ninclude_partial_instances\n\nbool, optional\n\nWhether to include padstack instances that have bounding boxes intersecting with point list polygons.\nThis operation may slow down the cutout export.Valid only if custom_extend and\nuse_pyaedt_cutout is provided.\n\nkeep_voids\n\nbool\n\nBoolean used for keep or not the voids intersecting the polygon used for clipping the layout.\nDefault value is True, False will remove the voids.Valid only if custom_extend is provided.\n\ncheck_terminals\n\nbool, optional\n\nWhether to check for all reference terminals and increase extent to include them into the cutout.\nThis applies to components which have a model (spice, touchstone or netlist) associated.\n\ninclude_pingroups\n\nbool, optional\n\nWhether to check for all pingroups terminals and increase extent to include them into the cutout.\nIt requires check_terminals.\n\nexpansion_factor\n\npython:int, optional\n\nThe method computes a float representing the largest number between\nthe dielectric thickness or trace width multiplied by the expansion_factor factor.\nThe trace width search is limited to nets with ports attached. Works only if use_pyaedt_cutout.\nDefault is 0 to disable the search.\n\nmaximum_iterations\n\npython:int, optional\n\nMaximum number of iterations before stopping a search for a cutout with an error.\nDefault is 10.\n\npreserve_components_with_model\n\nbool, optional\n\nWhether to preserve all pins of components that have associated models (Spice or NPort).\nThis parameter is applicable only for a PyAEDT cutout (except point list).\n\nsimple_pad_check\n\nbool, optional\n\nWhether to use the center of the pad to find the intersection with extent or use the bounding box.\nSecond method is much slower and requires to disable multithread on padstack removal.\nDefault is True.\n\nkeep_lines_as_path\n\nbool, optional\n\nWhether to keep the lines as Path after they are cutout or convert them to PolygonData.\nThis feature works only in Electronics Desktop (3D Layout).\nIf the flag is set to True it can cause issues in SiWave once the Edb is imported.\nDefault is False to generate PolygonData of cut lines.\n\ninclude_voids_in_extents\n\nbool, optional\n\nWhether to compute and include voids in pyaedt extent before the cutout. Cutout time can be affected.\nIt works only with Conforming cutout.\nDefault is False to generate extent without voids.\n\nReturns\n\nList\n\nList of coordinate points defining the extent used for clipping the design. If it failed return an empty\nlist.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb(r\"C:\\test.aedb\", version=\"2022.2\")\n>>> edb.logger.info_timer(\"Edb Opening\")\n>>> edb.logger.reset_timer()\n>>> start = time.time()\n>>> signal_list = []\n>>> for net in edb.nets.netlist:\n>>>      if \"3V3\" in net:\n>>>           signal_list.append(net)\n>>> power_list = [\"PGND\"]\n>>> edb.cutout(signal_nets=signal_list, reference_nets=power_list, extent_type=\"Conforming\")\n>>> end_time = str((time.time() - start) / 60)\n>>> edb.logger.info(\"Total legacy cutout time in min %s\", end_time)\n>>> edb.nets.plot(signal_list, None, color_by_net=True)\n>>> edb.nets.plot(power_list, None, color_by_net=True)\n>>> edb.save()\n>>> edb.close()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_connected_object_id_set",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_connected_object_id_set.html#get_connected_object_id_set",
        "title": "get_connected_object_id_set",
        "section": "get_connected_object_id_set",
        "text": "Produce a list of all geometries physically connected to a given layout object.\nFound connected objects IDs with Layout object.\nget_connected_object_id_set\nList\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_connected_object_id_set",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_connected_object_id_set.html#pyedb.grpc.database.primitive.polygon.Polygon.get_connected_object_id_set",
        "title": "get_connected_object_id_set > get_connected_object_id_set > get_connected_object_id_set",
        "section": "get_connected_object_id_set > get_connected_object_id_set",
        "text": "Polygon.get_connected_object_id_set() -> list[int]\n\nProduce a list of all geometries physically connected to a given layout object.\n\nReturns\n\nList[python:int]\n\nFound connected objects IDs with Layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.html#backdrillstublength",
        "title": "BackDrillStubLength",
        "section": "BackDrillStubLength",
        "text": "Maximum allowed back-drill stub length.\nBackDrillStubLength.construct([_fields_set])\n\nBackDrillStubLength.copy(*[, include, ...])\nReturns a copy of the model.\nBackDrillStubLength.dict(*[, include, ...])\n\nBackDrillStubLength.from_orm(obj)\n\nBackDrillStubLength.json(*[, include, ...])\n\nBackDrillStubLength.model_construct([...])\nCreates a new instance of the Model class with validated data.\nBackDrillStubLength.model_copy(*[, update, deep])\n!!! abstract \"Usage Documentation\"\nBackDrillStubLength.model_dump(*[, mode, ...])\n!!! abstract \"Usage Documentation\"\nBackDrillStubLength.model_dump_json(*[, ...])\n!!! abstract \"Usage Documentation\"\nBackDrillStubLength.model_json_schema([...])\nGenerates a JSON schema for a model class.\nBackDrillStubLength.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nBackDrillStubLength.model_post_init(context, /)\nOverride this method to perform additional initialization after __init__ and model_construct.\nBackDrillStubLength.model_rebuild(*[, ...])\nTry to rebuild the pydantic-core schema for the model.\nBackDrillStubLength.model_validate(obj, *[, ...])\nValidate a pydantic model instance.\nBackDrillStubLength.model_validate_json(...)\n!!! abstract \"Usage Documentation\"\nBackDrillStubLength.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nBackDrillStubLength.parse_file(path, *[, ...])\n\nBackDrillStubLength.parse_obj(obj)\n\nBackDrillStubLength.parse_raw(b, *[, ...])\n\nBackDrillStubLength.schema([by_alias, ...])\n\nBackDrillStubLength.schema_json(*[, ...])\n\nBackDrillStubLength.update_forward_refs(...)\n\nBackDrillStubLength.validate(value)\n\nBackDrillStubLength.model_computed_fields\n\nBackDrillStubLength.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nBackDrillStubLength.model_fields\n\nBackDrillStubLength.name\n\nBackDrillStubLength.value\n\nBackDrillStubLength\nBackDrillStubLength.construct\nBackDrillStubLength.copy\nBackDrillStubLength.dict\nBackDrillStubLength.from_orm\nBackDrillStubLength.json\nBackDrillStubLength.model_construct\nBackDrillStubLength.model_copy\nBackDrillStubLength.model_dump\nBackDrillStubLength.model_dump_json\nBackDrillStubLength.model_json_schema\nBackDrillStubLength.model_parametrized_name\nBackDrillStubLength.model_post_init\nBackDrillStubLength.model_rebuild\nBackDrillStubLength.model_validate\nBackDrillStubLength.model_validate_json\nBackDrillStubLength.model_validate_strings\nBackDrillStubLength.parse_file\nBackDrillStubLength.parse_obj\nBackDrillStubLength.parse_raw\nBackDrillStubLength.schema\nBackDrillStubLength.schema_json\nBackDrillStubLength.update_forward_refs\nBackDrillStubLength.validate\nBackDrillStubLength.model_computed_fields\nBackDrillStubLength.model_config\nBackDrillStubLength.model_fields\nBackDrillStubLength.name\nBackDrillStubLength.value"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.html#pyedb.workflows.drc.drc.BackDrillStubLength",
        "title": "BackDrillStubLength > BackDrillStubLength > BackDrillStubLength",
        "section": "BackDrillStubLength > BackDrillStubLength",
        "text": "class pyedb.workflows.drc.drc.BackDrillStubLength(*, name: str, value: str)\n\nMaximum allowed back-drill stub length.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nBackDrillStubLength.construct([_fields_set])\n\n\n\nBackDrillStubLength.copy(*[, include, ...])\n\nReturns a copy of the model.\n\nBackDrillStubLength.dict(*[, include, ...])\n\n\n\nBackDrillStubLength.from_orm(obj)\n\n\n\nBackDrillStubLength.json(*[, include, ...])\n\n\n\nBackDrillStubLength.model_construct([...])\n\nCreates a new instance of the Model class with validated data.\n\nBackDrillStubLength.model_copy(*[, update, deep])\n\n!!! abstract \"Usage Documentation\"\n\nBackDrillStubLength.model_dump(*[, mode, ...])\n\n!!! abstract \"Usage Documentation\"\n\nBackDrillStubLength.model_dump_json(*[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nBackDrillStubLength.model_json_schema([...])\n\nGenerates a JSON schema for a model class.\n\nBackDrillStubLength.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nBackDrillStubLength.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nBackDrillStubLength.model_rebuild(*[, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nBackDrillStubLength.model_validate(obj, *[, ...])\n\nValidate a pydantic model instance.\n\nBackDrillStubLength.model_validate_json(...)\n\n!!! abstract \"Usage Documentation\"\n\nBackDrillStubLength.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nBackDrillStubLength.parse_file(path, *[, ...])\n\n\n\nBackDrillStubLength.parse_obj(obj)\n\n\n\nBackDrillStubLength.parse_raw(b, *[, ...])\n\n\n\nBackDrillStubLength.schema([by_alias, ...])\n\n\n\nBackDrillStubLength.schema_json(*[, ...])\n\n\n\nBackDrillStubLength.update_forward_refs(...)\n\n\n\nBackDrillStubLength.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nBackDrillStubLength.model_computed_fields\n\n\n\nBackDrillStubLength.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nBackDrillStubLength.model_fields\n\n\n\nBackDrillStubLength.name\n\n\n\nBackDrillStubLength.value\n\n\n\n"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.parse_raw",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "parse_raw"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.parse_raw",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.parse_raw.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod DiffPairLengthMatch.parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.find_by_id.html#find_by_id",
        "title": "find_by_id",
        "section": "find_by_id",
        "text": "Find a Connectable object by database ID in a given layout.\nLayout to search for the Connectable object.\nDatabase ID.\nConnectable object with the given database ID.\nfind_by_id\nLayout\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.find_by_id.html#pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.find_by_id",
        "title": "find_by_id > find_by_id > find_by_id",
        "section": "find_by_id > find_by_id",
        "text": "classmethod BundleTerminal.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the Connectable object.\n\nuid\n\npython:int\n\nDatabase ID.\n\nReturns\n\nConnectable\n\nConnectable object with the given database ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.create_hfss.html#create_hfss",
        "title": "create_hfss",
        "section": "create_hfss",
        "text": "Create an HFSS model from an MCAD file.\nHFSS model created.\ncreate_hfss\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.create_hfss.html#pyedb.grpc.database.primitive.primitive.Primitive.create_hfss",
        "title": "create_hfss > create_hfss > create_hfss",
        "section": "create_hfss > create_hfss",
        "text": "Primitive.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nReturns\n\nMcadModel\n\nHFSS model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.dict",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "dict"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.dict",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.dict.html#pyedb.workflows.drc.drc.CopperBalance.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "CopperBalance.dict(*, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Dict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.schema_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "schema_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.schema_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.schema_json.html#pyedb.workflows.drc.drc.CopperBalance.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod CopperBalance.schema_json(*, by_alias: bool = True, ref_template: str = '#/$defs/{model}', **dumps_kwargs: Any) -> str\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.set_product_property.html#pyedb.grpc.database.ports.ports.WavePort.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "WavePort.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.html#pointterminal",
        "title": "PointTerminal",
        "section": "PointTerminal",
        "text": "Manages point terminal properties.\nPointTerminal.cast([term_type])\nCast the terminal object to the correct concrete type, fetching the type if necessary.\nPointTerminal.create(layout, net, layer, ...)\nCreate a point terminal.\nPointTerminal.create_3d_comp()\nCreate a 3D composite model from an MCAD file.\nPointTerminal.create_hfss()\nCreate an HFSS model from an MCAD file.\nPointTerminal.create_stride()\nCreate a Stride model from an MCAD file.\nPointTerminal.delete()\nDelete the layout object.\nPointTerminal.find(layout, name)\nFind a terminal by name in a given layout.\nPointTerminal.find_by_id(layout, uid)\nFind a Connectable object by database ID in a given layout.\nPointTerminal.get_product_property(prod_id, ...)\nGet the product property of the layout object for a given product ID and attribute ID.\nPointTerminal.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nPointTerminal.product_solver_names(product_id)\nGet the list of solver names.\nPointTerminal.product_solver_option(...)\nGet the name of the product solver option.\nPointTerminal.set_product_property(prod_id, ...)\nSet the product property of the layout object for a given product ID and attribute ID.\nPointTerminal.set_product_solver_option(...)\nSet the product solver option.\nPointTerminal.layout_obj_type\n\nPointTerminal.type\n\nPointTerminal\nPointTerminal.cast\nPointTerminal.create\nPointTerminal.create_3d_comp\nPointTerminal.create_hfss\nPointTerminal.create_stride\nPointTerminal.delete\nPointTerminal.find\nPointTerminal.find_by_id\nPointTerminal.get_product_property\nPointTerminal.get_product_property_ids\nPointTerminal.product_solver_names\nPointTerminal.product_solver_option\nPointTerminal.set_product_property\nPointTerminal.set_product_solver_option\nPointTerminal.layout_obj_type\nPointTerminal.type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.html#pyedb.grpc.database.terminal.point_terminal.PointTerminal",
        "title": "PointTerminal > PointTerminal > PointTerminal",
        "section": "PointTerminal > PointTerminal",
        "text": "class pyedb.grpc.database.terminal.point_terminal.PointTerminal(pedb, edb_object)\n\nManages point terminal properties.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nPointTerminal.cast([term_type])\n\nCast the terminal object to the correct concrete type, fetching the type if necessary.\n\nPointTerminal.create(layout, net, layer, ...)\n\nCreate a point terminal.\n\nPointTerminal.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nPointTerminal.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nPointTerminal.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nPointTerminal.delete()\n\nDelete the layout object.\n\nPointTerminal.find(layout, name)\n\nFind a terminal by name in a given layout.\n\nPointTerminal.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nPointTerminal.get_product_property(prod_id, ...)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nPointTerminal.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nPointTerminal.product_solver_names(product_id)\n\nGet the list of solver names.\n\nPointTerminal.product_solver_option(...)\n\nGet the name of the product solver option.\n\nPointTerminal.set_product_property(prod_id, ...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nPointTerminal.set_product_solver_option(...)\n\nSet the product solver option.\n\n\n\nAttributes\n\n\n\n\n\n\n\nPointTerminal.layout_obj_type\n\n\n\nPointTerminal.type\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "LayoutObjType: Layout object type of the Primitive class.\nlayout_obj_type\nLayoutObjType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.layout_obj_type.html#pyedb.grpc.database.primitive.circle.Circle.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "Circle.layout_obj_type = 0\n\nLayoutObjType: Layout object type of the Primitive class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.from_orm",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "from_orm"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.from_orm",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.from_orm.html#pyedb.workflows.drc.drc.MinLineWidth.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod MinLineWidth.from_orm(obj: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "validate"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.validate.html#pyedb.workflows.drc.drc.MinAnnularRing.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod MinAnnularRing.validate(value: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_polygon",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_polygon.html#create_polygon",
        "title": "create_polygon",
        "section": "create_polygon",
        "text": "Create a polygon based on a list of points and voids.\nShape or point lists of the main object. Point list can be in the format of [[x1,y1], [x2,y2],..,[xn,yn]].\nEach point can be:\n- [x, y] coordinate\n- [x, y, height] for an arc with specific height (between previous point and actual point)\n- [x, y, rotation, xc, yc] for an arc given a point, rotation and center.\nName of the layer on which to create the polygon.\nList of shape objects for voids or points that creates the shapes. The default is``[]``.\nName of the net. The default is \"\".\nAdded for compatibility with grpc.\nPolygon when successful, False when failed.\ncreate_polygon\npython:list\nof\npoints\nPolygonData\nmodeler.Shape\npython:str\npython:list\noptional\npython:str\noptional\n\"\"\npython:list\noptional\ndotnet.database.edb_data.primitives.Primitive\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_polygon",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_polygon.html#pyedb.dotnet.database.modeler.Modeler.create_polygon",
        "title": "create_polygon > create_polygon > create_polygon",
        "section": "create_polygon > create_polygon",
        "text": "Modeler.create_polygon(main_shape=None, layer_name='', voids=[], net_name='', points=None)\n\nCreate a polygon based on a list of points and voids.\n\nParameters\n\nmain_shape\n\npython:list of points or PolygonData or modeler.Shape\n\nShape or point lists of the main object. Point list can be in the format of [[x1,y1], [x2,y2],..,[xn,yn]].\nEach point can be:\n- [x, y] coordinate\n- [x, y, height] for an arc with specific height (between previous point and actual point)\n- [x, y, rotation, xc, yc] for an arc given a point, rotation and center.\n\nlayer_name\n\npython:str\n\nName of the layer on which to create the polygon.\n\nvoids\n\npython:list, optional\n\nList of shape objects for voids or points that creates the shapes. The default is``[]``.\n\nnet_name\n\npython:str, optional\n\nName of the net. The default is \"\".\n\npoints\n\npython:list, optional\n\nAdded for compatibility with grpc.\n\nReturns\n\nbool, dotnet.database.edb_data.primitives.Primitive\n\nPolygon when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.clone",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.clone.html#clone",
        "title": "clone",
        "section": "clone",
        "text": "Create a clone of the layer collection.\nLayer collection cloned.\nclone\nLayerCollection"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.clone",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.clone.html#pyedb.grpc.database.stackup.LayerCollection.clone",
        "title": "clone > clone > clone",
        "section": "clone > clone",
        "text": "LayerCollection.clone()\n\nCreate a clone of the layer collection.\n\nReturns\n\nLayerCollection\n\nLayer collection cloned.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/net",
        "href": "grpc_api/grpc/database/pyedb_lib/net/net.html#net",
        "title": "Net",
        "section": "Net",
        "text": "This class is managing EDB net.\nNet\nManages EDB functionalities for net objects and their primitives.\nNet\nNet"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.TriangularPatch.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.TriangularPatch.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Draw the patch, ground plane and feed geometry in EDB.\nTrue when the geometry has been successfully created.\ncreate"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.TriangularPatch.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.TriangularPatch.create.html#pyedb.libraries.rf_libraries.planar_antennas.TriangularPatch.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "TriangularPatch.create() -> bool\n\nDraw the patch, ground plane and feed geometry in EDB.\n\nReturns\n\nbool\n\nTrue when the geometry has been successfully created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_material",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_material.html#add_material",
        "title": "add_material",
        "section": "add_material",
        "text": "Add a new material.\nMaterial name.\nMaterial object.\nadd_material\npython:str\nMaterial"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_material",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_material.html#pyedb.grpc.database.definition.materials.Materials.add_material",
        "title": "add_material > add_material > add_material",
        "section": "add_material > add_material",
        "text": "Materials.add_material(name: str, **kwargs) -> Material\n\nAdd a new material.\n\nParameters\n\nname\n\npython:str\n\nMaterial name.\n\nReturns\n\nMaterial\n\nMaterial object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_rebuild",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce: Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors: Whether to raise errors, defaults to True.\n_parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n_types_namespace: The types namespace, defaults to None.\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_rebuild",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_rebuild.html#pyedb.workflows.drc.drc.MinLineWidth.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod MinLineWidth.model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -> bool | None\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n\nforce: Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors: Whether to raise errors, defaults to True.\n_parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n_types_namespace: The types namespace, defaults to None.\n\nReturns:\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileImportOptions",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileImportOptions.html#controlfileimportoptions",
        "title": "ControlFileImportOptions",
        "section": "ControlFileImportOptions",
        "text": "Manages import options for the control file.\nControlFileImportOptions"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileImportOptions",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileImportOptions.html#pyedb.grpc.database.control_file.ControlFileImportOptions",
        "title": "ControlFileImportOptions > ControlFileImportOptions > ControlFileImportOptions",
        "section": "ControlFileImportOptions > ControlFileImportOptions",
        "text": "class pyedb.grpc.database.control_file.ControlFileImportOptions\n\nManages import options for the control file.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.schema",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "schema"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.schema",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.schema.html#pyedb.grpc.database.definition.materials.MaterialProperties.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod MaterialProperties.schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}') -> Dict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/index",
        "href": "grpc_api/grpc/database/pyedb_lib/index.html#edb-lib",
        "title": "EDB lib",
        "section": "EDB lib",
        "text": "This section describes PyEDB libraries.\nEDB lib"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj: The object to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\nfrom_attributes: Whether to extract data from object attributes.\ncontext: Additional context to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nValidationError: If the object could not be validated.\nThe validated model instance.\nmodel_validate"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_validate.html#pyedb.workflows.drc.drc.DiffPair.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod DiffPair.model_validate(obj: Any, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\nValidate a pydantic model instance.\n\nArgs:\n\nobj: The object to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\nfrom_attributes: Whether to extract data from object attributes.\ncontext: Additional context to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nRaises:\n\nValidationError: If the object could not be validated.\n\nReturns:\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.convert_to_polygon",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.convert_to_polygon.html#convert_to_polygon",
        "title": "convert_to_polygon",
        "section": "convert_to_polygon",
        "text": "Convert path to polygon.\nPolygon when successful, False when failed.\nconvert_to_polygon\nPolygon\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.convert_to_polygon",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.convert_to_polygon.html#pyedb.grpc.database.primitive.circle.Circle.convert_to_polygon",
        "title": "convert_to_polygon > convert_to_polygon > convert_to_polygon",
        "section": "convert_to_polygon > convert_to_polygon",
        "text": "Circle.convert_to_polygon()\n\nConvert path to polygon.\n\nReturns\n\nPolygon\n\nPolygon when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.html#circuitport",
        "title": "CircuitPort",
        "section": "CircuitPort",
        "text": "Manages gap port properties.\nParameters\n———-\npedb : pyedb.edb.Edb\nEDB object from the Edblib library.\nEdge terminal instance from EDB.\nCircuitPort\nEdblib"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.html#pyedb.grpc.database.ports.ports.CircuitPort",
        "title": "CircuitPort > CircuitPort > CircuitPort",
        "section": "CircuitPort > CircuitPort",
        "text": "class pyedb.grpc.database.ports.ports.CircuitPort(pedb, edb_object)\n\nManages gap port properties.\nParameters\n———-\npedb : pyedb.edb.Edb\n\nEDB object from the Edblib library.\n\nedb_object\n\nAnsys.Ansoft.Edb.Cell.Terminal.EdgeTerminal\n\nEdge terminal instance from EDB."
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.html#examples",
        "title": "CircuitPort > Examples",
        "section": "Examples",
        "text": "This example shows how to access the GapPort class.\nCircuitPort.cast([term_type])\nCast the terminal object to the correct concrete type, fetching the type if necessary.\nCircuitPort.couple_ports(port)\nCreate a bundle wave port.\nCircuitPort.create(layout, name, edges[, ...])\nCreate an edge terminal.\nCircuitPort.create_3d_comp()\nCreate a 3D composite model from an MCAD file.\nCircuitPort.create_hfss()\nCreate an HFSS model from an MCAD file.\nCircuitPort.create_stride()\nCreate a Stride model from an MCAD file.\nCircuitPort.delete()\nDelete the layout object.\nCircuitPort.find(layout, name)\nFind a terminal by name in a given layout.\nCircuitPort.find_by_id(layout, uid)\nFind a Connectable object by database ID in a given layout.\nCircuitPort.get_product_property(prod_id, ...)\nGet the product property of the layout object for a given product ID and attribute ID.\nCircuitPort.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nCircuitPort.product_solver_names(product_id)\nGet the list of solver names.\nCircuitPort.product_solver_option(...)\nGet the name of the product solver option.\nCircuitPort.set_product_property(prod_id, ...)\nSet the product property of the layout object for a given product ID and attribute ID.\nCircuitPort.set_product_solver_option(...)\nSet the product solver option.\nCircuitPort.layout_obj_type\n\nCircuitPort.type\n\nExamples\nGapPort\nCircuitPort.cast\nCircuitPort.couple_ports\nCircuitPort.create\nCircuitPort.create_3d_comp\nCircuitPort.create_hfss\nCircuitPort.create_stride\nCircuitPort.delete\nCircuitPort.find\nCircuitPort.find_by_id\nCircuitPort.get_product_property\nCircuitPort.get_product_property_ids\nCircuitPort.product_solver_names\nCircuitPort.product_solver_option\nCircuitPort.set_product_property\nCircuitPort.set_product_solver_option\nCircuitPort.layout_obj_type\nCircuitPort.type"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_computed_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_computed_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_computed_fields.html#pyedb.workflows.drc.drc.DiffPair.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "DiffPair.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.get_power_module",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.get_power_module.html#get_power_module",
        "title": "get_power_module",
        "section": "get_power_module",
        "text": "Get the power module for a given component group name.\nComponent group name of the power module.\nget_power_module\npython:str\nPowerModule"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.get_power_module",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.get_power_module.html#pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.get_power_module",
        "title": "get_power_module > get_power_module > get_power_module",
        "section": "get_power_module > get_power_module",
        "text": "VoltageRegulator.get_power_module(comp_group_name)\n\nGet the power module for a given component group name.\n\nParameters\n\ncomp_group_name\n\npython:str\n\nComponent group name of the power module.\n\nReturns\n\nPowerModule\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_solver_settings.HFSSSolverSettings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_solver_settings.HFSSSolverSettings.html#hfsssolversettings",
        "title": "HFSSSolverSettings",
        "section": "HFSSSolverSettings",
        "text": "HFSS solver settings class.\nHFSSSolverSettings"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_solver_settings.HFSSSolverSettings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_solver_settings.HFSSSolverSettings.html#pyedb.grpc.database.simulation_setup.hfss_solver_settings.HFSSSolverSettings",
        "title": "HFSSSolverSettings > HFSSSolverSettings > HFSSSolverSettings",
        "section": "HFSSSolverSettings > HFSSSolverSettings",
        "text": "class pyedb.grpc.database.simulation_setup.hfss_solver_settings.HFSSSolverSettings(pedb, edb_object)\n\nHFSS solver settings class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_validate_strings",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj: The object containing string data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nThe validated Pydantic model.\nmodel_validate_strings"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_validate_strings",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_validate_strings.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod DiffPairLengthMatch.model_validate_strings(obj: Any, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\nValidate the given object with string data against the Pydantic model.\n\nArgs:\n\nobj: The object containing string data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nReturns:\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_pin_group_terminal_reference_pin",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_pin_group_terminal_reference_pin.html#get_pin_group_terminal_reference_pin",
        "title": "get_pin_group_terminal_reference_pin",
        "section": "get_pin_group_terminal_reference_pin",
        "text": "Return a list of pins and serves terminals connected to pingroups.\nPreferred reference net name.\nget_pin_group_terminal_reference_pin\npython:str\noptional\ndotnet.database.edb_data.padstack_data.EDBPadstackInstance"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_pin_group_terminal_reference_pin",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_pin_group_terminal_reference_pin.html#pyedb.dotnet.database.edb_data.ports.GapPort.get_pin_group_terminal_reference_pin",
        "title": "get_pin_group_terminal_reference_pin > get_pin_group_terminal_reference_pin > get_pin_group_terminal_reference_pin",
        "section": "get_pin_group_terminal_reference_pin > get_pin_group_terminal_reference_pin",
        "text": "GapPort.get_pin_group_terminal_reference_pin(gnd_net_name_preference=None)\n\nReturn a list of pins and serves terminals connected to pingroups.\n\nParameters\n\ngnd_net_name_preference\n\npython:str, optional\n\nPreferred reference net name.\n\nReturns\n\ndotnet.database.edb_data.padstack_data.EDBPadstackInstance\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.html#component",
        "title": "Component",
        "section": "Component",
        "text": "Manages EDB functionalities for components.\nComponents object.\nEdb Component Object\nComponent.add_member(member)\nAdd an object to the group.\nComponent.assign_rlc_model([res, ind, cap, ...])\nAssign RLC to this component.\nComponent.assign_s_param_model(file_path[, ...])\nAssign S-parameter to this component.\nComponent.assign_spice_model(file_path[, ...])\nAssign Spice model to this component.\nComponent.cast()\nCast the group object to the correct concrete type.\nComponent.create(layout, name, comp_name)\nCreate a component group with a component.\nComponent.create_3d_comp()\nCreate a 3D composite model from an MCAD file.\nComponent.create_clearance_on_component([...])\nCreate a Clearance on Soldermask layer by drawing a rectangle.\nComponent.create_hfss()\nCreate an HFSS model from an MCAD file.\nComponent.create_package_def([name, ...])\nCreate a package definition and assign it to the component.\nComponent.create_stride()\nCreate a Stride model from an MCAD file.\nComponent.delete()\nDelete the layout object.\nComponent.find(layout, name)\nFind a group by name.\nComponent.find_by_def(layout, comp_def_name)\nFind all components belonging to a given component definition.\nComponent.find_by_id(layout, uid)\nFind a Connectable object by database ID in a given layout.\nComponent.get_product_property(prod_id, attr_id)\nGet the product property of the layout object for a given product ID and attribute ID.\nComponent.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nComponent.remove_member(member)\nRemove an object from the group.\nComponent.set_product_property(prod_id, ...)\nSet the product property of the layout object for a given product ID and attribute ID.\nComponent.ungroup(recursive)\nDissolve the group.\nComponent.use_s_parameter_model(name[, ...])\nUse S-parameter model on the component.\nComponent.layout_obj_type\n\nComponent\npyedb.grpc.database.components.Components\nobject\nComponent.add_member\nComponent.assign_rlc_model\nComponent.assign_s_param_model\nComponent.assign_spice_model\nComponent.cast\nComponent.create\nComponent.create_3d_comp\nComponent.create_clearance_on_component\nComponent.create_hfss\nComponent.create_package_def\nComponent.create_stride\nComponent.delete\nComponent.find\nComponent.find_by_def\nComponent.find_by_id\nComponent.get_product_property\nComponent.get_product_property_ids\nComponent.remove_member\nComponent.set_product_property\nComponent.ungroup\nComponent.use_s_parameter_model\nComponent.layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.html#pyedb.grpc.database.hierarchy.component.Component",
        "title": "Component > Component > Component",
        "section": "Component > Component",
        "text": "class pyedb.grpc.database.hierarchy.component.Component(pedb, edb_object)\n\nManages EDB functionalities for components.\n\nParameters\n\nparent\n\npyedb.grpc.database.components.Components\n\nComponents object.\n\ncomponent\n\nobject\n\nEdb Component Object\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nComponent.add_member(member)\n\nAdd an object to the group.\n\nComponent.assign_rlc_model([res, ind, cap, ...])\n\nAssign RLC to this component.\n\nComponent.assign_s_param_model(file_path[, ...])\n\nAssign S-parameter to this component.\n\nComponent.assign_spice_model(file_path[, ...])\n\nAssign Spice model to this component.\n\nComponent.cast()\n\nCast the group object to the correct concrete type.\n\nComponent.create(layout, name, comp_name)\n\nCreate a component group with a component.\n\nComponent.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nComponent.create_clearance_on_component([...])\n\nCreate a Clearance on Soldermask layer by drawing a rectangle.\n\nComponent.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nComponent.create_package_def([name, ...])\n\nCreate a package definition and assign it to the component.\n\nComponent.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nComponent.delete()\n\nDelete the layout object.\n\nComponent.find(layout, name)\n\nFind a group by name.\n\nComponent.find_by_def(layout, comp_def_name)\n\nFind all components belonging to a given component definition.\n\nComponent.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nComponent.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nComponent.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nComponent.remove_member(member)\n\nRemove an object from the group.\n\nComponent.set_product_property(prod_id, ...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nComponent.ungroup(recursive)\n\nDissolve the group.\n\nComponent.use_s_parameter_model(name[, ...])\n\nUse S-parameter model on the component.\n\n\n\nAttributes\n\n\n\n\n\n\n\nComponent.layout_obj_type\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.youngs_modulus",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.youngs_modulus.html#youngs_modulus",
        "title": "youngs_modulus",
        "section": "youngs_modulus",
        "text": "youngs_modulus"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.youngs_modulus",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.youngs_modulus.html#pyedb.grpc.database.definition.materials.MaterialProperties.youngs_modulus",
        "title": "youngs_modulus > youngs_modulus > youngs_modulus",
        "section": "youngs_modulus > youngs_modulus",
        "text": "MaterialProperties.youngs_modulus: Annotated[float, Gt(gt=0)] | None\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.set_product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.set_product_solver_option.html#set_product_solver_option",
        "title": "set_product_solver_option",
        "section": "set_product_solver_option",
        "text": "Set the product solver option.\nID of the product.\nName of the solver.\nName of the product solver option.\nset_product_solver_option\nProductIdType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.set_product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.set_product_solver_option.html#pyedb.grpc.database.ports.ports.BundleWavePort.set_product_solver_option",
        "title": "set_product_solver_option > set_product_solver_option > set_product_solver_option",
        "section": "set_product_solver_option > set_product_solver_option",
        "text": "BundleWavePort.set_product_solver_option(product_id, solver_name, option)\n\nSet the product solver option.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nsolver_name\n\nobj:str\n\nName of the solver.\n\noption\n\nobj:str\n\nName of the product solver option.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "user_guide/communication_protocols",
        "href": "user_guide/communication_protocols.html#communication-protocol-grpc",
        "title": "Communication Protocol: gRPC",
        "section": "Communication Protocol: gRPC",
        "text": "PyEDB exclusively uses the gRPC Remote Procedure Calls (gRPC) protocol to communicate with the ansys-edb-core\nservice.\nThis modern framework is the foundation of PyEDB’s architecture and offers key benefits:\nHeadless Operation: Enables operation on servers without a GUI (for example Linux, Docker).\nPerformance: High-speed communication, ideal for processing large, complex designs.\nReliability: Robust connection handling and error reporting.\nDecoupled Development: The Python client and the core service can be updated independently.\nCommunication Protocol: gRPC\nansys-edb-core"
    },
    {
        "objectID": "user_guide/communication_protocols",
        "href": "user_guide/communication_protocols.html#checking-the-connection",
        "title": "Communication Protocol: gRPC > Checking the Connection",
        "section": "Checking the Connection",
        "text": "You can always check the status and version of the connection from your Python script.\nIf connection was successful, you should something similar to this in the console:\nChecking the Connection"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.AdaptiveType.MultiFrequency",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.AdaptiveType.MultiFrequency.html#multifrequency",
        "title": "MultiFrequency",
        "section": "MultiFrequency",
        "text": "MultiFrequency"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.AdaptiveType.MultiFrequency",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.AdaptiveType.MultiFrequency.html#pyedb.dotnet.database.utilities.simulation_setup.AdaptiveType.MultiFrequency",
        "title": "MultiFrequency > MultiFrequency > MultiFrequency",
        "section": "MultiFrequency > MultiFrequency",
        "text": "AdaptiveType.MultiFrequency = 1\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.get_product_property_ids",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs for a given product ID for the layer collection.\nProduct ID.\nList of attribute IDs for the given product ID.\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.get_product_property_ids",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.get_product_property_ids.html#pyedb.grpc.database.stackup.LayerCollection.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "LayerCollection.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs for a given product ID for the layer collection.\n\nParameters\n\nprod_id\n\nProductIdType\n\nProduct ID.\n\nReturns\n\npython:list[python:int]\n\nList of attribute IDs for the given product ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.set_product_property",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property associated with the given product and attribute ids.\nProduct ID.\nAttribute ID.\nProduct property’s new value\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.set_product_property",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.set_product_property.html#pyedb.grpc.edb.Edb.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "Edb.set_product_property(prod_id, attr_it, prop_value)\n\nSet the product property associated with the given product and attribute ids.\n\nParameters\n\nprod_id\n\nProductIdType\n\nProduct ID.\n\nattr_it\n\npython:int\n\nAttribute ID.\n\nprop_value\n\npython:str\n\nProduct property’s new value\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.move",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.move.html#move",
        "title": "move",
        "section": "move",
        "text": "Move the point by a vector.\nVector.\nPointData after moving or None if either point is an arc.\nmove\nPointData\nNone\nNone"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.move",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.move.html#pyedb.grpc.database.geometry.point_data.PointData.move",
        "title": "move > move > move",
        "section": "move > move",
        "text": "PointData.move(vector: PointLike) -> PointData | None\n\nMove the point by a vector.\n\nParameters\n\nvector\n\nPoint2DLike\n\nVector.\n\nReturns\n\nPointData or None\n\nPointData after moving or None if either point is an arc.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_closest_arc_midpoint",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_closest_arc_midpoint.html#get_closest_arc_midpoint",
        "title": "get_closest_arc_midpoint",
        "section": "get_closest_arc_midpoint",
        "text": "Get the closest arc midpoint of the primitive to the input data.\n[x, y].\nget_closest_arc_midpoint\nList\npython:float\nor\nList\nPointData\nLIst\npython:float\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_closest_arc_midpoint",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_closest_arc_midpoint.html#pyedb.grpc.database.primitive.primitive.Primitive.get_closest_arc_midpoint",
        "title": "get_closest_arc_midpoint > get_closest_arc_midpoint > get_closest_arc_midpoint",
        "section": "get_closest_arc_midpoint > get_closest_arc_midpoint",
        "text": "Primitive.get_closest_arc_midpoint(point) -> list[float]\n\nGet the closest arc midpoint of the primitive to the input data.\n\nParameters\n\npoint\n\nList[python:float] or List[PointData]\n\n\n\nReturns\n\nLIst[python:float, python:float]\n\n[x, y].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.set_product_property.html#pyedb.grpc.database.primitive.rectangle.Rectangle.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "Rectangle.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/models.md#model-copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nbefore creating the new model. You should trust this data.\ndeep: Set to True to make a deep copy of the model.\nNew model instance.\nmodel_copy"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_copy.html#pyedb.workflows.drc.drc.MinClearance.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "MinClearance.model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -> Self\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/models.md#model-copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nArgs:\n\nupdate: Values to change/add in the new model. Note: the data is not validated\n\nbefore creating the new model. You should trust this data.\n\ndeep: Set to True to make a deep copy of the model.\n\nReturns:\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the layout object.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.delete.html#pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "BundleTerminal.delete()\n\nDelete the layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/component_def",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/component_def.html#component-definition",
        "title": "Component Definition",
        "section": "Component Definition",
        "text": "These class is the containers of Component definition.\nComponentDef\nManages EDB functionalities for component definitions.\nComponent Definition\nComponentDef"
    },
    {
        "objectID": "workflows/sipi/index",
        "href": "workflows/sipi/index.html#workflows",
        "title": "Workflows",
        "section": "Workflows",
        "text": "This section describes SIPI workflows features.\nWorkflows"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.get_product_property.html#pyedb.grpc.database.hierarchy.pingroup.PinGroup.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "PinGroup.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.delete_single_pin_rlc",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.delete_single_pin_rlc.html#delete_single_pin_rlc",
        "title": "delete_single_pin_rlc",
        "section": "delete_single_pin_rlc",
        "text": "Delete all RLC components with a single pin.\nSingle pin component model type will be reverted to \"RLC\".\nWhether to only deactivate RLC components with a single point rather than\ndelete them. The default is False, in which case they are deleted.\nList of deleted RLC components.\ndelete_single_pin_rlc\n\"RLC\"\noptional\nFalse\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.delete_single_pin_rlc",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.delete_single_pin_rlc.html#pyedb.dotnet.database.components.Components.delete_single_pin_rlc",
        "title": "delete_single_pin_rlc > delete_single_pin_rlc > delete_single_pin_rlc",
        "section": "delete_single_pin_rlc > delete_single_pin_rlc",
        "text": "Components.delete_single_pin_rlc(deactivate_only: bool = False) -> list\n\nDelete all RLC components with a single pin.\nSingle pin component model type will be reverted to \"RLC\".\n\nParameters\n\ndeactivate_only\n\nbool, optional\n\nWhether to only deactivate RLC components with a single point rather than\ndelete them. The default is False, in which case they are deleted.\n\nReturns\n\npython:list\n\nList of deleted RLC components.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\")\n>>> list_of_deleted_rlcs = edbapp.components.delete_single_pin_rlc()\n>>> print(list_of_deleted_rlcs)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_bondwire",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_bondwire.html#create_bondwire",
        "title": "create_bondwire",
        "section": "create_bondwire",
        "text": "Create bondwire.\nBondwire definition name.\nPlacement layer name.\nBondwire width.\nMaterial name.\nStart layer name.\nStart x-coordinate.\nStart y-coordinate.\nEnd layer name.\nEnd x-coordinate.\nEnd y-coordinate.\nAssociated net name.\nStart cell instance name.\nEnd cell instance name.\nBondwire type (“jedec4”, “jedec5”, “apd”).\nBondwire object if created, False otherwise.\ncreate_bondwire\npython:str\npython:str\npython:float\npython:str\npython:str\npython:str\npython:float\npython:str\npython:float\npython:str\npython:str\npython:float\npython:str\npython:float\npython:str\npython:str\npython:str\noptional\npython:str\noptional\npython:str\noptional\npyedb.dotnet.database.edb_data.primitives_data.Bondwire"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_bondwire",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_bondwire.html#pyedb.grpc.database.modeler.Modeler.create_bondwire",
        "title": "create_bondwire > create_bondwire > create_bondwire",
        "section": "create_bondwire > create_bondwire",
        "text": "Modeler.create_bondwire(definition_name: str, placement_layer: str, width: float | str, material: str, start_layer_name: str, start_x: float | str, start_y: float | str, end_layer_name: str, end_x: float | str, end_y: float | str, net: str, start_cell_instance_name: str | None = None, end_cell_instance_name: str | None = None, bondwire_type: str = 'jedec4') -> Primitive | None\n\nCreate bondwire.\n\nParameters\n\ndefinition_name\n\npython:str\n\nBondwire definition name.\n\nplacement_layer\n\npython:str\n\nPlacement layer name.\n\nwidth\n\npython:float or python:str\n\nBondwire width.\n\nmaterial\n\npython:str\n\nMaterial name.\n\nstart_layer_name\n\npython:str\n\nStart layer name.\n\nstart_x\n\npython:float or python:str\n\nStart x-coordinate.\n\nstart_y\n\npython:float or python:str\n\nStart y-coordinate.\n\nend_layer_name\n\npython:str\n\nEnd layer name.\n\nend_x\n\npython:float or python:str\n\nEnd x-coordinate.\n\nend_y\n\npython:float or python:str\n\nEnd y-coordinate.\n\nnet\n\npython:str\n\nAssociated net name.\n\nstart_cell_instance_name\n\npython:str, optional\n\nStart cell instance name.\n\nend_cell_instance_name\n\npython:str, optional\n\nEnd cell instance name.\n\nbondwire_type\n\npython:str, optional\n\nBondwire type (“jedec4”, “jedec5”, “apd”).\n\nReturns\n\npyedb.dotnet.database.edb_data.primitives_data.Bondwire or bool\n\nBondwire object if created, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.html#modeler",
        "title": "Modeler",
        "section": "Modeler",
        "text": "Manages EDB methods for primitives management accessible from Edb.modeler.\nModeler.add_void(shape, void_shape)\nAdd void to shape.\nModeler.create_bondwire(definition_name, ...)\nCreate bondwire.\nModeler.create_circle(layer_name, x, y, radius)\nCreate circle primitive.\nModeler.create_pin_group(name[, pins_by_id, ...])\nCreate pin group.\nModeler.create_polygon(points, layer_name[, ...])\nCreate polygon primitive.\nModeler.create_rectangle(layer_name[, ...])\nCreate rectangle primitive.\nModeler.create_trace(path_list, layer_name)\nCreate trace path.\nModeler.defeature_polygon(poly[, tolerance])\nDefeature polygon.\nModeler.delete_batch_primitives(prim_list)\nDelete a batch of primitives and update caches.\nModeler.delete_primitives(net_names)\nDelete primitives by net name(s).\nModeler.fix_circle_void_for_clipping()\nFix circle void clipping issues.\nModeler.get_layout_statistics([...])\nGet layout statistics.\nModeler.get_polygon_bounding_box(polygon)\nGet bounding box of polygon.\nModeler.get_polygon_points(polygon)\nGet points defining a polygon.\nModeler.get_polygons_by_layer(layer_name[, ...])\nRetrieve polygons by layer.\nModeler.get_primitive(primitive_id[, edb_uid])\nRetrieve primitive by ID.\nModeler.get_primitive_by_layer_and_point([...])\nGet primitive at specified point on layer.\nModeler.get_primitives([net_name, ...])\nGet primitives with filtering.\nModeler.parametrize_polygon(polygon, ...[, ...])\nParametrize polygon points based on another polygon.\nModeler.parametrize_trace_width(nets_name[, ...])\nParametrize trace width.\nModeler.unite_polygons_on_layer([...])\nUnite polygons on layer.\nModeler\nModeler.add_void\nModeler.create_bondwire\nModeler.create_circle\nModeler.create_pin_group\nModeler.create_polygon\nModeler.create_rectangle\nModeler.create_trace\nModeler.defeature_polygon\nModeler.delete_batch_primitives\nModeler.delete_primitives\nModeler.fix_circle_void_for_clipping\nModeler.get_layout_statistics\nModeler.get_polygon_bounding_box\nModeler.get_polygon_points\nModeler.get_polygons_by_layer\nModeler.get_primitive\nModeler.get_primitive_by_layer_and_point\nModeler.get_primitives\nModeler.parametrize_polygon\nModeler.parametrize_trace_width\nModeler.unite_polygons_on_layer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.html#pyedb.grpc.database.modeler.Modeler",
        "title": "Modeler > Modeler > Modeler",
        "section": "Modeler > Modeler",
        "text": "class pyedb.grpc.database.modeler.Modeler(p_edb)\n\nManages EDB methods for primitives management accessible from Edb.modeler.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", edbversion=\"2021.2\")\n>>> edb_layout = edbapp.modeler\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nModeler.add_void(shape, void_shape)\n\nAdd void to shape.\n\nModeler.create_bondwire(definition_name, ...)\n\nCreate bondwire.\n\nModeler.create_circle(layer_name, x, y, radius)\n\nCreate circle primitive.\n\nModeler.create_pin_group(name[, pins_by_id, ...])\n\nCreate pin group.\n\nModeler.create_polygon(points, layer_name[, ...])\n\nCreate polygon primitive.\n\nModeler.create_rectangle(layer_name[, ...])\n\nCreate rectangle primitive.\n\nModeler.create_trace(path_list, layer_name)\n\nCreate trace path.\n\nModeler.defeature_polygon(poly[, tolerance])\n\nDefeature polygon.\n\nModeler.delete_batch_primitives(prim_list)\n\nDelete a batch of primitives and update caches.\n\nModeler.delete_primitives(net_names)\n\nDelete primitives by net name(s).\n\nModeler.fix_circle_void_for_clipping()\n\nFix circle void clipping issues.\n\nModeler.get_layout_statistics([...])\n\nGet layout statistics.\n\nModeler.get_polygon_bounding_box(polygon)\n\nGet bounding box of polygon.\n\nModeler.get_polygon_points(polygon)\n\nGet points defining a polygon.\n\nModeler.get_polygons_by_layer(layer_name[, ...])\n\nRetrieve polygons by layer.\n\nModeler.get_primitive(primitive_id[, edb_uid])\n\nRetrieve primitive by ID.\n\nModeler.get_primitive_by_layer_and_point([...])\n\nGet primitive at specified point on layer.\n\nModeler.get_primitives([net_name, ...])\n\nGet primitives with filtering.\n\nModeler.parametrize_polygon(polygon, ...[, ...])\n\nParametrize polygon points based on another polygon.\n\nModeler.parametrize_trace_width(nets_name[, ...])\n\nParametrize trace width.\n\nModeler.unite_polygons_on_layer([...])\n\nUnite polygons on layer.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.eligible_power_nets",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.eligible_power_nets.html#eligible_power_nets",
        "title": "eligible_power_nets",
        "section": "eligible_power_nets",
        "text": "Identify nets eligible for power/ground classification based on area ratio.\nUses the same algorithm implemented in SIwave.\nArea ratio threshold. Nets with plane area ratio above this value are\nconsidered power/ground nets.\nList of nets eligible as power/ground nets.\neligible_power_nets\npython:float\noptional\npython:list\npyedb.grpc.database.net.net.Net"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.eligible_power_nets",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.eligible_power_nets.html#pyedb.grpc.database.nets.Nets.eligible_power_nets",
        "title": "eligible_power_nets > eligible_power_nets > eligible_power_nets",
        "section": "eligible_power_nets > eligible_power_nets",
        "text": "Nets.eligible_power_nets(threshold: float = 0.3) -> List[Net]\n\nIdentify nets eligible for power/ground classification based on area ratio.\n\nUses the same algorithm implemented in SIwave.\n\nParameters\n\nthreshold\n\npython:float, optional\n\nArea ratio threshold. Nets with plane area ratio above this value are\nconsidered power/ground nets.\n\nReturns\n\npython:list[pyedb.grpc.database.net.net.Net]\n\nList of nets eligible as power/ground nets.\n\nExamples\n\n>>> eligible_pwr = edb_nets.eligible_power_nets(threshold=0.25)\n>>> print([net.name for net in eligible_pwr])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.is_net_in_component",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.is_net_in_component.html#is_net_in_component",
        "title": "is_net_in_component",
        "section": "is_net_in_component",
        "text": "Check if a net belongs to a component.\nName of the component.\nName of the net.\nTrue if the net is found in component pins.\nis_net_in_component\npython:str\npython:str\nTrue"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.is_net_in_component",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.is_net_in_component.html#pyedb.dotnet.database.nets.EdbNets.is_net_in_component",
        "title": "is_net_in_component > is_net_in_component > is_net_in_component",
        "section": "is_net_in_component > is_net_in_component",
        "text": "EdbNets.is_net_in_component(component_name, net_name)\n\nCheck if a net belongs to a component.\n\nParameters\n\ncomponent_name\n\npython:str\n\nName of the component.\n\nnet_name\n\npython:str\n\nName of the net.\n\nReturns\n\nbool\n\nTrue if the net is found in component pins.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj: The object to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\nfrom_attributes: Whether to extract data from object attributes.\ncontext: Additional context to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nValidationError: If the object could not be validated.\nThe validated model instance.\nmodel_validate"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_validate.html#pyedb.workflows.drc.drc.BackDrillStubLength.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod BackDrillStubLength.model_validate(obj: Any, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\nValidate a pydantic model instance.\n\nArgs:\n\nobj: The object to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\nfrom_attributes: Whether to extract data from object attributes.\ncontext: Additional context to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nRaises:\n\nValidationError: If the object could not be validated.\n\nReturns:\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.sweep_data.SweepData",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.sweep_data.SweepData.html#sweepdata",
        "title": "SweepData",
        "section": "SweepData",
        "text": "Frequency sweep data class.\nSweepData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.sweep_data.SweepData",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.sweep_data.SweepData.html#pyedb.grpc.database.simulation_setup.sweep_data.SweepData",
        "title": "SweepData > SweepData > SweepData",
        "section": "SweepData > SweepData",
        "text": "class pyedb.grpc.database.simulation_setup.sweep_data.SweepData(pedb, name, distribution, start_f, end_f, step, edb_object=None)\n\nFrequency sweep data class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/heatsink",
        "href": "dotnet_api/dotnet/utilities/heatsink.html#icepak-heat-sink",
        "title": "Icepak heat sink",
        "section": "Icepak heat sink",
        "text": "This class is the container of Icepak heat sink.\nHeatSink\nHeatsink model description.\nIcepak heat sink\nHeatSink"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_fill_material",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_fill_material.html#set_fill_material",
        "title": "set_fill_material",
        "section": "set_fill_material",
        "text": "Set the name of the fill material of the layer.\nNew name of the fill material.\nset_fill_material\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_fill_material",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_fill_material.html#pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_fill_material",
        "title": "set_fill_material > set_fill_material > set_fill_material",
        "section": "set_fill_material > set_fill_material",
        "text": "StackupLayer.set_fill_material(fill_material_name)\n\nSet the name of the fill material of the layer.\n\nParameters\n\nfill_material_name\n\npython:str\n\nNew name of the fill material.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.simplify_dielectrics_for_phi",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.simplify_dielectrics_for_phi.html#simplify_dielectrics_for_phi",
        "title": "simplify_dielectrics_for_phi",
        "section": "simplify_dielectrics_for_phi",
        "text": "Split dielectric layers at the boundaries of signal layers and merge them.\nThickness threshold for the layer.\nMethod for merging.\nList of dielectric layers created during the dielectric simplification process.\nsimplify_dielectrics_for_phi\nDatabase\npython:float\nDielectricMergingMethod\nWEIGHTED_CAPACITANCE\npython:list\nStackupLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.simplify_dielectrics_for_phi",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.simplify_dielectrics_for_phi.html#pyedb.grpc.database.stackup.LayerCollection.simplify_dielectrics_for_phi",
        "title": "simplify_dielectrics_for_phi > simplify_dielectrics_for_phi > simplify_dielectrics_for_phi",
        "section": "simplify_dielectrics_for_phi > simplify_dielectrics_for_phi",
        "text": "LayerCollection.simplify_dielectrics_for_phi(database, layer_thickness_thresh=-1, merging_method=DielectricMergingMethod.WEIGHTED_CAPACITANCE)\n\nSplit dielectric layers at the boundaries of signal layers and merge them.\n\nParameters\n\ndatabase\n\nDatabase\n\n\n\nlayer_thickness_thresh\n\npython:float, default: -1\n\nThickness threshold for the layer.\n\nmerging_method\n\nDielectricMergingMethod, default: WEIGHTED_CAPACITANCE\n\nMethod for merging.\n\nReturns\n\npython:list[StackupLayer]\n\nList of dielectric layers created during the dielectric simplification process.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.layers_between",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.layers_between.html#layers_between",
        "title": "layers_between",
        "section": "layers_between",
        "text": "Return the sub-list of layers that lies between start_layer\n(inclusive) and stop_layer (inclusive).  Works no matter which\nof the two is nearer the top of the stack.\nlayers_between"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.layers_between",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.layers_between.html#pyedb.grpc.database.padstacks.Padstacks.layers_between",
        "title": "layers_between > layers_between > layers_between",
        "section": "layers_between > layers_between",
        "text": "Padstacks.layers_between(layers, start_layer=None, stop_layer=None)\n\nReturn the sub-list of layers that lies between start_layer\n(inclusive) and stop_layer (inclusive).  Works no matter which\nof the two is nearer the top of the stack.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.closest_points",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.closest_points.html#closest_points",
        "title": "closest_points",
        "section": "closest_points",
        "text": "Get the closest points from this arc to another arc, and vice versa.\nOther arc.\nclosest_points\nArcData\npython:tuple\nof\nPointData\nPointData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.closest_points",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.closest_points.html#pyedb.grpc.database.geometry.arc_data.ArcData.closest_points",
        "title": "closest_points > closest_points > closest_points",
        "section": "closest_points > closest_points",
        "text": "ArcData.closest_points(other: ArcData) -> tuple[PointData, PointData]\n\nGet the closest points from this arc to another arc, and vice versa.\n\nParameters\n\nother\n\nArcData\n\nOther arc.\n\nReturns\n\npython:tuple of (PointData, PointData)\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude: Optional set or mapping specifying which fields to include in the copied model.\nexclude: Optional set or mapping specifying which fields to exclude in the copied model.\nupdate: Optional dictionary of field-value pairs to override field values in the copied model.\ndeep: If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.copy.html#pyedb.workflows.drc.drc.MinAnnularRing.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "MinAnnularRing.copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -> Self\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nArgs:\n\ninclude: Optional set or mapping specifying which fields to include in the copied model.\nexclude: Optional set or mapping specifying which fields to exclude in the copied model.\nupdate: Optional dictionary of field-value pairs to override field values in the copied model.\ndeep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.read_syslib_material",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.read_syslib_material.html#read_syslib_material",
        "title": "read_syslib_material",
        "section": "read_syslib_material",
        "text": "Read a specific material from syslib AMAT file.\nName of the material.\n{material name: dict of material properties}.\nread_syslib_material\npython:str\npython:dict"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.read_syslib_material",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.read_syslib_material.html#pyedb.grpc.database.definition.materials.Materials.read_syslib_material",
        "title": "read_syslib_material > read_syslib_material > read_syslib_material",
        "section": "read_syslib_material > read_syslib_material",
        "text": "Materials.read_syslib_material(material_name) -> dict[str, Material]\n\nRead a specific material from syslib AMAT file.\n\nParameters\n\nmaterial_name\n\npython:str\n\nName of the material.\n\nReturns\n\npython:dict\n\n{material name: dict of material properties}.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.close_edb",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.close_edb.html#close_edb",
        "title": "close_edb",
        "section": "close_edb",
        "text": "Close EDB and clean up resources.\nUse close() instead.\nTrue if successful, False otherwise.\nClose the EDB session:\n>>> edb.close_edb()\nclose_edb\nclose()"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.close_edb",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.close_edb.html#pyedb.grpc.edb.Edb.close_edb",
        "title": "close_edb > close_edb > close_edb",
        "section": "close_edb > close_edb",
        "text": "Edb.close_edb() -> bool\n\nClose EDB and clean up resources.\n\n..deprecated:: 0.51.0\n\nUse close() instead.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\nExamples\n\nClose the EDB session:\n>>> edb.close_edb()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.is_in_zone",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.is_in_zone.html#is_in_zone",
        "title": "is_in_zone",
        "section": "is_in_zone",
        "text": "Determine if the layer exists in the given zone.\nTrue when the layer exists in the given zone, False otherwise.\nis_in_zone\npython:int\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.is_in_zone",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.is_in_zone.html#pyedb.grpc.database.layers.stackup_layer.StackupLayer.is_in_zone",
        "title": "is_in_zone > is_in_zone > is_in_zone",
        "section": "is_in_zone > is_in_zone",
        "text": "StackupLayer.is_in_zone(zone)\n\nDetermine if the layer exists in the given zone.\n\nParameters\n\nzone\n\npython:int\n\n\n\nReturns\n\nbool\n\nTrue when the layer exists in the given zone, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_dump",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#python-mode)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude: A set of fields to include in the output.\nexclude: A set of fields to exclude from the output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\nA dictionary representation of the model.\nmodel_dump"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_dump",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_dump.html#pyedb.workflows.drc.drc.Rules.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "Rules.model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -> dict[str, Any]\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#python-mode)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n\nmode: The mode in which to_python should run.\n\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude: A set of fields to include in the output.\nexclude: A set of fields to exclude from the output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\n\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\n\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback: A function to call when an unknown value is encountered. If not provided,\n\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.create_3d_comp.html#create_3d_comp",
        "title": "create_3d_comp",
        "section": "create_3d_comp",
        "text": "Create a 3D composite model from an MCAD file.\n3D composite model created.\ncreate_3d_comp\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.create_3d_comp.html#pyedb.grpc.database.primitive.bondwire.Bondwire.create_3d_comp",
        "title": "create_3d_comp > create_3d_comp > create_3d_comp",
        "section": "create_3d_comp > create_3d_comp",
        "text": "Bondwire.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nReturns\n\nMcadModel\n\n3D composite model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_coax_port_on_component",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_coax_port_on_component.html#create_coax_port_on_component",
        "title": "create_coax_port_on_component",
        "section": "create_coax_port_on_component",
        "text": "The name of the new coaxial port is automatically assigned.\nList of one or more reference designators.\nList of one or more nets.\nDelete existing terminal with same name if exists.\nPort naming convention is ref_des`_`pin.net.name`_`pin.name\nTrue when successful, False when failed.\ncreate_coax_port_on_component\npython:list\npython:str\npython:list\npython:str\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_coax_port_on_component",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_coax_port_on_component.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_coax_port_on_component",
        "title": "create_coax_port_on_component > create_coax_port_on_component > create_coax_port_on_component",
        "section": "create_coax_port_on_component > create_coax_port_on_component",
        "text": "SourceExcitation.create_coax_port_on_component(ref_des_list: str | List[str], net_list: str | List[str], delete_existing_terminal: bool = False) -> List[str]\n\nCreate a coaxial port on a component or component list on a net or net list.\n\nThe name of the new coaxial port is automatically assigned.\n\nParameters\n\nref_des_list\n\npython:list, python:str\n\nList of one or more reference designators.\n\nnet_list\n\npython:list, python:str\n\nList of one or more nets.\n\ndelete_existing_terminal\n\nbool\n\nDelete existing terminal with same name if exists.\nPort naming convention is ref_des`_`pin.net.name`_`pin.name\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> edb.source_excitation.create_coax_port_on_component([\"U1\"], [\"RF1\", \"RF2\"])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.flip_design",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.flip_design.html#flip_design",
        "title": "flip_design",
        "section": "flip_design",
        "text": "Flip the current design of a layout.\nTrue when successful.\nflip_design\nTrue"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.flip_design",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.flip_design.html#pyedb.grpc.database.stackup.Stackup.flip_design",
        "title": "flip_design > flip_design > flip_design",
        "section": "flip_design > flip_design",
        "text": "Stackup.flip_design() -> bool\n\nFlip the current design of a layout.\n\nReturns\n\nbool\n\nTrue when successful.\n\nExamples\n\n>>> edb = Edb(edbpath=targetfile, edbversion=\"2021.2\")\n>>> edb.stackup.flip_design()\n>>> edb.save()\n>>> edb.close_edb()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/models.md#model-copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nbefore creating the new model. You should trust this data.\ndeep: Set to True to make a deep copy of the model.\nNew model instance.\nmodel_copy"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_copy.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "DiffPairLengthMatch.model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -> Self\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/models.md#model-copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nArgs:\n\nupdate: Values to change/add in the new model. Note: the data is not validated\n\nbefore creating the new model. You should trust this data.\n\ndeep: Set to True to make a deep copy of the model.\n\nReturns:\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.closest",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.closest.html#closest",
        "title": "closest",
        "section": "closest",
        "text": "Get the closest point on a line segment from the point.\nStart point of the line segment.\nEnd point of the line segment.\nCloset PointData or None if either point is an arc.\nclosest\nPointData\nNone\nNone"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.closest",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.closest.html#pyedb.grpc.database.geometry.point_data.PointData.closest",
        "title": "closest > closest > closest",
        "section": "closest > closest",
        "text": "PointData.closest(start: PointLike, end: PointLike) -> PointData | None\n\nGet the closest point on a line segment from the point.\n\nParameters\n\nstart\n\nPoint2DLike\n\nStart point of the line segment.\n\nend\n\nPoint2DLike\n\nEnd point of the line segment.\n\nReturns\n\nPointData or None\n\nCloset PointData or None if either point is an arc.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.is_valid",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.is_valid.html#is_valid",
        "title": "is_valid",
        "section": "is_valid",
        "text": "Determine if the layer collection is in a valid state.\nFor a laminate stackup, this method checks whether there is layer overlapping or a gap.\nFor an overlapping stackup, this method checks whether there is a dielectric layer\noverlapping or a gap.\nTrue if the layer collection is in a valid state, False otherwise.\nis_valid\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.is_valid",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.is_valid.html#pyedb.grpc.database.stackup.Stackup.is_valid",
        "title": "is_valid > is_valid > is_valid",
        "section": "is_valid > is_valid",
        "text": "Stackup.is_valid()\n\nDetermine if the layer collection is in a valid state.\n\nFor a laminate stackup, this method checks whether there is layer overlapping or a gap.\nFor an overlapping stackup, this method checks whether there is a dielectric layer\noverlapping or a gap.\n\nReturns\n\nbool\n\nTrue if the layer collection is in a valid state, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Remove a material from the database.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.delete.html#pyedb.grpc.database.definition.materials.Materials.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "Materials.delete(material_name) -> bool\n\nRemove a material from the database.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kHFSS",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kHFSS.html#khfss",
        "title": "kHFSS",
        "section": "kHFSS",
        "text": "kHFSS"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kHFSS",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kHFSS.html#pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kHFSS",
        "title": "kHFSS > kHFSS > kHFSS",
        "section": "kHFSS > kHFSS",
        "text": "SimulationSetupType.kHFSS = 'hfss'\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.plot",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.plot.html#plot",
        "title": "plot",
        "section": "plot",
        "text": "Plot the current polygon on matplotlib.\nWhether if plot the entire net or only the selected polygon. Default is False.\nWhether if show the plot or not. Default is True.\nSave the plot path.\nMatplotlib ax and figures.\nplot\noptional\nFalse\noptional\nTrue\npython:str\noptional\nax\nfig"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.plot",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.plot.html#pyedb.grpc.database.primitive.path.Path.plot",
        "title": "plot > plot > plot",
        "section": "plot > plot",
        "text": "Path.plot(plot_net=False, show=True, save_plot=None)\n\nPlot the current polygon on matplotlib.\n\nParameters\n\nplot_net\n\nbool, optional\n\nWhether if plot the entire net or only the selected polygon. Default is False.\n\nshow\n\nbool, optional\n\nWhether if show the plot or not. Default is True.\n\nsave_plot\n\npython:str, optional\n\nSave the plot path.\n\nReturns\n\n(ax, fig)\n\nMatplotlib ax and figures.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/padstack_instance",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/padstack_instance.html#pad-stack-instance",
        "title": "Pad-stack Instance",
        "section": "Pad-stack Instance",
        "text": "This class is managing EDB padstack instance.\nPadstackInstance\nManages EDB functionalities for a padstack.\nPad-stack Instance\nPadstackInstance"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_edge_port_vertical",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_edge_port_vertical.html#create_edge_port_vertical",
        "title": "create_edge_port_vertical",
        "section": "create_edge_port_vertical",
        "text": "Create a vertical edge port.\nPrimitive ID.\nCoordinate of the point to define the edge terminal.\nThe point must be on the target edge but not on the two\nends of the edge.\nName of the port. The default is None.\nImpedance of the port. The default value is 50.\nReference layer of the port. The default is None.\nType of the port. The default value is \"Gap\". Options are \"Gap\", \"Wave\".\nHorizontal extent factor. The default value is 5.\nVertical extent factor. The default value is 3.\nRadial extent factor. The default value is 0.\nLaunch Width of PEC. The default value is \"0.01mm\".\nPort name.\ncreate_edge_port_vertical\npython:int\npython:list\npython:str\noptional\nNone\npython:int\npython:float\noptional\n50\npython:str\noptional\nNone\npython:str\noptional\n\"Gap\"\n\"Gap\"\n\"Wave\"\npython:int\npython:float\noptional\n5\npython:int\npython:float\noptional\n3\npython:int\npython:float\noptional\n0\npython:str\noptional\n\"0.01mm\"\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_edge_port_vertical",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_edge_port_vertical.html#pyedb.dotnet.database.hfss.EdbHfss.create_edge_port_vertical",
        "title": "create_edge_port_vertical > create_edge_port_vertical > create_edge_port_vertical",
        "section": "create_edge_port_vertical > create_edge_port_vertical",
        "text": "EdbHfss.create_edge_port_vertical(prim_id, point_on_edge, port_name=None, impedance=50, reference_layer=None, hfss_type='Gap', horizontal_extent_factor=5, vertical_extent_factor=3, pec_launch_width='0.01mm')\n\nCreate a vertical edge port.\n\nParameters\n\nprim_id\n\npython:int\n\nPrimitive ID.\n\npoint_on_edge\n\npython:list\n\nCoordinate of the point to define the edge terminal.\nThe point must be on the target edge but not on the two\nends of the edge.\n\nport_name\n\npython:str, optional\n\nName of the port. The default is None.\n\nimpedance\n\npython:int, python:float, optional\n\nImpedance of the port. The default value is 50.\n\nreference_layer\n\npython:str, optional\n\nReference layer of the port. The default is None.\n\nhfss_type\n\npython:str, optional\n\nType of the port. The default value is \"Gap\". Options are \"Gap\", \"Wave\".\n\nhorizontal_extent_factor\n\npython:int, python:float, optional\n\nHorizontal extent factor. The default value is 5.\n\nvertical_extent_factor\n\npython:int, python:float, optional\n\nVertical extent factor. The default value is 3.\n\nradial_extent_factor\n\npython:int, python:float, optional\n\nRadial extent factor. The default value is 0.\n\npec_launch_width\n\npython:str, optional\n\nLaunch Width of PEC. The default value is \"0.01mm\".\n\nReturns\n\npython:str\n\nPort name.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.assign_rlc_model",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.assign_rlc_model.html#assign_rlc_model",
        "title": "assign_rlc_model",
        "section": "assign_rlc_model",
        "text": "Assign RLC to all components under this part name.\nResistance. Default is None.\nInductance. Default is None.\nCapacitance. Default is None.\nWhether it is parallel or series RLC component.\nassign_rlc_model\npython:int\npython:float\nNone\npython:int\npython:float\nNone\npython:int\npython:float\nNone\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.assign_rlc_model",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.assign_rlc_model.html#pyedb.grpc.database.definition.component_def.ComponentDef.assign_rlc_model",
        "title": "assign_rlc_model > assign_rlc_model > assign_rlc_model",
        "section": "assign_rlc_model > assign_rlc_model",
        "text": "ComponentDef.assign_rlc_model(res=None, ind=None, cap=None, is_parallel=False) -> bool\n\nAssign RLC to all components under this part name.\n\nParameters\n\nres\n\npython:int, python:float\n\nResistance. Default is None.\n\nind\n\npython:int, python:float\n\nInductance. Default is None.\n\ncap\n\npython:int, python:float\n\nCapacitance. Default is None.\n\nis_parallel\n\nbool, optional\n\nWhether it is parallel or series RLC component.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.create",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a pin group terminal.\nLayout to create the pin group terminal in.\nNet reference.\nName of the pin group terminal.\nPin group.\nWhether the pin group terminal is a reference terminal.\ncreate\nLayout\nNet\nstr\npython:None\nstr\nPinGroup\nbool\npython:False\nPinGroupTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.create",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.create.html#pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod PinGroupTerminal.create(layout, name, pin_group, net, is_ref=False)\n\nCreate a pin group terminal.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to create the pin group terminal in.\n\nnet\n\nNet or str or python:None\n\nNet reference.\n\nname\n\nstr\n\nName of the pin group terminal.\n\npin_group\n\nPinGroup\n\nPin group.\n\nis_ref\n\nbool, default: python:False\n\nWhether the pin group terminal is a reference terminal.\n\nReturns\n\nPinGroupTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.diff_pair_length_match",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.diff_pair_length_match.html#diff_pair_length_match",
        "title": "diff_pair_length_match",
        "section": "diff_pair_length_match",
        "text": "diff_pair_length_match"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.diff_pair_length_match",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.diff_pair_length_match.html#pyedb.workflows.drc.drc.Rules.diff_pair_length_match",
        "title": "diff_pair_length_match > diff_pair_length_match > diff_pair_length_match",
        "section": "diff_pair_length_match > diff_pair_length_match",
        "text": "Rules.diff_pair_length_match: List[DiffPairLengthMatch]\n\n"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_rebuild",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce: Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors: Whether to raise errors, defaults to True.\n_parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n_types_namespace: The types namespace, defaults to None.\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_rebuild",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_rebuild.html#pyedb.workflows.drc.drc.MinAnnularRing.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod MinAnnularRing.model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -> bool | None\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n\nforce: Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors: Whether to raise errors, defaults to True.\n_parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n_types_namespace: The types namespace, defaults to None.\n\nReturns:\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_edge_terminal_reference_primitive",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_edge_terminal_reference_primitive.html#get_edge_terminal_reference_primitive",
        "title": "get_edge_terminal_reference_primitive",
        "section": "get_edge_terminal_reference_primitive",
        "text": "Check and  return a primitive instance that serves Edge ports,\nwave ports and coupled edge ports that are directly connedted to primitives.\nget_edge_terminal_reference_primitive\npyedb.dotnet.database.edb_data.primitives_data.EDBPrimitives"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_edge_terminal_reference_primitive",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_edge_terminal_reference_primitive.html#pyedb.dotnet.database.edb_data.ports.GapPort.get_edge_terminal_reference_primitive",
        "title": "get_edge_terminal_reference_primitive > get_edge_terminal_reference_primitive > get_edge_terminal_reference_primitive",
        "section": "get_edge_terminal_reference_primitive > get_edge_terminal_reference_primitive",
        "text": "GapPort.get_edge_terminal_reference_primitive()\n\nCheck and  return a primitive instance that serves Edge ports,\nwave ports and coupled edge ports that are directly connedted to primitives.\n\nReturns\n\npyedb.dotnet.database.edb_data.primitives_data.EDBPrimitives\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.merge_dielectrics",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.merge_dielectrics.html#merge_dielectrics",
        "title": "merge_dielectrics",
        "section": "merge_dielectrics",
        "text": "Merge the dielectric layers in a range of layers into one large dielectric layer.\nmerge_dielectrics\nLayout\npython:str\npython:str\nDielectricMergingMethod\npython:str\npython:str\nStackupLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.merge_dielectrics",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.merge_dielectrics.html#pyedb.grpc.database.stackup.LayerCollection.merge_dielectrics",
        "title": "merge_dielectrics > merge_dielectrics > merge_dielectrics",
        "section": "merge_dielectrics > merge_dielectrics",
        "text": "LayerCollection.merge_dielectrics(layout, start_layer_name, end_layer_name, merging_method, merged_layer_name, merged_mat_name)\n\nMerge the dielectric layers in a range of layers into one large dielectric layer.\n\nParameters\n\nlayout\n\nLayout\n\n\n\nstart_layer_name\n\npython:str\n\n\n\nend_layer_name\n\npython:str\n\n\n\nmerging_method\n\nDielectricMergingMethod\n\n\n\nmerged_layer_name\n\npython:str\n\n\n\nmerged_mat_name\n\npython:str\n\n\n\nReturns\n\nStackupLayer\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.contains_net",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.contains_net.html#contains_net",
        "title": "contains_net",
        "section": "contains_net",
        "text": "Determine if a net exists in the net class.\nThe net to check. This can be a string representing the net name or a Net object.\nTrue if the net exists in the net class, False otherwise.\ncontains_net\npython:str\nNet"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.contains_net",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.contains_net.html#pyedb.grpc.database.net.net_class.NetClass.contains_net",
        "title": "contains_net > contains_net > contains_net",
        "section": "contains_net > contains_net",
        "text": "NetClass.contains_net(net) -> bool\n\nDetermine if a net exists in the net class.\n\nParameters\n\nnet\n\npython:str or Net\n\nThe net to check. This can be a string representing the net name or a Net object.\n\nReturns\n\nbool\n\nTrue if the net exists in the net class, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.Meander.electrical_length_deg",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.Meander.electrical_length_deg.html#electrical_length_deg",
        "title": "electrical_length_deg",
        "section": "electrical_length_deg",
        "text": "Electrical length of the meander at the specified frequency.\nFrequency in Hz.\nPhase shift in degrees.\nelectrical_length_deg\npython:float\npython:float"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.Meander.electrical_length_deg",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.Meander.electrical_length_deg.html#pyedb.libraries.rf_libraries.base_functions.Meander.electrical_length_deg",
        "title": "electrical_length_deg > electrical_length_deg > electrical_length_deg",
        "section": "electrical_length_deg > electrical_length_deg",
        "text": "Meander.electrical_length_deg(freq: float) -> float\n\nElectrical length of the meander at the specified frequency.\n\nParameters\n\nfreq\n\npython:float\n\nFrequency in Hz.\n\nReturns\n\npython:float\n\nPhase shift in degrees.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/padstack_instance_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/padstack_instance_terminal.html#padstack-instance-terminal",
        "title": "Padstack instance terminal",
        "section": "Padstack instance terminal",
        "text": "This class is managing EDB padstack instance terminal.\nPadstackInstanceTerminal\nManages bundle terminal properties.\nPadstack instance terminal\nPadstackInstanceTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.poisson_ratio",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.poisson_ratio.html#poisson_ratio",
        "title": "poisson_ratio",
        "section": "poisson_ratio",
        "text": "poisson_ratio"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.poisson_ratio",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.poisson_ratio.html#pyedb.grpc.database.definition.materials.MaterialProperties.poisson_ratio",
        "title": "poisson_ratio > poisson_ratio > poisson_ratio",
        "section": "poisson_ratio > poisson_ratio",
        "text": "MaterialProperties.poisson_ratio: Annotated[float, Gt(gt=0)] | None\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.json",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.json.html#json",
        "title": "json",
        "section": "json",
        "text": "json"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.json",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.json.html#pyedb.grpc.database.definition.materials.MaterialProperties.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "MaterialProperties.json(*, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -> str\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlCircuitPt",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlCircuitPt.html#controlcircuitpt",
        "title": "ControlCircuitPt",
        "section": "ControlCircuitPt",
        "text": "Circuit Port.\nControlCircuitPt"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlCircuitPt",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlCircuitPt.html#pyedb.dotnet.database.edb_data.control_file.ControlCircuitPt",
        "title": "ControlCircuitPt > ControlCircuitPt > ControlCircuitPt",
        "section": "ControlCircuitPt > ControlCircuitPt",
        "text": "class pyedb.dotnet.database.edb_data.control_file.ControlCircuitPt(name, x1, y1, lay1, x2, y2, lay2, z0)\n\nCircuit Port.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.remove_all_nets",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.remove_all_nets.html#remove_all_nets",
        "title": "remove_all_nets",
        "section": "remove_all_nets",
        "text": "Remove all nets from the extended net.\nremove_all_nets"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.remove_all_nets",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.remove_all_nets.html#pyedb.grpc.database.net.extended_net.ExtendedNet.remove_all_nets",
        "title": "remove_all_nets > remove_all_nets > remove_all_nets",
        "section": "remove_all_nets > remove_all_nets",
        "text": "ExtendedNet.remove_all_nets()\n\nRemove all nets from the extended net.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.dbscan",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.dbscan.html#dbscan",
        "title": "dbscan",
        "section": "dbscan",
        "text": "density based spatial clustering for padstack instances\npadstack id: [x, y]\nmaximum distance between two points to be included in one cluster\nminimum number of points that a cluster must have\nclusters {cluster label: [padstack ids]} <\ndbscan\npython:dict"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.dbscan",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.dbscan.html#pyedb.grpc.database.padstacks.Padstacks.dbscan",
        "title": "dbscan > dbscan > dbscan",
        "section": "dbscan > dbscan",
        "text": "static Padstacks.dbscan(padstack: Dict[int, List[float]], max_distance: float = 0.001, min_samples: int = 5) -> Dict[int, List[str]]\n\ndensity based spatial clustering for padstack instances\n\nParameters\n\npadstack\n\ndict.\n\npadstack id: [x, y]\n\nmax_distance: float\n\nmaximum distance between two points to be included in one cluster\n\nmin_samples: int\n\nminimum number of points that a cluster must have\n\nReturns\n\npython:dict\n\nclusters {cluster label: [padstack ids]} <\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_gds_comp_xml",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_gds_comp_xml.html#export_gds_comp_xml",
        "title": "export_gds_comp_xml",
        "section": "export_gds_comp_xml",
        "text": "Exports an XML file with selected components information for use in a GDS import.\nList of components whose information will be exported to xml file.\nGDS_COMPONENTS section units. Default is \"mm\".\nPath for outputting the XML file.\nTrue when successful, False when failed.\nexport_gds_comp_xml\npython:list\npython:str\noptional\n\"mm\"\npython:str\noptional\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_gds_comp_xml",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_gds_comp_xml.html#pyedb.dotnet.edb.Edb.export_gds_comp_xml",
        "title": "export_gds_comp_xml > export_gds_comp_xml > export_gds_comp_xml",
        "section": "export_gds_comp_xml > export_gds_comp_xml",
        "text": "Edb.export_gds_comp_xml(comps_to_export, gds_comps_unit='mm', control_path=None)\n\nExports an XML file with selected components information for use in a GDS import.\n\nParameters\n\ncomps_to_export\n\npython:list\n\nList of components whose information will be exported to xml file.\n\ngds_comps_unit\n\npython:str, optional\n\nGDS_COMPONENTS section units. Default is \"mm\".\n\ncontrol_path\n\npython:str, optional\n\nPath for outputting the XML file.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.get_product_property_ids.html#pyedb.grpc.database.ports.ports.WavePort.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "WavePort.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues: Trusted or pre-validated data dictionary.\nA new instance of the Model class with validated data.\nmodel_construct"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_construct.html#pyedb.workflows.drc.drc.CopperBalance.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod CopperBalance.model_construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nArgs:\n\n_fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues: Trusted or pre-validated data dictionary.\n\nReturns:\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kSIwaveDCIR",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kSIwaveDCIR.html#ksiwavedcir",
        "title": "kSIwaveDCIR",
        "section": "kSIwaveDCIR",
        "text": "kSIwaveDCIR"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kSIwaveDCIR",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kSIwaveDCIR.html#pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kSIwaveDCIR",
        "title": "kSIwaveDCIR > kSIwaveDCIR > kSIwaveDCIR",
        "section": "kSIwaveDCIR > kSIwaveDCIR",
        "text": "SimulationSetupType.kSIwaveDCIR = 'siwave_dc'\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.add_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.add_sweep.html#add_sweep",
        "title": "add_sweep",
        "section": "add_sweep",
        "text": "Add frequency sweep.\nName of the frequency sweep. The default is None.\nAdded for grpc compatibility.\nAdded for rpc compatibility.\nAdded for grpc compatibility.\nAdded for grpc compatibility.\nList of frequency points. The default is None.\nSweep type. The default is \"interpolation\". Options are \"discrete\",”discrete”``.\nadd_sweep\npython:str\noptional\nNone\npython:str\noptional\npython:str\noptional\npython:str\noptional\noptional\npython:list\noptional\nNone\npython:str\noptional\n\"interpolation\"\n\"discrete\""
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.add_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.add_sweep.html#pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.add_sweep",
        "title": "add_sweep > add_sweep > add_sweep",
        "section": "add_sweep > add_sweep",
        "text": "HfssSimulationSetup.add_sweep(name: str | None = None, distribution: str | None = None, start_freq: str | None = None, stop_freq: str | None = None, step=None, frequency_set: list | None = None, sweep_type: str = 'interpolation', **kwargs)\n\nAdd frequency sweep.\n\nParameters\n\nname\n\npython:str, optional\n\nName of the frequency sweep. The default is None.\n\ndistribution\n\npython:str, optional\n\nAdded for grpc compatibility.\n\nstart_freq\n\npython:str, optional\n\nAdded for rpc compatibility.\n\nstop_freq\n\npython:str, optional\n\nAdded for grpc compatibility.\n\nstep\n\noptional\n\nAdded for grpc compatibility.\n\nfrequency_set\n\npython:list, optional\n\nList of frequency points. The default is None.\n\nsweep_type\n\npython:str, optional\n\nSweep type. The default is \"interpolation\". Options are \"discrete\",”discrete”``.\n\nReturns\n\n\n\n——-\n\n\n\nExamples\n\n>>> setup1 = edbapp.create_siwave_syz_setup(\"setup1\")\n>>> setup1.add_sweep(name=\"sw1\", frequency_set=[\"linear count\", \"1MHz\", \"100MHz\", 10])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.loss_tangent_at_frequency",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.loss_tangent_at_frequency.html#loss_tangent_at_frequency",
        "title": "loss_tangent_at_frequency",
        "section": "loss_tangent_at_frequency",
        "text": "loss_tangent_at_frequency"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.loss_tangent_at_frequency",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.loss_tangent_at_frequency.html#pyedb.grpc.database.definition.materials.MaterialProperties.loss_tangent_at_frequency",
        "title": "loss_tangent_at_frequency > loss_tangent_at_frequency > loss_tangent_at_frequency",
        "section": "loss_tangent_at_frequency > loss_tangent_at_frequency",
        "text": "MaterialProperties.loss_tangent_at_frequency: Annotated[float, Gt(gt=0)] | None\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.get_product_property.html#pyedb.grpc.database.terminal.point_terminal.PointTerminal.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "PointTerminal.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.layout_obj_type.html#pyedb.grpc.database.ports.ports.GapPort.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "GapPort.layout_obj_type = 2\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.refresh_components",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.refresh_components.html#refresh_components",
        "title": "refresh_components",
        "section": "refresh_components",
        "text": "Refresh the component dictionary.\nTrue if successful, False otherwise.\nrefresh_components"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.refresh_components",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.refresh_components.html#pyedb.grpc.database.components.Components.refresh_components",
        "title": "refresh_components > refresh_components > refresh_components",
        "section": "refresh_components > refresh_components",
        "text": "Components.refresh_components() -> bool\n\nRefresh the component dictionary.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\nExamples\n\n>>> edbapp.components.refresh_components()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.create",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a padstack instance terminal.\nLayout to create the padstack instance terminal in.\nName of the padstack instance terminal.\nPadstack instance.\nLayer to place the padstack instance terminal on.\nNet.\nWhether the padstack instance terminal is a reference terminal.\ncreate\nLayout\nstr\nPadstackInstance\nLayer\nstr\nNet\nstr\npython:None\nbool\npython:False\nPadstackInstanceTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.create",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.create.html#pyedb.grpc.database.ports.ports.CoaxPort.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod CoaxPort.create(layout, name, padstack_instance, layer, net, is_ref=False)\n\nCreate a padstack instance terminal.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to create the padstack instance terminal in.\n\nname\n\nstr\n\nName of the padstack instance terminal.\n\npadstack_instance\n\nPadstackInstance\n\nPadstack instance.\n\nlayer\n\nLayer or str\n\nLayer to place the padstack instance terminal on.\n\nnet\n\nNet or str or python:None\n\nNet.\n\nis_ref\n\nbool, default: python:False\n\nWhether the padstack instance terminal is a reference terminal.\n\nReturns\n\nPadstackInstanceTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.variable_exists",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.variable_exists.html#variable_exists",
        "title": "variable_exists",
        "section": "variable_exists",
        "text": "Check if variable exists.\nVariable name.\nTrue if variable exists.\nvariable_exists\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.variable_exists",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.variable_exists.html#pyedb.grpc.edb.Edb.variable_exists",
        "title": "variable_exists > variable_exists > variable_exists",
        "section": "variable_exists > variable_exists",
        "text": "Edb.variable_exists(variable_name)\n\nCheck if variable exists.\n\nParameters\n\nvariable_name\n\npython:str\n\nVariable name.\n\nReturns\n\nbool\n\nTrue if variable exists.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.get_dimensions",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.get_dimensions.html#get_dimensions",
        "title": "get_dimensions",
        "section": "get_dimensions",
        "text": "Get the dimensions of the tensor of a material property.\nSimple -> 1x1\nAnisotropic -> 3x1\nTensor -> 3x3.\nMaterial property to get the dimensions of.\nThe tuple is of the format (col, row):\ncol: Number of rows of the material property.\nrow: Number of columns of the material property.\nget_dimensions\nSimple\n1x1\nAnisotropic\n3x1\nTensor\n3x3\nMaterialProperty\npython:tuple\nof\npython:int\npython:int\n(col, row)\ncol\nrow"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.get_dimensions",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.get_dimensions.html#pyedb.grpc.database.definition.materials.Material.get_dimensions",
        "title": "get_dimensions > get_dimensions > get_dimensions",
        "section": "get_dimensions > get_dimensions",
        "text": "Material.get_dimensions(material_property_id: MaterialProperty) -> Tuple[int, int]\n\nGet the dimensions of the tensor of a material property.\n\nThe mappings between the types of material properties and dimensions are as follows:\n\nSimple -> 1x1\n\nAnisotropic -> 3x1\n\nTensor -> 3x3.\n\nParameters\n\nmaterial_property_id\n\nMaterialProperty\n\nMaterial property to get the dimensions of.\n\nReturns\n\npython:tuple of (python:int, python:int)\n\nThe tuple is of the format (col, row):\n\ncol: Number of rows of the material property.\n\nrow: Number of columns of the material property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.find",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.find.html#find",
        "title": "find",
        "section": "find",
        "text": "Find a component definition in a given database.\nDatabase to search for the component definition.\nName of the component definition.\nComponent definition found, None otherwise.\nfind\nDatabase\npython:str\nComponentDef\nNone"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.find",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.find.html#pyedb.grpc.database.definition.component_def.ComponentDef.find",
        "title": "find > find > find",
        "section": "find > find",
        "text": "classmethod ComponentDef.find(db, comp_def_name)\n\nFind a component definition in a given database.\n\nParameters\n\ndb\n\nDatabase\n\nDatabase to search for the component definition.\n\ncomp_def_name\n\npython:str\n\nName of the component definition.\n\nReturns\n\nComponentDef\n\nComponent definition found, None otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings.set_si_slider",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings.set_si_slider.html#set_si_slider",
        "title": "set_si_slider",
        "section": "set_si_slider",
        "text": "set_si_slider"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings.set_si_slider",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings.set_si_slider.html#pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings.set_si_slider",
        "title": "set_si_slider > set_si_slider > set_si_slider",
        "section": "set_si_slider > set_si_slider",
        "text": "AdvancedSettings.set_si_slider(value)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.default_conductor_property_values",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.default_conductor_property_values.html#default_conductor_property_values",
        "title": "default_conductor_property_values",
        "section": "default_conductor_property_values",
        "text": "default_conductor_property_values"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.default_conductor_property_values",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.default_conductor_property_values.html#pyedb.grpc.database.definition.materials.Materials.default_conductor_property_values",
        "title": "default_conductor_property_values > default_conductor_property_values > default_conductor_property_values",
        "section": "default_conductor_property_values > default_conductor_property_values",
        "text": "Materials.default_conductor_property_values = {'conductivity': 58000000, 'dielectric_loss_tangent': 0, 'magnetic_loss_tangent': 0, 'mass_density': 8933, 'permeability': 0.999991, 'permittivity': 1, 'poisson_ratio': 0.38, 'specific_heat': 385, 'thermal_conductivity': 400, 'thermal_expansion_coefficient': 1.77e-05, 'youngs_modulus': 120000000000}\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileDielectric",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileDielectric.html#controlfiledielectric",
        "title": "ControlFileDielectric",
        "section": "ControlFileDielectric",
        "text": "ControlFileDielectric"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileDielectric",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileDielectric.html#pyedb.dotnet.database.edb_data.control_file.ControlFileDielectric",
        "title": "ControlFileDielectric > ControlFileDielectric > ControlFileDielectric",
        "section": "ControlFileDielectric > ControlFileDielectric",
        "text": "class pyedb.dotnet.database.edb_data.control_file.ControlFileDielectric(name, properties)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_backdrill_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_backdrill_type.html#get_backdrill_type",
        "title": "get_backdrill_type",
        "section": "get_backdrill_type",
        "text": "Return backdrill type\nParameters\n———-\nfrom_bottom : bool, optional\ndefault value is True.\nget_backdrill_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_backdrill_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_backdrill_type.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_backdrill_type",
        "title": "get_backdrill_type > get_backdrill_type > get_backdrill_type",
        "section": "get_backdrill_type > get_backdrill_type",
        "text": "PadstackInstance.get_backdrill_type(from_bottom=True)\n\nReturn backdrill type\nParameters\n———-\nfrom_bottom : bool, optional\n\ndefault value is True.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_dump_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#json-mode)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent: Indentation to use in the JSON output. If None is passed, the output will be compact.\nensure_ascii: If True, the output is guaranteed to have all incoming non-ASCII characters escaped.\nIf False (the default), these characters will be output as-is.\ninclude: Field(s) to include in the JSON output.\nexclude: Field(s) to exclude from the JSON output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to serialize using field aliases.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\nA JSON string representation of the model.\nmodel_dump_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_dump_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_dump_json.html#pyedb.workflows.drc.drc.CopperBalance.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "CopperBalance.model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -> str\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#json-mode)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nArgs:\n\nindent: Indentation to use in the JSON output. If None is passed, the output will be compact.\nensure_ascii: If True, the output is guaranteed to have all incoming non-ASCII characters escaped.\n\nIf False (the default), these characters will be output as-is.\n\ninclude: Field(s) to include in the JSON output.\nexclude: Field(s) to exclude from the JSON output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to serialize using field aliases.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\n\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\n\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback: A function to call when an unknown value is encountered. If not provided,\n\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_vendor_libraries",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_vendor_libraries.html#get_vendor_libraries",
        "title": "get_vendor_libraries",
        "section": "get_vendor_libraries",
        "text": "Retrieve all capacitors and inductors libraries from ANSYS installation (used by Siwave).\npyedb.component_libraries.ansys_components.ComponentPart\n..\nget_vendor_libraries\nComponentLib\nobject\ncontains\nnested\ndictionaries\nto\nnavigate\nthrough\ncomponent\ntype\nvendors\nseries"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_vendor_libraries",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_vendor_libraries.html#pyedb.dotnet.database.components.Components.get_vendor_libraries",
        "title": "get_vendor_libraries > get_vendor_libraries > get_vendor_libraries",
        "section": "get_vendor_libraries > get_vendor_libraries",
        "text": "Components.get_vendor_libraries()\n\nRetrieve all capacitors and inductors libraries from ANSYS installation (used by Siwave).\n\nReturns\n\nComponentLib object contains nested dictionaries to navigate through [component type][vendors][series]\n\n\n\nclass\n\npyedb.component_libraries.ansys_components.ComponentPart\n..\n\nExamples\n\n>>> edbapp = Edb()\n>>> comp_lib = edbapp.components.get_vendor_libraries()\n>>> network = comp_lib.capacitors[\"AVX\"][\"AccuP01005\"][\"C005YJ0R1ABSTR\"].s_parameters\n>>> network.write_touchstone(os.path.join(edbapp.directory, \"test_export.s2p\"))\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_layer_bottom",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_layer_bottom.html#add_layer_bottom",
        "title": "add_layer_bottom",
        "section": "add_layer_bottom",
        "text": "Add a layer on bottom of the stackup.\nName of the layer.\nType of the layer. The default to \"signal\". Options are \"signal\", \"dielectric\"\nadd_layer_bottom\npython:str\n\"signal\"\n\"signal\"\n\"dielectric\""
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_layer_bottom",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_layer_bottom.html#pyedb.dotnet.database.stackup.Stackup.add_layer_bottom",
        "title": "add_layer_bottom > add_layer_bottom > add_layer_bottom",
        "section": "add_layer_bottom > add_layer_bottom",
        "text": "Stackup.add_layer_bottom(name, layer_type='signal', **kwargs)\n\nAdd a layer on bottom of the stackup.\n\nParameters\n\nname\n\npython:str\n\nName of the layer.\n\nlayer_type: str, optional\n\nType of the layer. The default to \"signal\". Options are \"signal\", \"dielectric\"\n\nkwargs\n\n\n\nReturns\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.html#cell",
        "title": "Cell",
        "section": "Cell",
        "text": "Manage Cell\nCell.add_menu_variable(name, values[, ...])\nAdd a menu variable.\nCell.add_variable(name, value[, is_param])\nAdd a variable.\nCell.create(db, cell_type, cell_name)\nCreate a cell.\nCell.create_value(val)\nCreate a value instance.\nCell.cutout(included_nets, clipped_nets, ...)\nCut out an existing cell into a new cell.\nCell.delete()\nDelete the cell.\nCell.delete_simulation_setup(name)\nDelete a simulation setup by name.\nCell.delete_variable(name)\nDelete a variable.\nCell.find(database, cell_type[, name, cell_id])\nFind a cell in a database by either name or ID.\nCell.generate_auto_hfss_regions()\nGenerate auto HFSS regions.\nCell.generate_via_smart_box(net_name)\nGenerate a via smart box.\nCell.get_all_variable_names()\nGet all variable names.\nCell.get_product_property(prod_id, attr_id)\nGet the product-specific property of the cell.\nCell.get_product_property_ids(prod_id)\nGet a list of attribute IDS for a given product ID for the cell.\nCell.get_variable_desc(name)\nGet the description of a variable.\nCell.get_variable_value(name)\nGet the value for a given variable.\nCell.is_parameter(name)\nDetermine if the variable is a parameter.\nCell.set_hfss_extent_info(extents)\nSet the HFSS extents of this cell.\nCell.set_product_property(prod_id, attr_id, ...)\nSet the product property of the cell for a given product ID and attribute ID.\nCell.set_variable_desc(name, desc)\nSet a variable to have a new description.\nCell.set_variable_value(name, new_value)\nSet a variable to a new value.\nCell.layout_obj_type\n\nCell\nCell\nCell.add_menu_variable\nCell.add_variable\nCell.create\nCell.create_value\nCell.cutout\nCell.delete\nCell.delete_simulation_setup\nCell.delete_variable\nCell.find\nCell.generate_auto_hfss_regions\nCell.generate_via_smart_box\nCell.get_all_variable_names\nCell.get_product_property\nCell.get_product_property_ids\nCell.get_variable_desc\nCell.get_variable_value\nCell.is_parameter\nCell.set_hfss_extent_info\nCell.set_product_property\nCell.set_variable_desc\nCell.set_variable_value\nCell.layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.html#pyedb.grpc.database.layout.cell.Cell",
        "title": "Cell > Cell > Cell",
        "section": "Cell > Cell",
        "text": "class pyedb.grpc.database.layout.cell.Cell(pedb, edb_object)\n\nManage Cell\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nCell.add_menu_variable(name, values[, ...])\n\nAdd a menu variable.\n\nCell.add_variable(name, value[, is_param])\n\nAdd a variable.\n\nCell.create(db, cell_type, cell_name)\n\nCreate a cell.\n\nCell.create_value(val)\n\nCreate a value instance.\n\nCell.cutout(included_nets, clipped_nets, ...)\n\nCut out an existing cell into a new cell.\n\nCell.delete()\n\nDelete the cell.\n\nCell.delete_simulation_setup(name)\n\nDelete a simulation setup by name.\n\nCell.delete_variable(name)\n\nDelete a variable.\n\nCell.find(database, cell_type[, name, cell_id])\n\nFind a cell in a database by either name or ID.\n\nCell.generate_auto_hfss_regions()\n\nGenerate auto HFSS regions.\n\nCell.generate_via_smart_box(net_name)\n\nGenerate a via smart box.\n\nCell.get_all_variable_names()\n\nGet all variable names.\n\nCell.get_product_property(prod_id, attr_id)\n\nGet the product-specific property of the cell.\n\nCell.get_product_property_ids(prod_id)\n\nGet a list of attribute IDS for a given product ID for the cell.\n\nCell.get_variable_desc(name)\n\nGet the description of a variable.\n\nCell.get_variable_value(name)\n\nGet the value for a given variable.\n\nCell.is_parameter(name)\n\nDetermine if the variable is a parameter.\n\nCell.set_hfss_extent_info(extents)\n\nSet the HFSS extents of this cell.\n\nCell.set_product_property(prod_id, attr_id, ...)\n\nSet the product property of the cell for a given product ID and attribute ID.\n\nCell.set_variable_desc(name, desc)\n\nSet a variable to have a new description.\n\nCell.set_variable_value(name, new_value)\n\nSet a variable to a new value.\n\n\n\nAttributes\n\n\n\n\n\n\n\nCell.layout_obj_type\n\n\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.set_sim_setup_info",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.set_sim_setup_info.html#set_sim_setup_info",
        "title": "set_sim_setup_info",
        "section": "set_sim_setup_info",
        "text": "set_sim_setup_info"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.set_sim_setup_info",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.set_sim_setup_info.html#pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.set_sim_setup_info",
        "title": "set_sim_setup_info > set_sim_setup_info > set_sim_setup_info",
        "section": "set_sim_setup_info > set_sim_setup_info",
        "text": "RaptorXSimulationSetup.set_sim_setup_info(sim_setup_info)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.set_product_property.html#pyedb.grpc.database.terminal.terminal.Terminal.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "Terminal.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileMaterial",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileMaterial.html#controlfilematerial",
        "title": "ControlFileMaterial",
        "section": "ControlFileMaterial",
        "text": "Represents a material in the control file.\nMaterial name.\nMaterial properties dictionary.\nControlFileMaterial\npython:str\npython:dict"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileMaterial",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileMaterial.html#pyedb.grpc.database.control_file.ControlFileMaterial",
        "title": "ControlFileMaterial > ControlFileMaterial > ControlFileMaterial",
        "section": "ControlFileMaterial > ControlFileMaterial",
        "text": "class pyedb.grpc.database.control_file.ControlFileMaterial(name: str, properties: Dict[str, Any])\n\nRepresents a material in the control file.\n\nParameters\n\nname\n\npython:str\n\nMaterial name.\n\nproperties\n\npython:dict\n\nMaterial properties dictionary.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the primitive object to the correct concrete type.\ncast\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.cast.html#pyedb.grpc.database.primitive.polygon.Polygon.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "Polygon.cast() -> Primitive | None\n\nCast the primitive object to the correct concrete type.\n\nReturns\n\nPrimitive\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_settings.RaptorXSimulationSettings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_settings.RaptorXSimulationSettings.html#raptorxsimulationsettings",
        "title": "RaptorXSimulationSettings",
        "section": "RaptorXSimulationSettings",
        "text": "Raptor X simulation settings class.\nRaptorXSimulationSettings"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_settings.RaptorXSimulationSettings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_settings.RaptorXSimulationSettings.html#pyedb.grpc.database.simulation_setup.raptor_x_simulation_settings.RaptorXSimulationSettings",
        "title": "RaptorXSimulationSettings > RaptorXSimulationSettings > RaptorXSimulationSettings",
        "section": "RaptorXSimulationSettings > RaptorXSimulationSettings",
        "text": "class pyedb.grpc.database.simulation_setup.raptor_x_simulation_settings.RaptorXSimulationSettings(pedb, edb_object)\n\nRaptor X simulation settings class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.find_by_id.html#find_by_id",
        "title": "find_by_id",
        "section": "find_by_id",
        "text": "Find a Connectable object by database ID in a given layout.\nLayout to search for the Connectable object.\nDatabase ID.\nConnectable object with the given database ID.\nfind_by_id\nLayout\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.find_by_id.html#pyedb.grpc.database.ports.ports.CircuitPort.find_by_id",
        "title": "find_by_id > find_by_id > find_by_id",
        "section": "find_by_id > find_by_id",
        "text": "classmethod CircuitPort.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the Connectable object.\n\nuid\n\npython:int\n\nDatabase ID.\n\nReturns\n\nConnectable\n\nConnectable object with the given database ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_layout_file",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_layout_file.html#import_layout_file",
        "title": "import_layout_file",
        "section": "import_layout_file",
        "text": "Import a board file and generate an edb.def file in the working directory.\nThis function supports all AEDT formats, including DXF, GDS, SML (IPC2581), BRD, MCM, SIP, ZIP and TGZ.\nDo not execute this function with untrusted function argument, environment\nvariables or pyedb global settings.\nSee the security guide for details.\nFull path to the board file.\nDirectory in which to create the aedb folder. The name given to the AEDB file\nis the same as the name of the board file.\nFull path to the Ansys translator. The default is \"\".\nWhether to use the PPE License. The default is False.\nPath to the XML file. The default is None, in which case an attempt is made to find\nthe XML file in the same directory as the board file. To succeed, the XML file and board file\nmust have the same name. Only the extension differs.\nTechnology file. The file can be *.ircx, *.vlc.tech, or *.itf\nLayer map .map file.\nLayer filter .txt file.\nimport_layout_file\nedb.def\npython:str\npython:str\noptional\naedb\npython:str\noptional\n\"\"\nFalse\npython:str\noptional\nNone\npython:str\noptional\npython:str\noptional\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_layout_file",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_layout_file.html#pyedb.grpc.edb.Edb.import_layout_file",
        "title": "import_layout_file > import_layout_file > import_layout_file",
        "section": "import_layout_file > import_layout_file",
        "text": "Edb.import_layout_file(input_file, working_dir='', anstranslator_full_path='', use_ppe=False, control_file=None, map_file=None, tech_file=None, layer_filter=None)\n\nImport a board file and generate an edb.def file in the working directory.\n\nThis function supports all AEDT formats, including DXF, GDS, SML (IPC2581), BRD, MCM, SIP, ZIP and TGZ.\n\nDo not execute this function with untrusted function argument, environment\nvariables or pyedb global settings.\nSee the security guide for details.\n\nParameters\n\ninput_file\n\npython:str\n\nFull path to the board file.\n\nworking_dir\n\npython:str, optional\n\nDirectory in which to create the aedb folder. The name given to the AEDB file\nis the same as the name of the board file.\n\nanstranslator_full_path\n\npython:str, optional\n\nFull path to the Ansys translator. The default is \"\".\n\nuse_ppe\n\nbool\n\nWhether to use the PPE License. The default is False.\n\ncontrol_file\n\npython:str, optional\n\nPath to the XML file. The default is None, in which case an attempt is made to find\nthe XML file in the same directory as the board file. To succeed, the XML file and board file\nmust have the same name. Only the extension differs.\n\ntech_file\n\npython:str, optional\n\nTechnology file. The file can be *.ircx, *.vlc.tech, or *.itf\n\nmap_file\n\npython:str, optional\n\nLayer map .map file.\n\nlayer_filter:str,optional\n\nLayer filter .txt file.\n\nReturns\n\nFull path to the AEDB file\n\npython:str\n\n\n\nExamples\n\n>>> # Import a BRD file:\n>>> edb.import_layout_file(\"my_board.brd\", r\"C:/project\")\n>>> # Import a GDS file with control file:\n>>> edb.import_layout_file(\"layout.gds\", control_file=\"control.xml\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.set_product_property.html#pyedb.grpc.database.primitive.primitive.Primitive.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "Primitive.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlExtent",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlExtent.html#controlextent",
        "title": "ControlExtent",
        "section": "ControlExtent",
        "text": "Extent options.\nControlExtent"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlExtent",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlExtent.html#pyedb.dotnet.database.edb_data.control_file.ControlExtent",
        "title": "ControlExtent > ControlExtent > ControlExtent",
        "section": "ControlExtent > ControlExtent",
        "text": "class pyedb.dotnet.database.edb_data.control_file.ControlExtent(type='bbox', dieltype='bbox', diel_hactor=0.25, airbox_hfactor=0.25, airbox_vr_p=0.25, airbox_vr_n=0.25, useradiation=True, honor_primitives=True, truncate_at_gnd=True)\n\nExtent options.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete polygon from layout.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.delete.html#pyedb.grpc.database.primitive.polygon.Polygon.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "Polygon.delete()\n\nDelete polygon from layout.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_back_drill_by_layer",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_back_drill_by_layer.html#get_back_drill_by_layer",
        "title": "get_back_drill_by_layer",
        "section": "get_back_drill_by_layer",
        "text": "get_back_drill_by_layer"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_back_drill_by_layer",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_back_drill_by_layer.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_back_drill_by_layer",
        "title": "get_back_drill_by_layer > get_back_drill_by_layer > get_back_drill_by_layer",
        "section": "get_back_drill_by_layer > get_back_drill_by_layer",
        "text": "EDBPadstackInstance.get_back_drill_by_layer()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_closest_point",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_closest_point.html#get_closest_point",
        "title": "get_closest_point",
        "section": "get_closest_point",
        "text": "Get the closest point of the primitive to the input data.\n[x, y].\nget_closest_point\npython:list\nof\npython:float\nPointData\nList\npython:float\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_closest_point",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_closest_point.html#pyedb.grpc.database.primitive.polygon.Polygon.get_closest_point",
        "title": "get_closest_point > get_closest_point > get_closest_point",
        "section": "get_closest_point > get_closest_point",
        "text": "Polygon.get_closest_point(point) -> list[float]\n\nGet the closest point of the primitive to the input data.\n\nParameters\n\npoint\n\npython:list of python:float or PointData\n\n\n\nReturns\n\nList[python:float, python:float]\n\n[x, y].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.json.html#json",
        "title": "json",
        "section": "json",
        "text": "json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.json.html#pyedb.workflows.drc.drc.Rules.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "Rules.json(*, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -> str\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_statistics",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_statistics.html#get_statistics",
        "title": "get_statistics",
        "section": "get_statistics",
        "text": "Get the EDBStatistics object.\nget_statistics\nEDBStatistics\nobject\nfrom\nthe\nloaded"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_statistics",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_statistics.html#pyedb.dotnet.edb.Edb.get_statistics",
        "title": "get_statistics > get_statistics > get_statistics",
        "section": "get_statistics > get_statistics",
        "text": "Edb.get_statistics(compute_area=False)\n\nGet the EDBStatistics object.\n\nReturns\n\nEDBStatistics object from the loaded layout.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.dc_conductivity",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.dc_conductivity.html#dc_conductivity",
        "title": "dc_conductivity",
        "section": "dc_conductivity",
        "text": "dc_conductivity"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.dc_conductivity",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.dc_conductivity.html#pyedb.grpc.database.definition.materials.MaterialProperties.dc_conductivity",
        "title": "dc_conductivity > dc_conductivity > dc_conductivity",
        "section": "dc_conductivity > dc_conductivity",
        "text": "MaterialProperties.dc_conductivity: Annotated[float, Gt(gt=0)] | None\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.in_voids",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.in_voids.html#in_voids",
        "title": "in_voids",
        "section": "in_voids",
        "text": "Check if this padstack instance is in any void.\nNet name of the voids to be checked. Default is None.\nLayer name of the voids to be checked. Default is None.\nList of the voids that include this padstack instance.\nin_voids\npython:str\nNone\npython:str\nNone\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.in_voids",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.in_voids.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.in_voids",
        "title": "in_voids > in_voids > in_voids",
        "section": "in_voids > in_voids",
        "text": "EDBPadstackInstance.in_voids(net_name=None, layer_name=None)\n\nCheck if this padstack instance is in any void.\n\nParameters\n\nnet_name\n\npython:str\n\nNet name of the voids to be checked. Default is None.\n\nlayer_name\n\npython:str\n\nLayer name of the voids to be checked. Default is None.\n\nReturns\n\npython:list\n\nList of the voids that include this padstack instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_validate_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data: The JSON data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nThe validated Pydantic model.\nValidationError: If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_validate_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_validate_json.html#pyedb.workflows.drc.drc.MinLineWidth.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod MinLineWidth.model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n\njson_data: The JSON data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nReturns:\n\nThe validated Pydantic model.\n\nRaises:\n\nValidationError: If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_circuit_port_on_net",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_circuit_port_on_net.html#create_circuit_port_on_net",
        "title": "create_circuit_port_on_net",
        "section": "create_circuit_port_on_net",
        "text": "Create a circuit port on a NET.\nIt groups all pins belonging to the specified net and then applies the port on PinGroups.\nName of the positive component.\nName of the positive net.\nName of the negative component. The default is None, in which case the name of\nthe positive net is assigned.\nName of the negative net name. The default is None which will look for GND Nets.\nPort impedance value. The default is 50.\nName of the port. The default is \"\".\nThe name of the port.\ncreate_circuit_port_on_net\npython:str\npython:str\npython:str\noptional\nNone\npython:str\noptional\nNone\npython:float\noptional\n50\npython:str\noptional\n\"\"\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_circuit_port_on_net",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_circuit_port_on_net.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_circuit_port_on_net",
        "title": "create_circuit_port_on_net > create_circuit_port_on_net > create_circuit_port_on_net",
        "section": "create_circuit_port_on_net > create_circuit_port_on_net",
        "text": "SourceExcitation.create_circuit_port_on_net(positive_component_name: str, positive_net_name: str, negative_component_name: str, negative_net_name: str | None = None, impedance_value: int | float = 50, port_name: str | None = None) -> str | None\n\nCreate a circuit port on a NET.\n\nIt groups all pins belonging to the specified net and then applies the port on PinGroups.\n\nParameters\n\npositive_component_name\n\npython:str\n\nName of the positive component.\n\npositive_net_name\n\npython:str\n\nName of the positive net.\n\nnegative_component_name\n\npython:str, optional\n\nName of the negative component. The default is None, in which case the name of\nthe positive net is assigned.\n\nnegative_net_name\n\npython:str, optional\n\nName of the negative net name. The default is None which will look for GND Nets.\n\nimpedance_value\n\npython:float, optional\n\nPort impedance value. The default is 50.\n\nport_name\n\npython:str, optional\n\nName of the port. The default is \"\".\n\nReturns\n\npython:str\n\nThe name of the port.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> edb.source_excitation.create_circuit_port_on_net(\"U1\", \"VCC\", \"U1\", \"GND\", 50, \"PowerPort\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.html#material",
        "title": "Material",
        "section": "Material",
        "text": "Manage EDB methods for material property management.\nMaterial.create(database, name, **kwargs)\nCreate a material definition in a given database.\nMaterial.delete()\nDelete the material definition.\nMaterial.find_by_name(database, name)\nFind a material definition by name in a given database.\nMaterial.get_anisotropic_thermal_modifier(...)\nGet the thermal modifier of an anisotropic material property.\nMaterial.get_dimensions(material_property_id)\nGet the dimensions of the tensor of a material property.\nMaterial.get_property(material_property[, ...])\nGet a material property value.\nMaterial.get_thermal_modifier(...)\nGet the thermal modifier of a material property.\nMaterial.remove_property(material_property)\nRemove a property from the material definition.\nMaterial.set_anisotropic_thermal_modifier(...)\nSet the thermal modifier of an anisotropic material property.\nMaterial.set_debye_model()\nSet Debye model on current material.\nMaterial.set_djordjecvic_sarkar_model()\nSet Djordjecvic-Sarkar model on current material.\nMaterial.set_multipole_debye_model()\nSet multi-pole debeye model on current material.\nMaterial.set_property(material_property, value)\nSet a material property value.\nMaterial.set_thermal_modifier(...)\nSet the thermal modifier of the material property.\nMaterial.to_dict()\nConvert material into dictionary.\nMaterial.update(input_dict)\n\nMaterial\nMaterial.create\nMaterial.delete\nMaterial.find_by_name\nMaterial.get_anisotropic_thermal_modifier\nMaterial.get_dimensions\nMaterial.get_property\nMaterial.get_thermal_modifier\nMaterial.remove_property\nMaterial.set_anisotropic_thermal_modifier\nMaterial.set_debye_model\nMaterial.set_djordjecvic_sarkar_model\nMaterial.set_multipole_debye_model\nMaterial.set_property\nMaterial.set_thermal_modifier\nMaterial.to_dict\nMaterial.update"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.html#pyedb.grpc.database.definition.materials.Material",
        "title": "Material > Material > Material",
        "section": "Material > Material",
        "text": "class pyedb.grpc.database.definition.materials.Material(edb: Edb, edb_material_def)\n\nManage EDB methods for material property management.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nMaterial.create(database, name, **kwargs)\n\nCreate a material definition in a given database.\n\nMaterial.delete()\n\nDelete the material definition.\n\nMaterial.find_by_name(database, name)\n\nFind a material definition by name in a given database.\n\nMaterial.get_anisotropic_thermal_modifier(...)\n\nGet the thermal modifier of an anisotropic material property.\n\nMaterial.get_dimensions(material_property_id)\n\nGet the dimensions of the tensor of a material property.\n\nMaterial.get_property(material_property[, ...])\n\nGet a material property value.\n\nMaterial.get_thermal_modifier(...)\n\nGet the thermal modifier of a material property.\n\nMaterial.remove_property(material_property)\n\nRemove a property from the material definition.\n\nMaterial.set_anisotropic_thermal_modifier(...)\n\nSet the thermal modifier of an anisotropic material property.\n\nMaterial.set_debye_model()\n\nSet Debye model on current material.\n\nMaterial.set_djordjecvic_sarkar_model()\n\nSet Djordjecvic-Sarkar model on current material.\n\nMaterial.set_multipole_debye_model()\n\nSet multi-pole debeye model on current material.\n\nMaterial.set_property(material_property, value)\n\nSet a material property value.\n\nMaterial.set_thermal_modifier(...)\n\nSet the thermal modifier of the material property.\n\nMaterial.to_dict()\n\nConvert material into dictionary.\n\nMaterial.update(input_dict)\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.find_by_name",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.find_by_name.html#find_by_name",
        "title": "find_by_name",
        "section": "find_by_name",
        "text": "Find a layer in the layer collection.\nLayer name.\nfind_by_name\npython:str\nLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.find_by_name",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.find_by_name.html#pyedb.grpc.database.stackup.Stackup.find_by_name",
        "title": "find_by_name > find_by_name > find_by_name",
        "section": "find_by_name > find_by_name",
        "text": "Stackup.find_by_name(layer_name)\n\nFind a layer in the layer collection.\n\nParameters\n\nlayer_name\n\npython:str\n\nLayer name.\n\nReturns\n\nLayer\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property for a given product ID and attribute ID.\nProduct ID.\nAttribute ID.\nProduct property for the given product ID and attribute ID.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.get_product_property.html#pyedb.grpc.database.definition.component_def.ComponentDef.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "ComponentDef.get_product_property(prod_id: ProductIdType, attr_it: int) -> str\n\nGet the product property for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nProduct ID.\n\nattr_it\n\npython:int\n\nAttribute ID.\n\nReturns\n\npython:str\n\nProduct property for the given product ID and attribute ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.copy_zones",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.copy_zones.html#copy_zones",
        "title": "copy_zones",
        "section": "copy_zones",
        "text": "Copy multizone EDB project to one new edb per zone.\nDirectory path where all EDB project are copied, if empty will use the current EDB project.\ncopy_zones\npython:str\npython:dict\npython:str\npython:int\nEDB\nPolygonData\nReturn\na\ndictionary\nwith\nedb\npath\nas\nkey\nand\npython:tuple\nZone\nId\nas\nfirst\nitem\nand\nEDB\npolygon\nData\ndefining\nthe\nregion\nas\nsecond"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.copy_zones",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.copy_zones.html#pyedb.dotnet.edb.Edb.copy_zones",
        "title": "copy_zones > copy_zones > copy_zones",
        "section": "copy_zones > copy_zones",
        "text": "Edb.copy_zones(working_directory=None)\n\nCopy multizone EDB project to one new edb per zone.\n\nParameters\n\nworking_directory\n\npython:str\n\nDirectory path where all EDB project are copied, if empty will use the current EDB project.\n\nReturns\n\npython:dict[python:str](python:int, EDB PolygonData)\n\n\n\nReturn a dictionary with edb path as key and python:tuple Zone Id as first item and EDB polygon Data defining\n\n\n\nthe region as second item.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.mesh_operation.MeshOperation",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.mesh_operation.MeshOperation.html#meshoperation",
        "title": "MeshOperation",
        "section": "MeshOperation",
        "text": "Mesh operation class.\nMeshOperation"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.mesh_operation.MeshOperation",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.mesh_operation.MeshOperation.html#pyedb.grpc.database.simulation_setup.mesh_operation.MeshOperation",
        "title": "MeshOperation > MeshOperation > MeshOperation",
        "section": "MeshOperation > MeshOperation",
        "text": "class pyedb.grpc.database.simulation_setup.mesh_operation.MeshOperation(pedb, edb_object)\n\nMesh operation class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the terminal object to the correct concrete type, fetching the type if necessary.\ncast\nTerminalType\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.cast.html#pyedb.grpc.database.terminal.point_terminal.PointTerminal.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "PointTerminal.cast(term_type=None)\n\nCast the terminal object to the correct concrete type, fetching the type if necessary.\n\nParameters\n\nterm_type\n\nTerminalType\n\n\n\nReturns\n\nTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_cw",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_cw.html#is_cw",
        "title": "is_cw",
        "section": "is_cw",
        "text": "Determine if the arc rotates clockwise.\nThis method is the same as the is_left method.\nTrue when the arc rotates clockwise, False otherwise.\nis_cw\nis_left\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_cw",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_cw.html#pyedb.grpc.database.geometry.arc_data.ArcData.is_cw",
        "title": "is_cw > is_cw > is_cw",
        "section": "is_cw > is_cw",
        "text": "ArcData.is_cw() -> bool\n\nDetermine if the arc rotates clockwise.\n\nThis method is the same as the is_left method.\n\nReturns\n\nbool\n\nTrue when the arc rotates clockwise, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_product_property.html#pyedb.grpc.database.terminal.terminal.Terminal.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "Terminal.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.place_in_layout_3d_placement",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.place_in_layout_3d_placement.html#place_in_layout_3d_placement",
        "title": "place_in_layout_3d_placement",
        "section": "place_in_layout_3d_placement",
        "text": "Place current cell into another cell using 3D placement method.\nFlip the current layer stackup of a layout if requested.\nTarget Edb object.\nRotation angle in degrees. The default is 0.0.\nX offset value. The default is 0.0.\nY offset value. The default is 0.0.\nWhether to flip the current layout. The default is True.\nWhether to place the current layout on top of the destination layout. The default is True.\nSolder ball or bumps height. This value will be added to the elevation to align the two layouts.\nTrue when successful.\nplace_in_layout_3d_placement\npyedb.Edb\npython:float\noptional\n0.0\npython:float\noptional\n0.0\npython:float\noptional\n0.0\noptional\nTrue\noptional\nTrue\npython:float\noptional\nTrue"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.place_in_layout_3d_placement",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.place_in_layout_3d_placement.html#pyedb.grpc.database.stackup.Stackup.place_in_layout_3d_placement",
        "title": "place_in_layout_3d_placement > place_in_layout_3d_placement > place_in_layout_3d_placement",
        "section": "place_in_layout_3d_placement > place_in_layout_3d_placement",
        "text": "Stackup.place_in_layout_3d_placement(edb: Edb, angle: float = 0.0, offset_x: float = 0.0, offset_y: float = 0.0, flipped_stackup: bool = True, place_on_top: bool = True, solder_height: float = 0) -> bool\n\nPlace current cell into another cell using 3D placement method.\n\nFlip the current layer stackup of a layout if requested.\n\nParameters\n\nedb\n\npyedb.Edb\n\nTarget Edb object.\n\nangle\n\npython:float, optional\n\nRotation angle in degrees. The default is 0.0.\n\noffset_x\n\npython:float, optional\n\nX offset value. The default is 0.0.\n\noffset_y\n\npython:float, optional\n\nY offset value. The default is 0.0.\n\nflipped_stackup\n\nbool, optional\n\nWhether to flip the current layout. The default is True.\n\nplace_on_top\n\nbool, optional\n\nWhether to place the current layout on top of the destination layout. The default is True.\n\nsolder_height\n\npython:float, optional\n\nSolder ball or bumps height. This value will be added to the elevation to align the two layouts.\n\nReturns\n\nbool\n\nTrue when successful.\n\nExamples\n\n>>> edb1 = Edb(edbpath=targetfile1, edbversion=\"2021.2\")\n>>> edb2 = Edb(edbpath=targetfile2, edbversion=\"2021.2\")\n>>> hosting_cmp = edb1.components.get_component_by_name(\"U100\")\n>>> mounted_cmp = edb2.components.get_component_by_name(\"BGA\")\n>>> edb2.stackup.place_in_layout(\n...     edb1.active_cell,\n...     angle=0.0,\n...     offset_x=\"1mm\",\n...     offset_y=\"2mm\",\n...     flipped_stackup=False,\n...     place_on_top=True,\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/circle",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/circle.html#circle",
        "title": "Circle",
        "section": "Circle",
        "text": "This class is managing EDB circle.\nCircle\n\nCircle\nCircle"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.create_3d_comp.html#create_3d_comp",
        "title": "create_3d_comp",
        "section": "create_3d_comp",
        "text": "Create a 3D composite model from an MCAD file.\n3D composite model created.\ncreate_3d_comp\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.create_3d_comp.html#pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.create_3d_comp",
        "title": "create_3d_comp > create_3d_comp > create_3d_comp",
        "section": "create_3d_comp > create_3d_comp",
        "text": "PadstackInstanceTerminal.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nReturns\n\nMcadModel\n\n3D composite model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.AdaptiveSettings.add_multi_frequency_adaptive_setup",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.AdaptiveSettings.add_multi_frequency_adaptive_setup.html#add_multi_frequency_adaptive_setup",
        "title": "add_multi_frequency_adaptive_setup",
        "section": "add_multi_frequency_adaptive_setup",
        "text": "Add a setup for frequency data.\nFrequency with units or float frequency (in Hz).\nFrequency with units or float frequency (in Hz).\nMaximum number of passes. The default is 10.\nMaximum delta S. The default is 0.02.\nTrue if method is successful, False otherwise.\nadd_multi_frequency_adaptive_setup\npython:str\npython:float\npython:str\npython:float\npython:int\noptional\n10\npython:float\noptional\n0.02\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.AdaptiveSettings.add_multi_frequency_adaptive_setup",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.AdaptiveSettings.add_multi_frequency_adaptive_setup.html#pyedb.dotnet.database.sim_setup_data.data.settings.AdaptiveSettings.add_multi_frequency_adaptive_setup",
        "title": "add_multi_frequency_adaptive_setup > add_multi_frequency_adaptive_setup > add_multi_frequency_adaptive_setup",
        "section": "add_multi_frequency_adaptive_setup > add_multi_frequency_adaptive_setup",
        "text": "AdaptiveSettings.add_multi_frequency_adaptive_setup(freq_list, max_num_passes=10, max_delta_s=0.02)\n\nAdd a setup for frequency data.\n\nParameters\n\nlow_frequency\n\npython:str, python:float\n\nFrequency with units or float frequency (in Hz).\n\nhigh_frequency\n\npython:str, python:float\n\nFrequency with units or float frequency (in Hz).\n\nmax_num_passes\n\npython:int, optional\n\nMaximum number of passes. The default is 10.\n\nmax_delta_s\n\npython:float, optional\n\nMaximum delta S. The default is 0.02.\n\nReturns\n\nbool\n\nTrue if method is successful, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/siwave_simulation_setup",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/siwave_simulation_setup.html#siwave-simulation-setup",
        "title": "Siwave simulation setup",
        "section": "Siwave simulation setup",
        "text": "This class is managing EDB siwave simulation setup.\nSiwaveSimulationSetup\nSIwave simulation setup class.\nSiwave simulation setup\nSiwaveSimulationSetup"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_component_net_connection_info",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_component_net_connection_info.html#get_component_net_connection_info",
        "title": "get_component_net_connection_info",
        "section": "get_component_net_connection_info",
        "text": "Get net connection info for a component.\nReference designator.\nDictionary with refdes, pin_name, and net_name.\nget_component_net_connection_info\npython:str\npython:dict"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_component_net_connection_info",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_component_net_connection_info.html#pyedb.grpc.database.components.Components.get_component_net_connection_info",
        "title": "get_component_net_connection_info > get_component_net_connection_info > get_component_net_connection_info",
        "section": "get_component_net_connection_info > get_component_net_connection_info",
        "text": "Components.get_component_net_connection_info(refdes: str) -> Dict[str, List[str]]\n\nGet net connection info for a component.\n\nParameters\n\nrefdes\n\npython:str\n\nReference designator.\n\nReturns\n\npython:dict\n\nDictionary with refdes, pin_name, and net_name.\n\nExamples\n\n>>> info = edbapp.components.get_component_net_connection_info(\"U1\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/models.md#model-copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nbefore creating the new model. You should trust this data.\ndeep: Set to True to make a deep copy of the model.\nNew model instance.\nmodel_copy"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_copy.html#pyedb.workflows.drc.drc.Rules.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "Rules.model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -> Self\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/models.md#model-copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nArgs:\n\nupdate: Values to change/add in the new model. Note: the data is not validated\n\nbefore creating the new model. You should trust this data.\n\ndeep: Set to True to make a deep copy of the model.\n\nReturns:\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.assign_spice_model",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.assign_spice_model.html#assign_spice_model",
        "title": "assign_spice_model",
        "section": "assign_spice_model",
        "text": "Assign Spice model to this component.\nFile path of the Spice model.\nName of the Spice model.\nSpice model.\nassign_spice_model\npython:str\npython:str\noptional\nSpiceModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.assign_spice_model",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.assign_spice_model.html#pyedb.grpc.database.hierarchy.component.Component.assign_spice_model",
        "title": "assign_spice_model > assign_spice_model > assign_spice_model",
        "section": "assign_spice_model > assign_spice_model",
        "text": "Component.assign_spice_model(file_path: str, name: str | None = None, sub_circuit_name: str | None = None, terminal_pairs: list | None = None) -> SpiceModel\n\nAssign Spice model to this component.\n\nParameters\n\nfile_path\n\npython:str\n\nFile path of the Spice model.\n\nname\n\npython:str, optional\n\nName of the Spice model.\n\nReturns\n\nSpiceModel\n\nSpice model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.add_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.add_sweep.html#add_sweep",
        "title": "add_sweep",
        "section": "add_sweep",
        "text": "Add frequency sweep.\nName of the frequency sweep. The default is None.\nAdded for grpc compatibility.\nAdded for rpc compatibility.\nAdded for grpc compatibility.\nAdded for grpc compatibility.\nList of frequency points. The default is None.\nSweep type. The default is \"interpolation\". Options are \"discrete\",”discrete”``.\nadd_sweep\npython:str\noptional\nNone\npython:str\noptional\npython:str\noptional\npython:str\noptional\noptional\npython:list\noptional\nNone\npython:str\noptional\n\"interpolation\"\n\"discrete\""
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.add_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.add_sweep.html#pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.add_sweep",
        "title": "add_sweep > add_sweep > add_sweep",
        "section": "add_sweep > add_sweep",
        "text": "SiwaveDCSimulationSetup.add_sweep(name: str | None = None, distribution: str | None = None, start_freq: str | None = None, stop_freq: str | None = None, step=None, frequency_set: list | None = None, sweep_type: str = 'interpolation', **kwargs)\n\nAdd frequency sweep.\n\nParameters\n\nname\n\npython:str, optional\n\nName of the frequency sweep. The default is None.\n\ndistribution\n\npython:str, optional\n\nAdded for grpc compatibility.\n\nstart_freq\n\npython:str, optional\n\nAdded for rpc compatibility.\n\nstop_freq\n\npython:str, optional\n\nAdded for grpc compatibility.\n\nstep\n\noptional\n\nAdded for grpc compatibility.\n\nfrequency_set\n\npython:list, optional\n\nList of frequency points. The default is None.\n\nsweep_type\n\npython:str, optional\n\nSweep type. The default is \"interpolation\". Options are \"discrete\",”discrete”``.\n\nReturns\n\n\n\n——-\n\n\n\nExamples\n\n>>> setup1 = edbapp.create_siwave_syz_setup(\"setup1\")\n>>> setup1.add_sweep(name=\"sw1\", frequency_set=[\"linear count\", \"1MHz\", \"100MHz\", 10])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.create_stride.html#create_stride",
        "title": "create_stride",
        "section": "create_stride",
        "text": "Create a Stride model from an MCAD file.\nStride model created.\ncreate_stride\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.create_stride.html#pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.create_stride",
        "title": "create_stride > create_stride > create_stride",
        "section": "create_stride > create_stride",
        "text": "PinGroupTerminal.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nReturns\n\nMcadModel\n\nStride model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_point_terminal",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_point_terminal.html#get_point_terminal",
        "title": "get_point_terminal",
        "section": "get_point_terminal",
        "text": "Place terminal between two points.\nUse: func:get_point_terminal has been moved to edb.source_excitation.get_point_terminal.\nget_point_terminal"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_point_terminal",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_point_terminal.html#pyedb.grpc.edb.Edb.get_point_terminal",
        "title": "get_point_terminal > get_point_terminal > get_point_terminal",
        "section": "get_point_terminal > get_point_terminal",
        "text": "Edb.get_point_terminal(name, net_name, location, layer)\n\nPlace terminal between two points.\n\n..deprecated:: 0.50.0\n\nUse: func:get_point_terminal has been moved to edb.source_excitation.get_point_terminal.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.html#edbpadstackinstance",
        "title": "EDBPadstackInstance",
        "section": "EDBPadstackInstance",
        "text": "Manages EDB functionalities for a padstack.\nInherited AEDT object.\nEDBPadstackInstance.convert_hole_to_conical_shape([angle])\nConvert actual padstack instance to microvias 3D Objects with a given aspect ratio.\nEDBPadstackInstance.create_coax_port([name, ...])\nCreate a coax port.\nEDBPadstackInstance.create_port([name, ...])\nCreate a port on the padstack.\nEDBPadstackInstance.create_rectangle_in_pad(...)\nCreate a rectangle inscribed inside a padstack instance pad.\nEDBPadstackInstance.create_terminal([name])\nCreate a padstack instance terminal\nEDBPadstackInstance.delete()\nDelete this primitive.\nEDBPadstackInstance.get_back_drill_by_layer()\n\nEDBPadstackInstance.get_connected_object_id_set()\nProduce a list of all geometries physically connected to a given layout object.\nEDBPadstackInstance.get_connected_objects()\nGet connected objects.\nEDBPadstackInstance.get_reference_pins([...])\nSearch for reference pins using given criteria.\nEDBPadstackInstance.get_terminal([name, ...])\nGet PadstackInstanceTerminal object.\nEDBPadstackInstance.in_polygon(polygon_data)\nCheck if padstack Instance is in given polygon data.\nEDBPadstackInstance.in_voids([net_name, ...])\nCheck if this padstack instance is in any void.\nEDBPadstackInstance.parametrize_position([...])\nParametrize the instance position.\nEDBPadstackInstance.set_back_drill_by_layer(...)\nMethod added to bring compatibility with grpc.\nEDBPadstackInstance.set_backdrill_bottom(...)\nSet backdrill from bottom.\nEDBPadstackInstance.set_backdrill_top(...[, ...])\nSet backdrill from top.\nEDBPadstackInstance.split()\nSplit padstack instance into multiple instances.\nEDBPadstackInstance\nEDBPadstackInstance.convert_hole_to_conical_shape\nEDBPadstackInstance.create_coax_port\nEDBPadstackInstance.create_port\nEDBPadstackInstance.create_rectangle_in_pad\nEDBPadstackInstance.create_terminal\nEDBPadstackInstance.delete\nEDBPadstackInstance.get_back_drill_by_layer\nEDBPadstackInstance.get_connected_object_id_set\nEDBPadstackInstance.get_connected_objects\nEDBPadstackInstance.get_reference_pins\nEDBPadstackInstance.get_terminal\nEDBPadstackInstance.in_polygon\nEDBPadstackInstance.in_voids\nEDBPadstackInstance.parametrize_position\nEDBPadstackInstance.set_back_drill_by_layer\nEDBPadstackInstance.set_backdrill_bottom\nEDBPadstackInstance.set_backdrill_top\nEDBPadstackInstance.split"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance",
        "title": "EDBPadstackInstance > EDBPadstackInstance > EDBPadstackInstance",
        "section": "EDBPadstackInstance > EDBPadstackInstance",
        "text": "class pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance(edb_padstackinstance, _pedb)\n\nManages EDB functionalities for a padstack.\n\nParameters\n\nedb_padstackinstance\n\n\n\n_pedb\n\nInherited AEDT object.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb(myedb, edbversion=\"2021.2\")\n>>> edb_padstack_instance = edb.padstacks.instances[0]\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nEDBPadstackInstance.convert_hole_to_conical_shape([angle])\n\nConvert actual padstack instance to microvias 3D Objects with a given aspect ratio.\n\nEDBPadstackInstance.create_coax_port([name, ...])\n\nCreate a coax port.\n\nEDBPadstackInstance.create_port([name, ...])\n\nCreate a port on the padstack.\n\nEDBPadstackInstance.create_rectangle_in_pad(...)\n\nCreate a rectangle inscribed inside a padstack instance pad.\n\nEDBPadstackInstance.create_terminal([name])\n\nCreate a padstack instance terminal\n\nEDBPadstackInstance.delete()\n\nDelete this primitive.\n\nEDBPadstackInstance.get_back_drill_by_layer()\n\n\n\nEDBPadstackInstance.get_connected_object_id_set()\n\nProduce a list of all geometries physically connected to a given layout object.\n\nEDBPadstackInstance.get_connected_objects()\n\nGet connected objects.\n\nEDBPadstackInstance.get_reference_pins([...])\n\nSearch for reference pins using given criteria.\n\nEDBPadstackInstance.get_terminal([name, ...])\n\nGet PadstackInstanceTerminal object.\n\nEDBPadstackInstance.in_polygon(polygon_data)\n\nCheck if padstack Instance is in given polygon data.\n\nEDBPadstackInstance.in_voids([net_name, ...])\n\nCheck if this padstack instance is in any void.\n\nEDBPadstackInstance.parametrize_position([...])\n\nParametrize the instance position.\n\nEDBPadstackInstance.set_back_drill_by_layer(...)\n\nMethod added to bring compatibility with grpc.\n\nEDBPadstackInstance.set_backdrill_bottom(...)\n\nSet backdrill from bottom.\n\nEDBPadstackInstance.set_backdrill_top(...[, ...])\n\nSet backdrill from top.\n\nEDBPadstackInstance.split()\n\nSplit padstack instance into multiple instances.\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_wave_port",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_wave_port.html#create_wave_port",
        "title": "create_wave_port",
        "section": "create_wave_port",
        "text": "Create a wave port.\nPrimitive ID.\nCoordinate of the point to define the edge terminal.\nThe point must be on the target edge but not on the two\nends of the edge.\nName of the port. The default is None.\nImpedance of the port. The default value is 50.\nHorizontal extent factor. The default value is 5.\nVertical extent factor. The default value is 3.\nLaunch Width of PEC. The default value is \"0.01mm\".\nThe tuple contains: (Port name, pyedb.dotnet.database.edb_data.sources.Excitation).\ncreate_wave_port\npython:int\nPrimitive\npython:list\npython:str\noptional\nNone\npython:int\npython:float\noptional\n50\npython:int\npython:float\noptional\n5\npython:int\npython:float\noptional\n3\npython:str\noptional\n\"0.01mm\"\npython:tuple"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_wave_port",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_wave_port.html#pyedb.dotnet.database.hfss.EdbHfss.create_wave_port",
        "title": "create_wave_port > create_wave_port > create_wave_port",
        "section": "create_wave_port > create_wave_port",
        "text": "EdbHfss.create_wave_port(prim_id, point_on_edge, port_name=None, impedance=50, horizontal_extent_factor=5, vertical_extent_factor=3, pec_launch_width='0.01mm')\n\nCreate a wave port.\n\nParameters\n\nprim_id\n\npython:int, Primitive\n\nPrimitive ID.\n\npoint_on_edge\n\npython:list\n\nCoordinate of the point to define the edge terminal.\nThe point must be on the target edge but not on the two\nends of the edge.\n\nport_name\n\npython:str, optional\n\nName of the port. The default is None.\n\nimpedance\n\npython:int, python:float, optional\n\nImpedance of the port. The default value is 50.\n\nhorizontal_extent_factor\n\npython:int, python:float, optional\n\nHorizontal extent factor. The default value is 5.\n\nvertical_extent_factor\n\npython:int, python:float, optional\n\nVertical extent factor. The default value is 3.\n\npec_launch_width\n\npython:str, optional\n\nLaunch Width of PEC. The default value is \"0.01mm\".\n\nReturns\n\npython:tuple\n\nThe tuple contains: (Port name, pyedb.dotnet.database.edb_data.sources.Excitation).\n\nExamples\n\n>>> edb.hfss.create_wave_port(0, [\"-50mm\", \"-0mm\"])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.load_material",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.load_material.html#load_material",
        "title": "load_material",
        "section": "load_material",
        "text": "Load material.\nload_material"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.load_material",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.load_material.html#pyedb.dotnet.database.materials.Materials.load_material",
        "title": "load_material > load_material > load_material",
        "section": "load_material > load_material",
        "text": "Materials.load_material(material: dict)\n\nLoad material.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.html#pinpairmodel",
        "title": "PinPairModel",
        "section": "PinPairModel",
        "text": "Manage pin-pair model.\nPinPairModel.clone()\nClone a model.\nPinPairModel.create()\nCreate a pin pair model.\nPinPairModel.delete_rlc(pin_pair)\nDelete the RLC value for a pin pair.\nPinPairModel.pin_pairs()\nGet all pin pairs.\nPinPairModel.set_rlc(pin_pair, rlc)\nSet the RLC value for a pin pair.\nPinPairModel\nPinPairModel.clone\nPinPairModel.create\nPinPairModel.delete_rlc\nPinPairModel.pin_pairs\nPinPairModel.set_rlc"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.html#pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel",
        "title": "PinPairModel > PinPairModel > PinPairModel",
        "section": "PinPairModel > PinPairModel",
        "text": "class pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel(pedb, edb_object)\n\nManage pin-pair model.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nPinPairModel.clone()\n\nClone a model.\n\nPinPairModel.create()\n\nCreate a pin pair model.\n\nPinPairModel.delete_rlc(pin_pair)\n\nDelete the RLC value for a pin pair.\n\nPinPairModel.pin_pairs()\n\nGet all pin pairs.\n\nPinPairModel.set_rlc(pin_pair, rlc)\n\nSet the RLC value for a pin pair.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.remove_member",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.remove_member.html#remove_member",
        "title": "remove_member",
        "section": "remove_member",
        "text": "Remove an object from the group.\nObject to remove from the group.\nremove_member"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.remove_member",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.remove_member.html#pyedb.grpc.database.hierarchy.component.Component.remove_member",
        "title": "remove_member > remove_member > remove_member",
        "section": "remove_member > remove_member",
        "text": "Component.remove_member(member)\n\nRemove an object from the group.\n\nParameters\n\nmember\n\nConnectable\n\nObject to remove from the group.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.get_product_property.html#pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "VoltageRegulator.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_diff_pair_length_match",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_diff_pair_length_match.html#add_diff_pair_length_match",
        "title": "add_diff_pair_length_match",
        "section": "add_diff_pair_length_match",
        "text": "Append a length-matching rule for differential pairs.\nRule identifier.\nMaximum allowed length difference with unit, e.g. \"0.1mm\".\nList of differential pairs as tuples of\nSelf to enable method chaining.\nadd_diff_pair_length_match\npython:str\npython:str\n\"0.1mm\"\npython:list\npython:tuple\npython:str\npython:str\nRules"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_diff_pair_length_match",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_diff_pair_length_match.html#pyedb.workflows.drc.drc.Rules.add_diff_pair_length_match",
        "title": "add_diff_pair_length_match > add_diff_pair_length_match > add_diff_pair_length_match",
        "section": "add_diff_pair_length_match > add_diff_pair_length_match",
        "text": "Rules.add_diff_pair_length_match(name: str, tolerance: str, pairs: list[tuple[str, str]]) -> Rules\n\nAppend a length-matching rule for differential pairs.\n\nParameters\n\nname\n\npython:str\n\nRule identifier.\n\ntolerance\n\npython:str\n\nMaximum allowed length difference with unit, e.g. \"0.1mm\".\n\npairs\n\npython:list[python:tuple[python:str, python:str]]\n\nList of differential pairs as tuples of\n\nReturns\n\nRules\n\nSelf to enable method chaining.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlExtent",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlExtent.html#controlextent",
        "title": "ControlExtent",
        "section": "ControlExtent",
        "text": "Extent options.\nControlExtent"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlExtent",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlExtent.html#pyedb.grpc.database.utility.xml_control_file.ControlExtent",
        "title": "ControlExtent > ControlExtent > ControlExtent",
        "section": "ControlExtent > ControlExtent",
        "text": "class pyedb.grpc.database.utility.xml_control_file.ControlExtent(type='bbox', dieltype='bbox', diel_hactor=0.25, airbox_hfactor=0.25, airbox_vr_p=0.25, airbox_vr_n=0.25, useradiation=True, honor_primitives=True, truncate_at_gnd=True)\n\nExtent options.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj: The object to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\nfrom_attributes: Whether to extract data from object attributes.\ncontext: Additional context to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nValidationError: If the object could not be validated.\nThe validated model instance.\nmodel_validate"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_validate.html#pyedb.workflows.drc.drc.MinClearance.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod MinClearance.model_validate(obj: Any, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\nValidate a pydantic model instance.\n\nArgs:\n\nobj: The object to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\nfrom_attributes: Whether to extract data from object attributes.\ncontext: Additional context to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nRaises:\n\nValidationError: If the object could not be validated.\n\nReturns:\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_post_init",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nmodel_post_init"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_post_init",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_post_init.html#pyedb.workflows.drc.drc.BackDrillStubLength.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "BackDrillStubLength.model_post_init(context: Any, /) -> None\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.create",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a point terminal.\nLayout to create the point terminal in.\nNet.\nLayer to place the point terminal on.\nName of the point terminal.\nType of the point terminal.\ncreate\nLayout\nNet\nstr\npython:None\nLayer\nstr\nstr\nPointTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.create",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.create.html#pyedb.grpc.database.terminal.point_terminal.PointTerminal.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod PointTerminal.create(layout, net, layer, name, point)\n\nCreate a point terminal.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to create the point terminal in.\n\nnet\n\nNet or str or python:None\n\nNet.\n\nlayer\n\nLayer or str\n\nLayer to place the point terminal on.\n\nname\n\nstr\n\nName of the point terminal.\n\npoint\n\nPoint2DLike\n\nType of the point terminal.\n\nReturns\n\nPointTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSetups.add_setup",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSetups.add_setup.html#add_setup",
        "title": "add_setup",
        "section": "add_setup",
        "text": "Add a new setup\nSetup name.\nSetup Frequency.\nadd_setup\npython:str\npython:str\npyedb.dotnet.database.edb_data.control_file.ControlFileSetup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSetups.add_setup",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSetups.add_setup.html#pyedb.grpc.database.utility.xml_control_file.ControlFileSetups.add_setup",
        "title": "add_setup > add_setup > add_setup",
        "section": "add_setup > add_setup",
        "text": "ControlFileSetups.add_setup(name, frequency)\n\nAdd a new setup\n\nParameters\n\nname\n\npython:str\n\nSetup name.\n\nfrequency\n\npython:str\n\nSetup Frequency.\n\nReturns\n\npyedb.dotnet.database.edb_data.control_file.ControlFileSetup\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.scale",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.scale.html#scale",
        "title": "scale",
        "section": "scale",
        "text": "Uniformly scale all geometry and their locations by a positive factor.\nAmount that coordinates are multiplied by.\nscale\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.scale",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.scale.html#pyedb.grpc.edb.Edb.scale",
        "title": "scale > scale > scale",
        "section": "scale > scale",
        "text": "Edb.scale(scale_factor)\n\nUniformly scale all geometry and their locations by a positive factor.\n\nParameters\n\nscale_factor\n\npython:float\n\nAmount that coordinates are multiplied by.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.delete_frequency_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.delete_frequency_sweep.html#delete_frequency_sweep",
        "title": "delete_frequency_sweep",
        "section": "delete_frequency_sweep",
        "text": "Delete a frequency sweep.\ndelete_frequency_sweep"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.delete_frequency_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.delete_frequency_sweep.html#pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.delete_frequency_sweep",
        "title": "delete_frequency_sweep > delete_frequency_sweep > delete_frequency_sweep",
        "section": "delete_frequency_sweep > delete_frequency_sweep",
        "text": "SiwaveDCSimulationSetup.delete_frequency_sweep(sweep_data)\n\nDelete a frequency sweep.\n\nParameters\n\nsweep_data\n\nEdbFrequencySweep.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.load",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.load.html#load",
        "title": "load",
        "section": "load",
        "text": "Import stackup from a file. The file format can be XML, CSV, or JSON. Valid control file must\nhave the same number of signal layers. Signals layers can be renamed. Dielectric layers can be\nadded and deleted.\nPath to stackup file or dict with stackup details.\nIf rename is False then layer in layout not found in the stackup file are deleted.\nOtherwise, if the number of layer in the stackup file equals the number of stackup layer\nin the layout, layers are renamed according the file.\nNote that layer order matters, and has to be writtent from top to bottom layer in the file.\nTrue when successful, False when failed.\nload\npython:str\npython:dict\nFalse\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.load",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.load.html#pyedb.dotnet.database.stackup.Stackup.load",
        "title": "load > load > load",
        "section": "load > load",
        "text": "Stackup.load(file_path, rename=False)\n\nImport stackup from a file. The file format can be XML, CSV, or JSON. Valid control file must\nhave the same number of signal layers. Signals layers can be renamed. Dielectric layers can be\nadded and deleted.\n\nParameters\n\nfile_path\n\npython:str, python:dict\n\nPath to stackup file or dict with stackup details.\n\nrename\n\nbool\n\nIf rename is False then layer in layout not found in the stackup file are deleted.\nOtherwise, if the number of layer in the stackup file equals the number of stackup layer\nin the layout, layers are renamed according the file.\nNote that layer order matters, and has to be writtent from top to bottom layer in the file.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> edb.stackup.load(\"stackup.xml\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the layer object to the correct concrete type.\ncast\nLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.cast.html#pyedb.grpc.database.layers.stackup_layer.StackupLayer.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "StackupLayer.cast()\n\nCast the layer object to the correct concrete type.\n\nReturns\n\nLayer\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.create_hfss.html#create_hfss",
        "title": "create_hfss",
        "section": "create_hfss",
        "text": "Create an HFSS model from an MCAD file.\nHFSS model created.\ncreate_hfss\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.create_hfss.html#pyedb.grpc.database.ports.ports.GapPort.create_hfss",
        "title": "create_hfss > create_hfss > create_hfss",
        "section": "create_hfss > create_hfss",
        "text": "GapPort.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nReturns\n\nMcadModel\n\nHFSS model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.SpiralInductor.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.SpiralInductor.create.html#create",
        "title": "create",
        "section": "create",
        "text": "create"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.SpiralInductor.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.SpiralInductor.create.html#pyedb.libraries.rf_libraries.base_functions.SpiralInductor.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "SpiralInductor.create() -> bool\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.remove_layer",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.remove_layer.html#remove_layer",
        "title": "remove_layer",
        "section": "remove_layer",
        "text": "Remove a layer from stackup.\nName of the layer to remove.\nremove_layer\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.remove_layer",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.remove_layer.html#pyedb.dotnet.database.stackup.Stackup.remove_layer",
        "title": "remove_layer > remove_layer > remove_layer",
        "section": "remove_layer > remove_layer",
        "text": "Stackup.remove_layer(name)\n\nRemove a layer from stackup.\n\nParameters\n\nname\n\npython:str\n\nName of the layer to remove.\n\nReturns\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.create",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create an edge terminal.\nLayout to create the edge terminal in.\nName of the edge terminal.\nNet reference. The default is None.\nWhether the edge terminal is a reference terminal.\ncreate\nLayout\nstr\npython:list\nof\nEdge\nNet\nstr\npython:None\nNone\nbool\npython:False\nEdgeTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.create",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.create.html#pyedb.grpc.database.ports.ports.WavePort.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod WavePort.create(layout, name, edges, net=None, is_ref=False)\n\nCreate an edge terminal.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to create the edge terminal in.\n\nname\n\nstr\n\nName of the edge terminal.\n\nedges\n\npython:list of Edge\n\n\n\nnet\n\nNet or str or python:None\n\nNet reference. The default is None.\n\nis_ref\n\nbool, default: python:False\n\nWhether the edge terminal is a reference terminal.\n\nReturns\n\nEdgeTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.value",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.value.html#value",
        "title": "value",
        "section": "value",
        "text": "Convert a value into a pyedb value.\nvalue"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.value",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.value.html#pyedb.dotnet.edb.Edb.value",
        "title": "value > value > value",
        "section": "value > value",
        "text": "Edb.value(val)\n\nConvert a value into a pyedb value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.s_parameter_model.SparamModel.create",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.s_parameter_model.SparamModel.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create an S-parameter model.\nName of the S-parameter model.\nName of the reference net.\ncreate\npython:str\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.s_parameter_model.SparamModel.create",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.s_parameter_model.SparamModel.create.html#pyedb.grpc.database.hierarchy.s_parameter_model.SparamModel.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod SparamModel.create(name, ref_net)\n\nCreate an S-parameter model.\n\nParameters\n\nname\n\npython:str\n\nName of the S-parameter model.\n\nref_net\n\npython:str\n\nName of the reference net.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.ungroup",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.ungroup.html#ungroup",
        "title": "ungroup",
        "section": "ungroup",
        "text": "Delete the grouping.\nungroup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.ungroup",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.ungroup.html#pyedb.grpc.database.ports.ports.BundleWavePort.ungroup",
        "title": "ungroup > ungroup > ungroup",
        "section": "ungroup > ungroup",
        "text": "BundleWavePort.ungroup()\n\nDelete the grouping.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.make_zone_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.make_zone_primitive.html#make_zone_primitive",
        "title": "make_zone_primitive",
        "section": "make_zone_primitive",
        "text": "Make the primitive a zone primitive with a zone specified by the provided ID.\nID of the zone primitive to use.\nmake_zone_primitive\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.make_zone_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.make_zone_primitive.html#pyedb.grpc.database.primitive.circle.Circle.make_zone_primitive",
        "title": "make_zone_primitive > make_zone_primitive > make_zone_primitive",
        "section": "make_zone_primitive > make_zone_primitive",
        "text": "Circle.make_zone_primitive(zone_id: int)\n\nMake the primitive a zone primitive with a zone specified by the provided ID.\n\nParameters\n\nzone_id\n\npython:int\n\nID of the zone primitive to use.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.get_product_property_ids.html#pyedb.grpc.database.net.net.Net.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "Net.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the layout object.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.delete.html#pyedb.grpc.database.net.net_class.NetClass.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "NetClass.delete()\n\nDelete the layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.expand",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.expand.html#expand",
        "title": "expand",
        "section": "expand",
        "text": "Expand the polygon shape by an absolute value in all direction.\nOffset can be negative for negative expansion.\nOffset value in meters.\nTolerance in meters.\nWhether to round corners or not.\nIf True, use rounded corners in the expansion otherwise use straight edges (can be degenerate).\nThe maximum corner extension (when round corners are not used) at which point the corner is clipped.\nexpand\npython:float\noptional\npython:float\noptional\noptional\npython:float\noptional"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.expand",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.expand.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.expand",
        "title": "expand > expand > expand",
        "section": "expand > expand",
        "text": "EdbPolygon.expand(offset=0.001, tolerance=1e-12, round_corners=True, maximum_corner_extension=0.001)\n\nExpand the polygon shape by an absolute value in all direction.\nOffset can be negative for negative expansion.\n\nParameters\n\noffset\n\npython:float, optional\n\nOffset value in meters.\n\ntolerance\n\npython:float, optional\n\nTolerance in meters.\n\nround_corners\n\nbool, optional\n\nWhether to round corners or not.\nIf True, use rounded corners in the expansion otherwise use straight edges (can be degenerate).\n\nmaximum_corner_extension\n\npython:float, optional\n\nThe maximum corner extension (when round corners are not used) at which point the corner is clipped.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "LayoutObjType: Layout object type of the Primitive class.\nlayout_obj_type\nLayoutObjType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.layout_obj_type.html#pyedb.grpc.database.primitive.bondwire.Bondwire.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "Bondwire.layout_obj_type = 0\n\nLayoutObjType: Layout object type of the Primitive class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.limits",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.limits.html#limits",
        "title": "limits",
        "section": "limits",
        "text": "Retrieve stackup limits.\nWhether to retrieve only metals. The default is False.\nTuple containing:\n- Upper layer name\n- Upper layer top elevation\n- Lower layer name\n- Lower layer bottom elevation\nlimits\noptional\nFalse\npython:tuple"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.limits",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.limits.html#pyedb.grpc.database.stackup.Stackup.limits",
        "title": "limits > limits > limits",
        "section": "limits > limits",
        "text": "Stackup.limits(only_metals: bool = False) -> Tuple[str, str]\n\nRetrieve stackup limits.\n\nParameters\n\nonly_metals\n\nbool, optional\n\nWhether to retrieve only metals. The default is False.\n\nReturns\n\npython:tuple\n\nTuple containing:\n- Upper layer name\n- Upper layer top elevation\n- Lower layer name\n- Lower layer bottom elevation\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layer.html#add_layer",
        "title": "add_layer",
        "section": "add_layer",
        "text": "Insert a layer into stackup.\nName of the layer.\nName of the base layer.\nWhere to insert the new layer. The default is \"add_on_top\". Options are:\n- \"add_on_top\"\n- \"add_on_bottom\"\n- \"insert_above\"\n- \"insert_below\"\n- \"add_at_elevation\"\nType of layer. The default is \"signal\". Options are:\n- \"signal\"\n- \"dielectric\"\n- \"conducting\"\n- \"air_lines\"\n- \"error\"\n- \"symbol\"\n- \"measure\"\n- \"assembly\"\n- \"silkscreen\"\n- \"solder_mask\"\n- \"solder_paste\"\n- \"glue\"\n- \"wirebond\"\n- \"hfss_region\"\n- \"user\"\nMaterial of the layer.\nFill material of the layer.\nThickness of the layer.\nEtch factor of the layer.\nWhether the layer is negative.\nWhether roughness is enabled.\nElevation of new layer. Only valid for Overlapping Stackup.\nLayer object created.\nadd_layer\npython:str\npython:str\noptional\npython:str\noptional\n\"add_on_top\"\n\"add_on_top\"\n\"add_on_bottom\"\n\"insert_above\"\n\"insert_below\"\n\"add_at_elevation\"\npython:str\noptional\n\"signal\"\n\"signal\"\n\"dielectric\"\n\"conducting\"\n\"air_lines\"\n\"error\"\n\"symbol\"\n\"measure\"\n\"assembly\"\n\"silkscreen\"\n\"solder_mask\"\n\"solder_paste\"\n\"glue\"\n\"wirebond\"\n\"hfss_region\"\n\"user\"\npython:str\noptional\npython:str\noptional\npython:str\npython:float\noptional\npython:int\npython:float\noptional\noptional\noptional\npython:float\noptional\npyedb.grpc.database.layers.stackup_layer.StackupLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layer.html#pyedb.grpc.database.stackup.Stackup.add_layer",
        "title": "add_layer > add_layer > add_layer",
        "section": "add_layer > add_layer",
        "text": "Stackup.add_layer(layer_name: str, base_layer: str | None = None, method: str = 'add_on_top', layer_type: str = 'signal', material: str = 'copper', fillMaterial: str = 'FR4_epoxy', thickness: str | float = '35um', etch_factor: float | None = None, is_negative: bool = False, enable_roughness: bool = False, elevation: float | None = None) -> bool\n\nInsert a layer into stackup.\n\nParameters\n\nlayer_name\n\npython:str\n\nName of the layer.\n\nbase_layer\n\npython:str, optional\n\nName of the base layer.\n\nmethod\n\npython:str, optional\n\nWhere to insert the new layer. The default is \"add_on_top\". Options are:\n- \"add_on_top\"\n- \"add_on_bottom\"\n- \"insert_above\"\n- \"insert_below\"\n- \"add_at_elevation\"\n\nlayer_type\n\npython:str, optional\n\nType of layer. The default is \"signal\". Options are:\n- \"signal\"\n- \"dielectric\"\n- \"conducting\"\n- \"air_lines\"\n- \"error\"\n- \"symbol\"\n- \"measure\"\n- \"assembly\"\n- \"silkscreen\"\n- \"solder_mask\"\n- \"solder_paste\"\n- \"glue\"\n- \"wirebond\"\n- \"hfss_region\"\n- \"user\"\n\nmaterial\n\npython:str, optional\n\nMaterial of the layer.\n\nfillMaterial\n\npython:str, optional\n\nFill material of the layer.\n\nthickness\n\npython:str, python:float, optional\n\nThickness of the layer.\n\netch_factor\n\npython:int, python:float, optional\n\nEtch factor of the layer.\n\nis_negative\n\nbool, optional\n\nWhether the layer is negative.\n\nenable_roughness\n\nbool, optional\n\nWhether roughness is enabled.\n\nelevation\n\npython:float, optional\n\nElevation of new layer. Only valid for Overlapping Stackup.\n\nReturns\n\npyedb.grpc.database.layers.stackup_layer.StackupLayer\n\nLayer object created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_reference_pins",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_reference_pins.html#get_reference_pins",
        "title": "get_reference_pins",
        "section": "get_reference_pins",
        "text": "Find reference pins near a specified pin.\nTarget pin.\nReference net name. Default is \"gnd\".\nSearch radius in meters. Default is 5e-3 (5 mm).\nMaximum number of pins to return. Default is 0 (no limit).\nWhether to search only in component pins. Default is True.\nList of reference pins.\nget_reference_pins\npyedb.grpc.database.primitive.padstack_instance.PadstackInstance\npython:str\noptional\n\"gnd\"\npython:float\noptional\n5e-3\npython:int\noptional\n0\noptional\nTrue\npython:list\npyedb.grpc.database.primitive.padstack_instance.PadstackInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_reference_pins",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_reference_pins.html#pyedb.grpc.database.padstacks.Padstacks.get_reference_pins",
        "title": "get_reference_pins > get_reference_pins > get_reference_pins",
        "section": "get_reference_pins > get_reference_pins",
        "text": "Padstacks.get_reference_pins(positive_pin: int | str | PadstackInstance, reference_net: str = 'gnd', search_radius: float = 0.005, max_limit: int = 0, component_only: bool = True) -> List[PadstackInstance]\n\nFind reference pins near a specified pin.\n\nParameters\n\npositive_pin\n\npyedb.grpc.database.primitive.padstack_instance.PadstackInstance\n\nTarget pin.\n\nreference_net\n\npython:str, optional\n\nReference net name. Default is \"gnd\".\n\nsearch_radius\n\npython:float, optional\n\nSearch radius in meters. Default is 5e-3 (5 mm).\n\nmax_limit\n\npython:int, optional\n\nMaximum number of pins to return. Default is 0 (no limit).\n\ncomponent_only\n\nbool, optional\n\nWhether to search only in component pins. Default is True.\n\nReturns\n\npython:list[pyedb.grpc.database.primitive.padstack_instance.PadstackInstance]\n\nList of reference pins.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.Node",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.Node.html#node",
        "title": "Node",
        "section": "Node",
        "text": "Provides for handling nodes for Siwave sources.\nNode"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.Node",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.Node.html#pyedb.grpc.database.utility.sources.Node",
        "title": "Node > Node > Node",
        "section": "Node > Node",
        "text": "class pyedb.grpc.database.utility.sources.Node\n\nProvides for handling nodes for Siwave sources.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.angle",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.angle.html#angle",
        "title": "angle",
        "section": "angle",
        "text": "Get the angle between this arc and another arc if provided or the angle of this arc.\nOther arc.\nAngle in radians.\nangle\nArcData\npython:None\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.angle",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.angle.html#pyedb.grpc.database.geometry.arc_data.ArcData.angle",
        "title": "angle > angle > angle",
        "section": "angle > angle",
        "text": "ArcData.angle(arc: ArcData | None = None) -> float\n\nGet the angle between this arc and another arc if provided or the angle of this arc.\n\nParameters\n\narc\n\nArcData, default: python:None\n\nOther arc.\n\nReturns\n\npython:float\n\nAngle in radians.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.create",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a component definition in a given database.\nDatabase to create the component definition in.\nName of the component definition to create.\nFootprint cell of the component definition, optional\nComponent definition created.\ncreate\nDatabase\npython:str\nCell\nComponentDef"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.create",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.create.html#pyedb.grpc.database.definition.component_def.ComponentDef.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod ComponentDef.create(db, comp_def_name, fp)\n\nCreate a component definition in a given database.\n\nParameters\n\ndb\n\nDatabase\n\nDatabase to create the component definition in.\n\ncomp_def_name\n\npython:str\n\nName of the component definition to create.\n\nfp\n\nCell\n\nFootprint cell of the component definition, optional\n\nReturns\n\nComponentDef\n\nComponent definition created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kSIwaveEMI",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kSIwaveEMI.html#ksiwaveemi",
        "title": "kSIwaveEMI",
        "section": "kSIwaveEMI",
        "text": "kSIwaveEMI"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kSIwaveEMI",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kSIwaveEMI.html#pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kSIwaveEMI",
        "title": "kSIwaveEMI > kSIwaveEMI > kSIwaveEMI",
        "section": "kSIwaveEMI > kSIwaveEMI",
        "text": "SimulationSetupType.kSIwaveEMI = 'siwave_emi'\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.get_thermal_modifier",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.get_thermal_modifier.html#get_thermal_modifier",
        "title": "get_thermal_modifier",
        "section": "get_thermal_modifier",
        "text": "Get the thermal modifier of a material property.\nMaterial property to get the thermal modifier of.\nget_thermal_modifier\nMaterialProperty\nMaterialPropertyThermalModifier"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.get_thermal_modifier",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.get_thermal_modifier.html#pyedb.grpc.database.definition.materials.Material.get_thermal_modifier",
        "title": "get_thermal_modifier > get_thermal_modifier > get_thermal_modifier",
        "section": "get_thermal_modifier > get_thermal_modifier",
        "text": "Material.get_thermal_modifier(material_property_id: MaterialProperty) -> MaterialPropertyThermalModifier\n\nGet the thermal modifier of a material property.\n\nParameters\n\nmaterial_property_id\n\nMaterialProperty\n\nMaterial property to get the thermal modifier of.\n\nReturns\n\nMaterialPropertyThermalModifier\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/index",
        "href": "libraries/index.html#pyedb-libraries-062dev0",
        "title": "PyEDB libraries 0.62.dev0",
        "section": "PyEDB libraries 0.62.dev0",
        "text": "PyEDB comes along with a set of libraries that allow improve user experience.\nLearn more about PyEDB basic RF libraries.\ncommon\nrf_basic\nantennas\nPyEDB libraries 0.62.dev0"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_pin_group_terminal",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_pin_group_terminal.html#create_pin_group_terminal",
        "title": "create_pin_group_terminal",
        "section": "create_pin_group_terminal",
        "text": "Create a pin group terminal.\nName of the source.\ncreate_pin_group_terminal\nVoltageSource\nCircuitPort\nCurrentSource\nDCTerminal\nResistorSource"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_pin_group_terminal",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_pin_group_terminal.html#pyedb.dotnet.database.siwave.EdbSiwave.create_pin_group_terminal",
        "title": "create_pin_group_terminal > create_pin_group_terminal > create_pin_group_terminal",
        "section": "create_pin_group_terminal > create_pin_group_terminal",
        "text": "EdbSiwave.create_pin_group_terminal(source)\n\nCreate a pin group terminal.\n\nParameters\n\nsource\n\nVoltageSource, CircuitPort, CurrentSource, DCTerminal or ResistorSource\n\nName of the source.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.remove_net",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.remove_net.html#remove_net",
        "title": "remove_net",
        "section": "remove_net",
        "text": "Remove a net.\nThis method is invalid for a differential pair.\nremove_net"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.remove_net",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.remove_net.html#pyedb.grpc.database.net.differential_pair.DifferentialPair.remove_net",
        "title": "remove_net > remove_net > remove_net",
        "section": "remove_net > remove_net",
        "text": "DifferentialPair.remove_net(net)\n\nRemove a net.\n\nThis method is invalid for a differential pair.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_product_property.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "PadstackInstance.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.create",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a bundle terminal.\ncreate\npython:list\nof\nTerminal\nBundleTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.create",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.create.html#pyedb.grpc.database.ports.ports.BundleWavePort.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod BundleWavePort.create(terminals)\n\nCreate a bundle terminal.\n\nParameters\n\nterminals\n\npython:list of Terminal\n\n\n\nReturns\n\nBundleTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.copy_cells",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.copy_cells.html#copy_cells",
        "title": "copy_cells",
        "section": "copy_cells",
        "text": "Copy Cells from other Databases or this Database into this Database.\nCells to copy.\nNew Cells created in this Database.\ncopy_cells\npython:list\nCell\npython:list\nCell"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.copy_cells",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.copy_cells.html#pyedb.dotnet.edb.Edb.copy_cells",
        "title": "copy_cells > copy_cells > copy_cells",
        "section": "copy_cells > copy_cells",
        "text": "Edb.copy_cells(cells_to_copy)\n\nCopy Cells from other Databases or this Database into this Database.\n\nParameters\n\ncells_to_copy\n\npython:list[Cell]\n\nCells to copy.\n\nReturns\n\npython:list[Cell]\n\nNew Cells created in this Database.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.scale",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.scale.html#scale",
        "title": "scale",
        "section": "scale",
        "text": "Scales the polygon relative to a center point by a factor.\nScaling factor.\nIf None scaling is done from polygon center.\nTrue when successful, False when failed.\nscale\npython:float\nList\nof\npython:float\npython:str\noptional\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.scale",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.scale.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.scale",
        "title": "scale > scale > scale",
        "section": "scale > scale",
        "text": "EdbPolygon.scale(factor, center=None)\n\nScales the polygon relative to a center point by a factor.\n\nParameters\n\nfactor\n\npython:float\n\nScaling factor.\n\ncenter\n\nList of python:float or python:str [x,y], optional\n\nIf None scaling is done from polygon center.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.DifferentialTLine.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.DifferentialTLine.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create the two traces using only parameter strings so the\ngeometry stays fully editable in AEDT.\nEDB object IDs of the positive and negative traces.\ncreate\npython:list\npython:float"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.DifferentialTLine.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.DifferentialTLine.create.html#pyedb.libraries.rf_libraries.base_functions.DifferentialTLine.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "DifferentialTLine.create() -> List[float]\n\nCreate the two traces using only parameter strings so the\ngeometry stays fully editable in AEDT.\n\nReturns\n\npython:list[python:float]\n\nEDB object IDs of the positive and negative traces.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.CircuitPort",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.CircuitPort.html#circuitport",
        "title": "CircuitPort",
        "section": "CircuitPort",
        "text": "Manages a circuit port.\nCircuitPort"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.CircuitPort",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.CircuitPort.html#pyedb.grpc.database.utility.sources.CircuitPort",
        "title": "CircuitPort > CircuitPort > CircuitPort",
        "section": "CircuitPort > CircuitPort",
        "text": "class pyedb.grpc.database.utility.sources.CircuitPort(pedb, impedance='50')\n\nManages a circuit port.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/index",
        "href": "grpc_api/grpc/database/index.html#database",
        "title": "Database",
        "section": "Database",
        "text": "This section describes EDB database classes.\nDatabase"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.product_solver_names",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.product_solver_names.html#product_solver_names",
        "title": "product_solver_names",
        "section": "product_solver_names",
        "text": "Get the list of solver names.\nID of the product.\nproduct_solver_names\nProductIdType\npython:list\nof\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.product_solver_names",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.product_solver_names.html#pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.product_solver_names",
        "title": "product_solver_names > product_solver_names > product_solver_names",
        "section": "product_solver_names > product_solver_names",
        "text": "BundleTerminal.product_solver_names(product_id)\n\nGet the list of solver names.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nReturns\n\npython:list of python:str\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.is_intersecting",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.is_intersecting.html#is_intersecting",
        "title": "is_intersecting",
        "section": "is_intersecting",
        "text": "Check if actual primitive and another primitive or polygon data intesects.\nis_intersecting\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.is_intersecting",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.is_intersecting.html#pyedb.grpc.database.primitive.primitive.Primitive.is_intersecting",
        "title": "is_intersecting > is_intersecting > is_intersecting",
        "section": "is_intersecting > is_intersecting",
        "text": "Primitive.is_intersecting(primitive) -> bool\n\nCheck if actual primitive and another primitive or polygon data intesects.\n\nParameters\n\nprimitive\n\nPrimitive or PolygonData\n\n\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.layout_statistics.LayoutStatistics",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.layout_statistics.LayoutStatistics.html#layoutstatistics",
        "title": "LayoutStatistics",
        "section": "LayoutStatistics",
        "text": "Statistics object\nObject properties example.\n>>> stat_model = EDBStatistics()\n>>> stat_model.num_capacitors\n>>> stat_model.num_resistors\n>>> stat_model.num_inductors\n>>> stat_model.layout_size\n>>> stat_model.num_discrete_components\n>>> stat_model.num_inductors\n>>> stat_model.num_resistors\n>>> stat_model.num_capacitors\n>>> stat_model.num_nets\n>>> stat_model.num_traces\n>>> stat_model.num_polygons\n>>> stat_model.num_vias\n>>> stat_model.stackup_thickness\n>>> stat_model.occupying_surface\n>>> stat_model.occupying_ratio\nLayoutStatistics"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.layout_statistics.LayoutStatistics",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.layout_statistics.LayoutStatistics.html#pyedb.grpc.database.utility.layout_statistics.LayoutStatistics",
        "title": "LayoutStatistics > LayoutStatistics > LayoutStatistics",
        "section": "LayoutStatistics > LayoutStatistics",
        "text": "class pyedb.grpc.database.utility.layout_statistics.LayoutStatistics\n\nStatistics object\n\nObject properties example.\n>>> stat_model = EDBStatistics()\n>>> stat_model.num_capacitors\n>>> stat_model.num_resistors\n>>> stat_model.num_inductors\n>>> stat_model.layout_size\n>>> stat_model.num_discrete_components\n>>> stat_model.num_inductors\n>>> stat_model.num_resistors\n>>> stat_model.num_capacitors\n>>> stat_model.num_nets\n>>> stat_model.num_traces\n>>> stat_model.num_polygons\n>>> stat_model.num_vias\n>>> stat_model.stackup_thickness\n>>> stat_model.occupying_surface\n>>> stat_model.occupying_ratio\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "construct"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.construct.html#pyedb.workflows.drc.drc.Rules.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod Rules.construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.duplicate",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.duplicate.html#duplicate",
        "title": "duplicate",
        "section": "duplicate",
        "text": "Duplicate a padstack definition.\nName of the padstack definition to duplicate.\nName for the new padstack definition.\nName of the new padstack definition.\nduplicate\npython:str\npython:str\noptional\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.duplicate",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.duplicate.html#pyedb.grpc.database.padstacks.Padstacks.duplicate",
        "title": "duplicate > duplicate > duplicate",
        "section": "duplicate > duplicate",
        "text": "Padstacks.duplicate(target_padstack_name: str, new_padstack_name: str = '') -> str\n\nDuplicate a padstack definition.\n\nParameters\n\ntarget_padstack_name\n\npython:str\n\nName of the padstack definition to duplicate.\n\nnew_padstack_name\n\npython:str, optional\n\nName for the new padstack definition.\n\nReturns\n\npython:str\n\nName of the new padstack definition.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.are_port_reference_terminals_connected",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.are_port_reference_terminals_connected.html#are_port_reference_terminals_connected",
        "title": "are_port_reference_terminals_connected",
        "section": "are_port_reference_terminals_connected",
        "text": "Check if port reference terminals are connected.\nReference net name to check.\nTrue if all port references are connected.\nare_port_reference_terminals_connected\npython:str\noptional"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.are_port_reference_terminals_connected",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.are_port_reference_terminals_connected.html#pyedb.grpc.edb.Edb.are_port_reference_terminals_connected",
        "title": "are_port_reference_terminals_connected > are_port_reference_terminals_connected > are_port_reference_terminals_connected",
        "section": "are_port_reference_terminals_connected > are_port_reference_terminals_connected",
        "text": "Edb.are_port_reference_terminals_connected(common_reference=None)\n\nCheck if port reference terminals are connected.\n\nParameters\n\ncommon_reference\n\npython:str, optional\n\nReference net name to check.\n\nReturns\n\nbool\n\nTrue if all port references are connected.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.get_product_property_ids.html#pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "PadstackInstanceTerminal.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileStackup.add_material",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileStackup.add_material.html#add_material",
        "title": "add_material",
        "section": "add_material",
        "text": "Add a new material with specific properties.\nMaterial name.\nMaterial permittivity. The default is 1.0.\nMaterial tangent losses. The default is 0.0.\nMaterial permeability. The default is 1.0.\nMaterial conductivity. The default is 0.0.\nSpecific material properties. The default is None.\nDictionary with key and material property value.\nadd_material\npython:str\npython:float\noptional\n1.0\npython:float\noptional\n0.0\npython:float\noptional\n1.0\npython:float\noptional\n0.0\npython:dict\noptional\nNone\npyedb.dotnet.database.edb_data.control_file.ControlFileMaterial"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileStackup.add_material",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileStackup.add_material.html#pyedb.dotnet.database.edb_data.control_file.ControlFileStackup.add_material",
        "title": "add_material > add_material > add_material",
        "section": "add_material > add_material",
        "text": "ControlFileStackup.add_material(material_name, permittivity=1.0, dielectric_loss_tg=0.0, permeability=1.0, conductivity=0.0, properties=None)\n\nAdd a new material with specific properties.\n\nParameters\n\nmaterial_name\n\npython:str\n\nMaterial name.\n\npermittivity\n\npython:float, optional\n\nMaterial permittivity. The default is 1.0.\n\ndielectric_loss_tg\n\npython:float, optional\n\nMaterial tangent losses. The default is 0.0.\n\npermeability\n\npython:float, optional\n\nMaterial permeability. The default is 1.0.\n\nconductivity\n\npython:float, optional\n\nMaterial conductivity. The default is 0.0.\n\nproperties\n\npython:dict, optional\n\nSpecific material properties. The default is None.\nDictionary with key and material property value.\n\nReturns\n\npyedb.dotnet.database.edb_data.control_file.ControlFileMaterial\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.delete_single_pin_rlc",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.delete_single_pin_rlc.html#delete_single_pin_rlc",
        "title": "delete_single_pin_rlc",
        "section": "delete_single_pin_rlc",
        "text": "Delete or deactivate single-pin RLC components.\nWhether to only deactivate instead of deleting.\nList of affected components.\ndelete_single_pin_rlc\noptional\npython:list\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.delete_single_pin_rlc",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.delete_single_pin_rlc.html#pyedb.grpc.database.components.Components.delete_single_pin_rlc",
        "title": "delete_single_pin_rlc > delete_single_pin_rlc > delete_single_pin_rlc",
        "section": "delete_single_pin_rlc > delete_single_pin_rlc",
        "text": "Components.delete_single_pin_rlc(deactivate_only: bool = False) -> List[str]\n\nDelete or deactivate single-pin RLC components.\n\nParameters\n\ndeactivate_only\n\nbool, optional\n\nWhether to only deactivate instead of deleting.\n\nReturns\n\npython:list[python:str]\n\nList of affected components.\n\nExamples\n\n>>> deleted = edbapp.components.delete_single_pin_rlc()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_nets_from_pin_list",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_nets_from_pin_list.html#get_nets_from_pin_list",
        "title": "get_nets_from_pin_list",
        "section": "get_nets_from_pin_list",
        "text": "Get nets from pin list.\nList of pins.\nList of net names.\nget_nets_from_pin_list\npython:list\npython:list\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_nets_from_pin_list",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_nets_from_pin_list.html#pyedb.grpc.database.components.Components.get_nets_from_pin_list",
        "title": "get_nets_from_pin_list > get_nets_from_pin_list > get_nets_from_pin_list",
        "section": "get_nets_from_pin_list > get_nets_from_pin_list",
        "text": "Components.get_nets_from_pin_list(pins: List[Any]) -> List[str]\n\nGet nets from pin list.\n\nParameters\n\npins\n\npython:list\n\nList of pins.\n\nReturns\n\npython:list[python:str]\n\nList of net names.\n\nExamples\n\n>>> nets = edbapp.components.get_nets_from_pin_list(pins)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_closest_point",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_closest_point.html#get_closest_point",
        "title": "get_closest_point",
        "section": "get_closest_point",
        "text": "Get the closest point of the primitive to the input data.\n[x, y].\nget_closest_point\npython:list\nof\npython:float\nPointData\nList\npython:float\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_closest_point",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_closest_point.html#pyedb.grpc.database.primitive.path.Path.get_closest_point",
        "title": "get_closest_point > get_closest_point > get_closest_point",
        "section": "get_closest_point > get_closest_point",
        "text": "Path.get_closest_point(point) -> list[float]\n\nGet the closest point of the primitive to the input data.\n\nParameters\n\npoint\n\npython:list of python:float or PointData\n\n\n\nReturns\n\nList[python:float, python:float]\n\n[x, y].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.create",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a non-stackup layer.\nLayer name.\nLayer type.\ncreate\npython:str\nLayerType\nLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.create",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.create.html#pyedb.grpc.database.layers.layer.Layer.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "static Layer.create(name, lyr_type)\n\nCreate a non-stackup layer.\n\nParameters\n\nname\n\npython:str\n\nLayer name.\n\nlyr_type\n\nLayerType\n\nLayer type.\n\nReturns\n\nLayer\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_dump",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#python-mode)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude: A set of fields to include in the output.\nexclude: A set of fields to exclude from the output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\nA dictionary representation of the model.\nmodel_dump"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_dump",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_dump.html#pyedb.workflows.drc.drc.CopperBalance.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "CopperBalance.model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -> dict[str, Any]\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#python-mode)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n\nmode: The mode in which to_python should run.\n\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude: A set of fields to include in the output.\nexclude: A set of fields to exclude from the output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\n\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\n\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback: A function to call when an unknown value is encountered. If not provided,\n\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.find",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.find.html#find",
        "title": "find",
        "section": "find",
        "text": "Find a group by name.\nLayout to search for the group.\nName of the group.\nGroup that is found, None otherwise.\nfind\nLayout\npython:str\nGroup\nNone"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.find",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.find.html#pyedb.grpc.database.hierarchy.component.Component.find",
        "title": "find > find > find",
        "section": "find > find",
        "text": "classmethod Component.find(layout, name)\n\nFind a group by name.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the group.\n\nname\n\npython:str\n\nName of the group.\n\nReturns\n\nGroup\n\nGroup that is found, None otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings.get_configurations",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings.get_configurations.html#get_configurations",
        "title": "get_configurations",
        "section": "get_configurations",
        "text": "Get all attributes.\nget_configurations\npython:dict"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings.get_configurations",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings.get_configurations.html#pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings.get_configurations",
        "title": "get_configurations > get_configurations > get_configurations",
        "section": "get_configurations > get_configurations",
        "text": "AdvancedSettings.get_configurations()\n\nGet all attributes.\n\nReturns\n\npython:dict\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.add_project_variable",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.add_project_variable.html#add_project_variable",
        "title": "add_project_variable",
        "section": "add_project_variable",
        "text": "Add a variable to edb database (project). The variable will have the prefix $.\nUser can use also the setitem to create or assign a variable. See example below.\nName of the variable. Name can be provided without $ prefix.\nValue of the variable with units.\nDescription of the variable.\nTuple containing the AddVariable result and variable server.\nadd_project_variable\npython:str\n$\npython:str\npython:float\npython:str\noptional\npython:tuple\nAddVariable"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.add_project_variable",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.add_project_variable.html#pyedb.dotnet.edb.Edb.add_project_variable",
        "title": "add_project_variable > add_project_variable > add_project_variable",
        "section": "add_project_variable > add_project_variable",
        "text": "Edb.add_project_variable(variable_name, variable_value, description='')\n\nAdd a variable to edb database (project). The variable will have the prefix $.\n\n..note::\n\nUser can use also the setitem to create or assign a variable. See example below.\n\nParameters\n\nvariable_name\n\npython:str\n\nName of the variable. Name can be provided without $ prefix.\n\nvariable_value\n\npython:str, python:float\n\nValue of the variable with units.\n\ndescription\n\npython:str, optional\n\nDescription of the variable.\n\nReturns\n\npython:tuple\n\nTuple containing the AddVariable result and variable server.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb_app = Edb()\n>>> boolean_1, ant_length = edb_app.add_project_variable(\"my_local_variable\", \"1cm\")\n>>> print(edb_app[\"$my_local_variable\"])  # using getitem\n>>> edb_app[\"$my_local_variable\"] = \"1cm\"  # using setitem\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.parse_obj",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "parse_obj"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.parse_obj",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.parse_obj.html#pyedb.workflows.drc.drc.CopperBalance.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod CopperBalance.parse_obj(obj: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.ungroup",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.ungroup.html#ungroup",
        "title": "ungroup",
        "section": "ungroup",
        "text": "Delete the grouping.\nungroup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.ungroup",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.ungroup.html#pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.ungroup",
        "title": "ungroup > ungroup > ungroup",
        "section": "ungroup > ungroup",
        "text": "BundleTerminal.ungroup()\n\nDelete the grouping.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.get_simulation_settings",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.get_simulation_settings.html#get_simulation_settings",
        "title": "get_simulation_settings",
        "section": "get_simulation_settings",
        "text": "get_simulation_settings"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.get_simulation_settings",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.get_simulation_settings.html#pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.get_simulation_settings",
        "title": "get_simulation_settings > get_simulation_settings > get_simulation_settings",
        "section": "get_simulation_settings > get_simulation_settings",
        "text": "SiwaveDCSimulationSetup.get_simulation_settings()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.max_percent",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.max_percent.html#max_percent",
        "title": "max_percent",
        "section": "max_percent",
        "text": "max_percent"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.max_percent",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.max_percent.html#pyedb.workflows.drc.drc.CopperBalance.max_percent",
        "title": "max_percent > max_percent > max_percent",
        "section": "max_percent > max_percent",
        "text": "CopperBalance.max_percent: int\n\n"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_min_line_width",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_min_line_width.html#add_min_line_width",
        "title": "add_min_line_width",
        "section": "add_min_line_width",
        "text": "Append a minimum-line-width rule.\nRule identifier\nMinimum width with unit, e.g. \"3.5mil\".\nList of layer names to apply the rule to.  If None,\napplies to all signal layers.\nSelf to enable method chaining.\nadd_min_line_width\npython:str\npython:str\n\"3.5mil\"\npython:list\npython:str\noptional\nNone\nRules"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_min_line_width",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_min_line_width.html#pyedb.workflows.drc.drc.Rules.add_min_line_width",
        "title": "add_min_line_width > add_min_line_width > add_min_line_width",
        "section": "add_min_line_width > add_min_line_width",
        "text": "Rules.add_min_line_width(name: str, value: str, layers: list[str] | None = None) -> Rules\n\nAppend a minimum-line-width rule.\n\nParameters\n\nname\n\npython:str\n\nRule identifier\n\nvalue\n\npython:str\n\nMinimum width with unit, e.g. \"3.5mil\".\n\nlayers\n\npython:list[python:str], optional\n\nList of layer names to apply the rule to.  If None,\napplies to all signal layers.\n\nReturns\n\nRules\n\nSelf to enable method chaining.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/edb",
        "href": "grpc_api/grpc/edb.html#edb-grpc-main-class",
        "title": "Edb gRPC main class",
        "section": "Edb gRPC main class",
        "text": "An AEDB database is a folder that contains the database representing any part of a PCB.\nIt can be opened and edited using the Edb class.\nedb.Edb\nMain class for interacting with Ansys Electronics Desktop Database (EDB).\nEdb gRPC main class\nEdb\nedb.Edb"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_pin_from_component_and_net",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_pin_from_component_and_net.html#get_pin_from_component_and_net",
        "title": "get_pin_from_component_and_net",
        "section": "get_pin_from_component_and_net",
        "text": "Retrieve pins by component reference designator and net name.\nComponent reference designator.\nNet name.\nList of matching pin instances.\nget_pin_from_component_and_net\npython:str\noptional\npython:str\noptional\npython:list\npyedb.grpc.database.primitive.padstack_instance.PadstackInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_pin_from_component_and_net",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_pin_from_component_and_net.html#pyedb.grpc.database.padstacks.Padstacks.get_pin_from_component_and_net",
        "title": "get_pin_from_component_and_net > get_pin_from_component_and_net > get_pin_from_component_and_net",
        "section": "get_pin_from_component_and_net > get_pin_from_component_and_net",
        "text": "Padstacks.get_pin_from_component_and_net(refdes: str | None = None, netname: str | None = None) -> List[PadstackInstance]\n\nRetrieve pins by component reference designator and net name.\n\nParameters\n\nrefdes\n\npython:str, optional\n\nComponent reference designator.\n\nnetname\n\npython:str, optional\n\nNet name.\n\nReturns\n\npython:list[pyedb.grpc.database.primitive.padstack_instance.PadstackInstance]\n\nList of matching pin instances.\n\nExamples\n\n>>> pins = edb_padstacks.get_pin_from_component_and_net(refdes=\"U1\", netname=\"VCC\")\n>>> pins = edb_padstacks.get_pin_from_component_and_net(netname=\"GND\")  # All GND pins\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.add_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.add_sweep.html#add_sweep",
        "title": "add_sweep",
        "section": "add_sweep",
        "text": "Add frequency sweep.\nName of the frequency sweep. The default is None.\nAdded for grpc compatibility.\nAdded for rpc compatibility.\nAdded for grpc compatibility.\nAdded for grpc compatibility.\nList of frequency points. The default is None.\nSweep type. The default is \"interpolation\". Options are \"discrete\",”discrete”``.\nadd_sweep\npython:str\noptional\nNone\npython:str\noptional\npython:str\noptional\npython:str\noptional\noptional\npython:list\noptional\nNone\npython:str\noptional\n\"interpolation\"\n\"discrete\""
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.add_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.add_sweep.html#pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.add_sweep",
        "title": "add_sweep > add_sweep > add_sweep",
        "section": "add_sweep > add_sweep",
        "text": "SimulationSetup.add_sweep(name: str | None = None, distribution: str | None = None, start_freq: str | None = None, stop_freq: str | None = None, step=None, frequency_set: list | None = None, sweep_type: str = 'interpolation', **kwargs)\n\nAdd frequency sweep.\n\nParameters\n\nname\n\npython:str, optional\n\nName of the frequency sweep. The default is None.\n\ndistribution\n\npython:str, optional\n\nAdded for grpc compatibility.\n\nstart_freq\n\npython:str, optional\n\nAdded for rpc compatibility.\n\nstop_freq\n\npython:str, optional\n\nAdded for grpc compatibility.\n\nstep\n\noptional\n\nAdded for grpc compatibility.\n\nfrequency_set\n\npython:list, optional\n\nList of frequency points. The default is None.\n\nsweep_type\n\npython:str, optional\n\nSweep type. The default is \"interpolation\". Options are \"discrete\",”discrete”``.\n\nReturns\n\n\n\n——-\n\n\n\nExamples\n\n>>> setup1 = edbapp.create_siwave_syz_setup(\"setup1\")\n>>> setup1.add_sweep(name=\"sw1\", frequency_set=[\"linear count\", \"1MHz\", \"100MHz\", 10])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileLayer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileLayer.html#controlfilelayer",
        "title": "ControlFileLayer",
        "section": "ControlFileLayer",
        "text": "Represents a general layer in the control file.\nLayer name.\nLayer properties dictionary.\nControlFileLayer\npython:str\npython:dict"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileLayer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileLayer.html#pyedb.grpc.database.control_file.ControlFileLayer",
        "title": "ControlFileLayer > ControlFileLayer > ControlFileLayer",
        "section": "ControlFileLayer > ControlFileLayer",
        "text": "class pyedb.grpc.database.control_file.ControlFileLayer(name, properties)\n\nRepresents a general layer in the control file.\n\nParameters\n\nname\n\npython:str\n\nLayer name.\n\nproperties\n\npython:dict\n\nLayer properties dictionary.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.min_line_width",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.min_line_width.html#min_line_width",
        "title": "min_line_width",
        "section": "min_line_width",
        "text": "min_line_width"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.min_line_width",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.min_line_width.html#pyedb.workflows.drc.drc.Rules.min_line_width",
        "title": "min_line_width > min_line_width > min_line_width",
        "section": "min_line_width > min_line_width",
        "text": "Rules.min_line_width: List[MinLineWidth]\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.generate_auto_hfss_regions",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.generate_auto_hfss_regions.html#generate_auto_hfss_regions",
        "title": "generate_auto_hfss_regions",
        "section": "generate_auto_hfss_regions",
        "text": "Generate auto HFSS regions.\nThis method automatically identifies areas for use as HFSS regions in SIwave simulations.\ngenerate_auto_hfss_regions"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.generate_auto_hfss_regions",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.generate_auto_hfss_regions.html#pyedb.grpc.database.layout.cell.Cell.generate_auto_hfss_regions",
        "title": "generate_auto_hfss_regions > generate_auto_hfss_regions > generate_auto_hfss_regions",
        "section": "generate_auto_hfss_regions > generate_auto_hfss_regions",
        "text": "Cell.generate_auto_hfss_regions()\n\nGenerate auto HFSS regions.\n\nThis method automatically identifies areas for use as HFSS regions in SIwave simulations.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/modeler",
        "href": "grpc_api/grpc/database/modeler.html#modeler--primitives",
        "title": "Modeler & primitives",
        "section": "Modeler & primitives",
        "text": "These classes are the containers of primitives and all relative methods.\nPrimitives are planes, lines, rectangles, and circles.\nModeler & primitives"
    },
    {
        "objectID": "grpc_api/grpc/database/modeler",
        "href": "grpc_api/grpc/database/modeler.html#primitives-properties",
        "title": "Modeler & primitives > Primitives properties",
        "section": "Primitives properties",
        "text": "These classes are the containers of data management for primitives and arcs.\nmodeler.Modeler\nManages EDB methods for primitives management accessible from Edb.modeler.\nPrimitives properties\nmodeler.Modeler"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.unite",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.unite.html#unite",
        "title": "unite",
        "section": "unite",
        "text": "Compute the union of a list of polygons.\nList of polygons.\nunite\npython:list\nof\nPolygonData\npython:list\nof\nPolygonData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.unite",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.unite.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.unite",
        "title": "unite > unite > unite",
        "section": "unite > unite",
        "text": "classmethod PolygonData.unite(polygons: list[PolygonData]) -> list[PolygonData]\n\nCompute the union of a list of polygons.\n\nParameters\n\npolygons\n\npython:list of PolygonData\n\nList of polygons.\n\nReturns\n\npython:list of PolygonData\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.parse_obj",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "parse_obj"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.parse_obj",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.parse_obj.html#pyedb.workflows.drc.drc.BackDrillStubLength.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod BackDrillStubLength.parse_obj(obj: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.min_annular_ring",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.min_annular_ring.html#min_annular_ring",
        "title": "min_annular_ring",
        "section": "min_annular_ring",
        "text": "min_annular_ring"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.min_annular_ring",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.min_annular_ring.html#pyedb.workflows.drc.drc.Rules.min_annular_ring",
        "title": "min_annular_ring > min_annular_ring > min_annular_ring",
        "section": "min_annular_ring > min_annular_ring",
        "text": "Rules.min_annular_ring: List[MinAnnularRing]\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/hfss_advanced_meshing_settings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/hfss_advanced_meshing_settings.html#hfss-advanced-meshing-settings",
        "title": "HFSS advanced meshing settings",
        "section": "HFSS advanced meshing settings",
        "text": "This class is managing EDB HFSS advanced meshing settings.\nHFSSAdvancedMeshingSettings\n\nHFSS advanced meshing settings\nHFSSAdvancedMeshingSettings"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileStackup.add_dielectric",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileStackup.add_dielectric.html#add_dielectric",
        "title": "add_dielectric",
        "section": "add_dielectric",
        "text": "Add a new dielectric.\nLayer name.\nDielectric layer index as they must be stacked. If not provided the layer index will be incremented.\nMaterial name.\nLayer thickness.\nDictionary with key and  property value.\nLayer name used for layer placement. Default value is None. This option is used for inserting\ndielectric layer between two existing ones. When no argument is provided the dielectric layer will be placed\non top of the stacked ones.\nProvides the method to use when the argument base_layer is provided. When True the layer is added\non top on the base layer, when False it will be added below.\nadd_dielectric\npython:str\npython:int\noptional\npython:str\npython:float\npython:dict\npython:str\noptional\nNone\nbase_layer\nTrue\nFalse\npyedb.dotnet.database.edb_data.control_file.ControlFileDielectric"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileStackup.add_dielectric",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileStackup.add_dielectric.html#pyedb.dotnet.database.edb_data.control_file.ControlFileStackup.add_dielectric",
        "title": "add_dielectric > add_dielectric > add_dielectric",
        "section": "add_dielectric > add_dielectric",
        "text": "ControlFileStackup.add_dielectric(layer_name, layer_index=None, material='', thickness=0.0, properties=None, base_layer=None, add_on_top=True)\n\nAdd a new dielectric.\n\nParameters\n\nlayer_name\n\npython:str\n\nLayer name.\n\nlayer_index\n\npython:int, optional\n\nDielectric layer index as they must be stacked. If not provided the layer index will be incremented.\n\nmaterial\n\npython:str\n\nMaterial name.\n\nthickness\n\npython:float\n\nLayer thickness.\n\nproperties\n\npython:dict\n\nDictionary with key and  property value.\n\nbase_layer\n\npython:str,  optional\n\nLayer name used for layer placement. Default value is None. This option is used for inserting\ndielectric layer between two existing ones. When no argument is provided the dielectric layer will be placed\non top of the stacked ones.\n\nmethod\n\nbool, Optional.\n\nProvides the method to use when the argument base_layer is provided. When True the layer is added\non top on the base layer, when False it will be added below.\n\nReturns\n\npyedb.dotnet.database.edb_data.control_file.ControlFileDielectric\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/models.md#model-copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nbefore creating the new model. You should trust this data.\ndeep: Set to True to make a deep copy of the model.\nNew model instance.\nmodel_copy"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_copy.html#pyedb.workflows.drc.drc.MinAnnularRing.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "MinAnnularRing.model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -> Self\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/models.md#model-copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nArgs:\n\nupdate: Values to change/add in the new model. Note: the data is not validated\n\nbefore creating the new model. You should trust this data.\n\ndeep: Set to True to make a deep copy of the model.\n\nReturns:\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_resistor_on_pin",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_resistor_on_pin.html#create_resistor_on_pin",
        "title": "create_resistor_on_pin",
        "section": "create_resistor_on_pin",
        "text": "Create a Resistor boundary between two given pins.\nPositive Pin.\nNegative Pin.\nResistance value. The default is 1.\nName of the resistor. The default is \"\".\nName of the Resistor.\ncreate_resistor_on_pin\nObject\nObject\npython:float\noptional\n1\npython:str\noptional\n\"\"\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_resistor_on_pin",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_resistor_on_pin.html#pyedb.dotnet.database.hfss.EdbHfss.create_resistor_on_pin",
        "title": "create_resistor_on_pin > create_resistor_on_pin > create_resistor_on_pin",
        "section": "create_resistor_on_pin > create_resistor_on_pin",
        "text": "EdbHfss.create_resistor_on_pin(pos_pin, neg_pin, rvalue=1, resistor_name='')\n\nCreate a Resistor boundary between two given pins.\n\nParameters\n\npos_pin\n\nObject\n\nPositive Pin.\n\nneg_pin\n\nObject\n\nNegative Pin.\n\nrvalue\n\npython:float, optional\n\nResistance value. The default is 1.\n\nresistor_name\n\npython:str, optional\n\nName of the resistor. The default is \"\".\n\nReturns\n\npython:str\n\nName of the Resistor.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", \"project name\", \"release version\")\n>>> pins = edbapp.components.get_pin_from_component(\"U2A5\")\n>>> edbapp.hfss.create_resistor_on_pin(pins[0], pins[1], 50, \"res_name\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the layout object.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.delete.html#pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "PinGroupTerminal.delete()\n\nDelete the layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_document_layer",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_document_layer.html#add_document_layer",
        "title": "add_document_layer",
        "section": "add_document_layer",
        "text": "Add a document layer.\nName of the layer.\nType of the layer. The default is \"user\". Options are \"user\", \"outline\"\nadd_document_layer\npython:str\n\"user\"\n\"user\"\n\"outline\""
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_document_layer",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_document_layer.html#pyedb.dotnet.database.stackup.Stackup.add_document_layer",
        "title": "add_document_layer > add_document_layer > add_document_layer",
        "section": "add_document_layer > add_document_layer",
        "text": "Stackup.add_document_layer(name, layer_type='user', **kwargs)\n\nAdd a document layer.\n\nParameters\n\nname\n\npython:str\n\nName of the layer.\n\nlayer_type: str, optional\n\nType of the layer. The default is \"user\". Options are \"user\", \"outline\"\n\nkwargs\n\n\n\nReturns\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.hfss_extent_info.HfssExtentInfo",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.hfss_extent_info.HfssExtentInfo.html#hfssextentinfo",
        "title": "HfssExtentInfo",
        "section": "HfssExtentInfo",
        "text": "Manages EDB functionalities for HFSS extent information.\nInherited EDB object.\nHfssExtentInfo.export_config()\nExport HFSS extent information.\nHfssExtentInfo.load_config(config)\nLoad HFSS extent configuration.\nHfssExtentInfo\npyedb.edb.Edb\nHfssExtentInfo.export_config\nHfssExtentInfo.load_config"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.hfss_extent_info.HfssExtentInfo",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.hfss_extent_info.HfssExtentInfo.html#pyedb.dotnet.database.edb_data.hfss_extent_info.HfssExtentInfo",
        "title": "HfssExtentInfo > HfssExtentInfo > HfssExtentInfo",
        "section": "HfssExtentInfo > HfssExtentInfo",
        "text": "class pyedb.dotnet.database.edb_data.hfss_extent_info.HfssExtentInfo(pedb)\n\nManages EDB functionalities for HFSS extent information.\n\nParameters\n\npedb\n\npyedb.edb.Edb\n\nInherited EDB object.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nHfssExtentInfo.export_config()\n\nExport HFSS extent information.\n\nHfssExtentInfo.load_config(config)\n\nLoad HFSS extent configuration.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/hfss_advanced_settings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/hfss_advanced_settings.html#hfss-advanced-settings",
        "title": "HFSS advanced settings",
        "section": "HFSS advanced settings",
        "text": "This class is managing EDB HFSS advanced settings.\nHFSSAdvancedSettings\n\nHFSS advanced settings\nHFSSAdvancedSettings"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.get_net_by_name",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.get_net_by_name.html#get_net_by_name",
        "title": "get_net_by_name",
        "section": "get_net_by_name",
        "text": "Find a net by name.\nName of the net to find.\nNet object if found, otherwise None.\nget_net_by_name\npython:str\npyedb.grpc.database.net.net.Net"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.get_net_by_name",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.get_net_by_name.html#pyedb.grpc.database.nets.Nets.get_net_by_name",
        "title": "get_net_by_name > get_net_by_name > get_net_by_name",
        "section": "get_net_by_name > get_net_by_name",
        "text": "Nets.get_net_by_name(net_name: str) -> Net | None\n\nFind a net by name.\n\nParameters\n\nnet_name\n\npython:str\n\nName of the net to find.\n\nReturns\n\npyedb.grpc.database.net.net.Net\n\nNet object if found, otherwise None.\n\nExamples\n\n>>> found_net = edb_nets.get_net_by_name(\"PCIe_TX\")\n>>> if found_net:\n...     print(\"Net found:\", found_net.name)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.layers",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.layers.html#layers",
        "title": "layers",
        "section": "layers",
        "text": "layers"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.layers",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.layers.html#pyedb.workflows.drc.drc.CopperBalance.layers",
        "title": "layers > layers > layers",
        "section": "layers > layers",
        "text": "CopperBalance.layers: List[str]\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.clear_instances_cache",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.clear_instances_cache.html#clear_instances_cache",
        "title": "clear_instances_cache",
        "section": "clear_instances_cache",
        "text": "Clear the cached padstack instances.\nclear_instances_cache"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.clear_instances_cache",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.clear_instances_cache.html#pyedb.grpc.database.padstacks.Padstacks.clear_instances_cache",
        "title": "clear_instances_cache > clear_instances_cache > clear_instances_cache",
        "section": "clear_instances_cache > clear_instances_cache",
        "text": "Padstacks.clear_instances_cache()\n\nClear the cached padstack instances.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.add_rlc_boundary",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.add_rlc_boundary.html#add_rlc_boundary",
        "title": "add_rlc_boundary",
        "section": "add_rlc_boundary",
        "text": "Add RLC gap boundary on component and replace it with a circuit port.\nThe circuit port supports only 2-pin components.\n. deprecated:: pyedb 0.28.0\nUse pyedb.grpc.core.excitations.add_rlc_boundary() instead.\nReference designator of the RLC component.\nWhen True circuit type are defined, if False gap type will be used instead (compatible with HFSS 3D\nmodeler). Default value is True.\nTrue when successful, False when failed.\nadd_rlc_boundary\npyedb.grpc.core.excitations.add_rlc_boundary()\npython:str\nTrue\nFalse\nTrue\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.add_rlc_boundary",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.add_rlc_boundary.html#pyedb.grpc.database.components.Components.add_rlc_boundary",
        "title": "add_rlc_boundary > add_rlc_boundary > add_rlc_boundary",
        "section": "add_rlc_boundary > add_rlc_boundary",
        "text": "Components.add_rlc_boundary(component: str | Component | None = None, circuit_type: bool = True) -> bool\n\nAdd RLC gap boundary on component and replace it with a circuit port.\nThe circuit port supports only 2-pin components.\n\n. deprecated:: pyedb 0.28.0\nUse pyedb.grpc.core.excitations.add_rlc_boundary() instead.\n\nParameters\n\ncomponent\n\npython:str\n\nReference designator of the RLC component.\n\ncircuit_type\n\nbool\n\nWhen True circuit type are defined, if False gap type will be used instead (compatible with HFSS 3D\nmodeler). Default value is True.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/mesh_operation",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/mesh_operation.html#mesh-operation",
        "title": "Mesh operation",
        "section": "Mesh operation",
        "text": "This class is managing EDB mesh operation.\nMeshOperation\nMesh operation class.\nMesh operation\nMeshOperation"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.disjoint_nets",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.disjoint_nets.html#disjoint_nets",
        "title": "disjoint_nets",
        "section": "disjoint_nets",
        "text": "Find and fix disjoint nets from a given netlist.\nList of nets on which check disjoints. If None is provided then the algorithm will loop on all nets.\nRemove all secondary nets other than principal one (the one with more objects in it). Default is False.\nClean all disjoint nets with area less than specified area in square meters. Default is 0.0 to disable it.\nWhether if the naming order has to be by number of objects (fastest) or area (slowest but more accurate).\nDefault is False.\nWhether if delete disjoints pins not connected to any other primitive or not. Default is False.\nNew nets created.\ndisjoint_nets\npython:str\npython:list\noptional\noptional\noptional\noptional\nFalse\noptional\nFalse\nList"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.disjoint_nets",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.disjoint_nets.html#pyedb.grpc.database.layout_validation.LayoutValidation.disjoint_nets",
        "title": "disjoint_nets > disjoint_nets > disjoint_nets",
        "section": "disjoint_nets > disjoint_nets",
        "text": "LayoutValidation.disjoint_nets(net_list: str | List[str] | None = None, keep_only_main_net: bool = False, clean_disjoints_less_than: float = 0.0, order_by_area: bool = False, keep_disjoint_pins: bool = False) -> List[str]\n\nFind and fix disjoint nets from a given netlist.\n\nParameters\n\nnet_list\n\npython:str, python:list, optional\n\nList of nets on which check disjoints. If None is provided then the algorithm will loop on all nets.\n\nkeep_only_main_net\n\nbool, optional\n\nRemove all secondary nets other than principal one (the one with more objects in it). Default is False.\n\nclean_disjoints_less_than\n\nbool, optional\n\nClean all disjoint nets with area less than specified area in square meters. Default is 0.0 to disable it.\n\norder_by_area\n\nbool, optional\n\nWhether if the naming order has to be by number of objects (fastest) or area (slowest but more accurate).\nDefault is False.\n\nkeep_disjoint_pins\n\nbool, optional\n\nWhether if delete disjoints pins not connected to any other primitive or not. Default is False.\n\nReturns\n\nList\n\nNew nets created.\n\nExamples\n\n>>> edb = Edb(\"edb_file\")\n>>> # Find disjoint nets on all nets\n>>> new_nets = edb.layout_validation.disjoint_nets()\n>>>\n>>> # Clean disjoints on specific nets with advanced options\n>>> cleaned = edb.layout_validation.disjoint_nets(\n...     net_list=[\"GND\"],\n...     keep_only_main_net=True,\n...     clean_disjoints_less_than=1e-6,\n...     order_by_area=True\n... ))\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.update_layout",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.update_layout.html#update_layout",
        "title": "update_layout",
        "section": "update_layout",
        "text": "Update the layout with the current layer collection.\nupdate_layout"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.update_layout",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.update_layout.html#pyedb.grpc.database.stackup.Stackup.update_layout",
        "title": "update_layout > update_layout > update_layout",
        "section": "update_layout > update_layout",
        "text": "Stackup.update_layout()\n\nUpdate the layout with the current layer collection.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> edb.stackup.update_layout()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_model_for_arbitrary_wave_ports",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_model_for_arbitrary_wave_ports.html#create_model_for_arbitrary_wave_ports",
        "title": "create_model_for_arbitrary_wave_ports",
        "section": "create_model_for_arbitrary_wave_ports",
        "text": "Create simplified model for arbitrary wave port generation.\nWorking directory.\nBoard orientation (“top” or “bottom”).\nNets to include. All if None.\nCustom terminal diameter. Auto-calculated if None.\nOutput AEDB path.\nWave port box thickness.\nTrue if successful, False otherwise.\ncreate_model_for_arbitrary_wave_ports\npython:str\npython:str\noptional\npython:list\noptional\npython:float\noptional\npython:str\noptional\npython:str\noptional"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_model_for_arbitrary_wave_ports",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_model_for_arbitrary_wave_ports.html#pyedb.grpc.edb.Edb.create_model_for_arbitrary_wave_ports",
        "title": "create_model_for_arbitrary_wave_ports > create_model_for_arbitrary_wave_ports > create_model_for_arbitrary_wave_ports",
        "section": "create_model_for_arbitrary_wave_ports > create_model_for_arbitrary_wave_ports",
        "text": "Edb.create_model_for_arbitrary_wave_ports(temp_directory, mounting_side='top', signal_nets=None, terminal_diameter=None, output_edb=None, launching_box_thickness='100um')\n\nCreate simplified model for arbitrary wave port generation.\n\nParameters\n\ntemp_directory\n\npython:str\n\nWorking directory.\n\nmounting_side\n\npython:str, optional\n\nBoard orientation (“top” or “bottom”).\n\nsignal_nets\n\npython:list, optional\n\nNets to include. All if None.\n\nterminal_diameter\n\npython:float, optional\n\nCustom terminal diameter. Auto-calculated if None.\n\noutput_edb\n\npython:str, optional\n\nOutput AEDB path.\n\nlaunching_box_thickness\n\npython:str, optional\n\nWave port box thickness.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.scale",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.scale.html#scale",
        "title": "scale",
        "section": "scale",
        "text": "Scales the polygon relative to a center point by a factor.\nScaling factor.\nIf None scaling is done from polygon center.\nTrue when successful, False when failed.\nscale\npython:float\nList\nof\npython:float\npython:str\noptional\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.scale",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.scale.html#pyedb.grpc.database.primitive.polygon.Polygon.scale",
        "title": "scale > scale > scale",
        "section": "scale > scale",
        "text": "Polygon.scale(factor, center=None) -> bool\n\nScales the polygon relative to a center point by a factor.\n\nParameters\n\nfactor\n\npython:float\n\nScaling factor.\n\ncenter\n\nList of python:float or python:str [x,y], optional\n\nIf None scaling is done from polygon center.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.find",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.find.html#find",
        "title": "find",
        "section": "find",
        "text": "Find a terminal by name in a given layout.\nLayout to search for the terminal.\nName of the terminal.\nfind\nLayout\nstr\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.find",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.find.html#pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.find",
        "title": "find > find > find",
        "section": "find > find",
        "text": "classmethod PadstackInstanceTerminal.find(layout, name)\n\nFind a terminal by name in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the terminal.\n\nname\n\nstr\n\nName of the terminal.\n\nReturns\n\nTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.intersection_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.intersection_type.html#intersection_type",
        "title": "intersection_type",
        "section": "intersection_type",
        "text": "Get intersection type between actual primitive and another primitive or polygon data.\nIntersection type:\n0 - objects do not intersect,\n1 - this object fully inside other (no common contour points),\n2 - other object fully inside this,\n3 - common contour points,\n4 - undefined intersection.\nintersection_type\nPolygon\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.intersection_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.intersection_type.html#pyedb.grpc.database.primitive.rectangle.Rectangle.intersection_type",
        "title": "intersection_type > intersection_type > intersection_type",
        "section": "intersection_type > intersection_type",
        "text": "Rectangle.intersection_type(primitive)\n\nGet intersection type between actual primitive and another primitive or polygon data.\n\nParameters\n\nprimitive\n\nPolygon or PolygonData\n\n\n\nReturns\n\npython:int\n\nIntersection type:\n0 - objects do not intersect,\n1 - this object fully inside other (no common contour points),\n2 - other object fully inside this,\n3 - common contour points,\n4 - undefined intersection.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.from_orm",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "from_orm"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.from_orm",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.from_orm.html#pyedb.workflows.drc.drc.BackDrillStubLength.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod BackDrillStubLength.from_orm(obj: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_terminal.html#create_terminal",
        "title": "create_terminal",
        "section": "create_terminal",
        "text": "Create a terminal.\nName of the terminal.\nPin group terminal.\ncreate_terminal\npython:str\noptional\nPinGroupTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_terminal.html#pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_terminal",
        "title": "create_terminal > create_terminal > create_terminal",
        "section": "create_terminal > create_terminal",
        "text": "PinGroup.create_terminal(name=None) -> PinGroupTerminal\n\nCreate a terminal.\n\nParameters\n\nname\n\npython:str, optional\n\nName of the terminal.\n\nReturns\n\nPinGroupTerminal.\n\nPin group terminal.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_padstack_terminal_reference_pin",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_padstack_terminal_reference_pin.html#get_padstack_terminal_reference_pin",
        "title": "get_padstack_terminal_reference_pin",
        "section": "get_padstack_terminal_reference_pin",
        "text": "Get a list of pad stacks instances and serves Coax wave ports,\npingroup terminals, PadEdge terminals.\nPreferred reference net name.\nget_padstack_terminal_reference_pin\npython:str\noptional\ndotnet.database.edb_data.padstack_data.EDBPadstackInstance"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_padstack_terminal_reference_pin",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_padstack_terminal_reference_pin.html#pyedb.dotnet.database.edb_data.ports.GapPort.get_padstack_terminal_reference_pin",
        "title": "get_padstack_terminal_reference_pin > get_padstack_terminal_reference_pin > get_padstack_terminal_reference_pin",
        "section": "get_padstack_terminal_reference_pin > get_padstack_terminal_reference_pin",
        "text": "GapPort.get_padstack_terminal_reference_pin(gnd_net_name_preference=None)\n\nGet a list of pad stacks instances and serves Coax wave ports,\npingroup terminals, PadEdge terminals.\n\nParameters\n\ngnd_net_name_preference\n\npython:str, optional\n\nPreferred reference net name.\n\nReturns\n\ndotnet.database.edb_data.padstack_data.EDBPadstackInstance\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.delete",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete a component.\nName of the component.\nTrue when successful, False when failed.\ndelete\npython:str\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.delete",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.delete.html#pyedb.dotnet.database.components.Components.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "Components.delete(component_name)\n\nDelete a component.\n\nParameters\n\ncomponent_name\n\npython:str\n\nName of the component.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\")\n>>> edbapp.components.delete(\"A1\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.clone",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.clone.html#clone",
        "title": "clone",
        "section": "clone",
        "text": "Clone a primitive object with keeping same definition and location.\nTrue when successful, False when failed.\nclone\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.clone",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.clone.html#pyedb.grpc.database.primitive.path.Path.clone",
        "title": "clone > clone > clone",
        "section": "clone > clone",
        "text": "Path.clone()\n\nClone a primitive object with keeping same definition and location.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_product_property_ids.html#pyedb.grpc.database.primitive.polygon.Polygon.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "Polygon.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.edb_value",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.edb_value.html#edb_value",
        "title": "edb_value",
        "section": "edb_value",
        "text": "Convert a value to an EDB value. Value can be a string, float or integer. Mainly used in internal calls.\nedb_value\npython:str\npython:float\npython:int\nInstance\nof"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.edb_value",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.edb_value.html#pyedb.dotnet.edb.Edb.edb_value",
        "title": "edb_value > edb_value > edb_value",
        "section": "edb_value > edb_value",
        "text": "Edb.edb_value(value, var_server=None)\n\nConvert a value to an EDB value. Value can be a string, float or integer. Mainly used in internal calls.\n\nParameters\n\nvalue\n\npython:str, python:float, python:int\n\n\n\nReturns\n\nInstance of Edb.Utility.Value\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.get_configurations",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.get_configurations.html#get_configurations",
        "title": "get_configurations",
        "section": "get_configurations",
        "text": "Get SIwave SYZ simulation settings.\nDictionary of SIwave SYZ simulation settings.\nget_configurations\npython:dict"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.get_configurations",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.get_configurations.html#pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.get_configurations",
        "title": "get_configurations > get_configurations > get_configurations",
        "section": "get_configurations > get_configurations",
        "text": "SiwaveSimulationSetup.get_configurations()\n\nGet SIwave SYZ simulation settings.\n\nReturns\n\npython:dict\n\nDictionary of SIwave SYZ simulation settings.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.type.html#type",
        "title": "type",
        "section": "type",
        "text": "type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.type.html#pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.type",
        "title": "type > type > type",
        "section": "type > type",
        "text": "EdgeTerminal.type = 0\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_hfss_prop.html#set_hfss_prop",
        "title": "set_hfss_prop",
        "section": "set_hfss_prop",
        "text": "Set HFSS properties.\nMaterial property name to set.\nWhether to solve inside.\nset_hfss_prop\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_hfss_prop.html#pyedb.grpc.database.primitive.bondwire.Bondwire.set_hfss_prop",
        "title": "set_hfss_prop > set_hfss_prop > set_hfss_prop",
        "section": "set_hfss_prop > set_hfss_prop",
        "text": "Bondwire.set_hfss_prop(material: str, solve_inside: bool)\n\nSet HFSS properties.\n\nParameters\n\nmaterial\n\npython:str\n\nMaterial property name to set.\n\nsolve_inside\n\nbool\n\nWhether to solve inside.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_point",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_point.html#is_point",
        "title": "is_point",
        "section": "is_point",
        "text": "Determine if the arc is a point.\nAn arc is a point when its start and end points are the same.\nTolearance.\nTrue when the arc is a point, False otherwise.\nis_point\npython:float\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_point",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_point.html#pyedb.grpc.database.geometry.arc_data.ArcData.is_point",
        "title": "is_point > is_point > is_point",
        "section": "is_point > is_point",
        "text": "ArcData.is_point(tolerance: float = 0.0) -> bool\n\nDetermine if the arc is a point.\n\nAn arc is a point when its start and end points are the same.\n\nParameters\n\ntolerance\n\npython:float, default: 0.0\n\nTolearance.\n\nReturns\n\nbool\n\nTrue when the arc is a point, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_voltage_source_on_net",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_voltage_source_on_net.html#create_voltage_source_on_net",
        "title": "create_voltage_source_on_net",
        "section": "create_voltage_source_on_net",
        "text": "Create a voltage source.\nName of the positive component.\nName of the positive net.\nName of the negative component. The default is None, in which case the name of\nthe positive net is assigned.\nName of the negative net name. The default is None which will look for GND Nets.\nValue for the voltage. The default is 3.3.\nValue for the phase. The default is 0.\nName of the source. The default is \"\".\nThe name of the source.\ncreate_voltage_source_on_net\npython:str\npython:str\npython:str\noptional\nNone\npython:str\noptional\nNone\npython:float\noptional\n3.3\noptional\n0\npython:str\noptional\n\"\"\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_voltage_source_on_net",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_voltage_source_on_net.html#pyedb.dotnet.database.siwave.EdbSiwave.create_voltage_source_on_net",
        "title": "create_voltage_source_on_net > create_voltage_source_on_net > create_voltage_source_on_net",
        "section": "create_voltage_source_on_net > create_voltage_source_on_net",
        "text": "EdbSiwave.create_voltage_source_on_net(positive_component_name, positive_net_name, negative_component_name=None, negative_net_name=None, voltage_value=3.3, phase_value=0, source_name='')\n\nCreate a voltage source.\n\nParameters\n\npositive_component_name\n\npython:str\n\nName of the positive component.\n\npositive_net_name\n\npython:str\n\nName of the positive net.\n\nnegative_component_name\n\npython:str, optional\n\nName of the negative component. The default is None, in which case the name of\nthe positive net is assigned.\n\nnegative_net_name\n\npython:str, optional\n\nName of the negative net name. The default is None which will look for GND Nets.\n\nvoltage_value\n\npython:float, optional\n\nValue for the voltage. The default is 3.3.\n\nphase_value\n\noptional\n\nValue for the phase. The default is 0.\n\nsource_name\n\npython:str, optional\n\nName of the source. The default is \"\".\n\nReturns\n\npython:str\n\nThe name of the source.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", \"project name\", \"release version\")\n>>> edb.siwave.create_voltage_source_on_net(\"U2A5\", \"V1P5_S3\", \"U2A5\", \"GND\", 3.3, 0, \"source_name\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_end_cap_style",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_end_cap_style.html#get_end_cap_style",
        "title": "get_end_cap_style",
        "section": "get_end_cap_style",
        "text": "Get end cap styles for the path.\nReturns a tuple in this format:\n(end_cap1, end_cap2)\nend_cap1 : End cap style of path start end cap.\nend_cap2 : End cap style of path end end cap.\nget_end_cap_style\npython:tuple\nof\nPathEndCapType\nPathEndCapType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_end_cap_style",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_end_cap_style.html#pyedb.grpc.database.primitive.path.Path.get_end_cap_style",
        "title": "get_end_cap_style > get_end_cap_style > get_end_cap_style",
        "section": "get_end_cap_style > get_end_cap_style",
        "text": "Path.get_end_cap_style() -> tuple[PathEndCapType, PathEndCapType]\n\nGet end cap styles for the path.\n\nReturns\n\npython:tuple of (PathEndCapType, PathEndCapType)\n\nReturns a tuple in this format:\n\n(end_cap1, end_cap2)\n\nend_cap1 : End cap style of path start end cap.\n\nend_cap2 : End cap style of path end end cap.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.set_solderball",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.set_solderball.html#set_solderball",
        "title": "set_solderball",
        "section": "set_solderball",
        "text": "Set solderball for the given PadstackInstance.\nPadstack instance id or object.\nName of the layer where the solder ball is placed. No default values.\nBollean triggering is the solder ball is placed on Top or Bottom of the layer stackup.\nSolder ball diameter value.\nset_solderball\nEdb.Cell.Primitive.PadstackInstance\npython:int\ndouble"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.set_solderball",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.set_solderball.html#pyedb.grpc.database.padstacks.Padstacks.set_solderball",
        "title": "set_solderball > set_solderball > set_solderball",
        "section": "set_solderball > set_solderball",
        "text": "Padstacks.set_solderball(padstackInst, sballLayer_name, isTopPlaced=True, ballDiam=0.0001)\n\nSet solderball for the given PadstackInstance.\n\nParameters\n\npadstackInst\n\nEdb.Cell.Primitive.PadstackInstance or python:int\n\nPadstack instance id or object.\n\nsballLayer_name\n\nstr,\n\nName of the layer where the solder ball is placed. No default values.\n\nisTopPlaced\n\nbool, optional.\n\nBollean triggering is the solder ball is placed on Top or Bottom of the layer stackup.\n\nballDiam\n\ndouble, optional,\n\nSolder ball diameter value.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadProperties.int_to_geometry_type",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadProperties.int_to_geometry_type.html#int_to_geometry_type",
        "title": "int_to_geometry_type",
        "section": "int_to_geometry_type",
        "text": "Convert an integer to an EDB.PadGeometryType.\nEDB.PadGeometryType enumerator value.\nint_to_geometry_type\npython:int\nobject"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadProperties.int_to_geometry_type",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadProperties.int_to_geometry_type.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadProperties.int_to_geometry_type",
        "title": "int_to_geometry_type > int_to_geometry_type > int_to_geometry_type",
        "section": "int_to_geometry_type > int_to_geometry_type",
        "text": "EDBPadProperties.int_to_geometry_type(val=0)\n\nConvert an integer to an EDB.PadGeometryType.\n\nParameters\n\nval\n\npython:int\n\n\n\nReturns\n\nobject\n\nEDB.PadGeometryType enumerator value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.update_forward_refs",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "update_forward_refs"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.update_forward_refs",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.update_forward_refs.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod DiffPairLengthMatch.update_forward_refs(**localns: Any) -> None\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_post_init",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nmodel_post_init"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_post_init",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_post_init.html#pyedb.workflows.drc.drc.MinClearance.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "MinClearance.model_post_init(context: Any, /) -> None\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Drc.check",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Drc.check.html#check",
        "title": "check",
        "section": "check",
        "text": "Run all rules and return a list of violations.\nRules are dispatched to the appropriate internal handler\n(_rule_*) automatically.  The method is thread-safe and\nre-entrant; successive calls overwrite previous results.\nValidated rule container.\nEach dictionary describes a single violation and contains at\nminimum the keys:\nrule – rule type (minLineWidth, minClearance, …)\nlimit_um – limit value in micrometres\nAdditional keys are rule-specific (layer, net1, primitive, …)\ncheck\nRules\npython:list\npython:dict\nrule\nminLineWidth\nminClearance\nlimit_um\nlayer\nnet1\nprimitive"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Drc.check",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Drc.check.html#pyedb.workflows.drc.drc.Drc.check",
        "title": "check > check > check",
        "section": "check > check",
        "text": "Drc.check(rules: Rules) -> List[Dict[str, Any]]\n\nRun all rules and return a list of violations.\n\nRules are dispatched to the appropriate internal handler\n(_rule_*) automatically.  The method is thread-safe and\nre-entrant; successive calls overwrite previous results.\n\nParameters\n\nrules\n\nRules\n\nValidated rule container.\n\nReturns\n\npython:list[python:dict]\n\nEach dictionary describes a single violation and contains at\nminimum the keys:\n\nrule – rule type (minLineWidth, minClearance, …)\n\nlimit_um – limit value in micrometres\n\nAdditional keys are rule-specific (layer, net1, primitive, …)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.convert_hole_to_conical_shape",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.convert_hole_to_conical_shape.html#convert_hole_to_conical_shape",
        "title": "convert_hole_to_conical_shape",
        "section": "convert_hole_to_conical_shape",
        "text": "Convert actual padstack instance to microvias 3D Objects with a given aspect ratio.\nAngle of laser penetration in degrees. The angle defines the lowest hole diameter with this formula:\nHoleDiameter -2*tan(laser_angle* Hole depth). Hole depth is the height of the via (dielectric thickness).\nThe default is 75.\nThe lowest hole is 0.75*HoleDepth/HoleDiam.\nconvert_hole_to_conical_shape\npython:float\noptional\n75\n0.75*HoleDepth/HoleDiam"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.convert_hole_to_conical_shape",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.convert_hole_to_conical_shape.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.convert_hole_to_conical_shape",
        "title": "convert_hole_to_conical_shape > convert_hole_to_conical_shape > convert_hole_to_conical_shape",
        "section": "convert_hole_to_conical_shape > convert_hole_to_conical_shape",
        "text": "EDBPadstackInstance.convert_hole_to_conical_shape(angle=75)\n\nConvert actual padstack instance to microvias 3D Objects with a given aspect ratio.\n\nParameters\n\nangle\n\npython:float, optional\n\nAngle of laser penetration in degrees. The angle defines the lowest hole diameter with this formula:\nHoleDiameter -2*tan(laser_angle* Hole depth). Hole depth is the height of the via (dielectric thickness).\nThe default is 75.\nThe lowest hole is 0.75*HoleDepth/HoleDiam.\n\nReturns\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.add_void",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.add_void.html#add_void",
        "title": "add_void",
        "section": "add_void",
        "text": "Add a void to current primitive.\nTrue if successful, either  False.\nadd_void\npython:list\npyedb.dotnet.database.edb_data.primitives_data.EDBPrimitives\nEDB\nPrimitive\nPoint\npython:list\nin\nthe\nformat\nof\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.add_void",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.add_void.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.add_void",
        "title": "add_void > add_void > add_void",
        "section": "add_void > add_void",
        "text": "EdbPolygon.add_void(point_list)\n\nAdd a void to current primitive.\n\nParameters\n\npoint_list\n\npython:list or pyedb.dotnet.database.edb_data.primitives_data.EDBPrimitives             or EDB Primitive Object. Point python:list in the format of [[x1,y1], [x2,y2],..,[xn,yn]].\n\n\n\nReturns\n\nbool\n\nTrue if successful, either  False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.delete",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete this primitive.\ndelete"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.delete",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.delete.html#pyedb.dotnet.database.edb_data.ports.WavePort.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "WavePort.delete()\n\nDelete this primitive.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.expand",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.expand.html#expand",
        "title": "expand",
        "section": "expand",
        "text": "Expand the polygon shape by an absolute value in all direction.\nOffset can be negative for negative expansion.\nOffset value in meters.\nTolerance in meters.\nWhether to round corners or not.\nIf True, use rounded corners in the expansion otherwise use straight edges (can be degenerate).\nThe maximum corner extension (when round corners are not used) at which point the corner is clipped.\nexpand\npython:float\noptional\npython:float\noptional\noptional\npython:float\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.expand",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.expand.html#pyedb.grpc.database.primitive.polygon.Polygon.expand",
        "title": "expand > expand > expand",
        "section": "expand > expand",
        "text": "Polygon.expand(offset=0.001, tolerance=1e-12, round_corners=True, maximum_corner_extension=0.001) -> list[any]\n\nExpand the polygon shape by an absolute value in all direction.\nOffset can be negative for negative expansion.\n\nParameters\n\noffset\n\npython:float, optional\n\nOffset value in meters.\n\ntolerance\n\npython:float, optional\n\nTolerance in meters.\n\nround_corners\n\nbool, optional\n\nWhether to round corners or not.\nIf True, use rounded corners in the expansion otherwise use straight edges (can be degenerate).\n\nmaximum_corner_extension\n\npython:float, optional\n\nThe maximum corner extension (when round corners are not used) at which point the corner is clipped.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.AdvancedMeshSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.AdvancedMeshSettings.html#advancedmeshsettings",
        "title": "AdvancedMeshSettings",
        "section": "AdvancedMeshSettings",
        "text": "Manages EDB methods for advanced mesh settings.\nAdvancedMeshSettings"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.AdvancedMeshSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.AdvancedMeshSettings.html#pyedb.dotnet.database.sim_setup_data.data.settings.AdvancedMeshSettings",
        "title": "AdvancedMeshSettings > AdvancedMeshSettings > AdvancedMeshSettings",
        "section": "AdvancedMeshSettings > AdvancedMeshSettings",
        "text": "class pyedb.dotnet.database.sim_setup_data.data.settings.AdvancedMeshSettings(parent)\n\nManages EDB methods for advanced mesh settings.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_primitive_by_layer_and_point",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_primitive_by_layer_and_point.html#get_primitive_by_layer_and_point",
        "title": "get_primitive_by_layer_and_point",
        "section": "get_primitive_by_layer_and_point",
        "text": "Get primitive at specified point on layer.\n[x, y] coordinate point.\nLayer name(s) to filter by.\nNet name(s) to filter by.\nList of primitive objects at the point.\nIf point is invalid.\nget_primitive_by_layer_and_point\npython:list\noptional\npython:str\npython:list\noptional\npython:str\npython:list\noptional\npython:list\nValueError"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_primitive_by_layer_and_point",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_primitive_by_layer_and_point.html#pyedb.grpc.database.modeler.Modeler.get_primitive_by_layer_and_point",
        "title": "get_primitive_by_layer_and_point > get_primitive_by_layer_and_point > get_primitive_by_layer_and_point",
        "section": "get_primitive_by_layer_and_point > get_primitive_by_layer_and_point",
        "text": "Modeler.get_primitive_by_layer_and_point(point: List[float] | None = None, layer: str | List[str] | None = None, nets: str | List[str] | None = None) -> List[Primitive]\n\nGet primitive at specified point on layer.\n\nParameters\n\npoint\n\npython:list, optional\n\n[x, y] coordinate point.\n\nlayer\n\npython:str or python:list, optional\n\nLayer name(s) to filter by.\n\nnets\n\npython:str or python:list, optional\n\nNet name(s) to filter by.\n\nReturns\n\npython:list\n\nList of primitive objects at the point.\n\nRaises\n\nValueError\n\nIf point is invalid.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.back_drill_stub_length",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.back_drill_stub_length.html#back_drill_stub_length",
        "title": "back_drill_stub_length",
        "section": "back_drill_stub_length",
        "text": "back_drill_stub_length"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.back_drill_stub_length",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.back_drill_stub_length.html#pyedb.workflows.drc.drc.Rules.back_drill_stub_length",
        "title": "back_drill_stub_length > back_drill_stub_length > back_drill_stub_length",
        "section": "back_drill_stub_length > back_drill_stub_length",
        "text": "Rules.back_drill_stub_length: List[BackDrillStubLength]\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_terminal.html#create_terminal",
        "title": "create_terminal",
        "section": "create_terminal",
        "text": "Create a padstack instance terminal.\nPadstackInstanceTerminal object.\ncreate_terminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_terminal.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_terminal",
        "title": "create_terminal > create_terminal > create_terminal",
        "section": "create_terminal > create_terminal",
        "text": "PadstackInstance.create_terminal(name=None) -> PadstackInstanceTerminal\n\nCreate a padstack instance terminal.\n\nReturns\n\n:class:`PadstackInstanceTerminal <pyedb.grpc.database.terminal.padstack_instance_terminal.\n\n\n\nPadstackInstanceTerminal>`\n\nPadstackInstanceTerminal object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create_3d_comp.html#create_3d_comp",
        "title": "create_3d_comp",
        "section": "create_3d_comp",
        "text": "Create a 3D composite model from an MCAD file.\n3D composite model created.\ncreate_3d_comp\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create_3d_comp.html#pyedb.grpc.database.primitive.path.Path.create_3d_comp",
        "title": "create_3d_comp > create_3d_comp > create_3d_comp",
        "section": "create_3d_comp > create_3d_comp",
        "text": "Path.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nReturns\n\nMcadModel\n\n3D composite model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_layer_top",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_layer_top.html#add_layer_top",
        "title": "add_layer_top",
        "section": "add_layer_top",
        "text": "Add a layer on top of the stackup.\nName of the layer.\nType of the layer. The default is \"signal\". Options are \"signal\" and \"dielectric\".\nAdditional keyword arguments. Possible keys are:\n- thickness : float, layer thickness.\n- material : str, layer material.\nLayer object created.\nadd_layer_top\npython:str\npython:str\noptional\n\"signal\"\n\"signal\"\n\"dielectric\"\npython:dict\noptional\nthickness\nmaterial\npyedb.grpc.database.layers.stackup_layer.StackupLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_layer_top",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_layer_top.html#pyedb.grpc.database.stackup.LayerCollection.add_layer_top",
        "title": "add_layer_top > add_layer_top > add_layer_top",
        "section": "add_layer_top > add_layer_top",
        "text": "LayerCollection.add_layer_top(name: str, layer_type: str = 'signal', **kwargs) -> Layer | None\n\nAdd a layer on top of the stackup.\n\nParameters\n\nname\n\npython:str\n\nName of the layer.\n\nlayer_type\n\npython:str, optional\n\nType of the layer. The default is \"signal\". Options are \"signal\" and \"dielectric\".\n\n**kwargs\n\npython:dict, optional\n\nAdditional keyword arguments. Possible keys are:\n- thickness : float, layer thickness.\n- material : str, layer material.\n\nReturns\n\npyedb.grpc.database.layers.stackup_layer.StackupLayer\n\nLayer object created.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> top_layer = edb.stackup.add_layer_top(\n...     \"NewTopLayer\", layer_type=\"signal\", thickness=\"0.1mm\", material=\"copper\"\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.add_frequency_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.add_frequency_sweep.html#add_frequency_sweep",
        "title": "add_frequency_sweep",
        "section": "add_frequency_sweep",
        "text": "Add frequency sweep.\nName of the frequency sweep. The default is None.\nList of frequency points. The default is None.\nadd_frequency_sweep\npython:str\noptional\nNone\npython:list\noptional\nNone\npyedb.dotnet.database.edb_data.simulation_setup_data.EdbFrequencySweep"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.add_frequency_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.add_frequency_sweep.html#pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.add_frequency_sweep",
        "title": "add_frequency_sweep > add_frequency_sweep > add_frequency_sweep",
        "section": "add_frequency_sweep > add_frequency_sweep",
        "text": "SiwaveDCSimulationSetup.add_frequency_sweep(name=None, frequency_sweep=None)\n\nAdd frequency sweep.\n\nParameters\n\nname\n\npython:str, optional\n\nName of the frequency sweep. The default is None.\n\nfrequency_sweep\n\npython:list, optional\n\nList of frequency points. The default is None.\n\nReturns\n\npyedb.dotnet.database.edb_data.simulation_setup_data.EdbFrequencySweep\n\n\n\nExamples\n\n>>> setup1 = edbapp.create_siwave_syz_setup(\"setup1\")\n>>> setup1.add_frequency_sweep(\n...     frequency_sweep=[\n...         [\"linear count\", \"0\", \"1kHz\", 1],\n...         [\"log scale\", \"1kHz\", \"0.1GHz\", 10],\n...         [\"linear scale\", \"0.1GHz\", \"10GHz\", \"0.1GHz\"],\n...     ]\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileStackup.add_dielectric",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileStackup.add_dielectric.html#add_dielectric",
        "title": "add_dielectric",
        "section": "add_dielectric",
        "text": "Add a new dielectric layer.\nDielectric layer name.\nStacking order index. Auto-assigned if None.\nMaterial name.\nLayer thickness.\nAdditional properties. Overrides default parameters.\nExisting layer name for relative placement.\nWhether to add on top of base layer. Default is True.\nCreated dielectric layer object.\nadd_dielectric\npython:str\npython:int\noptional\nNone\npython:str\npython:float\npython:dict\noptional\npython:str\noptional\noptional\nTrue\nControlFileDielectric"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileStackup.add_dielectric",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileStackup.add_dielectric.html#pyedb.grpc.database.control_file.ControlFileStackup.add_dielectric",
        "title": "add_dielectric > add_dielectric > add_dielectric",
        "section": "add_dielectric > add_dielectric",
        "text": "ControlFileStackup.add_dielectric(layer_name: str, layer_index: int | None = None, material: str = '', thickness: float = 0.0, properties: Dict[str, Any] | None = None, base_layer: str | None = None, add_on_top: bool = True) -> ControlFileDielectric\n\nAdd a new dielectric layer.\n\nParameters\n\nlayer_name\n\npython:str\n\nDielectric layer name.\n\nlayer_index\n\npython:int, optional\n\nStacking order index. Auto-assigned if None.\n\nmaterial\n\npython:str\n\nMaterial name.\n\nthickness\n\npython:float\n\nLayer thickness.\n\nproperties\n\npython:dict, optional\n\nAdditional properties. Overrides default parameters.\n\nbase_layer\n\npython:str, optional\n\nExisting layer name for relative placement.\n\nadd_on_top\n\nbool, optional\n\nWhether to add on top of base layer. Default is True.\n\nReturns\n\nControlFileDielectric\n\nCreated dielectric layer object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.delete_primitives",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.delete_primitives.html#delete_primitives",
        "title": "delete_primitives",
        "section": "delete_primitives",
        "text": "Delete primitives by net name(s).\nNet name(s).\nTrue if successful, False otherwise.\ndelete_primitives\npython:str\npython:list"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.delete_primitives",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.delete_primitives.html#pyedb.grpc.database.modeler.Modeler.delete_primitives",
        "title": "delete_primitives > delete_primitives > delete_primitives",
        "section": "delete_primitives > delete_primitives",
        "text": "Modeler.delete_primitives(net_names: str | List[str]) -> bool\n\nDelete primitives by net name(s).\n\nParameters\n\nnet_names\n\npython:str or python:list\n\nNet name(s).\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the terminal object to the correct concrete type, fetching the type if necessary.\ncast\nTerminalType\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.cast.html#pyedb.grpc.database.ports.ports.BundleWavePort.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "BundleWavePort.cast(term_type=None)\n\nCast the terminal object to the correct concrete type, fetching the type if necessary.\n\nParameters\n\nterm_type\n\nTerminalType\n\n\n\nReturns\n\nTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetClassData.delete",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetClassData.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Edb Dotnet Api Database Delete.\ndelete"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetClassData.delete",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetClassData.delete.html#pyedb.dotnet.database.edb_data.nets_data.EDBNetClassData.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "EDBNetClassData.delete()\n\nEdb Dotnet Api Database Delete.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.close",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.close.html#close",
        "title": "close",
        "section": "close",
        "text": "Close EDB and cleanup variables.\nTrue when successful, False when failed.\nclose\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.close",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.close.html#pyedb.dotnet.edb.Edb.close",
        "title": "close > close > close",
        "section": "close > close",
        "text": "Edb.close(**kwargs)\n\nClose EDB and cleanup variables.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.defeature_polygon",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.defeature_polygon.html#defeature_polygon",
        "title": "defeature_polygon",
        "section": "defeature_polygon",
        "text": "Defeature the polygon based on the maximum surface deviation criteria.\nPolygon to defeature.\nMaximum tolerance criteria. The default is 0.001.\nTrue when successful, False when failed.\ndefeature_polygon\npython:float\nEdb\nPolygon\nprimitive\npython:float\noptional\n0.001\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.defeature_polygon",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.defeature_polygon.html#pyedb.dotnet.database.modeler.Modeler.defeature_polygon",
        "title": "defeature_polygon > defeature_polygon > defeature_polygon",
        "section": "defeature_polygon > defeature_polygon",
        "text": "Modeler.defeature_polygon(poly, tolerance=0.001)\n\nDefeature the polygon based on the maximum surface deviation criteria.\n\nParameters\n\nmaximum_surface_deviation\n\npython:float\n\n\n\npoly\n\nEdb Polygon primitive\n\nPolygon to defeature.\n\ntolerance\n\npython:float, optional\n\nMaximum tolerance criteria. The default is 0.001.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.build_simulation_project",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.build_simulation_project.html#build_simulation_project",
        "title": "build_simulation_project",
        "section": "build_simulation_project",
        "text": "Build a ready-to-solve simulation project.\nSimulationConfiguration object that can be instantiated or directly loaded with a\nconfiguration file.\nTrue when successful, False when Failed.\nbuild_simulation_project\npyedb.dotnet.database.edb_data.simulation_configuration.SimulationConfiguration\nTrue\nFailed"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.build_simulation_project",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.build_simulation_project.html#pyedb.dotnet.edb.Edb.build_simulation_project",
        "title": "build_simulation_project > build_simulation_project > build_simulation_project",
        "section": "build_simulation_project > build_simulation_project",
        "text": "Edb.build_simulation_project(simulation_setup: SimulationConfiguration) -> bool\n\nBuild a ready-to-solve simulation project.\n\nParameters\n\nsimulation_setup\n\npyedb.dotnet.database.edb_data.simulation_configuration.SimulationConfiguration.\n\nSimulationConfiguration object that can be instantiated or directly loaded with a\nconfiguration file.\n\nReturns\n\nbool\n\nTrue when successful, False when Failed.\n\nExamples\n\n>>> from pyedb import Edb\n>>> from pyedb.dotnet.database.edb_data.simulation_configuration import SimulationConfiguration\n>>> config_file = path_configuration_file\n>>> source_file = path_to_edb_folder\n>>> edb = Edb(source_file)\n>>> sim_setup = SimulationConfiguration(config_file)\n>>> edb.build_simulation_project(sim_setup)\n>>> edb.save_edb()\n>>> edb.close_edb()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get the list of property IDs for a given property ID.\nProduct ID.\nAttribute IDs for the given product ID.\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.get_product_property_ids.html#pyedb.grpc.database.definition.package_def.PackageDef.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "PackageDef.get_product_property_ids(prod_id)\n\nGet the list of property IDs for a given property ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nProduct ID.\n\nReturns\n\npython:list[python:int]\n\nAttribute IDs for the given product ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.couple_ports",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.couple_ports.html#couple_ports",
        "title": "couple_ports",
        "section": "couple_ports",
        "text": "Create a bundle wave port.\nPorts to be added.\ncouple_ports\nWaveport\nBundleWavePort"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.couple_ports",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.couple_ports.html#pyedb.grpc.database.ports.ports.CircuitPort.couple_ports",
        "title": "couple_ports > couple_ports > couple_ports",
        "section": "couple_ports > couple_ports",
        "text": "CircuitPort.couple_ports(port)\n\nCreate a bundle wave port.\n\nParameters\n\nport\n\nWaveport,\n\n\n\n:class:`GapPOrt <pyedb.grpc.database.ports.ports.GapPort>`, list, optional\n\nPorts to be added.\n\nReturns\n\nBundleWavePort\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.set_solution_broadband",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.set_solution_broadband.html#set_solution_broadband",
        "title": "set_solution_broadband",
        "section": "set_solution_broadband",
        "text": "Set solution to broadband.\nLow frequency value.\nHigh frequency value.\nMax delta S value.\nMaximum number of passes.\nset_solution_broadband\npython:str\npython:str\npython:float\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.set_solution_broadband",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.set_solution_broadband.html#pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.set_solution_broadband",
        "title": "set_solution_broadband > set_solution_broadband > set_solution_broadband",
        "section": "set_solution_broadband > set_solution_broadband",
        "text": "HfssSimulationSetup.set_solution_broadband(low_frequency='1GHz', high_frequency='10GHz', max_delta_s=0.02, max_num_passes=10)\n\nSet solution to broadband.\n\nParameters\n\nlow_frequency\n\npython:str\n\nLow frequency value.\n\nhigh_frequency\n\npython:str\n\nHigh frequency value.\n\nmax_delta_s\n\npython:float\n\nMax delta S value.\n\nmax_num_passes\n\npython:int\n\nMaximum number of passes.\n\nReturns\n\nbool.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/materials",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/materials.html#component-definition",
        "title": "Component Definition",
        "section": "Component Definition",
        "text": "These class is the containers of Component definition.\nMaterialProperties\nStore material properties.\nMaterial\nManage EDB methods for material property management.\nMaterials\nManages EDB methods for material management accessible from Edb.materials property.\nComponent Definition\nMaterialProperties\nMaterial\nMaterials"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData.html#edbextendednetdata",
        "title": "EDBExtendedNetData",
        "section": "EDBExtendedNetData",
        "text": "Manages EDB functionalities for a primitives.\nIt Inherits EDB Object properties.\nEDBExtendedNetData.add_net(name)\nAdd a new net.\nEDBExtendedNetData.api_create(name)\nEdb Dotnet Api Database Edb.ExtendedNet.Create.\nEDBExtendedNetData.delete()\nEdb Dotnet Api Database Delete.\nEDBExtendedNetData.find_by_name(layout, net)\nEdb Dotnet Api Database Edb.ExtendedNet.FindByName.\nEDBExtendedNetData\nEDBExtendedNetData.add_net\nEDBExtendedNetData.api_create\nEDBExtendedNetData.delete\nEDBExtendedNetData.find_by_name"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData.html#pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData",
        "title": "EDBExtendedNetData > EDBExtendedNetData > EDBExtendedNetData",
        "section": "EDBExtendedNetData > EDBExtendedNetData",
        "text": "class pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData(core_app, raw_extended_net=None)\n\nManages EDB functionalities for a primitives.\nIt Inherits EDB Object properties.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb(myedb, edbversion=\"2021.2\")\n>>> edb_extended_net = edb.nets.extended_nets[\"GND\"]\n>>> edb_extended_net.name  # Class Property\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nEDBExtendedNetData.add_net(name)\n\nAdd a new net.\n\nEDBExtendedNetData.api_create(name)\n\nEdb Dotnet Api Database Edb.ExtendedNet.Create.\n\nEDBExtendedNetData.delete()\n\nEdb Dotnet Api Database Delete.\n\nEDBExtendedNetData.find_by_name(layout, net)\n\nEdb Dotnet Api Database Edb.ExtendedNet.FindByName.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.layout_obj_type.html#pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "EdgeTerminal.layout_obj_type = 2\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.import_bom",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.import_bom.html#import_bom",
        "title": "import_bom",
        "section": "import_bom",
        "text": "Import BOM file.\nBOM file path.\nDelimiter character.\nReference designator column index.\nPart name column index.\nComponent type column index.\nValue column index.\nTrue if successful, False otherwise.\nimport_bom\npython:str\npython:str\noptional\npython:int\noptional\npython:int\noptional\npython:int\noptional\npython:int\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.import_bom",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.import_bom.html#pyedb.grpc.database.components.Components.import_bom",
        "title": "import_bom > import_bom > import_bom",
        "section": "import_bom > import_bom",
        "text": "Components.import_bom(bom_file: str, delimiter: str = ',', refdes_col: int = 0, part_name_col: int = 1, comp_type_col: int = 2, value_col: int = 3) -> bool\n\nImport BOM file.\n\nParameters\n\nbom_file\n\npython:str\n\nBOM file path.\n\ndelimiter\n\npython:str, optional\n\nDelimiter character.\n\nrefdes_col\n\npython:int, optional\n\nReference designator column index.\n\npart_name_col\n\npython:int, optional\n\nPart name column index.\n\ncomp_type_col\n\npython:int, optional\n\nComponent type column index.\n\nvalue_col\n\npython:int, optional\n\nValue column index.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\nExamples\n\n>>> edbapp.components.import_bom(\"bom.csv\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.area",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.area.html#area",
        "title": "area",
        "section": "area",
        "text": "Return the total area.\nEither if the voids have to be included in computation.\nThe default value is True.\narea\noptional\nTrue\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.area",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.area.html#pyedb.grpc.database.primitive.rectangle.Rectangle.area",
        "title": "area > area > area",
        "section": "area > area",
        "text": "Rectangle.area(include_voids=True) -> float\n\nReturn the total area.\n\nParameters\n\ninclude_voids\n\nbool, optional\n\nEither if the voids have to be included in computation.\nThe default value is True.\n\nReturns\n\npython:float\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.set_si_slider",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.set_si_slider.html#set_si_slider",
        "title": "set_si_slider",
        "section": "set_si_slider",
        "text": "Set SIwave SI simulation accuracy level.\nOptions are:\n- 0: Optimal speed;\n- 1:  Balanced;\n- 2: Optimal accuracy```.\nset_si_slider\n0\n1\n2"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.set_si_slider",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.set_si_slider.html#pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.set_si_slider",
        "title": "set_si_slider > set_si_slider > set_si_slider",
        "section": "set_si_slider > set_si_slider",
        "text": "SiwaveSimulationSetup.set_si_slider(value)\n\nSet SIwave SI simulation accuracy level.\n\nOptions are:\n- 0: Optimal speed;\n- 1:  Balanced;\n- 2: Optimal accuracy```.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.find_layer_by_name",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.find_layer_by_name.html#find_layer_by_name",
        "title": "find_layer_by_name",
        "section": "find_layer_by_name",
        "text": "Finds a layer with the given name.\nfind_layer_by_name"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.find_layer_by_name",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.find_layer_by_name.html#pyedb.dotnet.database.stackup.Stackup.find_layer_by_name",
        "title": "find_layer_by_name > find_layer_by_name > find_layer_by_name",
        "section": "find_layer_by_name > find_layer_by_name",
        "text": "Stackup.find_layer_by_name(name: str)\n\nFinds a layer with the given name.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_dielectric_material",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_dielectric_material.html#add_dielectric_material",
        "title": "add_dielectric_material",
        "section": "add_dielectric_material",
        "text": "Add a new dielectric material in library.\nName of the new material.\nPermittivity of the new material.\nDielectric loss tangent of the new material.\nMaterial object.\nadd_dielectric_material\npython:str\npython:str\npython:float\npython:int\npython:str\npython:float\npython:int\nMaterial"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_dielectric_material",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_dielectric_material.html#pyedb.grpc.database.definition.materials.Materials.add_dielectric_material",
        "title": "add_dielectric_material > add_dielectric_material > add_dielectric_material",
        "section": "add_dielectric_material > add_dielectric_material",
        "text": "Materials.add_dielectric_material(name, permittivity, dielectric_loss_tangent, **kwargs) -> Material\n\nAdd a new dielectric material in library.\n\nParameters\n\nname\n\npython:str\n\nName of the new material.\n\npermittivity\n\npython:str, python:float, python:int\n\nPermittivity of the new material.\n\ndielectric_loss_tangent\n\npython:str, python:float, python:int\n\nDielectric loss tangent of the new material.\n\nReturns\n\nMaterial\n\nMaterial object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlProperty",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlProperty.html#controlproperty",
        "title": "ControlProperty",
        "section": "ControlProperty",
        "text": "ControlProperty"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlProperty",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlProperty.html#pyedb.dotnet.database.edb_data.control_file.ControlProperty",
        "title": "ControlProperty > ControlProperty > ControlProperty",
        "section": "ControlProperty > ControlProperty",
        "text": "class pyedb.dotnet.database.edb_data.control_file.ControlProperty(property_name, value)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.get_product_property_ids.html#pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "EdgeTerminal.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.make_zone_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.make_zone_primitive.html#make_zone_primitive",
        "title": "make_zone_primitive",
        "section": "make_zone_primitive",
        "text": "Make the primitive a zone primitive with a zone specified by the provided ID.\nID of the zone primitive to use.\nmake_zone_primitive\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.make_zone_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.make_zone_primitive.html#pyedb.grpc.database.primitive.bondwire.Bondwire.make_zone_primitive",
        "title": "make_zone_primitive > make_zone_primitive > make_zone_primitive",
        "section": "make_zone_primitive > make_zone_primitive",
        "text": "Bondwire.make_zone_primitive(zone_id: int)\n\nMake the primitive a zone primitive with a zone specified by the provided ID.\n\nParameters\n\nzone_id\n\npython:int\n\nID of the zone primitive to use.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.html#materials",
        "title": "Materials",
        "section": "Materials",
        "text": "Manages EDB methods for material management accessible from Edb.materials property.\nMaterials.add_conductor_material(name[, ...])\nAdd a new conductor material.\nMaterials.add_debye_material(name, ...)\nAdd a dielectric with the Debye model.\nMaterials.add_dielectric_material(name, ...)\nAdd a new dielectric material in library.\nMaterials.add_djordjevicsarkar_dielectric(...)\nAdd a dielectric using the Djordjevic-Sarkar model.\nMaterials.add_material(name, **kwargs)\nAdd a new material.\nMaterials.add_multipole_debye_material(name, ...)\nAdd a dielectric with the Multipole Debye model.\nMaterials.delete_material(material_name)\nRemove a material from the database.\nMaterials.duplicate(material_name, ...)\nDuplicate a material from the database.\nMaterials.iterate_materials_in_amat([amat_file])\nIterate over material description in an AMAT file.\nMaterials.load_amat(amat_file)\nLoad materials from an AMAT file.\nMaterials.load_material(material)\nLoad material.\nMaterials.material_property_to_id(property_name)\nConvert a material property name to a material property ID.\nMaterials.read_materials(amat_file)\nRead materials from an AMAT file.\nMaterials.read_syslib_material(material_name)\nRead a specific material from syslib AMAT file.\nMaterials.update_material(material_name, ...)\nUpdate material attributes.\nMaterials.update_materials_from_sys_library([...])\nUpdate material properties from syslib AMAT file.\nMaterials.default_conductor_property_values\n\nMaterials.default_dielectric_property_values\n\nMaterials\nMaterials.add_conductor_material\nMaterials.add_debye_material\nMaterials.add_dielectric_material\nMaterials.add_djordjevicsarkar_dielectric\nMaterials.add_material\nMaterials.add_multipole_debye_material\nMaterials.delete_material\nMaterials.duplicate\nMaterials.iterate_materials_in_amat\nMaterials.load_amat\nMaterials.load_material\nMaterials.material_property_to_id\nMaterials.read_materials\nMaterials.read_syslib_material\nMaterials.update_material\nMaterials.update_materials_from_sys_library\nMaterials.default_conductor_property_values\nMaterials.default_dielectric_property_values"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.html#pyedb.dotnet.database.materials.Materials",
        "title": "Materials > Materials > Materials",
        "section": "Materials > Materials",
        "text": "class pyedb.dotnet.database.materials.Materials(edb: Edb)\n\nManages EDB methods for material management accessible from Edb.materials property.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nMaterials.add_conductor_material(name[, ...])\n\nAdd a new conductor material.\n\nMaterials.add_debye_material(name, ...)\n\nAdd a dielectric with the Debye model.\n\nMaterials.add_dielectric_material(name, ...)\n\nAdd a new dielectric material in library.\n\nMaterials.add_djordjevicsarkar_dielectric(...)\n\nAdd a dielectric using the Djordjevic-Sarkar model.\n\nMaterials.add_material(name, **kwargs)\n\nAdd a new material.\n\nMaterials.add_multipole_debye_material(name, ...)\n\nAdd a dielectric with the Multipole Debye model.\n\nMaterials.delete_material(material_name)\n\nRemove a material from the database.\n\nMaterials.duplicate(material_name, ...)\n\nDuplicate a material from the database.\n\nMaterials.iterate_materials_in_amat([amat_file])\n\nIterate over material description in an AMAT file.\n\nMaterials.load_amat(amat_file)\n\nLoad materials from an AMAT file.\n\nMaterials.load_material(material)\n\nLoad material.\n\nMaterials.material_property_to_id(property_name)\n\nConvert a material property name to a material property ID.\n\nMaterials.read_materials(amat_file)\n\nRead materials from an AMAT file.\n\nMaterials.read_syslib_material(material_name)\n\nRead a specific material from syslib AMAT file.\n\nMaterials.update_material(material_name, ...)\n\nUpdate material attributes.\n\nMaterials.update_materials_from_sys_library([...])\n\nUpdate material properties from syslib AMAT file.\n\n\n\nAttributes\n\n\n\n\n\n\n\nMaterials.default_conductor_property_values\n\n\n\nMaterials.default_dielectric_property_values\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.hfss_extent_info.HfssExtentInfo.export_config",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.hfss_extent_info.HfssExtentInfo.export_config.html#export_config",
        "title": "export_config",
        "section": "export_config",
        "text": "Export HFSS extent information.\nParameters of the HFSS extent information.\nexport_config\npython:dict"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.hfss_extent_info.HfssExtentInfo.export_config",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.hfss_extent_info.HfssExtentInfo.export_config.html#pyedb.grpc.database.utility.hfss_extent_info.HfssExtentInfo.export_config",
        "title": "export_config > export_config > export_config",
        "section": "export_config > export_config",
        "text": "HfssExtentInfo.export_config()\n\nExport HFSS extent information.\n\nReturns\n\npython:dict\n\nParameters of the HFSS extent information.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_copper_balance",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_copper_balance.html#add_copper_balance",
        "title": "add_copper_balance",
        "section": "add_copper_balance",
        "text": "Append a copper-density balance rule.\nRule identifier.\nMaximum allowed copper imbalance in percent (e.g. 15 for 15%).\nList of layer names to apply the rule to.\nSelf to enable method chaining.\nadd_copper_balance\npython:str\npython:int\n15\npython:list\npython:str\nRules"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_copper_balance",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_copper_balance.html#pyedb.workflows.drc.drc.Rules.add_copper_balance",
        "title": "add_copper_balance > add_copper_balance > add_copper_balance",
        "section": "add_copper_balance > add_copper_balance",
        "text": "Rules.add_copper_balance(name: str, max_percent: int, layers: list[str]) -> Rules\n\nAppend a copper-density balance rule.\n\nParameters\n\nname\n\npython:str\n\nRule identifier.\n\nmax_percent\n\npython:int\n\nMaximum allowed copper imbalance in percent (e.g. 15 for 15%).\n\nlayers\n\npython:list[python:str]\n\nList of layer names to apply the rule to.\n\nReturns\n\nRules\n\nSelf to enable method chaining.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.variables.Variable.delete",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.variables.Variable.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete this variable.\nTrue when successful, False when failed.\ndelete\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.variables.Variable.delete",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.variables.Variable.delete.html#pyedb.dotnet.database.edb_data.variables.Variable.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "Variable.delete()\n\nDelete this variable.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> edb.design_variables[\"new_variable\"].delete()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.AdaptiveSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.AdaptiveSettings.html#adaptivesettings",
        "title": "AdaptiveSettings",
        "section": "AdaptiveSettings",
        "text": "Manages EDB methods for adaptive settings.\nAdaptiveSettings.add_adaptive_frequency_data([...])\nAdd a setup for frequency data.\nAdaptiveSettings.add_broadband_adaptive_frequency_data([...])\nAdd a setup for frequency data.\nAdaptiveSettings.add_multi_frequency_adaptive_setup(...)\nAdd a setup for frequency data.\nAdaptiveSettings\nAdaptiveSettings.add_adaptive_frequency_data\nAdaptiveSettings.add_broadband_adaptive_frequency_data\nAdaptiveSettings.add_multi_frequency_adaptive_setup"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.AdaptiveSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.AdaptiveSettings.html#pyedb.dotnet.database.sim_setup_data.data.settings.AdaptiveSettings",
        "title": "AdaptiveSettings > AdaptiveSettings > AdaptiveSettings",
        "section": "AdaptiveSettings > AdaptiveSettings",
        "text": "class pyedb.dotnet.database.sim_setup_data.data.settings.AdaptiveSettings(parent)\n\nManages EDB methods for adaptive settings.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nAdaptiveSettings.add_adaptive_frequency_data([...])\n\nAdd a setup for frequency data.\n\nAdaptiveSettings.add_broadband_adaptive_frequency_data([...])\n\nAdd a setup for frequency data.\n\nAdaptiveSettings.add_multi_frequency_adaptive_setup(...)\n\nAdd a setup for frequency data.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.subtract",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.subtract.html#subtract",
        "title": "subtract",
        "section": "subtract",
        "text": "Subtract active primitive with one or more primitives.\nor: List[Primitives]\nor: class:PolygonData <ansys.edb.core.geometry.polygon_data.PolygonData>\nList of Primitive objects.\nsubtract\nPrimitives\nPrimitives\nList\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.subtract",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.subtract.html#pyedb.grpc.database.primitive.circle.Circle.subtract",
        "title": "subtract > subtract > subtract",
        "section": "subtract > subtract",
        "text": "Circle.subtract(primitives) -> list[any]\n\nSubtract active primitive with one or more primitives.\n\nParameters\n\nprimitives\n\nPrimitives\n\nor: List[Primitives]\nor: class:PolygonData <ansys.edb.core.geometry.polygon_data.PolygonData>\n\nReturns\n\nList[Primitive]\n\nList of Primitive objects.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_edb",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_edb.html#export_edb",
        "title": "export_edb",
        "section": "export_edb",
        "text": "Export the layout as EDB.\nPath to the EDB.\nexport_edb\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_edb",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_edb.html#pyedb.siwave.Siwave.export_edb",
        "title": "export_edb > export_edb > export_edb",
        "section": "export_edb > export_edb",
        "text": "Siwave.export_edb(file_path: str)\n\nExport the layout as EDB.\n\nParameters\n\nfile_path\n\npython:str\n\nPath to the EDB.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.html#edgeterminal",
        "title": "EdgeTerminal",
        "section": "EdgeTerminal",
        "text": "EdgeTerminal.cast([term_type])\nCast the terminal object to the correct concrete type, fetching the type if necessary.\nEdgeTerminal.couple_ports(port)\nCreate a bundle wave port.\nEdgeTerminal.create(layout, name, edges[, ...])\nCreate an edge terminal.\nEdgeTerminal.create_3d_comp()\nCreate a 3D composite model from an MCAD file.\nEdgeTerminal.create_hfss()\nCreate an HFSS model from an MCAD file.\nEdgeTerminal.create_stride()\nCreate a Stride model from an MCAD file.\nEdgeTerminal.delete()\nDelete the layout object.\nEdgeTerminal.find(layout, name)\nFind a terminal by name in a given layout.\nEdgeTerminal.find_by_id(layout, uid)\nFind a Connectable object by database ID in a given layout.\nEdgeTerminal.get_product_property(prod_id, ...)\nGet the product property of the layout object for a given product ID and attribute ID.\nEdgeTerminal.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nEdgeTerminal.product_solver_names(product_id)\nGet the list of solver names.\nEdgeTerminal.product_solver_option(...)\nGet the name of the product solver option.\nEdgeTerminal.set_product_property(prod_id, ...)\nSet the product property of the layout object for a given product ID and attribute ID.\nEdgeTerminal.set_product_solver_option(...)\nSet the product solver option.\nEdgeTerminal.layout_obj_type\n\nEdgeTerminal.type\n\nEdgeTerminal\nEdgeTerminal.cast\nEdgeTerminal.couple_ports\nEdgeTerminal.create\nEdgeTerminal.create_3d_comp\nEdgeTerminal.create_hfss\nEdgeTerminal.create_stride\nEdgeTerminal.delete\nEdgeTerminal.find\nEdgeTerminal.find_by_id\nEdgeTerminal.get_product_property\nEdgeTerminal.get_product_property_ids\nEdgeTerminal.product_solver_names\nEdgeTerminal.product_solver_option\nEdgeTerminal.set_product_property\nEdgeTerminal.set_product_solver_option\nEdgeTerminal.layout_obj_type\nEdgeTerminal.type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.html#pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal",
        "title": "EdgeTerminal > EdgeTerminal > EdgeTerminal",
        "section": "EdgeTerminal > EdgeTerminal",
        "text": "class pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal(pedb, edb_object)\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nEdgeTerminal.cast([term_type])\n\nCast the terminal object to the correct concrete type, fetching the type if necessary.\n\nEdgeTerminal.couple_ports(port)\n\nCreate a bundle wave port.\n\nEdgeTerminal.create(layout, name, edges[, ...])\n\nCreate an edge terminal.\n\nEdgeTerminal.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nEdgeTerminal.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nEdgeTerminal.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nEdgeTerminal.delete()\n\nDelete the layout object.\n\nEdgeTerminal.find(layout, name)\n\nFind a terminal by name in a given layout.\n\nEdgeTerminal.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nEdgeTerminal.get_product_property(prod_id, ...)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nEdgeTerminal.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nEdgeTerminal.product_solver_names(product_id)\n\nGet the list of solver names.\n\nEdgeTerminal.product_solver_option(...)\n\nGet the name of the product solver option.\n\nEdgeTerminal.set_product_property(prod_id, ...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nEdgeTerminal.set_product_solver_option(...)\n\nSet the product solver option.\n\n\n\nAttributes\n\n\n\n\n\n\n\nEdgeTerminal.layout_obj_type\n\n\n\nEdgeTerminal.type\n\n\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_coax_port_on_component",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_coax_port_on_component.html#create_coax_port_on_component",
        "title": "create_coax_port_on_component",
        "section": "create_coax_port_on_component",
        "text": "The name of the new coaxial port is automatically assigned.\nList of one or more reference designators.\nList of one or more nets.\nOnly active with grpc version. This argument is added only to ensure compatibility between DotNet and grpc.\nTrue when successful, False when failed.\ncreate_coax_port_on_component\npython:list\npython:str\npython:list\npython:str\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_coax_port_on_component",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_coax_port_on_component.html#pyedb.dotnet.database.hfss.EdbHfss.create_coax_port_on_component",
        "title": "create_coax_port_on_component > create_coax_port_on_component > create_coax_port_on_component",
        "section": "create_coax_port_on_component > create_coax_port_on_component",
        "text": "EdbHfss.create_coax_port_on_component(ref_des_list, net_list, delete_existing_terminal=False)\n\nCreate a coaxial port on a component or component list on a net or net list.\n\nThe name of the new coaxial port is automatically assigned.\n\nParameters\n\nref_des_list\n\npython:list, python:str\n\nList of one or more reference designators.\n\nnet_list\n\npython:list, python:str\n\nList of one or more nets.\n\ndelete_existing_terminal\n\nbool\n\nOnly active with grpc version. This argument is added only to ensure compatibility between DotNet and grpc.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_aedt_pin_name",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_aedt_pin_name.html#get_aedt_pin_name",
        "title": "get_aedt_pin_name",
        "section": "get_aedt_pin_name",
        "text": "Get AEDT pin name.\nPin instance.\nAEDT pin name.\nget_aedt_pin_name\npyedb.grpc.database.padstacks.PadstackInstance\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_aedt_pin_name",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_aedt_pin_name.html#pyedb.grpc.database.components.Components.get_aedt_pin_name",
        "title": "get_aedt_pin_name > get_aedt_pin_name > get_aedt_pin_name",
        "section": "get_aedt_pin_name > get_aedt_pin_name",
        "text": "Components.get_aedt_pin_name(pin: Any) -> str\n\nGet AEDT pin name.\n\nParameters\n\npin\n\npyedb.grpc.database.padstacks.PadstackInstance\n\nPin instance.\n\nReturns\n\npython:str\n\nAEDT pin name.\n\nExamples\n\n>>> name = edbapp.components.get_aedt_pin_name(pin)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_point_terminal",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_point_terminal.html#get_point_terminal",
        "title": "get_point_terminal",
        "section": "get_point_terminal",
        "text": "Place a voltage probe between two points.\nName of the terminal.\nName of the net.\nLocation of the terminal.\nLayer of the terminal.\nget_point_terminal\npython:str\npython:list\nlegacy.edb_core.edb_data.terminals.PointTerminal"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_point_terminal",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_point_terminal.html#pyedb.dotnet.edb.Edb.get_point_terminal",
        "title": "get_point_terminal > get_point_terminal > get_point_terminal",
        "section": "get_point_terminal > get_point_terminal",
        "text": "Edb.get_point_terminal(name, net_name, location, layer)\n\nPlace a voltage probe between two points.\n\nParameters\n\nname\n\nstr,\n\nName of the terminal.\n\nnet_name\n\npython:str\n\nName of the net.\n\nlocation\n\npython:list\n\nLocation of the terminal.\n\nlayer\n\nstr,\n\nLayer of the terminal.\n\nReturns\n\nlegacy.edb_core.edb_data.terminals.PointTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.Substrate.name",
        "href": "libraries/_autosummary/pyedb.libraries.common.Substrate.name.html#name",
        "title": "name",
        "section": "name",
        "text": "name"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.Substrate.name",
        "href": "libraries/_autosummary/pyedb.libraries.common.Substrate.name.html#pyedb.libraries.common.Substrate.name",
        "title": "name > name > name",
        "section": "name > name",
        "text": "Substrate.name: str = 'SUB'\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.plot",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.plot.html#plot",
        "title": "plot",
        "section": "plot",
        "text": "Plot the current polygon on matplotlib.\nWhether if plot the entire net or only the selected polygon. Default is False.\nWhether if show the plot or not. Default is True.\nSave the plot path.\nMatplotlib ax and figures.\nplot\noptional\nFalse\noptional\nTrue\npython:str\noptional\nax\nfig"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.plot",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.plot.html#pyedb.grpc.database.primitive.polygon.Polygon.plot",
        "title": "plot > plot > plot",
        "section": "plot > plot",
        "text": "Polygon.plot(plot_net=False, show=True, save_plot=None)\n\nPlot the current polygon on matplotlib.\n\nParameters\n\nplot_net\n\nbool, optional\n\nWhether if plot the entire net or only the selected polygon. Default is False.\n\nshow\n\nbool, optional\n\nWhether if show the plot or not. Default is True.\n\nsave_plot\n\npython:str, optional\n\nSave the plot path.\n\nReturns\n\n(ax, fig)\n\nMatplotlib ax and figures.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_closest_arc_midpoint",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_closest_arc_midpoint.html#get_closest_arc_midpoint",
        "title": "get_closest_arc_midpoint",
        "section": "get_closest_arc_midpoint",
        "text": "Get the closest arc midpoint of the primitive to the input data.\nget_closest_arc_midpoint\npython:list\nof\npython:float\nPointData\npython:list\nof\npython:float"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_closest_arc_midpoint",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_closest_arc_midpoint.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_closest_arc_midpoint",
        "title": "get_closest_arc_midpoint > get_closest_arc_midpoint > get_closest_arc_midpoint",
        "section": "get_closest_arc_midpoint > get_closest_arc_midpoint",
        "text": "EdbPolygon.get_closest_arc_midpoint(point)\n\nGet the closest arc midpoint of the primitive to the input data.\n\nParameters\n\npoint\n\npython:list of python:float or PointData\n\n\n\nReturns\n\npython:list of python:float\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.create",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create an HFSS setup.\ncreate"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.create",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.create.html#pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "RaptorXSimulationSetup.create(name=None)\n\nCreate an HFSS setup.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.layout_obj_type.html#pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "BundleTerminal.layout_obj_type = 2\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.iterate_materials_in_amat",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.iterate_materials_in_amat.html#iterate_materials_in_amat",
        "title": "iterate_materials_in_amat",
        "section": "iterate_materials_in_amat",
        "text": "Iterate over material description in an AMAT file.\nFull path to the AMAT file to read.\niterate_materials_in_amat\npython:str\npython:dict"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.iterate_materials_in_amat",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.iterate_materials_in_amat.html#pyedb.grpc.database.definition.materials.Materials.iterate_materials_in_amat",
        "title": "iterate_materials_in_amat > iterate_materials_in_amat > iterate_materials_in_amat",
        "section": "iterate_materials_in_amat > iterate_materials_in_amat",
        "text": "Materials.iterate_materials_in_amat(amat_file=None)\n\nIterate over material description in an AMAT file.\n\nParameters\n\namat_file\n\npython:str\n\nFull path to the AMAT file to read.\n\nYields\n\npython:dict\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings.set_pi_slider",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings.set_pi_slider.html#set_pi_slider",
        "title": "set_pi_slider",
        "section": "set_pi_slider",
        "text": "set_pi_slider"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings.set_pi_slider",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings.set_pi_slider.html#pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings.set_pi_slider",
        "title": "set_pi_slider > set_pi_slider > set_pi_slider",
        "section": "set_pi_slider > set_pi_slider",
        "text": "AdvancedSettings.set_pi_slider(value)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/PadstackData",
        "href": "dotnet_api/dotnet/edb_data/PadstackData.html#vias-and-padstacks",
        "title": "vias and padstacks",
        "section": "vias and padstacks",
        "text": "vias and padstacks"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/PadstackData",
        "href": "dotnet_api/dotnet/edb_data/PadstackData.html#instances-and-definitions",
        "title": "vias and padstacks > Instances and definitions",
        "section": "Instances and definitions",
        "text": "These classes are the containers of data management for padstacks instances and padstack definitions.\nEDBPadProperties\nManages EDB functionalities for pad properties.\nEDBPadstack\nManages EDB functionalities for a padstack.\nEDBPadstackInstance\nManages EDB functionalities for a padstack.\nInstances and definitions\nEDBPadProperties\nEDBPadstack\nEDBPadstackInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNets.create",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNets.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a new Extended net.\nName of the extended net.\nName of the nets to be added into this extended net.\nCreated ExtendedNet object.\ncreate\npython:str\npython:str\npython:list\nExtendedNet"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNets.create",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNets.create.html#pyedb.grpc.database.net.extended_net.ExtendedNets.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "ExtendedNets.create(name, net)\n\nCreate a new Extended net.\n\nParameters\n\nname\n\npython:str\n\nName of the extended net.\n\nnet\n\npython:str, python:list\n\nName of the nets to be added into this extended net.\n\nReturns\n\nExtendedNet\n\nCreated ExtendedNet object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadProperties.int_to_pad_type",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadProperties.int_to_pad_type.html#int_to_pad_type",
        "title": "int_to_pad_type",
        "section": "int_to_pad_type",
        "text": "Convert an integer to an EDB.PadGeometryType.\nEDB.PadType enumerator value.\nint_to_pad_type\npython:int\nobject"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadProperties.int_to_pad_type",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadProperties.int_to_pad_type.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadProperties.int_to_pad_type",
        "title": "int_to_pad_type > int_to_pad_type > int_to_pad_type",
        "section": "int_to_pad_type > int_to_pad_type",
        "text": "EDBPadProperties.int_to_pad_type(val=0)\n\nConvert an integer to an EDB.PadGeometryType.\n\nParameters\n\nval\n\npython:int\n\n\n\nReturns\n\nobject\n\nEDB.PadType enumerator value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/XmlControlFile",
        "href": "dotnet_api/dotnet/XmlControlFile.html#xml-control-file",
        "title": "XML control file",
        "section": "XML control file",
        "text": "Convert a technology file to EDB control file.\nControlProperty\n\nControlFileMaterial\n\nControlFileDielectric\n\nControlFileLayer\n\nControlFileVia\n\nControlFileStackup\nClass that manages the Stackup info.\nControlFileImportOptions\nImport Options.\nControlExtent\nExtent options.\nControlCircuitPt\nCircuit Port.\nControlFileComponent\nComponents.\nControlFileComponents\nClass for component management.\nXML control file\nControlProperty\nControlFileMaterial\nControlFileDielectric\nControlFileLayer\nControlFileVia\nControlFileStackup\nControlFileImportOptions\nControlExtent\nControlCircuitPt\nControlFileComponent\nControlFileComponents"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_layout_pcb",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_layout_pcb.html#import_layout_pcb",
        "title": "import_layout_pcb",
        "section": "import_layout_pcb",
        "text": "Import layout file and generate AEDB.\nSupported formats: BRD, MCM, XML (IPC2581), GDS, ODB++ (TGZ/ZIP), DXF\nFull path to input file.\nOutput directory for AEDB.\nPath to Ansys translator executable.\nUse PPE license. Default False.\nXML control file path.\nTechnology file path.\nLayer map file path.\nLayer filter file path.\nAEDB path if successful, False otherwise.\nimport_layout_pcb\npython:str\npython:str\noptional\npython:str\noptional\noptional\npython:str\noptional\npython:str\noptional\npython:str\noptional\npython:str\noptional\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_layout_pcb",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_layout_pcb.html#pyedb.grpc.edb.Edb.import_layout_pcb",
        "title": "import_layout_pcb > import_layout_pcb > import_layout_pcb",
        "section": "import_layout_pcb > import_layout_pcb",
        "text": "Edb.import_layout_pcb(input_file, working_dir='', anstranslator_full_path='', use_ppe=False, control_file=None, map_file=None, tech_file=None, layer_filter=None)\n\nImport layout file and generate AEDB.\n\nSupported formats: BRD, MCM, XML (IPC2581), GDS, ODB++ (TGZ/ZIP), DXF\n\nParameters\n\ninput_file\n\npython:str\n\nFull path to input file.\n\nworking_dir\n\npython:str, optional\n\nOutput directory for AEDB.\n\nanstranslator_full_path\n\npython:str, optional\n\nPath to Ansys translator executable.\n\nuse_ppe\n\nbool, optional\n\nUse PPE license. Default False.\n\ncontrol_file\n\npython:str, optional\n\nXML control file path.\n\ntech_file\n\npython:str, optional\n\nTechnology file path.\n\nmap_file\n\npython:str, optional\n\nLayer map file path.\n\nlayer_filter\n\npython:str, optional\n\nLayer filter file path.\n\nReturns\n\npython:str or bool\n\nAEDB path if successful, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.refresh_components",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.refresh_components.html#refresh_components",
        "title": "refresh_components",
        "section": "refresh_components",
        "text": "Refresh the component dictionary.\nrefresh_components"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.refresh_components",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.refresh_components.html#pyedb.dotnet.database.components.Components.refresh_components",
        "title": "refresh_components > refresh_components > refresh_components",
        "section": "refresh_components > refresh_components",
        "text": "Components.refresh_components()\n\nRefresh the component dictionary.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.create_rectangle_in_pad",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.create_rectangle_in_pad.html#create_rectangle_in_pad",
        "title": "create_rectangle_in_pad",
        "section": "create_rectangle_in_pad",
        "text": "Create a rectangle inscribed inside a padstack instance pad.\nThe rectangle is fully inscribed in the pad and has the maximum area.\nIt is necessary to specify the layer on which the rectangle will be created.\nName of the layer on which to create the polygon.\nIf True does not create the rectangle and just returns a list containing the rectangle vertices.\nDefault is False.\nOrder of the lattice partition used to find the quasi-lattice polygon that approximates polygon.\nDefault is 16.\nPolygon when successful, False when failed, list of list if return_points=True.\ncreate_rectangle_in_pad\npython:str\noptional\npython:float\noptional\npolygon\n16\nList\npyedb.dotnet.database.edb_data.primitives.EDBPrimitives\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.create_rectangle_in_pad",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.create_rectangle_in_pad.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.create_rectangle_in_pad",
        "title": "create_rectangle_in_pad > create_rectangle_in_pad > create_rectangle_in_pad",
        "section": "create_rectangle_in_pad > create_rectangle_in_pad",
        "text": "EDBPadstackInstance.create_rectangle_in_pad(layer_name, return_points=False, partition_max_order=16)\n\nCreate a rectangle inscribed inside a padstack instance pad.\n\nThe rectangle is fully inscribed in the pad and has the maximum area.\nIt is necessary to specify the layer on which the rectangle will be created.\n\nParameters\n\nlayer_name\n\npython:str\n\nName of the layer on which to create the polygon.\n\nreturn_points\n\nbool, optional\n\nIf True does not create the rectangle and just returns a list containing the rectangle vertices.\nDefault is False.\n\npartition_max_order\n\npython:float, optional\n\nOrder of the lattice partition used to find the quasi-lattice polygon that approximates polygon.\nDefault is 16.\n\nReturns\n\nbool, List,  pyedb.dotnet.database.edb_data.primitives.EDBPrimitives\n\nPolygon when successful, False when failed, list of list if return_points=True.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", edbversion=\"2021.2\")\n>>> edb_layout = edbapp.modeler\n>>> list_of_padstack_instances = list(edbapp.padstacks.instances.values())\n>>> padstack_inst = list_of_padstack_instances[0]\n>>> padstack_inst.create_rectangle_in_pad(\"TOP\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.Meander.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.Meander.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Draw the meander in the attached EDB cell and calculate its\nphysical length.\nTrue on success.\ncreate"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.Meander.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.Meander.create.html#pyedb.libraries.rf_libraries.base_functions.Meander.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "Meander.create() -> bool\n\nDraw the meander in the attached EDB cell and calculate its\nphysical length.\n\nReturns\n\nbool\n\nTrue on success.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.create_hfss.html#create_hfss",
        "title": "create_hfss",
        "section": "create_hfss",
        "text": "Create an HFSS model from an MCAD file.\nHFSS model created.\ncreate_hfss\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.create_hfss.html#pyedb.grpc.database.primitive.polygon.Polygon.create_hfss",
        "title": "create_hfss > create_hfss > create_hfss",
        "section": "create_hfss > create_hfss",
        "text": "Polygon.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nReturns\n\nMcadModel\n\nHFSS model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.set_solution_single_frequency",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.set_solution_single_frequency.html#set_solution_single_frequency",
        "title": "set_solution_single_frequency",
        "section": "set_solution_single_frequency",
        "text": "Set HFSS single frequency solution.\nParameters\n———-\nfrequency : str, optional\nAdaptive frequency.\nMaxmímum passes number. Default value 10.\nMaximum delta S value. Default value 0.02,\nset_solution_single_frequency"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.set_solution_single_frequency",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.set_solution_single_frequency.html#pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.set_solution_single_frequency",
        "title": "set_solution_single_frequency > set_solution_single_frequency > set_solution_single_frequency",
        "section": "set_solution_single_frequency > set_solution_single_frequency",
        "text": "HfssSimulationSetup.set_solution_single_frequency(frequency='5GHz', max_num_passes=10, max_delta_s=0.02) -> bool\n\nSet HFSS single frequency solution.\nParameters\n———-\nfrequency : str, optional\n\nAdaptive frequency.\n\nmax_num_passes\n\nint, optional\n\nMaxmímum passes number. Default value 10.\n\nmax_delta_s\n\nfloat, optional\n\nMaximum delta S value. Default value 0.02,\n\nReturns\n\nbool.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "user_guide/getting_started",
        "href": "user_guide/getting_started.html#getting-started-your-first-script",
        "title": "Getting Started: Your First Script",
        "section": "Getting Started: Your First Script",
        "text": "This tutorial walks you through creating a simple EDB from scratch using the pure Python client connected to the\nansys-edb-core gRPC service.\nGetting Started: Your First Script\nansys-edb-core"
    },
    {
        "objectID": "user_guide/getting_started",
        "href": "user_guide/getting_started.html#prerequisites",
        "title": "Getting Started: Your First Script > Prerequisites",
        "section": "Prerequisites",
        "text": "The PyEDB client is installed (pip install pyedb).\nThe ansys-edb-core service is installed and available (see ../installation).\nPrerequisites\nansys-edb-core"
    },
    {
        "objectID": "user_guide/getting_started",
        "href": "user_guide/getting_started.html#import-and-initialize-with-a-context-manager",
        "title": "Getting Started: Your First Script > Import and Initialize with a Context Manager",
        "section": "Import and Initialize with a Context Manager",
        "text": "Import and Initialize with a Context Manager"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_components_from_nets",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_components_from_nets.html#get_components_from_nets",
        "title": "get_components_from_nets",
        "section": "get_components_from_nets",
        "text": "Get components connected to specified nets.\nNet name(s) to filter by.\nList of component names.\nget_components_from_nets\npython:str\npython:list\npython:str\noptional\npython:list\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_components_from_nets",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_components_from_nets.html#pyedb.grpc.database.components.Components.get_components_from_nets",
        "title": "get_components_from_nets > get_components_from_nets > get_components_from_nets",
        "section": "get_components_from_nets > get_components_from_nets",
        "text": "Components.get_components_from_nets(netlist=None) -> list[str]\n\nGet components connected to specified nets.\n\nParameters\n\nnetlist\n\npython:str or python:list[python:str], optional\n\nNet name(s) to filter by.\n\nReturns\n\npython:list[python:str]\n\nList of component names.\n\nExamples\n\n>>> comps = edbapp.components.get_components_from_nets([\"GND\", \"VCC\"])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.layout_obj_type.html#pyedb.grpc.database.net.differential_pair.DifferentialPair.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "DifferentialPair.layout_obj_type = 11\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.export_definition",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.export_definition.html#export_definition",
        "title": "export_definition",
        "section": "export_definition",
        "text": "Export component definitions to json file.\nFile path of json file.\nexport_definition\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.export_definition",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.export_definition.html#pyedb.dotnet.database.components.Components.export_definition",
        "title": "export_definition > export_definition > export_definition",
        "section": "export_definition > export_definition",
        "text": "Components.export_definition(file_path)\n\nExport component definitions to json file.\n\nParameters\n\nfile_path\n\npython:str\n\nFile path of json file.\n\nReturns\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.s_parameter_model.SparamModel.clone",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.s_parameter_model.SparamModel.clone.html#clone",
        "title": "clone",
        "section": "clone",
        "text": "Clone a model.\nclone\nModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.s_parameter_model.SparamModel.clone",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.s_parameter_model.SparamModel.clone.html#pyedb.grpc.database.hierarchy.s_parameter_model.SparamModel.clone",
        "title": "clone > clone > clone",
        "section": "clone > clone",
        "text": "SparamModel.clone()\n\nClone a model.\n\nReturns\n\nModel cloned.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.set_simulation_settings",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.set_simulation_settings.html#set_simulation_settings",
        "title": "set_simulation_settings",
        "section": "set_simulation_settings",
        "text": "set_simulation_settings"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.set_simulation_settings",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.set_simulation_settings.html#pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.set_simulation_settings",
        "title": "set_simulation_settings > set_simulation_settings > set_simulation_settings",
        "section": "set_simulation_settings > set_simulation_settings",
        "text": "SimulationSetup.set_simulation_settings(sim_settings: dict)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/padstacks",
        "href": "grpc_api/grpc/database/padstacks.html#padstacks",
        "title": "Padstacks",
        "section": "Padstacks",
        "text": "Class managing Padstacks.\npadstacks.Padstacks\nManages EDB methods for padstacks accessible from Edb.padstacks property.\nPadstacks\npadstacks.Padstacks"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_parametrized_name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nString representing the new class where params are passed to cls as type variables.\nTypeError: Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_parametrized_name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_parametrized_name.html#pyedb.workflows.drc.drc.Rules.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod Rules.model_parametrized_name(params: tuple[type[Any], ...]) -> str\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n\nparams: Tuple of types of the class. Given a generic class\n\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturns:\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises:\n\nTypeError: Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_outline_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_outline_layer.html#add_outline_layer",
        "title": "add_outline_layer",
        "section": "add_outline_layer",
        "text": "Add an outline layer named “Outline” if it is not present.\nTrue when successful.\nadd_outline_layer\nTrue"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_outline_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_outline_layer.html#pyedb.grpc.database.stackup.Stackup.add_outline_layer",
        "title": "add_outline_layer > add_outline_layer > add_outline_layer",
        "section": "add_outline_layer > add_outline_layer",
        "text": "Stackup.add_outline_layer(name: str = 'Outline') -> bool\n\nAdd an outline layer named “Outline” if it is not present.\n\nReturns\n\nbool\n\nTrue when successful.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> edb.stackup.add_outline_layer()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.set_solder_ball",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.set_solder_ball.html#set_solder_ball",
        "title": "set_solder_ball",
        "section": "set_solder_ball",
        "text": "Set cylindrical solder balls on a given component.\nName of the discrete component.\nDiameter of the solder ball.\nHeight of the solder ball.\nShape of solder ball. Options are \"Cylinder\",\n\"Spheroid\". The default is \"Cylinder\".\nMid diameter of the solder ball.\nGive the chip orientation, \"chip_down\" or \"chip_up\". Default is \"chip_down\". Only applicable on\nIC model.\nWhether to automatically set reference size.\nX size of the reference. Applicable when auto_reference_size is False.\nY size of the reference. Applicable when auto_reference_size is False.\nHeight of the reference. Applicable when auto_reference_size is False.\nTrue when successful, False when failed.\nset_solder_ball\npython:str\nEDB\ncomponent\noptional\npython:str\npython:float\noptional\npython:str\npython:float\noptional\npython:str\noptional\n\"Cylinder\"\n\"Spheroid\"\n\"Cylinder\"\npython:str\npython:float\noptional\npython:str\noptional\n\"chip_down\"\n\"chip_up\"\n\"chip_down\"\noptional\npython:int\npython:str\npython:float\noptional\npython:int\npython:str\npython:float\noptional\npython:int\npython:str\npython:float\noptional\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.set_solder_ball",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.set_solder_ball.html#pyedb.dotnet.database.components.Components.set_solder_ball",
        "title": "set_solder_ball > set_solder_ball > set_solder_ball",
        "section": "set_solder_ball > set_solder_ball",
        "text": "Components.set_solder_ball(component='', sball_diam=None, sball_height=None, shape='Cylinder', sball_mid_diam=None, chip_orientation='chip_down', auto_reference_size=True, reference_size_x=0, reference_size_y=0, reference_height=0)\n\nSet cylindrical solder balls on a given component.\n\nParameters\n\ncomponent\n\npython:str or EDB component, optional\n\nName of the discrete component.\n\nsball_diam\n\npython:str, python:float, optional\n\nDiameter of the solder ball.\n\nsball_height\n\npython:str, python:float, optional\n\nHeight of the solder ball.\n\nshape\n\npython:str, optional\n\nShape of solder ball. Options are \"Cylinder\",\n\"Spheroid\". The default is \"Cylinder\".\n\nsball_mid_diam\n\npython:str, python:float, optional\n\nMid diameter of the solder ball.\n\nchip_orientation\n\npython:str, optional\n\nGive the chip orientation, \"chip_down\" or \"chip_up\". Default is \"chip_down\". Only applicable on\nIC model.\n\nauto_reference_size\n\nbool, optional\n\nWhether to automatically set reference size.\n\nreference_size_x\n\npython:int, python:str, python:float, optional\n\nX size of the reference. Applicable when auto_reference_size is False.\n\nreference_size_y\n\npython:int, python:str, python:float, optional\n\nY size of the reference. Applicable when auto_reference_size is False.\n\nreference_height\n\npython:int, python:str, python:float, optional\n\nHeight of the reference. Applicable when auto_reference_size is False.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\")\n>>> edbapp.components.set_solder_ball(\"A1\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_layers",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_layers.html#get_layers",
        "title": "get_layers",
        "section": "get_layers",
        "text": "Get a list of layers in the layer collection using a layer filter.\nLayer filter.\nList of layers based on the filter used.\nget_layers\nLayerTypeSet\nLayerType\npython:list\nLayerType\nALL_LAYER_SET\npython:list\nLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_layers",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_layers.html#pyedb.grpc.database.stackup.Stackup.get_layers",
        "title": "get_layers > get_layers > get_layers",
        "section": "get_layers > get_layers",
        "text": "Stackup.get_layers(layer_filter=LayerTypeSet.ALL_LAYER_SET)\n\nGet a list of layers in the layer collection using a layer filter.\n\nParameters\n\nlayer_filter\n\nLayerTypeSet or LayerType or python:list[LayerType], default: ALL_LAYER_SET\n\nLayer filter.\n\nReturns\n\npython:list[Layer]\n\nList of layers based on the filter used.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.layout_obj_type.html#pyedb.grpc.database.ports.ports.WavePort.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "WavePort.layout_obj_type = 2\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_reference_pins",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_reference_pins.html#get_reference_pins",
        "title": "get_reference_pins",
        "section": "get_reference_pins",
        "text": "Search for reference pins using given criteria.\nReference net. The default is \"GND\".\nSearch radius for finding padstack instances. The default is 5e-3.\nMaximum limit for the padstack instances found. The default is 0, in which\ncase no limit is applied. The maximum limit value occurs on the nearest\nreference pins from the positive one that is found.\nWhether to limit the search to component padstack instances only. The\ndefault is True. When False, the search is extended to the entire layout.\nList of dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.\nget_reference_pins\npython:str\noptional\n\"GND\"\npython:float\noptional\n5e-3\npython:int\noptional\n0\noptional\nTrue\nFalse\npython:list\ndotnet.database.edb_data.padstacks_data.EDBPadstackInstance"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_reference_pins",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_reference_pins.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_reference_pins",
        "title": "get_reference_pins > get_reference_pins > get_reference_pins",
        "section": "get_reference_pins > get_reference_pins",
        "text": "EDBPadstackInstance.get_reference_pins(reference_net='GND', search_radius=0.005, max_limit=0, component_only=True)\n\nSearch for reference pins using given criteria.\n\nParameters\n\nreference_net\n\npython:str, optional\n\nReference net. The default is \"GND\".\n\nsearch_radius\n\npython:float, optional\n\nSearch radius for finding padstack instances. The default is 5e-3.\n\nmax_limit\n\npython:int, optional\n\nMaximum limit for the padstack instances found. The default is 0, in which\ncase no limit is applied. The maximum limit value occurs on the nearest\nreference pins from the positive one that is found.\n\ncomponent_only\n\nbool, optional\n\nWhether to limit the search to component padstack instances only. The\ndefault is True. When False, the search is extended to the entire layout.\n\nReturns\n\npython:list\n\nList of dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.\n\nExamples\n\n>>> edbapp = Edb(\"target_path\")\n>>> pin = edbapp.components.instances[\"J5\"].pins[\"19\"]\n>>> reference_pins = pin.get_reference_pins(reference_net=\"GND\", search_radius=5e-3, max_limit=0,\n>>> component_only=True)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_copy",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/models.md#model-copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nbefore creating the new model. You should trust this data.\ndeep: Set to True to make a deep copy of the model.\nNew model instance.\nmodel_copy"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_copy",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_copy.html#pyedb.grpc.database.definition.materials.MaterialProperties.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "MaterialProperties.model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -> Self\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/models.md#model-copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nArgs:\n\nupdate: Values to change/add in the new model. Note: the data is not validated\n\nbefore creating the new model. You should trust this data.\n\ndeep: Set to True to make a deep copy of the model.\n\nReturns:\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.set_product_property.html#pyedb.grpc.database.primitive.polygon.Polygon.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "Polygon.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.split",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.split.html#split",
        "title": "split",
        "section": "split",
        "text": "Split padstack instance into multiple instances. The new instances only connect adjacent layers.\nsplit"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.split",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.split.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.split",
        "title": "split > split > split",
        "section": "split > split",
        "text": "EDBPadstackInstance.split() -> list\n\nSplit padstack instance into multiple instances. The new instances only connect adjacent layers.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_connected_object_id_set",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_connected_object_id_set.html#get_connected_object_id_set",
        "title": "get_connected_object_id_set",
        "section": "get_connected_object_id_set",
        "text": "Produce a list of all geometries physically connected to a given layout object.\nFound connected objects IDs with Layout object.\nget_connected_object_id_set\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_connected_object_id_set",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_connected_object_id_set.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_connected_object_id_set",
        "title": "get_connected_object_id_set > get_connected_object_id_set > get_connected_object_id_set",
        "section": "get_connected_object_id_set > get_connected_object_id_set",
        "text": "EdbPolygon.get_connected_object_id_set()\n\nProduce a list of all geometries physically connected to a given layout object.\n\nReturns\n\npython:list\n\nFound connected objects IDs with Layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_traj",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_traj.html#get_traj",
        "title": "get_traj",
        "section": "get_traj",
        "text": "Get trajectory parameters of the bondwire.\nReturns a tuple in this format:\n(x1, y1, x2, y2)\nx1 : X value of the start point.\ny1 : Y value of the start point.\nx1 : X value of the end point.\ny1 : Y value of the end point.\nget_traj\npython:tuple\nof\nValue\nValue\nValue\nValue"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_traj",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_traj.html#pyedb.grpc.database.primitive.bondwire.Bondwire.get_traj",
        "title": "get_traj > get_traj > get_traj",
        "section": "get_traj > get_traj",
        "text": "Bondwire.get_traj() -> tuple[Value, Value, Value, Value]\n\nGet trajectory parameters of the bondwire.\n\nReturns\n\npython:tuple of (Value, Value, Value, Value)\n\nReturns a tuple in this format:\n\n(x1, y1, x2, y2)\n\nx1 : X value of the start point.\n\ny1 : Y value of the start point.\n\nx1 : X value of the end point.\n\ny1 : Y value of the end point.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/siwave_dcir_simulation_setup",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/siwave_dcir_simulation_setup.html#siwave-dcir-simulation-setup",
        "title": "Siwave dcir simulation setup",
        "section": "Siwave dcir simulation setup",
        "text": "This class is managing EDB siwave dcir simulation setup.\nSIWaveDCIRSimulationSetup\nSiwave Dcir simulation setup class.\nSiwave dcir simulation setup\nSIWaveDCIRSimulationSetup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.create_3d_comp.html#create_3d_comp",
        "title": "create_3d_comp",
        "section": "create_3d_comp",
        "text": "Create a 3D composite model from an MCAD file.\n3D composite model created.\ncreate_3d_comp\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.create_3d_comp.html#pyedb.grpc.database.ports.ports.GapPort.create_3d_comp",
        "title": "create_3d_comp > create_3d_comp > create_3d_comp",
        "section": "create_3d_comp > create_3d_comp",
        "text": "GapPort.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nReturns\n\nMcadModel\n\n3D composite model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/sim_setup_info",
        "href": "dotnet_api/dotnet/sim_setup_data/data/sim_setup_info.html#simulation-setup-info",
        "title": "Simulation setup info",
        "section": "Simulation setup info",
        "text": "This class is the container of simulation setup info.\nSimSetupInfo\n\nSimulation setup info\nSimSetupInfo"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/bondwire",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/bondwire.html#bondwire",
        "title": "Bondwire",
        "section": "Bondwire",
        "text": "This class is managing EDB bondwire.\nBondwire\nClass representing a bond-wire object.\nBondwire\nBondwire"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.add_component_model",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.add_component_model.html#add_component_model",
        "title": "add_component_model",
        "section": "add_component_model",
        "text": "Add a component model to this component def.\nComponent Model to be added.\nOnce a component model is added to one component def, it cannot be added to any other, even when removed.\nadd_component_model\nComponent Model"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.add_component_model",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.add_component_model.html#pyedb.grpc.database.definition.component_def.ComponentDef.add_component_model",
        "title": "add_component_model > add_component_model > add_component_model",
        "section": "add_component_model > add_component_model",
        "text": "ComponentDef.add_component_model(value)\n\nAdd a component model to this component def.\n\nParameters\n\nvalue\n\nComponent Model\n\nComponent Model to be added.\n\nNotes\n\nOnce a component model is added to one component def, it cannot be added to any other, even when removed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.create_stride.html#create_stride",
        "title": "create_stride",
        "section": "create_stride",
        "text": "Create a Stride model from an MCAD file.\nStride model created.\ncreate_stride\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.create_stride.html#pyedb.grpc.database.ports.ports.CircuitPort.create_stride",
        "title": "create_stride > create_stride > create_stride",
        "section": "create_stride > create_stride",
        "text": "CircuitPort.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nReturns\n\nMcadModel\n\nStride model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.write_export3d_option_config_file",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.write_export3d_option_config_file.html#write_export3d_option_config_file",
        "title": "write_export3d_option_config_file",
        "section": "write_export3d_option_config_file",
        "text": "Write the options for a 3D export to a configuration file.\nFull path to the configuration file to save 3D export options to.\nConfiguration dictionaries. The default is None.\nwrite_export3d_option_config_file\npython:str\npython:dict\noptional\nNone"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.write_export3d_option_config_file",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.write_export3d_option_config_file.html#pyedb.dotnet.edb.Edb.write_export3d_option_config_file",
        "title": "write_export3d_option_config_file > write_export3d_option_config_file > write_export3d_option_config_file",
        "section": "write_export3d_option_config_file > write_export3d_option_config_file",
        "text": "Edb.write_export3d_option_config_file(path_to_output, config_dictionaries=None)\n\nWrite the options for a 3D export to a configuration file.\n\nParameters\n\npath_to_output\n\npython:str\n\nFull path to the configuration file to save 3D export options to.\n\nconfig_dictionaries\n\npython:dict, optional\n\nConfiguration dictionaries. The default is None.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_connected_object_id_set",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_connected_object_id_set.html#get_connected_object_id_set",
        "title": "get_connected_object_id_set",
        "section": "get_connected_object_id_set",
        "text": "Produce a list of all geometries physically connected to a given layout object.\nFound connected objects IDs with Layout object.\nget_connected_object_id_set\npython:list"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_connected_object_id_set",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_connected_object_id_set.html#pyedb.grpc.database.ports.ports.ExcitationSources.get_connected_object_id_set",
        "title": "get_connected_object_id_set > get_connected_object_id_set > get_connected_object_id_set",
        "section": "get_connected_object_id_set > get_connected_object_id_set",
        "text": "ExcitationSources.get_connected_object_id_set()\n\nProduce a list of all geometries physically connected to a given layout object.\n\nReturns\n\npython:list\n\nFound connected objects IDs with Layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.place_in_layout",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.place_in_layout.html#place_in_layout",
        "title": "place_in_layout",
        "section": "place_in_layout",
        "text": "Place current Cell into another cell using layer placement method.\nFlip the current layer stackup of a layout if requested. Transform parameters currently not supported.\nCell on which to place the current layout. If None the Cell will be applied on an empty new Cell.\nThe rotation angle applied on the design.\nThe x offset value.\nThe y offset value.\nEither if the current layout is inverted.\nIf True and place_on_top is True the stackup will be flipped before the merge.\nEither if place the current layout on Top or Bottom of destination Layout.\nTrue when succeed False if not.\nplace_in_layout\nEdb\ndouble\noptional\ndouble\noptional\ndouble\noptional\noptional\noptional\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.place_in_layout",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.place_in_layout.html#pyedb.dotnet.database.stackup.Stackup.place_in_layout",
        "title": "place_in_layout > place_in_layout > place_in_layout",
        "section": "place_in_layout > place_in_layout",
        "text": "Stackup.place_in_layout(edb, angle=0.0, offset_x=0.0, offset_y=0.0, flipped_stackup=True, place_on_top=True)\n\nPlace current Cell into another cell using layer placement method.\nFlip the current layer stackup of a layout if requested. Transform parameters currently not supported.\n\nParameters\n\nedb\n\nEdb\n\nCell on which to place the current layout. If None the Cell will be applied on an empty new Cell.\n\nangle\n\ndouble, optional\n\nThe rotation angle applied on the design.\n\noffset_x\n\ndouble, optional\n\nThe x offset value.\n\noffset_y\n\ndouble, optional\n\nThe y offset value.\n\nflipped_stackup\n\nbool, optional\n\nEither if the current layout is inverted.\nIf True and place_on_top is True the stackup will be flipped before the merge.\n\nplace_on_top\n\nbool, optional\n\nEither if place the current layout on Top or Bottom of destination Layout.\n\nReturns\n\nbool\n\nTrue when succeed False if not.\n\nExamples\n\n>>> edb1 = Edb(edbpath=targetfile1, edbversion=\"2021.2\")\n>>> edb2 = Edb(edbpath=targetfile2, edbversion=\"2021.2\")\n\n>>> hosting_cmp = edb1.components.get_component_by_name(\"U100\")\n>>> mounted_cmp = edb2.components.get_component_by_name(\"BGA\")\n\n>>> vector, rotation, solder_ball_height = edb1.components.get_component_placement_vector(\n...     mounted_component=mounted_cmp,\n...     hosting_component=hosting_cmp,\n...     mounted_component_pin1=\"A12\",\n...     mounted_component_pin2=\"A14\",\n...     hosting_component_pin1=\"A12\",\n...     hosting_component_pin2=\"A14\",\n... )\n>>> edb2.stackup.place_in_layout(\n...     edb1.active_cell,\n...     angle=0.0,\n...     offset_x=vector[0],\n...     offset_y=vector[1],\n...     flipped_stackup=False,\n...     place_on_top=True,\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.create_stride.html#create_stride",
        "title": "create_stride",
        "section": "create_stride",
        "text": "Create a Stride model from an MCAD file.\nStride model created.\ncreate_stride\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.create_stride.html#pyedb.grpc.database.ports.ports.BundleWavePort.create_stride",
        "title": "create_stride > create_stride > create_stride",
        "section": "create_stride > create_stride",
        "text": "BundleWavePort.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nReturns\n\nMcadModel\n\nStride model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_fields.html#pyedb.workflows.drc.drc.MinAnnularRing.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "MinAnnularRing.model_fields = {'name': FieldInfo(annotation=str, required=True), 'value': FieldInfo(annotation=str, required=True)}\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.render",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.render.html#render",
        "title": "render",
        "section": "render",
        "text": "Get the polygon data of a rectangle.\nType that defines the meaning of the given parameters.\nX value of the lower-left point or center point.\nY value of the lower-left point or center point.\nX value of the upper-right point or width.\nY value of the upper-right point or height.\nCorner radius.\nRotation.\nWhether the rectangle is hole.\nPolygon data object created.\nrender\nRectangleRepresentationType\npython:False\nPolygonData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.render",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.render.html#pyedb.grpc.database.primitive.rectangle.Rectangle.render",
        "title": "render > render > render",
        "section": "render > render",
        "text": "classmethod Rectangle.render(rep_type: RectangleRepresentationType, x_lower_left_or_center_x: ValueLike, y_lower_left_or_center_y: ValueLike, x_upper_right_or_width: ValueLike, y_upper_right_or_height: ValueLike, corner_radius: ValueLike, rotation: ValueLike, is_hole: bool = False) -> PolygonData\n\nGet the polygon data of a rectangle.\n\nParameters\n\nrep_type\n\nRectangleRepresentationType\n\nType that defines the meaning of the given parameters.\n\nx_lower_left_or_center_x\n\nValueLike\n\nX value of the lower-left point or center point.\n\ny_lower_left_or_center_y\n\nValueLike\n\nY value of the lower-left point or center point.\n\nx_upper_right_or_width\n\nValueLike\n\nX value of the upper-right point or width.\n\ny_upper_right_or_height\n\nValueLike\n\nY value of the upper-right point or height.\n\ncorner_radius\n\nValueLike\n\nCorner radius.\n\nrotation\n\nValueLike\n\nRotation.\n\nis_hole\n\nbool, default: python:False\n\nWhether the rectangle is hole.\n\nReturns\n\nPolygonData\n\nPolygon data object created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.get_product_property.html#pyedb.grpc.database.net.differential_pair.DifferentialPair.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "DifferentialPair.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef.html#padstackdef",
        "title": "PadstackDef",
        "section": "PadstackDef",
        "text": "Manages EDB functionalities for a padstack.\nInherited AEDT object.\nPadstackDef.convert_to_3d_microvias([...])\nConvert actual padstack instance to microvias 3D Objects with a given aspect ratio.\nPadstackDef.create(db, name)\nCreate a padstack definition in a given database.\nPadstackDef.delete()\nDelete the padstack definition.\nPadstackDef.find_by_name(db, name)\nFind a padstack definition by name in a given database.\nPadstackDef.split_to_microvias()\nConvert actual padstack definition to multiple microvias definitions.\nPadstackDef\npython:str\nPadstackDef.convert_to_3d_microvias\nPadstackDef.create\nPadstackDef.delete\nPadstackDef.find_by_name\nPadstackDef.split_to_microvias"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef.html#pyedb.grpc.database.definition.padstack_def.PadstackDef",
        "title": "PadstackDef > PadstackDef > PadstackDef",
        "section": "PadstackDef > PadstackDef",
        "text": "class pyedb.grpc.database.definition.padstack_def.PadstackDef(pedb, edb_object)\n\nManages EDB functionalities for a padstack.\n\nParameters\n\nedb_padstack\n\n\n\nppadstack\n\npython:str\n\nInherited AEDT object.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb(myedb, edbversion=\"2021.2\")\n>>> edb_padstack = edb.padstacks.definitions[\"MyPad\"]\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nPadstackDef.convert_to_3d_microvias([...])\n\nConvert actual padstack instance to microvias 3D Objects with a given aspect ratio.\n\nPadstackDef.create(db, name)\n\nCreate a padstack definition in a given database.\n\nPadstackDef.delete()\n\nDelete the padstack definition.\n\nPadstackDef.find_by_name(db, name)\n\nFind a padstack definition by name in a given database.\n\nPadstackDef.split_to_microvias()\n\nConvert actual padstack definition to multiple microvias definitions.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.find_by_id.html#find_by_id",
        "title": "find_by_id",
        "section": "find_by_id",
        "text": "Find a Connectable object by database ID in a given layout.\nLayout to search for the Connectable object.\nDatabase ID.\nConnectable object with the given database ID.\nfind_by_id\nLayout\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.find_by_id.html#pyedb.grpc.database.ports.ports.CoaxPort.find_by_id",
        "title": "find_by_id > find_by_id > find_by_id",
        "section": "find_by_id > find_by_id",
        "text": "classmethod CoaxPort.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the Connectable object.\n\nuid\n\npython:int\n\nDatabase ID.\n\nReturns\n\nConnectable\n\nConnectable object with the given database ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.delete_padstack_instances",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.delete_padstack_instances.html#delete_padstack_instances",
        "title": "delete_padstack_instances",
        "section": "delete_padstack_instances",
        "text": "Delete padstack instances by net names.\nNames of the nets whose padstack instances should be deleted.\nTrue when successful, False when failed.\ndelete_padstack_instances\npython:str\npython:list\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.delete_padstack_instances",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.delete_padstack_instances.html#pyedb.grpc.database.padstacks.Padstacks.delete_padstack_instances",
        "title": "delete_padstack_instances > delete_padstack_instances > delete_padstack_instances",
        "section": "delete_padstack_instances > delete_padstack_instances",
        "text": "Padstacks.delete_padstack_instances(net_names: str | List[str]) -> bool\n\nDelete padstack instances by net names.\n\nParameters\n\nnet_names\n\npython:str, python:list\n\nNames of the nets whose padstack instances should be deleted.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> success = edb_padstacks.delete_padstack_instances(\"GND\")\n>>> success = edb_padstacks.delete_padstack_instances([\"GND\", \"PWR\"])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.split",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.split.html#split",
        "title": "split",
        "section": "split",
        "text": "Split padstack instance into multiple instances. The new instances only connect adjacent layers.\nsplit"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.split",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.split.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.split",
        "title": "split > split > split",
        "section": "split > split",
        "text": "PadstackInstance.split() -> list\n\nSplit padstack instance into multiple instances. The new instances only connect adjacent layers.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.create_3d_comp.html#create_3d_comp",
        "title": "create_3d_comp",
        "section": "create_3d_comp",
        "text": "Create a 3D composite model from an MCAD file.\n3D composite model created.\ncreate_3d_comp\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.create_3d_comp.html#pyedb.grpc.database.primitive.primitive.Primitive.create_3d_comp",
        "title": "create_3d_comp > create_3d_comp > create_3d_comp",
        "section": "create_3d_comp > create_3d_comp",
        "text": "Primitive.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nReturns\n\nMcadModel\n\n3D composite model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.trim_component_reference_size",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.trim_component_reference_size.html#trim_component_reference_size",
        "title": "trim_component_reference_size",
        "section": "trim_component_reference_size",
        "text": "Trim the common component reference to the minimally acceptable size.\nEdb_DATA.SimulationConfiguration object\nTrue, reduce the reference to a box covering only the active terminals (i.e. those with\nFalse, reduce the reference to the minimal size needed to cover all pins\nTrue when succeeded, False when failed.\ntrim_component_reference_size"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.trim_component_reference_size",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.trim_component_reference_size.html#pyedb.dotnet.database.hfss.EdbHfss.trim_component_reference_size",
        "title": "trim_component_reference_size > trim_component_reference_size > trim_component_reference_size",
        "section": "trim_component_reference_size > trim_component_reference_size",
        "text": "EdbHfss.trim_component_reference_size(simulation_setup=None, trim_to_terminals=False)\n\nTrim the common component reference to the minimally acceptable size.\n\nParameters\n\nsimulation_setup\n\nEdb_DATA.SimulationConfiguration object\n\ntrim_to_terminals\n\nbool.\n\nTrue, reduce the reference to a box covering only the active terminals (i.e. those with\n\nports).\n\nFalse, reduce the reference to the minimal size needed to cover all pins\n\nReturns\n\nbool\n\nTrue when succeeded, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_q3d",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_q3d.html#export_q3d",
        "title": "export_q3d",
        "section": "export_q3d",
        "text": "Export to Q3D project.\nOutput directory.\nNets to export.\nProcessing cores to use.\nCustom AEDT filename.\nRun Siwave in background. Default False.\nPath to generated AEDT file.\nexport_q3d\npython:str\npython:list\noptional\npython:int\noptional\npython:str\noptional\noptional\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_q3d",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_q3d.html#pyedb.grpc.edb.Edb.export_q3d",
        "title": "export_q3d > export_q3d > export_q3d",
        "section": "export_q3d > export_q3d",
        "text": "Edb.export_q3d(path_to_output, net_list=None, num_cores=None, aedt_file_name=None, hidden=False)\n\nExport to Q3D project.\n\nParameters\n\npath_to_output\n\npython:str\n\nOutput directory.\n\nnet_list\n\npython:list, optional\n\nNets to export.\n\nnum_cores\n\npython:int, optional\n\nProcessing cores to use.\n\naedt_file_name\n\npython:str, optional\n\nCustom AEDT filename.\n\nhidden\n\nbool, optional\n\nRun Siwave in background. Default False.\n\nReturns\n\npython:str\n\nPath to generated AEDT file.\n\nExamples\n\n>>> # Export to Q3D project:\n>>> edb.export_q3d(r\"C:/output\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the primitive object to the correct concrete type.\ncast\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.cast.html#pyedb.grpc.database.primitive.primitive.Primitive.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "Primitive.cast() -> Primitive | None\n\nCast the primitive object to the correct concrete type.\n\nReturns\n\nPrimitive\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.assign_rlc_model",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.assign_rlc_model.html#assign_rlc_model",
        "title": "assign_rlc_model",
        "section": "assign_rlc_model",
        "text": "Assign RLC to this component.\nResistance. Default is None.\nInductance. Default is None.\nCapacitance. Default is None.\nWhether it is a parallel or series RLC component. The default is False.\nComponent Model.\nassign_rlc_model\npython:int\npython:float\nNone\npython:int\npython:float\nNone\npython:int\npython:float\nNone\noptional\nFalse\nModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.assign_rlc_model",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.assign_rlc_model.html#pyedb.grpc.database.hierarchy.component.Component.assign_rlc_model",
        "title": "assign_rlc_model > assign_rlc_model > assign_rlc_model",
        "section": "assign_rlc_model > assign_rlc_model",
        "text": "Component.assign_rlc_model(res=None, ind=None, cap=None, is_parallel=False) -> PinPairModel\n\nAssign RLC to this component.\n\nParameters\n\nres\n\npython:int, python:float\n\nResistance. Default is None.\n\nind\n\npython:int, python:float\n\nInductance. Default is None.\n\ncap\n\npython:int, python:float\n\nCapacitance. Default is None.\n\nis_parallel\n\nbool, optional\n\nWhether it is a parallel or series RLC component. The default is False.\n\nReturns\n\nModel\n\nComponent Model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.add_void",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.add_void.html#add_void",
        "title": "add_void",
        "section": "add_void",
        "text": "Add a void to current primitive.\nTrue if successful, either  False.\nadd_void\npython:list\nPrimitive\npoint\npython:list\nin\nthe\nformat\nof\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.add_void",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.add_void.html#pyedb.grpc.database.primitive.circle.Circle.add_void",
        "title": "add_void > add_void > add_void",
        "section": "add_void > add_void",
        "text": "Circle.add_void(point_list) -> bool\n\nAdd a void to current primitive.\n\nParameters\n\npoint_list\n\npython:list or Primitive             or point python:list in the format of [[x1,y1], [x2,y2],..,[xn,yn]].\n\n\n\nReturns\n\nbool\n\nTrue if successful, either  False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.html#primitive",
        "title": "Primitive",
        "section": "Primitive",
        "text": "Manages EDB functionalities for a primitives.\nIt inherits EDB Object properties.\nPrimitive.add_void(point_list)\nAdd a void to current primitive.\nPrimitive.area([include_voids])\nReturn the total area.\nPrimitive.cast()\nCast the primitive object to the correct concrete type.\nPrimitive.convert_to_polygon()\nConvert path to polygon.\nPrimitive.create_3d_comp()\nCreate a 3D composite model from an MCAD file.\nPrimitive.create_hfss()\nCreate an HFSS model from an MCAD file.\nPrimitive.create_stride()\nCreate a Stride model from an MCAD file.\nPrimitive.delete()\nDelete the layout object.\nPrimitive.expand([offset, tolerance, ...])\nExpand the polygon shape by an absolute value in all direction.\nPrimitive.find_by_id(layout, uid)\nFind a Connectable object by database ID in a given layout.\nPrimitive.get_closest_arc_midpoint(point)\nGet the closest arc midpoint of the primitive to the input data.\nPrimitive.get_closest_point(point)\nGet the closest point of the primitive to the input data.\nPrimitive.get_connected_object_id_set()\nProduce a list of all geometries physically connected to a given layout object.\nPrimitive.get_connected_objects()\nGet connected objects.\nPrimitive.get_hfss_prop()\nGet HFSS properties.\nPrimitive.get_product_property(prod_id, attr_id)\nGet the product property of the layout object for a given product ID and attribute ID.\nPrimitive.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nPrimitive.intersect(primitives)\nIntersect active primitive with one or more primitives.\nPrimitive.intersection_type(primitive)\nGet intersection type between actual primitive and another primitive or polygon data.\nPrimitive.is_intersecting(primitive)\nCheck if actual primitive and another primitive or polygon data intesects.\nPrimitive.make_zone_primitive(zone_id)\nMake the primitive a zone primitive with a zone specified by the provided ID.\nPrimitive.plot([plot_net, show, save_plot])\nPlot the current polygon on matplotlib.\nPrimitive.points([arc_segments])\nReturn the list of points with arcs converted to segments.\nPrimitive.remove_hfss_prop()\nRemove HFSS properties.\nPrimitive.scale(factor[, center])\nScales the polygon relative to a center point by a factor.\nPrimitive.set_hfss_prop(material, solve_inside)\nSet HFSS properties.\nPrimitive.set_product_property(prod_id, ...)\nSet the product property of the layout object for a given product ID and attribute ID.\nPrimitive.subtract(primitives)\nSubtract active primitive with one or more primitives.\nPrimitive.unite(primitives)\nUnite active primitive with one or more primitives.\nPrimitive.layout_obj_type\nLayoutObjType: Layout object type of the Primitive class.\nPrimitive\nPrimitive.add_void\nPrimitive.area\nPrimitive.cast\nPrimitive.convert_to_polygon\nPrimitive.create_3d_comp\nPrimitive.create_hfss\nPrimitive.create_stride\nPrimitive.delete\nPrimitive.expand\nPrimitive.find_by_id\nPrimitive.get_closest_arc_midpoint\nPrimitive.get_closest_point\nPrimitive.get_connected_object_id_set\nPrimitive.get_connected_objects\nPrimitive.get_hfss_prop\nPrimitive.get_product_property\nPrimitive.get_product_property_ids\nPrimitive.intersect\nPrimitive.intersection_type\nPrimitive.is_intersecting\nPrimitive.make_zone_primitive\nPrimitive.plot\nPrimitive.points\nPrimitive.remove_hfss_prop\nPrimitive.scale\nPrimitive.set_hfss_prop\nPrimitive.set_product_property\nPrimitive.subtract\nPrimitive.unite\nPrimitive.layout_obj_type\nLayoutObjType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.html#pyedb.grpc.database.primitive.primitive.Primitive",
        "title": "Primitive > Primitive > Primitive",
        "section": "Primitive > Primitive",
        "text": "class pyedb.grpc.database.primitive.primitive.Primitive(pedb, edb_object)\n\nManages EDB functionalities for a primitives.\nIt inherits EDB Object properties.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb(myedb, edbversion=\"2021.2\")\n>>> edb_prim = edb.modeler.primitives[0]\n>>> edb_prim.is_void  # Class Property\n>>> edb_prim.IsVoid()  # EDB Object Property\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nPrimitive.add_void(point_list)\n\nAdd a void to current primitive.\n\nPrimitive.area([include_voids])\n\nReturn the total area.\n\nPrimitive.cast()\n\nCast the primitive object to the correct concrete type.\n\nPrimitive.convert_to_polygon()\n\nConvert path to polygon.\n\nPrimitive.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nPrimitive.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nPrimitive.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nPrimitive.delete()\n\nDelete the layout object.\n\nPrimitive.expand([offset, tolerance, ...])\n\nExpand the polygon shape by an absolute value in all direction.\n\nPrimitive.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nPrimitive.get_closest_arc_midpoint(point)\n\nGet the closest arc midpoint of the primitive to the input data.\n\nPrimitive.get_closest_point(point)\n\nGet the closest point of the primitive to the input data.\n\nPrimitive.get_connected_object_id_set()\n\nProduce a list of all geometries physically connected to a given layout object.\n\nPrimitive.get_connected_objects()\n\nGet connected objects.\n\nPrimitive.get_hfss_prop()\n\nGet HFSS properties.\n\nPrimitive.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nPrimitive.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nPrimitive.intersect(primitives)\n\nIntersect active primitive with one or more primitives.\n\nPrimitive.intersection_type(primitive)\n\nGet intersection type between actual primitive and another primitive or polygon data.\n\nPrimitive.is_intersecting(primitive)\n\nCheck if actual primitive and another primitive or polygon data intesects.\n\nPrimitive.make_zone_primitive(zone_id)\n\nMake the primitive a zone primitive with a zone specified by the provided ID.\n\nPrimitive.plot([plot_net, show, save_plot])\n\nPlot the current polygon on matplotlib.\n\nPrimitive.points([arc_segments])\n\nReturn the list of points with arcs converted to segments.\n\nPrimitive.remove_hfss_prop()\n\nRemove HFSS properties.\n\nPrimitive.scale(factor[, center])\n\nScales the polygon relative to a center point by a factor.\n\nPrimitive.set_hfss_prop(material, solve_inside)\n\nSet HFSS properties.\n\nPrimitive.set_product_property(prod_id, ...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nPrimitive.subtract(primitives)\n\nSubtract active primitive with one or more primitives.\n\nPrimitive.unite(primitives)\n\nUnite active primitive with one or more primitives.\n\n\n\nAttributes\n\n\n\n\n\n\n\nPrimitive.layout_obj_type\n\nLayoutObjType: Layout object type of the Primitive class.\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kLNA",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kLNA.html#klna",
        "title": "kLNA",
        "section": "kLNA",
        "text": "kLNA"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kLNA",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kLNA.html#pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kLNA",
        "title": "kLNA > kLNA > kLNA",
        "section": "kLNA > kLNA",
        "text": "SimulationSetupType.kLNA = 'lna'\n\n"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.value",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.value.html#value",
        "title": "value",
        "section": "value",
        "text": "value"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.value",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.value.html#pyedb.workflows.drc.drc.MinAnnularRing.value",
        "title": "value > value > value",
        "section": "value > value",
        "text": "MinAnnularRing.value: str\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.find_padstack_instances",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.find_padstack_instances.html#find_padstack_instances",
        "title": "find_padstack_instances",
        "section": "find_padstack_instances",
        "text": "Finds padstack instances matching the specified criteria.\nThis method filters the available padstack instances based on specified attributes such as\naedt_name, component_name, component_pin_name, net_name, or instance_id. Criteria\ncan be passed as individual values or as a list of values. If no padstack instances match\nthe criteria, an error is raised.\nName(s) of the AEDT padstack instance(s) to filter.\nName(s) of the component(s) to filter padstack instances by.\nName(s) of the component pin(s) to filter padstack instances by.\nName(s) of the net(s) to filter padstack instances by.\nID(s) of the padstack instance(s) to filter.\nA list of padstack instances matching the specified criteria.\nfind_padstack_instances\nUnion\npython:str\nList\npython:str\noptional\nUnion\npython:str\nList\npython:str\noptional\nUnion\npython:str\nList\npython:str\noptional\nUnion\npython:str\nList\npython:str\noptional\nUnion\npython:int\nList\npython:int\noptional\nList"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.find_padstack_instances",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.find_padstack_instances.html#pyedb.grpc.database.layout.layout.Layout.find_padstack_instances",
        "title": "find_padstack_instances > find_padstack_instances > find_padstack_instances",
        "section": "find_padstack_instances > find_padstack_instances",
        "text": "Layout.find_padstack_instances(aedt_name: str | List[str] | None = None, component_name: str | List[str] | None = None, component_pin_name: str | List[str] | None = None, net_name: str | List[str] | None = None, instance_id: int | List[int] | None = None) -> List\n\nFinds padstack instances matching the specified criteria.\n\nThis method filters the available padstack instances based on specified attributes such as\naedt_name, component_name, component_pin_name, net_name, or instance_id. Criteria\ncan be passed as individual values or as a list of values. If no padstack instances match\nthe criteria, an error is raised.\n\nParameters\n\naedt_name\n\nUnion[python:str, List[python:str]], optional\n\nName(s) of the AEDT padstack instance(s) to filter.\n\ncomponent_name\n\nUnion[python:str, List[python:str]], optional\n\nName(s) of the component(s) to filter padstack instances by.\n\ncomponent_pin_name\n\nUnion[python:str, List[python:str]], optional\n\nName(s) of the component pin(s) to filter padstack instances by.\n\nnet_name\n\nUnion[python:str, List[python:str]], optional\n\nName(s) of the net(s) to filter padstack instances by.\n\ninstance_id\n\nUnion[python:int, List[python:int]], optional\n\nID(s) of the padstack instance(s) to filter.\n\nReturns\n\nList\n\nA list of padstack instances matching the specified criteria.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.create_mesh_region",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.create_mesh_region.html#create_mesh_region",
        "title": "create_mesh_region",
        "section": "create_mesh_region",
        "text": "Designate a mesh region in a design and create partitions for meshing.\nHorizontal padding of the new mesh region (applied to both x and y directions).\nVertical padding above the new mesh region.\nVertical padding below the new mesh region.\nTrue will create a new mesh region defined by the active nets in the design.\nFalse will create a new mesh region defined by the dielectric extents in the design.\nTrue will include bot positive nets and reference nets in the definition of the new mesh region.\nFalse will not include bot positive nets and reference nets.\nExtent type of the new mesh region.\nNumber of partitions to create on x-axis in the new mesh region.\nNumber of partitions to create on y-axis in the new mesh region.\ncreate_mesh_region\nValue\nValue\nValue\nTrue\nFalse\nTrue\nFalse\nExtentType\npython:int\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.create_mesh_region",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.create_mesh_region.html#pyedb.grpc.database.layout.layout.Layout.create_mesh_region",
        "title": "create_mesh_region > create_mesh_region > create_mesh_region",
        "section": "create_mesh_region > create_mesh_region",
        "text": "Layout.create_mesh_region(xy_exp: Value, pos_z_exp: Value, neg_z_exp: Value, use_active_nets: bool, incl_ref: bool, ext: ExtentType, num_x_partitions: int, num_y_partitions: int)\n\nDesignate a mesh region in a design and create partitions for meshing.\n\nParameters\n\nxy_exp\n\nValue\n\nHorizontal padding of the new mesh region (applied to both x and y directions).\n\npos_z_exp\n\nValue\n\nVertical padding above the new mesh region.\n\nneg_z_exp\n\nValue\n\nVertical padding below the new mesh region.\n\nuse_active_nets: bool\n\nTrue will create a new mesh region defined by the active nets in the design.\nFalse will create a new mesh region defined by the dielectric extents in the design.\n\nincl_ref\n\nbool\n\nTrue will include bot positive nets and reference nets in the definition of the new mesh region.\nFalse will not include bot positive nets and reference nets.\n\next\n\nExtentType\n\nExtent type of the new mesh region.\n\nnum_x_partitions\n\npython:int\n\nNumber of partitions to create on x-axis in the new mesh region.\n\nnum_y_partitions\n\npython:int\n\nNumber of partitions to create on y-axis in the new mesh region.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_computed_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_computed_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_computed_fields.html#pyedb.workflows.drc.drc.BackDrillStubLength.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "BackDrillStubLength.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/SiWave",
        "href": "dotnet_api/dotnet/SiWave.html#siwave-manager",
        "title": "SIwave manager",
        "section": "SIwave manager",
        "text": "SIwave is a specialized tool\nfor power integrity, signal integrity, and EMI analysis of IC packages and PCB. This tool\nsolves power delivery systems and high-speed channels in electronic devices. It can be\naccessed from PyEDB in Windows only. All setups can be implemented through EDB API.\nSiwave([specified_version])\nInitializes SIwave based on the inputs provided and manages SIwave release and closing.\nSIwave manager\nSiwave"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.save_edb_as",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.save_edb_as.html#save_edb_as",
        "title": "save_edb_as",
        "section": "save_edb_as",
        "text": "Save the EDB file as another file.\n. deprecated:: pyedb 0.47.0\nUse: func:save_as instead.\nName of the new file to save to.\nTrue when successful, False when failed.\nsave_edb_as\npython:str\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.save_edb_as",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.save_edb_as.html#pyedb.dotnet.edb.Edb.save_edb_as",
        "title": "save_edb_as > save_edb_as > save_edb_as",
        "section": "save_edb_as > save_edb_as",
        "text": "Edb.save_edb_as(path)\n\nSave the EDB file as another file.\n\n. deprecated:: pyedb 0.47.0\nUse: func:save_as instead.\n\nParameters\n\npath\n\npython:str\n\nName of the new file to save to.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_json_schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias: Whether to use attribute aliases or not.\nref_template: The reference template.\nunion_format: The format to use when combining schemas from unions together. Can be one of:\n‘any_of’: Use the [anyOf](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\nkeyword to combine schemas (the default).\n- ‘primitive_type_array’: Use the [type](https://json-schema.org/understanding-json-schema/reference/type)\nkeyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\ntype (string, boolean, null, integer or number) or contains constraints/metadata, falls back to\nany_of.\nGenerateJsonSchema with your desired modifications\nmode: The mode in which to generate the schema.\nThe JSON schema for the given model class.\nmodel_json_schema"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_json_schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_json_schema.html#pyedb.workflows.drc.drc.MinClearance.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod MinClearance.model_json_schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}', schema_generator: type[~pydantic.json_schema.GenerateJsonSchema] = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: ~typing.Literal['validation', 'serialization'] = 'validation', *, union_format: ~typing.Literal['any_of', 'primitive_type_array'] = 'any_of') -> dict[str, Any]\n\nGenerates a JSON schema for a model class.\n\nArgs:\n\nby_alias: Whether to use attribute aliases or not.\nref_template: The reference template.\nunion_format: The format to use when combining schemas from unions together. Can be one of:\n\n‘any_of’: Use the [anyOf](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n\nkeyword to combine schemas (the default).\n- ‘primitive_type_array’: Use the [type](https://json-schema.org/understanding-json-schema/reference/type)\nkeyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\ntype (string, boolean, null, integer or number) or contains constraints/metadata, falls back to\nany_of.\n\nschema_generator: To override the logic used to generate the JSON schema, as a subclass of\n\nGenerateJsonSchema with your desired modifications\n\nmode: The mode in which to generate the schema.\n\nReturns:\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/polygon",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/polygon.html#polygon",
        "title": "Polygon",
        "section": "Polygon",
        "text": "This class is managing EDB polygon.\nPolygon\n\nPolygon\nPolygon"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.siw_dc_ir_settings.SiwaveDCIRSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.siw_dc_ir_settings.SiwaveDCIRSettings.html#siwavedcirsettings",
        "title": "SiwaveDCIRSettings",
        "section": "SiwaveDCIRSettings",
        "text": "Class for DC IR settings.\nSiwaveDCIRSettings"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.siw_dc_ir_settings.SiwaveDCIRSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.siw_dc_ir_settings.SiwaveDCIRSettings.html#pyedb.dotnet.database.sim_setup_data.data.siw_dc_ir_settings.SiwaveDCIRSettings",
        "title": "SiwaveDCIRSettings > SiwaveDCIRSettings > SiwaveDCIRSettings",
        "section": "SiwaveDCIRSettings > SiwaveDCIRSettings",
        "text": "class pyedb.dotnet.database.sim_setup_data.data.siw_dc_ir_settings.SiwaveDCIRSettings(parent)\n\nClass for DC IR settings.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.save_project",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.save_project.html#save_project",
        "title": "save_project",
        "section": "save_project",
        "text": "Save the project.\nFull path to the project. The default is None.\nName of the project. The default is None.\nTrue when successful, False when failed.\nsave_project\npython:str\noptional\nNone\npython:str\noptional\nNone\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.save_project",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.save_project.html#pyedb.siwave.Siwave.save_project",
        "title": "save_project > save_project > save_project",
        "section": "save_project > save_project",
        "text": "Siwave.save_project(projectpath=None, projectName=None)\n\nSave the project.\n\nParameters\n\nproj_path\n\npython:str, optional\n\nFull path to the project. The default is None.\n\nprojectName\n\npython:str, optional\n\nName of the project. The default is None.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.set_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.set_hfss_prop.html#set_hfss_prop",
        "title": "set_hfss_prop",
        "section": "set_hfss_prop",
        "text": "Set HFSS properties.\nMaterial property name to set.\nWhether to solve inside.\nset_hfss_prop\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.set_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.set_hfss_prop.html#pyedb.grpc.database.primitive.primitive.Primitive.set_hfss_prop",
        "title": "set_hfss_prop > set_hfss_prop > set_hfss_prop",
        "section": "set_hfss_prop > set_hfss_prop",
        "text": "Primitive.set_hfss_prop(material: str, solve_inside: bool)\n\nSet HFSS properties.\n\nParameters\n\nmaterial\n\npython:str\n\nMaterial property name to set.\n\nsolve_inside\n\nbool\n\nWhether to solve inside.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_roughness_model",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_roughness_model.html#set_roughness_model",
        "title": "set_roughness_model",
        "section": "set_roughness_model",
        "text": "Set the roughness model used by the layer.\nset_roughness_model\nRoughnessRegion"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_roughness_model",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_roughness_model.html#pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_roughness_model",
        "title": "set_roughness_model > set_roughness_model > set_roughness_model",
        "section": "set_roughness_model > set_roughness_model",
        "text": "StackupLayer.set_roughness_model(roughness_model, region)\n\nSet the roughness model used by the layer.\n\nParameters\n\nroughness_model\n\nRoughnessModel\n\n\n\nregion\n\nRoughnessRegion\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.import_from_control_file",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.import_from_control_file.html#import_from_control_file",
        "title": "import_from_control_file",
        "section": "import_from_control_file",
        "text": "Import layers from a control file and optional XML schema file.\nFull path to the control file.\nFull path to the XML schema file.\nimport_from_control_file\npython:str\npython:str\npython:None"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.import_from_control_file",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.import_from_control_file.html#pyedb.grpc.database.stackup.LayerCollection.import_from_control_file",
        "title": "import_from_control_file > import_from_control_file > import_from_control_file",
        "section": "import_from_control_file > import_from_control_file",
        "text": "LayerCollection.import_from_control_file(control_file_path, schema_file_path=None)\n\nImport layers from a control file and optional XML schema file.\n\nParameters\n\ncontrol_file_path\n\npython:str\n\nFull path to the control file.\n\nschema_file_path\n\npython:str, default: python:None\n\nFull path to the XML schema file.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileBoundaries",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileBoundaries.html#controlfileboundaries",
        "title": "ControlFileBoundaries",
        "section": "ControlFileBoundaries",
        "text": "Manages boundaries for the control file.\nLength units. Default is “um”.\nControlFileBoundaries.add_extent([type, ...])\nAdd an extent.\nControlFileBoundaries.add_port(name, x1, y1, ...)\nAdd a port.\nControlFileBoundaries\npython:str\noptional\nControlFileBoundaries.add_extent\nControlFileBoundaries.add_port"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileBoundaries",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileBoundaries.html#pyedb.grpc.database.control_file.ControlFileBoundaries",
        "title": "ControlFileBoundaries > ControlFileBoundaries > ControlFileBoundaries",
        "section": "ControlFileBoundaries > ControlFileBoundaries",
        "text": "class pyedb.grpc.database.control_file.ControlFileBoundaries(units: str = 'um')\n\nManages boundaries for the control file.\n\nParameters\n\nunits\n\npython:str, optional\n\nLength units. Default is “um”.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nControlFileBoundaries.add_extent([type, ...])\n\nAdd an extent.\n\nControlFileBoundaries.add_port(name, x1, y1, ...)\n\nAdd a port.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.create",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create an edge terminal.\nLayout to create the edge terminal in.\nName of the edge terminal.\nNet reference. The default is None.\nWhether the edge terminal is a reference terminal.\ncreate\nLayout\nstr\npython:list\nof\nEdge\nNet\nstr\npython:None\nNone\nbool\npython:False\nEdgeTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.create",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.create.html#pyedb.grpc.database.ports.ports.GapPort.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod GapPort.create(layout, name, edges, net=None, is_ref=False)\n\nCreate an edge terminal.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to create the edge terminal in.\n\nname\n\nstr\n\nName of the edge terminal.\n\nedges\n\npython:list of Edge\n\n\n\nnet\n\nNet or str or python:None\n\nNet reference. The default is None.\n\nis_ref\n\nbool, default: python:False\n\nWhether the edge terminal is a reference terminal.\n\nReturns\n\nEdgeTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.heatsink.HeatSink",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.heatsink.HeatSink.html#heatsink",
        "title": "HeatSink",
        "section": "HeatSink",
        "text": "Heatsink model description.\nInherited object.\nHeatSink\npyedb.dotnet.edb.Edb\nAnsys.Ansoft.Edb.Utility.HeatSink"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.heatsink.HeatSink",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.heatsink.HeatSink.html#pyedb.dotnet.database.utilities.heatsink.HeatSink",
        "title": "HeatSink > HeatSink > HeatSink",
        "section": "HeatSink > HeatSink",
        "text": "class pyedb.dotnet.database.utilities.heatsink.HeatSink(pedb, edb_object=None)\n\nHeatsink model description.\n\nParameters\n\npedb\n\npyedb.dotnet.edb.Edb\n\nInherited object.\n\nedb_object\n\nAnsys.Ansoft.Edb.Utility.HeatSink,\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "LayoutObjType: Layout object type of the Primitive class.\nlayout_obj_type\nLayoutObjType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.layout_obj_type.html#pyedb.grpc.database.primitive.primitive.Primitive.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "Primitive.layout_obj_type = 0\n\nLayoutObjType: Layout object type of the Primitive class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.rlc.Rlc",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.rlc.Rlc.html#rlc",
        "title": "Rlc",
        "section": "Rlc",
        "text": "Rlc"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.rlc.Rlc",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.rlc.Rlc.html#pyedb.grpc.database.utility.rlc.Rlc",
        "title": "Rlc > Rlc > Rlc",
        "section": "Rlc > Rlc",
        "text": "class pyedb.grpc.database.utility.rlc.Rlc(pedb, edb_object)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.convert_to_polygon",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.convert_to_polygon.html#convert_to_polygon",
        "title": "convert_to_polygon",
        "section": "convert_to_polygon",
        "text": "Convert path to polygon.\nPolygon when successful, False when failed.\nconvert_to_polygon\nPolygon\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.convert_to_polygon",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.convert_to_polygon.html#pyedb.grpc.database.primitive.path.Path.convert_to_polygon",
        "title": "convert_to_polygon > convert_to_polygon > convert_to_polygon",
        "section": "convert_to_polygon > convert_to_polygon",
        "text": "Path.convert_to_polygon()\n\nConvert path to polygon.\n\nReturns\n\nPolygon\n\nPolygon when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the terminal object to the correct concrete type, fetching the type if necessary.\ncast\nTerminalType\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.cast.html#pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "PinGroupTerminal.cast(term_type=None)\n\nCast the terminal object to the correct concrete type, fetching the type if necessary.\n\nParameters\n\nterm_type\n\nTerminalType\n\n\n\nReturns\n\nTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_padstack_instances_rtree_index",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_padstack_instances_rtree_index.html#get_padstack_instances_rtree_index",
        "title": "get_padstack_instances_rtree_index",
        "section": "get_padstack_instances_rtree_index",
        "text": "Returns padstack instances Rtree index.\nnet name of list of nets name applying filtering on padstack instances selection. If None is provided\nall instances are included in the index. Default value is None.\nget_padstack_instances_rtree_index\npython:str\npython:list\noptional\nNone\nNone\nRtree\nindex"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_padstack_instances_rtree_index",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_padstack_instances_rtree_index.html#pyedb.grpc.database.padstacks.Padstacks.get_padstack_instances_rtree_index",
        "title": "get_padstack_instances_rtree_index > get_padstack_instances_rtree_index > get_padstack_instances_rtree_index",
        "section": "get_padstack_instances_rtree_index > get_padstack_instances_rtree_index",
        "text": "Padstacks.get_padstack_instances_rtree_index(nets: str | List[str] | None = None) -> Index\n\nReturns padstack instances Rtree index.\n\nParameters\n\nnets\n\npython:str or python:list, optional\n\nnet name of list of nets name applying filtering on padstack instances selection. If None is provided\nall instances are included in the index. Default value is None.\n\nReturns\n\nRtree index object.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.expand",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.expand.html#expand",
        "title": "expand",
        "section": "expand",
        "text": "Expand the polygon shape by an absolute value in all direction.\nOffset can be negative for negative expansion.\nOffset value in meters.\nTolerance in meters.\nWhether to round corners or not.\nIf True, use rounded corners in the expansion otherwise use straight edges (can be degenerate).\nThe maximum corner extension (when round corners are not used) at which point the corner is clipped.\nexpand\npython:float\noptional\npython:float\noptional\noptional\npython:float\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.expand",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.expand.html#pyedb.grpc.database.primitive.rectangle.Rectangle.expand",
        "title": "expand > expand > expand",
        "section": "expand > expand",
        "text": "Rectangle.expand(offset=0.001, tolerance=1e-12, round_corners=True, maximum_corner_extension=0.001) -> list[any]\n\nExpand the polygon shape by an absolute value in all direction.\nOffset can be negative for negative expansion.\n\nParameters\n\noffset\n\npython:float, optional\n\nOffset value in meters.\n\ntolerance\n\npython:float, optional\n\nTolerance in meters.\n\nround_corners\n\nbool, optional\n\nWhether to round corners or not.\nIf True, use rounded corners in the expansion otherwise use straight edges (can be degenerate).\n\nmaximum_corner_extension\n\npython:float, optional\n\nThe maximum corner extension (when round corners are not used) at which point the corner is clipped.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_simulation_setup.SiwaveSimulationSetup.create",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_simulation_setup.SiwaveSimulationSetup.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a SIWave simulationsetup.\nCell to create simulation setup in.\nName of the simulation setup.\nSimulation setup created.\ncreate\nCell\npython:str\nSIWaveSimulationSetup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_simulation_setup.SiwaveSimulationSetup.create",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_simulation_setup.SiwaveSimulationSetup.create.html#pyedb.grpc.database.simulation_setup.siwave_simulation_setup.SiwaveSimulationSetup.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod SiwaveSimulationSetup.create(cell, name)\n\nCreate a SIWave simulationsetup.\n\nParameters\n\ncell\n\nCell\n\nCell to create simulation setup in.\n\nname\n\npython:str\n\nName of the simulation setup.\n\nReturns\n\nSIWaveSimulationSetup\n\nSimulation setup created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.set_product_property.html#pyedb.grpc.database.net.extended_net.ExtendedNet.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "ExtendedNet.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_connected_objects",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_connected_objects.html#get_connected_objects",
        "title": "get_connected_objects",
        "section": "get_connected_objects",
        "text": "Get connected objects.\nget_connected_objects\nList\nLayoutObjInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_connected_objects",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_connected_objects.html#pyedb.grpc.database.primitive.rectangle.Rectangle.get_connected_objects",
        "title": "get_connected_objects > get_connected_objects > get_connected_objects",
        "section": "get_connected_objects > get_connected_objects",
        "text": "Rectangle.get_connected_objects()\n\nGet connected objects.\n\nReturns\n\nList[LayoutObjInstance]\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.is_parameter",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.is_parameter.html#is_parameter",
        "title": "is_parameter",
        "section": "is_parameter",
        "text": "Determine if the variable is a parameter.\nVariable name.\nTrue if the variable is a parameter, False otherwise.\nis_parameter\npython:str\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.is_parameter",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.is_parameter.html#pyedb.grpc.database.layout.layout.Layout.is_parameter",
        "title": "is_parameter > is_parameter > is_parameter",
        "section": "is_parameter > is_parameter",
        "text": "Layout.is_parameter(name)\n\nDetermine if the variable is a parameter.\n\nParameters\n\nname\n\npython:str\n\nVariable name.\n\nReturns\n\nbool\n\nTrue if the variable is a parameter, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "schema"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.schema.html#pyedb.workflows.drc.drc.BackDrillStubLength.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod BackDrillStubLength.schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}') -> Dict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.set_product_property.html#pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "PinGroupTerminal.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.layout_obj_type.html#pyedb.grpc.database.layers.layer.Layer.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "Layer.layout_obj_type = 5\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.add_frequency_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.add_frequency_sweep.html#add_frequency_sweep",
        "title": "add_frequency_sweep",
        "section": "add_frequency_sweep",
        "text": "Add frequency sweep.\nName of the frequency sweep. The default is None.\nList of frequency points. The default is None.\nadd_frequency_sweep\npython:str\noptional\nNone\npython:list\noptional\nNone\npyedb.dotnet.database.edb_data.simulation_setup_data.EdbFrequencySweep"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.add_frequency_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.add_frequency_sweep.html#pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.add_frequency_sweep",
        "title": "add_frequency_sweep > add_frequency_sweep > add_frequency_sweep",
        "section": "add_frequency_sweep > add_frequency_sweep",
        "text": "SiwaveSimulationSetup.add_frequency_sweep(name=None, frequency_sweep=None)\n\nAdd frequency sweep.\n\nParameters\n\nname\n\npython:str, optional\n\nName of the frequency sweep. The default is None.\n\nfrequency_sweep\n\npython:list, optional\n\nList of frequency points. The default is None.\n\nReturns\n\npyedb.dotnet.database.edb_data.simulation_setup_data.EdbFrequencySweep\n\n\n\nExamples\n\n>>> setup1 = edbapp.create_siwave_syz_setup(\"setup1\")\n>>> setup1.add_frequency_sweep(\n...     frequency_sweep=[\n...         [\"linear count\", \"0\", \"1kHz\", 1],\n...         [\"log scale\", \"1kHz\", \"0.1GHz\", 10],\n...         [\"linear scale\", \"0.1GHz\", \"10GHz\", \"0.1GHz\"],\n...     ]\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/layer",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/layer.html#layer",
        "title": "Layer",
        "section": "Layer",
        "text": "This class is managing EDB layer.\nLayer\nManages Layer.\nLayer\nLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.create_3d_comp.html#create_3d_comp",
        "title": "create_3d_comp",
        "section": "create_3d_comp",
        "text": "Create a 3D composite model from an MCAD file.\n3D composite model created.\ncreate_3d_comp\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.create_3d_comp.html#pyedb.grpc.database.ports.ports.CoaxPort.create_3d_comp",
        "title": "create_3d_comp > create_3d_comp > create_3d_comp",
        "section": "create_3d_comp > create_3d_comp",
        "text": "CoaxPort.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nReturns\n\nMcadModel\n\n3D composite model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.add_frequency_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.add_frequency_sweep.html#add_frequency_sweep",
        "title": "add_frequency_sweep",
        "section": "add_frequency_sweep",
        "text": "Add frequency sweep.\nName of the frequency sweep. The default is None.\nList of frequency points. The default is None.\nadd_frequency_sweep\npython:str\noptional\nNone\npython:list\noptional\nNone\npyedb.dotnet.database.edb_data.simulation_setup_data.EdbFrequencySweep"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.add_frequency_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.add_frequency_sweep.html#pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.add_frequency_sweep",
        "title": "add_frequency_sweep > add_frequency_sweep > add_frequency_sweep",
        "section": "add_frequency_sweep > add_frequency_sweep",
        "text": "SimulationSetup.add_frequency_sweep(name=None, frequency_sweep=None)\n\nAdd frequency sweep.\n\nParameters\n\nname\n\npython:str, optional\n\nName of the frequency sweep. The default is None.\n\nfrequency_sweep\n\npython:list, optional\n\nList of frequency points. The default is None.\n\nReturns\n\npyedb.dotnet.database.edb_data.simulation_setup_data.EdbFrequencySweep\n\n\n\nExamples\n\n>>> setup1 = edbapp.create_siwave_syz_setup(\"setup1\")\n>>> setup1.add_frequency_sweep(\n...     frequency_sweep=[\n...         [\"linear count\", \"0\", \"1kHz\", 1],\n...         [\"log scale\", \"1kHz\", \"0.1GHz\", 10],\n...         [\"linear scale\", \"0.1GHz\", \"10GHz\", \"0.1GHz\"],\n...     ]\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/index",
        "href": "dotnet_api/dotnet/sim_setup_data/data/index.html#simulation-setup-data",
        "title": "Simulation setup data",
        "section": "Simulation setup data",
        "text": "This section describes Simulation setup data.\nSimulation setup data"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.add_port_on_rlc_component",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.add_port_on_rlc_component.html#add_port_on_rlc_component",
        "title": "add_port_on_rlc_component",
        "section": "add_port_on_rlc_component",
        "text": "Deactivate RLC component and replace it with a circuit port.\nThe circuit port supports only two-pin components.\nReference designator of the RLC component.\nTrue will replace RLC component by circuit ports, False gap ports compatible with HFSS 3D modeler\nexport.\nWhether to define the PEC boundary, The default is False. If set to True,\na perfect short is created between the pin and impedance is ignored. This\nparameter is only supported on a port created between two pins, such as\nwhen there is no pin group.\nTrue when successful, False when failed.\nadd_port_on_rlc_component\npython:str\nTrue\nFalse\noptional\nFalse\nTrue\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.add_port_on_rlc_component",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.add_port_on_rlc_component.html#pyedb.grpc.database.source_excitations.SourceExcitation.add_port_on_rlc_component",
        "title": "add_port_on_rlc_component > add_port_on_rlc_component > add_port_on_rlc_component",
        "section": "add_port_on_rlc_component > add_port_on_rlc_component",
        "text": "SourceExcitation.add_port_on_rlc_component(component: str | Component | None = None, circuit_ports: bool = True, pec_boundary: bool = False) -> bool\n\nDeactivate RLC component and replace it with a circuit port.\nThe circuit port supports only two-pin components.\n\nParameters\n\ncomponent\n\npython:str\n\nReference designator of the RLC component.\n\ncircuit_ports\n\nbool\n\nTrue will replace RLC component by circuit ports, False gap ports compatible with HFSS 3D modeler\nexport.\n\npec_boundary\n\nbool, optional\n\nWhether to define the PEC boundary, The default is False. If set to True,\na perfect short is created between the pin and impedance is ignored. This\nparameter is only supported on a port created between two pins, such as\nwhen there is no pin group.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> edb.source_excitation.add_port_on_rlc_component(\"R1\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.find_by_id.html#find_by_id",
        "title": "find_by_id",
        "section": "find_by_id",
        "text": "Find a Connectable object by database ID in a given layout.\nLayout to search for the Connectable object.\nDatabase ID.\nConnectable object with the given database ID.\nfind_by_id\nLayout\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.find_by_id.html#pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.find_by_id",
        "title": "find_by_id > find_by_id > find_by_id",
        "section": "find_by_id > find_by_id",
        "text": "classmethod PadstackInstanceTerminal.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the Connectable object.\n\nuid\n\npython:int\n\nDatabase ID.\n\nReturns\n\nConnectable\n\nConnectable object with the given database ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileDielectric",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileDielectric.html#controlfiledielectric",
        "title": "ControlFileDielectric",
        "section": "ControlFileDielectric",
        "text": "ControlFileDielectric"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileDielectric",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileDielectric.html#pyedb.grpc.database.utility.xml_control_file.ControlFileDielectric",
        "title": "ControlFileDielectric > ControlFileDielectric > ControlFileDielectric",
        "section": "ControlFileDielectric > ControlFileDielectric",
        "text": "class pyedb.grpc.database.utility.xml_control_file.ControlFileDielectric(name, properties)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.parametrize_trace_width",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.parametrize_trace_width.html#parametrize_trace_width",
        "title": "parametrize_trace_width",
        "section": "parametrize_trace_width",
        "text": "Parametrize a Trace on specific layer or all stackup.\nname of the net or list of nets to parametrize.\nname of the layer or list of layers to which the net to parametrize has to be included.\nname of the parameter to create.\nvalue with units of parameter to create.\nIf None, the first trace width of Net will be used as parameter value.\nparametrize_trace_width\npython:str\npython:list\npython:str\noptional\npython:str\noptional\npython:str\npython:float\noptional"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.parametrize_trace_width",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.parametrize_trace_width.html#pyedb.dotnet.database.modeler.Modeler.parametrize_trace_width",
        "title": "parametrize_trace_width > parametrize_trace_width > parametrize_trace_width",
        "section": "parametrize_trace_width > parametrize_trace_width",
        "text": "Modeler.parametrize_trace_width(nets_name, layers_name=None, parameter_name='trace_width', variable_value=None)\n\nParametrize a Trace on specific layer or all stackup.\n\nParameters\n\nnets_name\n\npython:str, python:list\n\nname of the net or list of nets to parametrize.\n\nlayers_name\n\npython:str, optional\n\nname of the layer or list of layers to which the net to parametrize has to be included.\n\nparameter_name\n\npython:str, optional\n\nname of the parameter to create.\n\nvariable_value\n\npython:str, python:float, optional\n\nvalue with units of parameter to create.\nIf None, the first trace width of Net will be used as parameter value.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.html#pointdata",
        "title": "PointData",
        "section": "PointData",
        "text": "Class managing Point Data\nPointData.angle(other)\nGet the angle between this vector and another vector.\nPointData.closest(start, end)\nGet the closest point on a line segment from the point.\nPointData.cross(other)\nCompute the cross product of the point vector with another point vector.\nPointData.distance(start[, end])\nCompute the shortest distance from the point to a line segment when an end point is given.\nPointData.dot(other)\nPerform per-component multiplication (dot product) of this point and another point.\nPointData.equals(other[, tolerance])\nDetermine if two points are located at the same coordinates.\nPointData.magnitude()\nGet the magnitude of the point vector.\nPointData.move(vector)\nMove the point by a vector.\nPointData.normalized()\nNormalize the point vector.\nPointData.rotate(angle, center)\nRotate a point at a given center by a given angle.\nPointData\nPoint Data\nPointData.angle\nPointData.closest\nPointData.cross\nPointData.distance\nPointData.dot\nPointData.equals\nPointData.magnitude\nPointData.move\nPointData.normalized\nPointData.rotate"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.html#pyedb.grpc.database.geometry.point_data.PointData",
        "title": "PointData > PointData > PointData",
        "section": "PointData > PointData",
        "text": "class pyedb.grpc.database.geometry.point_data.PointData(edb_object=None)\n\nClass managing Point Data\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nPointData.angle(other)\n\nGet the angle between this vector and another vector.\n\nPointData.closest(start, end)\n\nGet the closest point on a line segment from the point.\n\nPointData.cross(other)\n\nCompute the cross product of the point vector with another point vector.\n\nPointData.distance(start[, end])\n\nCompute the shortest distance from the point to a line segment when an end point is given.\n\nPointData.dot(other)\n\nPerform per-component multiplication (dot product) of this point and another point.\n\nPointData.equals(other[, tolerance])\n\nDetermine if two points are located at the same coordinates.\n\nPointData.magnitude()\n\nGet the magnitude of the point vector.\n\nPointData.move(vector)\n\nMove the point by a vector.\n\nPointData.normalized()\n\nNormalize the point vector.\n\nPointData.rotate(angle, center)\n\nRotate a point at a given center by a given angle.\n\n"
    },
    {
        "objectID": "installation",
        "href": "installation.html#installation",
        "title": "Installation",
        "section": "Installation",
        "text": "Installation"
    },
    {
        "objectID": "installation",
        "href": "installation.html#prerequisites",
        "title": "Installation > Prerequisites",
        "section": "Prerequisites",
        "text": "PyEDB requires the ansys-edb-core gRPC client service to be running.\nThe legacy pyedb.dotnet module is deprecated and moved to an archived branch. All new projects must use the gRPC client described below.\n** Use AEDT Installation (Windows-Linux)**\nYou must have AEDT installed, the ansys-edb-core server service is included.\nThe PyEDB client is a python package automatically installed with PyEDB and will automatically find and connect to the\nserver.\nMake sure you are running the latest ansys-edb-core client version compatible with your AEDT version.\nPrerequisites\nLooking for the old DotNet API?\nansys-edb-core\npyedb.dotnet\nansys-edb-core"
    },
    {
        "objectID": "installation",
        "href": "installation.html#install-the-pyedb-client",
        "title": "Installation > Install the PyEDB Client",
        "section": "Install the PyEDB Client",
        "text": "The PyEDB Python client is installed via pip. It is highly recommended to use a virtual environment.\nInstall the PyEDB Client"
    },
    {
        "objectID": "installation",
        "href": "installation.html#verifying-the-installation",
        "title": "Installation > Verifying the Installation",
        "section": "Verifying the Installation",
        "text": "To test your installation and connection to the ansys-edb-core service, run the following Python script:\nVerifying the Installation\nansys-edb-core"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.fix_self_intersections",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.fix_self_intersections.html#fix_self_intersections",
        "title": "fix_self_intersections",
        "section": "fix_self_intersections",
        "text": "Find and fix self intersections from a given netlist.\nList of nets on which check disjoints. If None is provided then the algorithm will loop on all nets.\nfix_self_intersections\npython:str\npython:list\noptional"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.fix_self_intersections",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.fix_self_intersections.html#pyedb.dotnet.database.layout_validation.LayoutValidation.fix_self_intersections",
        "title": "fix_self_intersections > fix_self_intersections > fix_self_intersections",
        "section": "fix_self_intersections > fix_self_intersections",
        "text": "LayoutValidation.fix_self_intersections(net_list=None)\n\nFind and fix self intersections from a given netlist.\n\nParameters\n\nnet_list\n\npython:str, python:list, optional\n\nList of nets on which check disjoints. If None is provided then the algorithm will loop on all nets.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.RadialStub.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.RadialStub.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Draw the fan-shaped polygon and the feeding line.\nTrue on success.\ncreate"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.RadialStub.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.RadialStub.create.html#pyedb.libraries.rf_libraries.base_functions.RadialStub.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "RadialStub.create() -> bool\n\nDraw the fan-shaped polygon and the feeding line.\n\nReturns\n\nbool\n\nTrue on success.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_connected_objects",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_connected_objects.html#get_connected_objects",
        "title": "get_connected_objects",
        "section": "get_connected_objects",
        "text": "Get objects connected to a layout object.\nTarget layout object.\nConnected objects (padstacks, paths, polygons, etc.).\nget_connected_objects\npython:list"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_connected_objects",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_connected_objects.html#pyedb.grpc.edb.Edb.get_connected_objects",
        "title": "get_connected_objects > get_connected_objects > get_connected_objects",
        "section": "get_connected_objects > get_connected_objects",
        "text": "Edb.get_connected_objects(layout_object_instance)\n\nGet objects connected to a layout object.\n\nParameters\n\nlayout_object_instance\n\nTarget layout object.\n\nReturns\n\npython:list\n\nConnected objects (padstacks, paths, polygons, etc.).\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_parameters",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_parameters.html#get_parameters",
        "title": "get_parameters",
        "section": "get_parameters",
        "text": "Get coordinates parameters.\nstr,\nfloat,\nfloat,\nfloat,\nfloat,\nfloat,\nfloat`\nReturns a tuple of the following format:\n(representation_type, parameter1, parameter2, parameter3, parameter4, corner_radius, rotation)\nrepresentation_type : Type that defines given parameters meaning.\nparameter1 : X value of lower left point or center point.\nparameter2 : Y value of lower left point or center point.\nparameter3 : X value of upper right point or width.\nparameter4 : Y value of upper right point or height.\ncorner_radius : Corner radius.\nrotation : Rotation.\nget_parameters\npython:tuple"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_parameters",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_parameters.html#pyedb.grpc.database.primitive.rectangle.Rectangle.get_parameters",
        "title": "get_parameters > get_parameters > get_parameters",
        "section": "get_parameters > get_parameters",
        "text": "Rectangle.get_parameters()\n\nGet coordinates parameters.\n\nReturns\n\npython:tuple[\n\nstr,\nfloat,\nfloat,\nfloat,\nfloat,\nfloat,\nfloat`\n\n]\n\nReturns a tuple of the following format:\n\n(representation_type, parameter1, parameter2, parameter3, parameter4, corner_radius, rotation)\n\nrepresentation_type : Type that defines given parameters meaning.\n\nparameter1 : X value of lower left point or center point.\n\nparameter2 : Y value of lower left point or center point.\n\nparameter3 : X value of upper right point or width.\n\nparameter4 : Y value of upper right point or height.\n\ncorner_radius : Corner radius.\n\nrotation : Rotation.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the cell.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.delete.html#pyedb.grpc.database.layout.cell.Cell.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "Cell.delete()\n\nDelete the cell.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/sweep_data",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/sweep_data.html#sweep-data",
        "title": "Sweep data",
        "section": "Sweep data",
        "text": "This class is managing EDB sweep data for frequency sweep.\nSweepData\nFrequency sweep data class.\nSweep data\nSweepData"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_component_placement_vector",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_component_placement_vector.html#get_component_placement_vector",
        "title": "get_component_placement_vector",
        "section": "get_component_placement_vector",
        "text": "Get placement vector between two components.\nMounted component.\nHosting component.\nPin name on mounted component.\nPin name on mounted component.\nPin name on hosting component.\nPin name on hosting component.\nWhether the component is flipped.\n(success, vector, rotation, solder_ball_height)\nget_component_placement_vector\npyedb.grpc.database.hierarchy.component.Component\npyedb.grpc.database.hierarchy.component.Component\npython:str\npython:str\npython:str\npython:str\noptional\npython:tuple"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_component_placement_vector",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_component_placement_vector.html#pyedb.grpc.database.components.Components.get_component_placement_vector",
        "title": "get_component_placement_vector > get_component_placement_vector > get_component_placement_vector",
        "section": "get_component_placement_vector > get_component_placement_vector",
        "text": "Components.get_component_placement_vector(mounted_component: Component, hosting_component: Component, mounted_component_pin1: str, mounted_component_pin2: str, hosting_component_pin1: str, hosting_component_pin2: str, flipped: bool = False) -> Tuple[bool, List[float], float, float]\n\nGet placement vector between two components.\n\nParameters\n\nmounted_component\n\npyedb.grpc.database.hierarchy.component.Component\n\nMounted component.\n\nhosting_component\n\npyedb.grpc.database.hierarchy.component.Component\n\nHosting component.\n\nmounted_component_pin1\n\npython:str\n\nPin name on mounted component.\n\nmounted_component_pin2\n\npython:str\n\nPin name on mounted component.\n\nhosting_component_pin1\n\npython:str\n\nPin name on hosting component.\n\nhosting_component_pin2\n\npython:str\n\nPin name on hosting component.\n\nflipped\n\nbool, optional\n\nWhether the component is flipped.\n\nReturns\n\npython:tuple\n\n(success, vector, rotation, solder_ball_height)\n\nExamples\n\n>>> vec, rot, height = edbapp.components.get_component_placement_vector(...)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.product_solver_option.html#product_solver_option",
        "title": "product_solver_option",
        "section": "product_solver_option",
        "text": "Get the name of the product solver option.\nID of the product.\nName of the solver.\nName of the product solver option.\nproduct_solver_option\nProductIdType\nstr\nstr"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.product_solver_option.html#pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.product_solver_option",
        "title": "product_solver_option > product_solver_option > product_solver_option",
        "section": "product_solver_option > product_solver_option",
        "text": "BundleTerminal.product_solver_option(product_id, solver_name)\n\nGet the name of the product solver option.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nsolver_name\n\nstr\n\nName of the solver.\n\nReturns\n\nstr\n\nName of the product solver option.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.find_dc_short",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.find_dc_short.html#find_dc_short",
        "title": "find_dc_short",
        "section": "find_dc_short",
        "text": "Find DC-shorted nets.\nIf True, rename all the nets. (default)\nIf False, only report dc shorts.\n[[net name, net name]].\nfind_dc_short\noptional\nList\nList\npython:str\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.find_dc_short",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.find_dc_short.html#pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.find_dc_short",
        "title": "find_dc_short > find_dc_short > find_dc_short",
        "section": "find_dc_short > find_dc_short",
        "text": "EDBNetsData.find_dc_short(fix=False)\n\nFind DC-shorted nets.\n\nParameters\n\nfix\n\nbool, optional\n\nIf True, rename all the nets. (default)\nIf False, only report dc shorts.\n\nReturns\n\nList[List[python:str, python:str]]\n\n[[net name, net name]].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.type",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.type.html#type",
        "title": "type",
        "section": "type",
        "text": "type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.type",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.type.html#pyedb.grpc.database.ports.ports.BundleWavePort.type",
        "title": "type > type > type",
        "section": "type > type",
        "text": "BundleWavePort.type = 4\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/hfss_general_settings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/hfss_general_settings.html#hfss-general-settings",
        "title": "HFSS general settings",
        "section": "HFSS general settings",
        "text": "This class is managing EDB HFSS general settings.\nHFSSGeneralSettings\nPyEDB-core HFSS general settings class.\nHFSS general settings\nHFSSGeneralSettings"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.html#packagedef",
        "title": "PackageDef",
        "section": "PackageDef",
        "text": "Manages EDB package definitions.\nEdb object.\ncomponent_part_name : str, optional\nPart name of the component.\nBounding box defines the shape of the package. For example, [[0, 0], [“2mm”, “2mm”]].\nPackageDef.create(db, name)\nCreate a package definition in a given database.\nPackageDef.delete()\nDelete the package definition.\nPackageDef.find_by_id(db, uid)\nFind a package definition object by ID in a given database.\nPackageDef.find_by_name(db, name)\nFind a package definition object by name in a given database.\nPackageDef.get_product_property(prod_id, attr_it)\nGet the product property for a given product ID and attribute ID.\nPackageDef.get_product_property_ids(prod_id)\nGet the list of property IDs for a given property ID.\nPackageDef.set_heatsink(fin_base_height, ...)\nSet Heat sink. Parameters ---------- fin_base_height : str, float     Fin base height. fin_height : str, float     Fin height. fin_orientation : str     Fin orientation. Supported values, x_oriented, y_oriented. fin_spacing : str, float     Fin spacing. fin_thickness : str, float     Fin thickness.\nPackageDef.set_product_property(prod_id, ...)\nSet the product property for the given product ID and attribute ID.\nPackageDef\nEdb\nobject\npython:list\noptional\nPackageDef.create\nPackageDef.delete\nPackageDef.find_by_id\nPackageDef.find_by_name\nPackageDef.get_product_property\nPackageDef.get_product_property_ids\nPackageDef.set_heatsink\nPackageDef.set_product_property"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.html#pyedb.grpc.database.definition.package_def.PackageDef",
        "title": "PackageDef > PackageDef > PackageDef",
        "section": "PackageDef > PackageDef",
        "text": "class pyedb.grpc.database.definition.package_def.PackageDef(pedb, edb_object=None, name=None, component_part_name=None, extent_bounding_box=None)\n\nManages EDB package definitions.\n\nParameters\n\npedb\n\nEdb\n\nEdb object.\n\nedb_object\n\nobject\n\n\n\nEdb PackageDef Object\n\ncomponent_part_name : str, optional\nPart name of the component.\n\nextent_bounding_box\n\npython:list, optional\n\nBounding box defines the shape of the package. For example, [[0, 0], [“2mm”, “2mm”]].\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nPackageDef.create(db, name)\n\nCreate a package definition in a given database.\n\nPackageDef.delete()\n\nDelete the package definition.\n\nPackageDef.find_by_id(db, uid)\n\nFind a package definition object by ID in a given database.\n\nPackageDef.find_by_name(db, name)\n\nFind a package definition object by name in a given database.\n\nPackageDef.get_product_property(prod_id, attr_it)\n\nGet the product property for a given product ID and attribute ID.\n\nPackageDef.get_product_property_ids(prod_id)\n\nGet the list of property IDs for a given property ID.\n\nPackageDef.set_heatsink(fin_base_height, ...)\n\nSet Heat sink. Parameters ---------- fin_base_height : str, float     Fin base height. fin_height : str, float     Fin height. fin_orientation : str     Fin orientation. Supported values, x_oriented, y_oriented. fin_spacing : str, float     Fin spacing. fin_thickness : str, float     Fin thickness.\n\nPackageDef.set_product_property(prod_id, ...)\n\nSet the product property for the given product ID and attribute ID.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.get_all_variable_names",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.get_all_variable_names.html#get_all_variable_names",
        "title": "get_all_variable_names",
        "section": "get_all_variable_names",
        "text": "Get all variable names.\nNames of all variables.\nget_all_variable_names\npython:list\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.get_all_variable_names",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.get_all_variable_names.html#pyedb.grpc.database.layout.layout.Layout.get_all_variable_names",
        "title": "get_all_variable_names > get_all_variable_names > get_all_variable_names",
        "section": "get_all_variable_names > get_all_variable_names",
        "text": "Layout.get_all_variable_names()\n\nGet all variable names.\n\nReturns\n\npython:list[python:str]\n\nNames of all variables.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.export_bom",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.export_bom.html#export_bom",
        "title": "export_bom",
        "section": "export_bom",
        "text": "Export BOM file.\nOutput file path.\nDelimiter character.\nTrue if successful, False otherwise.\nexport_bom\npython:str\npython:str\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.export_bom",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.export_bom.html#pyedb.grpc.database.components.Components.export_bom",
        "title": "export_bom > export_bom > export_bom",
        "section": "export_bom > export_bom",
        "text": "Components.export_bom(bom_file: str, delimiter: str = ',') -> bool\n\nExport BOM file.\n\nParameters\n\nbom_file\n\npython:str\n\nOutput file path.\n\ndelimiter\n\npython:str, optional\n\nDelimiter character.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\nExamples\n\n>>> edbapp.components.export_bom(\"exported_bom.csv\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues: Trusted or pre-validated data dictionary.\nA new instance of the Model class with validated data.\nmodel_construct"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_construct.html#pyedb.workflows.drc.drc.MinClearance.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod MinClearance.model_construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nArgs:\n\n_fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues: Trusted or pre-validated data dictionary.\n\nReturns:\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.create",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a padstack definition.\nName of the padstack definition.\nHole diameter with units. Default is \"300um\".\nPad diameter with units. Default is \"400um\".\nAnti-pad diameter with units. Default is \"600um\".\nPad geometry type (“Circle”, “Rectangle”, “Polygon”). Default is \"Circle\".\nAnti-pad geometry type (“Circle”, “Rectangle”, “Bullet”, “Polygon”). Default is \"Circle\".\nX-size for rectangular/bullet shapes. Default is \"600um\".\nY-size for rectangular/bullet shapes. Default is \"600um\".\nCorner radius for bullet shapes. Default is \"300um\".\nX-offset for anti-pad. Default is \"0.0\".\nY-offset for anti-pad. Default is \"0.0\".\nRotation for anti-pad in degrees. Default is \"0.0\".\nWhether the padstack has a hole. Default is True.\nX-offset for pad. Default is \"0.0\".\nY-offset for pad. Default is \"0.0\".\nRotation for pad in degrees. Default is \"0.0\".\nPolygon points for custom pad shape.\nPolygon points for custom anti-pad shape.\nPolygon points for custom hole shape.\nStarting layer name.\nEnding layer name.\nWhether to add “Default” layer. Default is False.\nAnti-pad X-size. Default is \"600um\".\nAnti-pad Y-size. Default is \"600um\".\nHole range type (“through”, “begin_on_upper_pad”, “end_on_lower_pad”, “upper_pad_to_lower_pad”).\nDefault is \"upper_pad_to_lower_pad\".\nName of the created padstack definition.\ncreate\npython:str\noptional\npython:str\noptional\n\"300um\"\npython:str\noptional\n\"400um\"\npython:str\noptional\n\"600um\"\npython:str\noptional\n\"Circle\"\npython:str\noptional\n\"Circle\"\npython:str\noptional\n\"600um\"\npython:str\noptional\n\"600um\"\npython:str\noptional\n\"300um\"\npython:str\noptional\n\"0.0\"\npython:str\noptional\n\"0.0\"\npython:str\noptional\n\"0.0\"\noptional\nTrue\npython:str\noptional\n\"0.0\"\npython:str\noptional\n\"0.0\"\npython:str\noptional\n\"0.0\"\npython:list\nansys.edb.core.geometry.PolygonData\noptional\npython:list\nansys.edb.core.geometry.PolygonData\noptional\npython:list\nansys.edb.core.geometry.PolygonData\noptional\npython:str\noptional\npython:str\noptional\noptional\nFalse\npython:str\noptional\n\"600um\"\npython:str\noptional\n\"600um\"\npython:str\noptional\n\"upper_pad_to_lower_pad\"\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.create",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.create.html#pyedb.grpc.database.padstacks.Padstacks.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "Padstacks.create(padstackname: str | None = None, holediam: str = '300um', paddiam: str = '400um', antipaddiam: str = '600um', pad_shape: str = 'Circle', antipad_shape: str = 'Circle', x_size: str = '600um', y_size: str = '600um', corner_radius: str = '300um', offset_x: str = '0.0', offset_y: str = '0.0', rotation: str = '0.0', has_hole: bool = True, pad_offset_x: str = '0.0', pad_offset_y: str = '0.0', pad_rotation: str = '0.0', pad_polygon: Any | None = None, antipad_polygon: Any | None = None, polygon_hole: Any | None = None, start_layer: str | None = None, stop_layer: str | None = None, add_default_layer: bool = False, anti_pad_x_size: str = '600um', anti_pad_y_size: str = '600um', hole_range: str = 'upper_pad_to_lower_pad')\n\nCreate a padstack definition.\n\nParameters\n\npadstackname\n\npython:str, optional\n\nName of the padstack definition.\n\nholediam\n\npython:str, optional\n\nHole diameter with units. Default is \"300um\".\n\npaddiam\n\npython:str, optional\n\nPad diameter with units. Default is \"400um\".\n\nantipaddiam\n\npython:str, optional\n\nAnti-pad diameter with units. Default is \"600um\".\n\npad_shape\n\npython:str, optional\n\nPad geometry type (“Circle”, “Rectangle”, “Polygon”). Default is \"Circle\".\n\nantipad_shape\n\npython:str, optional\n\nAnti-pad geometry type (“Circle”, “Rectangle”, “Bullet”, “Polygon”). Default is \"Circle\".\n\nx_size\n\npython:str, optional\n\nX-size for rectangular/bullet shapes. Default is \"600um\".\n\ny_size\n\npython:str, optional\n\nY-size for rectangular/bullet shapes. Default is \"600um\".\n\ncorner_radius\n\npython:str, optional\n\nCorner radius for bullet shapes. Default is \"300um\".\n\noffset_x\n\npython:str, optional\n\nX-offset for anti-pad. Default is \"0.0\".\n\noffset_y\n\npython:str, optional\n\nY-offset for anti-pad. Default is \"0.0\".\n\nrotation\n\npython:str, optional\n\nRotation for anti-pad in degrees. Default is \"0.0\".\n\nhas_hole\n\nbool, optional\n\nWhether the padstack has a hole. Default is True.\n\npad_offset_x\n\npython:str, optional\n\nX-offset for pad. Default is \"0.0\".\n\npad_offset_y\n\npython:str, optional\n\nY-offset for pad. Default is \"0.0\".\n\npad_rotation\n\npython:str, optional\n\nRotation for pad in degrees. Default is \"0.0\".\n\npad_polygon\n\npython:list or ansys.edb.core.geometry.PolygonData, optional\n\nPolygon points for custom pad shape.\n\nantipad_polygon\n\npython:list or ansys.edb.core.geometry.PolygonData, optional\n\nPolygon points for custom anti-pad shape.\n\npolygon_hole\n\npython:list or ansys.edb.core.geometry.PolygonData, optional\n\nPolygon points for custom hole shape.\n\nstart_layer\n\npython:str, optional\n\nStarting layer name.\n\nstop_layer\n\npython:str, optional\n\nEnding layer name.\n\nadd_default_layer\n\nbool, optional\n\nWhether to add “Default” layer. Default is False.\n\nanti_pad_x_size\n\npython:str, optional\n\nAnti-pad X-size. Default is \"600um\".\n\nanti_pad_y_size\n\npython:str, optional\n\nAnti-pad Y-size. Default is \"600um\".\n\nhole_range\n\npython:str, optional\n\nHole range type (“through”, “begin_on_upper_pad”, “end_on_lower_pad”, “upper_pad_to_lower_pad”).\nDefault is \"upper_pad_to_lower_pad\".\n\nReturns\n\npython:str\n\nName of the created padstack definition.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the primitive object to the correct concrete type.\ncast\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.cast.html#pyedb.grpc.database.primitive.rectangle.Rectangle.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "Rectangle.cast() -> Primitive | None\n\nCast the primitive object to the correct concrete type.\n\nReturns\n\nPrimitive\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_layers",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_layers.html#add_layers",
        "title": "add_layers",
        "section": "add_layers",
        "text": "Add a list of layers to the layer collection.\nList of layers.\nadd_layers\npython:list\nLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_layers",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_layers.html#pyedb.grpc.database.stackup.LayerCollection.add_layers",
        "title": "add_layers > add_layers > add_layers",
        "section": "add_layers > add_layers",
        "text": "LayerCollection.add_layers(layers)\n\nAdd a list of layers to the layer collection.\n\nParameters\n\nlayers\n\npython:list[Layer]\n\nList of layers.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave.add_siwave_syz_analysis",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave.add_siwave_syz_analysis.html#add_siwave_syz_analysis",
        "title": "add_siwave_syz_analysis",
        "section": "add_siwave_syz_analysis",
        "text": "Add a SIwave AC analysis to EDB.\nLevel of accuracy of SI slider. Default is 1.\nType of the sweep. Default is \"linear\". Options are:\n- \"linear\"\n- \"linear_count\"\n- \"decade_count\"\n- \"octave_count\"\n- \"exponential\"\nStarting frequency. Default is 1.\nStopping frequency. Default is 1e9.\nFrequency step. Default is 1e6. Used for \"decade_count\", \"linear_count\", \"octave_count\"\ndistribution. Must be integer in that case.\nWhether the sweep is discrete. Default is False.\nSetup object class.\nadd_siwave_syz_analysis\npython:int\noptional\n1\npython:str\noptional\n\"linear\"\n\"linear\"\n\"linear_count\"\n\"decade_count\"\n\"octave_count\"\n\"exponential\"\npython:str\npython:float\noptional\n1\npython:str\npython:float\noptional\n1e9\npython:str\npython:float\npython:int\noptional\n1e6\n\"decade_count\"\n\"linear_count\"\n\"octave_count\"\noptional\nFalse\npyedb.dotnet.database.edb_data.siwave_simulation_setup_data.SiwaveSYZSimulationSetup"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave.add_siwave_syz_analysis",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave.add_siwave_syz_analysis.html#pyedb.grpc.database.siwave.Siwave.add_siwave_syz_analysis",
        "title": "add_siwave_syz_analysis > add_siwave_syz_analysis > add_siwave_syz_analysis",
        "section": "add_siwave_syz_analysis > add_siwave_syz_analysis",
        "text": "Siwave.add_siwave_syz_analysis(accuracy_level: int = 1, distribution: str = 'linear', start_freq: str | float = 1, stop_freq: str | float = 1000000000.0, step_freq: str | float | int = 1000000.0, discrete_sweep: bool = False) -> Any\n\nAdd a SIwave AC analysis to EDB.\n\nParameters\n\naccuracy_level\n\npython:int, optional\n\nLevel of accuracy of SI slider. Default is 1.\n\ndistribution\n\npython:str, optional\n\nType of the sweep. Default is \"linear\". Options are:\n- \"linear\"\n- \"linear_count\"\n- \"decade_count\"\n- \"octave_count\"\n- \"exponential\"\n\nstart_freq\n\npython:str, python:float, optional\n\nStarting frequency. Default is 1.\n\nstop_freq\n\npython:str, python:float, optional\n\nStopping frequency. Default is 1e9.\n\nstep_freq\n\npython:str, python:float, python:int, optional\n\nFrequency step. Default is 1e6. Used for \"decade_count\", \"linear_count\", \"octave_count\"\ndistribution. Must be integer in that case.\n\ndiscrete_sweep\n\nbool, optional\n\nWhether the sweep is discrete. Default is False.\n\nReturns\n\npyedb.dotnet.database.edb_data.siwave_simulation_setup_data.SiwaveSYZSimulationSetup\n\nSetup object class.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", edbversion=\"2021.2\")\n>>> # Add SYZ analysis with linear sweep from 1kHz to 10GHz\n>>> setup = edbapp.siwave.add_siwave_syz_analysis(start_freq=1e3, stop_freq=10e9, distribution=\"linear\")\n>>> # Add SYZ analysis with decade sweep\n>>> setup = edbapp.siwave.add_siwave_syz_analysis(\n...     start_freq=1e3,\n...     stop_freq=10e9,\n...     distribution=\"decade_count\",\n...     step_freq=10,  # 10 points per decade\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/index",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/index.html#hierarchy-classes",
        "title": "Hierarchy classes",
        "section": "Hierarchy classes",
        "text": "This section describes EDB hierarchy classes.\nHierarchy classes"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/index",
        "href": "dotnet_api/dotnet/sim_setup_data/io/index.html#simulation-setup-io",
        "title": "Simulation setup IO",
        "section": "Simulation setup IO",
        "text": "This section describes Simulation setup IO.\nSimulation setup IO"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.find_by_id.html#find_by_id",
        "title": "find_by_id",
        "section": "find_by_id",
        "text": "Find a Connectable object by database ID in a given layout.\nLayout to search for the Connectable object.\nDatabase ID.\nConnectable object with the given database ID.\nfind_by_id\nLayout\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.find_by_id.html#pyedb.grpc.database.primitive.path.Path.find_by_id",
        "title": "find_by_id > find_by_id > find_by_id",
        "section": "find_by_id > find_by_id",
        "text": "classmethod Path.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the Connectable object.\n\nuid\n\npython:int\n\nDatabase ID.\n\nReturns\n\nConnectable\n\nConnectable object with the given database ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.product_solver_option.html#product_solver_option",
        "title": "product_solver_option",
        "section": "product_solver_option",
        "text": "Get the name of the product solver option.\nID of the product.\nName of the solver.\nName of the product solver option.\nproduct_solver_option\nProductIdType\nstr\nstr"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.product_solver_option.html#pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.product_solver_option",
        "title": "product_solver_option > product_solver_option > product_solver_option",
        "section": "product_solver_option > product_solver_option",
        "text": "PinGroupTerminal.product_solver_option(product_id, solver_name)\n\nGet the name of the product solver option.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nsolver_name\n\nstr\n\nName of the solver.\n\nReturns\n\nstr\n\nName of the product solver option.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.can_be_zone_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.can_be_zone_primitive.html#can_be_zone_primitive",
        "title": "can_be_zone_primitive",
        "section": "can_be_zone_primitive",
        "text": "bool: Flag indicating if a circle can be a zone.\ncan_be_zone_primitive\nbool"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.can_be_zone_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.can_be_zone_primitive.html#pyedb.grpc.database.primitive.circle.Circle.can_be_zone_primitive",
        "title": "can_be_zone_primitive > can_be_zone_primitive > can_be_zone_primitive",
        "section": "can_be_zone_primitive > can_be_zone_primitive",
        "text": "Circle.can_be_zone_primitive() -> bool\n\nbool: Flag indicating if a circle can be a zone.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.create_stride.html#create_stride",
        "title": "create_stride",
        "section": "create_stride",
        "text": "Create a Stride model from an MCAD file.\nStride model created.\ncreate_stride\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.create_stride.html#pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.create_stride",
        "title": "create_stride > create_stride > create_stride",
        "section": "create_stride > create_stride",
        "text": "BundleTerminal.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nReturns\n\nMcadModel\n\nStride model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.add",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.add.html#add",
        "title": "add",
        "section": "add",
        "text": "add"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.add",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.add.html#pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.add",
        "title": "add > add > add",
        "section": "add > add",
        "text": "SweepData.add(sweep_type, start, stop, increment)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/hfss",
        "href": "grpc_api/grpc/database/hfss.html#hfss",
        "title": "HFSS",
        "section": "HFSS",
        "text": "HFSS"
    },
    {
        "objectID": "grpc_api/grpc/database/hfss",
        "href": "grpc_api/grpc/database/hfss.html#class-managing-hfss-container",
        "title": "HFSS > Class managing HFSS container",
        "section": "Class managing HFSS container",
        "text": "These classes are the containers of HFSS class.\nhfss.Hfss\nManages EDB methods for HFSS setup configuration.\nClass managing HFSS container\nhfss.Hfss"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.create_hfss.html#create_hfss",
        "title": "create_hfss",
        "section": "create_hfss",
        "text": "Create an HFSS model from an MCAD file.\nHFSS model created.\ncreate_hfss\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.create_hfss.html#pyedb.grpc.database.primitive.bondwire.Bondwire.create_hfss",
        "title": "create_hfss > create_hfss > create_hfss",
        "section": "create_hfss > create_hfss",
        "text": "Bondwire.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nReturns\n\nMcadModel\n\nHFSS model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_segment",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_segment.html#is_segment",
        "title": "is_segment",
        "section": "is_segment",
        "text": "Determine if the arc is a straight line segment.\nTolearance.\nTrue when the arc is a straight line segment, False otherwise.\nis_segment\npython:float\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_segment",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_segment.html#pyedb.grpc.database.geometry.arc_data.ArcData.is_segment",
        "title": "is_segment > is_segment > is_segment",
        "section": "is_segment > is_segment",
        "text": "ArcData.is_segment(tolerance: float = 0.0) -> bool\n\nDetermine if the arc is a straight line segment.\n\nParameters\n\ntolerance\n\npython:float, default: 0.0\n\nTolearance.\n\nReturns\n\nbool\n\nTrue when the arc is a straight line segment, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_hfss_prop.html#get_hfss_prop",
        "title": "get_hfss_prop",
        "section": "get_hfss_prop",
        "text": "Get HFSS properties.\nReturns a tuple in this format:\n(material, solve_inside)\nmaterial :  Name of the material property.\nsolve_inside : Whether to solve inside.\nget_hfss_prop\npython:tuple\nof\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_hfss_prop.html#pyedb.grpc.database.primitive.primitive.Primitive.get_hfss_prop",
        "title": "get_hfss_prop > get_hfss_prop > get_hfss_prop",
        "section": "get_hfss_prop > get_hfss_prop",
        "text": "Primitive.get_hfss_prop() -> tuple[str, bool]\n\nGet HFSS properties.\n\nReturns\n\npython:tuple of (python:str, bool)\n\nReturns a tuple in this format:\n\n(material, solve_inside)\n\nmaterial :  Name of the material property.\n\nsolve_inside : Whether to solve inside.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_3d_data.Point3DData.midpoint",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_3d_data.Point3DData.midpoint.html#midpoint",
        "title": "midpoint",
        "section": "midpoint",
        "text": "Compute the midpoint of this point and another point.\nOther point\nMidpoint of the two points.\nmidpoint\nPoint3DData\nPoint3DData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_3d_data.Point3DData.midpoint",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_3d_data.Point3DData.midpoint.html#pyedb.grpc.database.geometry.point_3d_data.Point3DData.midpoint",
        "title": "midpoint > midpoint > midpoint",
        "section": "midpoint > midpoint",
        "text": "Point3DData.midpoint(other: Point3DData) -> Point3DData\n\nCompute the midpoint of this point and another point.\n\nParameters\n\nother\n\nPoint3DData\n\nOther point\n\nReturns\n\nPoint3DData\n\nMidpoint of the two points.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_min_clearance",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_min_clearance.html#add_min_clearance",
        "title": "add_min_clearance",
        "section": "add_min_clearance",
        "text": "Append a minimum-clearance rule between two nets (wild-cards allowed).\nRule identifier.\nMinimum clearance with unit, e.g. \"4mil\".\nFirst net name or wild-card (\"*\").\nSecond net name or wild-card (\"*\").\nSelf to enable method chaining.\nadd_min_clearance\npython:str\npython:str\n\"4mil\"\npython:str\n\"*\"\npython:str\n\"*\"\nRules"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_min_clearance",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_min_clearance.html#pyedb.workflows.drc.drc.Rules.add_min_clearance",
        "title": "add_min_clearance > add_min_clearance > add_min_clearance",
        "section": "add_min_clearance > add_min_clearance",
        "text": "Rules.add_min_clearance(name: str, value: str, net1: str, net2: str) -> Rules\n\nAppend a minimum-clearance rule between two nets (wild-cards allowed).\n\nParameters\n\nname\n\npython:str\n\nRule identifier.\n\nvalue\n\npython:str\n\nMinimum clearance with unit, e.g. \"4mil\".\n\nnet1\n\npython:str\n\nFirst net name or wild-card (\"*\").\n\nnet2\n\npython:str\n\nSecond net name or wild-card (\"*\").\n\nReturns\n\nRules\n\nSelf to enable method chaining.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.create_from_points",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.create_from_points.html#create_from_points",
        "title": "create_from_points",
        "section": "create_from_points",
        "text": "create_from_points"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.create_from_points",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.create_from_points.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.create_from_points",
        "title": "create_from_points > create_from_points > create_from_points",
        "section": "create_from_points > create_from_points",
        "text": "PolygonData.create_from_points(points, closed=True)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_reference_pins",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_reference_pins.html#get_reference_pins",
        "title": "get_reference_pins",
        "section": "get_reference_pins",
        "text": "Search for reference pins using given criteria.\nReference net. The default is \"GND\".\nSearch radius for finding padstack instances. The default is 5e-3.\nMaximum limit for the padstack instances found. The default is 0, in which\ncase no limit is applied. The maximum limit value occurs on the nearest\nreference pins from the positive one that is found.\nWhether to limit the search to component padstack instances only. The\ndefault is True. When False, the search is extended to the entire layout.\nget_reference_pins\npython:str\noptional\n\"GND\"\npython:float\noptional\n5e-3\npython:int\noptional\n0\noptional\nTrue\nFalse\nList\nPadstackInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_reference_pins",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_reference_pins.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_reference_pins",
        "title": "get_reference_pins > get_reference_pins > get_reference_pins",
        "section": "get_reference_pins > get_reference_pins",
        "text": "PadstackInstance.get_reference_pins(reference_net='GND', search_radius=0.005, max_limit=0, component_only=True) -> list[any]\n\nSearch for reference pins using given criteria.\n\nParameters\n\nreference_net\n\npython:str, optional\n\nReference net. The default is \"GND\".\n\nsearch_radius\n\npython:float, optional\n\nSearch radius for finding padstack instances. The default is 5e-3.\n\nmax_limit\n\npython:int, optional\n\nMaximum limit for the padstack instances found. The default is 0, in which\ncase no limit is applied. The maximum limit value occurs on the nearest\nreference pins from the positive one that is found.\n\ncomponent_only\n\nbool, optional\n\nWhether to limit the search to component padstack instances only. The\ndefault is True. When False, the search is extended to the entire layout.\n\nReturns\n\nList[PadstackInstance]\n\n\n\nExamples\n\n>>> edbapp = Edb(\"target_path\")\n>>> pin = edbapp.components.instances[\"J5\"].pins[\"19\"]\n>>> reference_pins = pin.get_reference_pins(reference_net=\"GND\", search_radius=5e-3, max_limit=0,\n>>> component_only=True)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_pin_from_component",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_pin_from_component.html#get_pin_from_component",
        "title": "get_pin_from_component",
        "section": "get_pin_from_component",
        "text": "Get pins from a component with optional filtering.\nComponent name or instance.\nNet name(s) to filter by.\nPin name to filter by.\nList of pin instances.\nget_pin_from_component\npython:str\npyedb.grpc.database.hierarchy.component.Component\npython:str\npython:list\npython:str\noptional\npython:str\noptional\npython:list\npyedb.grpc.database.padstacks.PadstackInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_pin_from_component",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_pin_from_component.html#pyedb.grpc.database.components.Components.get_pin_from_component",
        "title": "get_pin_from_component > get_pin_from_component > get_pin_from_component",
        "section": "get_pin_from_component > get_pin_from_component",
        "text": "Components.get_pin_from_component(component: str | Component, net_name: str | List[str] | None = None, pin_name: str | None = None) -> List[Any]\n\nGet pins from a component with optional filtering.\n\nParameters\n\ncomponent\n\npython:str or pyedb.grpc.database.hierarchy.component.Component\n\nComponent name or instance.\n\nnet_name\n\npython:str or python:list[python:str], optional\n\nNet name(s) to filter by.\n\npin_name\n\npython:str, optional\n\nPin name to filter by.\n\nReturns\n\npython:list[pyedb.grpc.database.padstacks.PadstackInstance]\n\nList of pin instances.\n\nExamples\n\n>>> pins = edbapp.components.get_pin_from_component(\"R1\", net_name=\"GND\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.get_ports_number",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.get_ports_number.html#get_ports_number",
        "title": "get_ports_number",
        "section": "get_ports_number",
        "text": "Return the total number of excitation ports in a layout.\nNumber of ports.\nget_ports_number\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.get_ports_number",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.get_ports_number.html#pyedb.grpc.database.source_excitations.SourceExcitation.get_ports_number",
        "title": "get_ports_number > get_ports_number > get_ports_number",
        "section": "get_ports_number > get_ports_number",
        "text": "SourceExcitation.get_ports_number() -> int\n\nReturn the total number of excitation ports in a layout.\n\nParameters\n\nNone\n\n\n\nReturns\n\npython:int\n\nNumber of ports.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> num_ports = edb.source_excitation.get_ports_number()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileStackup.add_via",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileStackup.add_via.html#add_via",
        "title": "add_via",
        "section": "add_via",
        "text": "Add a new via layer.\nVia layer name.\nMaterial name.\nGDS data type for via layer.\nTarget layer name in EDB/HFSS.\nStarting layer name.\nStopping layer name.\nWhether to solve inside via. Default is True.\nVia grouping method. Default is “proximity”.\nVia grouping tolerance. Default is 1e-6.\nWhether via groups are persistent. Default is True.\nSnap via group method. Default is “distance”.\nSnap via group tolerance. Default is 10e-9.\nAdditional properties. Overrides default parameters.\nCreated via object.\nadd_via\npython:str\npython:str\npython:int\npython:str\npython:str\npython:str\noptional\nTrue\npython:str\noptional\npython:float\noptional\noptional\nTrue\npython:str\noptional\npython:float\noptional\npython:dict\noptional\nControlFileVia"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileStackup.add_via",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileStackup.add_via.html#pyedb.grpc.database.control_file.ControlFileStackup.add_via",
        "title": "add_via > add_via > add_via",
        "section": "add_via > add_via",
        "text": "ControlFileStackup.add_via(layer_name: str, material: str = '', gds_type: int = 0, target_layer: str = '', start_layer: str = '', stop_layer: str = '', solve_inside: bool = True, via_group_method: str = 'proximity', via_group_tol: float = 1e-06, via_group_persistent: bool = True, snap_via_group_method: str = 'distance', snap_via_group_tol: float = 1e-08, properties: Dict[str, Any] | None = None) -> ControlFileVia\n\nAdd a new via layer.\n\nParameters\n\nlayer_name\n\npython:str\n\nVia layer name.\n\nmaterial\n\npython:str\n\nMaterial name.\n\ngds_type\n\npython:int\n\nGDS data type for via layer.\n\ntarget_layer\n\npython:str\n\nTarget layer name in EDB/HFSS.\n\nstart_layer\n\npython:str\n\nStarting layer name.\n\nstop_layer\n\npython:str\n\nStopping layer name.\n\nsolve_inside\n\nbool, optional\n\nWhether to solve inside via. Default is True.\n\nvia_group_method\n\npython:str, optional\n\nVia grouping method. Default is “proximity”.\n\nvia_group_tol\n\npython:float, optional\n\nVia grouping tolerance. Default is 1e-6.\n\nvia_group_persistent\n\nbool, optional\n\nWhether via groups are persistent. Default is True.\n\nsnap_via_group_method\n\npython:str, optional\n\nSnap via group method. Default is “distance”.\n\nsnap_via_group_tol\n\npython:float, optional\n\nSnap via group tolerance. Default is 10e-9.\n\nproperties\n\npython:dict, optional\n\nAdditional properties. Overrides default parameters.\n\nReturns\n\nControlFileVia\n\nCreated via object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.create_stride.html#create_stride",
        "title": "create_stride",
        "section": "create_stride",
        "text": "Create a Stride model from an MCAD file.\nStride model created.\ncreate_stride\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.create_stride.html#pyedb.grpc.database.primitive.polygon.Polygon.create_stride",
        "title": "create_stride > create_stride > create_stride",
        "section": "create_stride > create_stride",
        "text": "Polygon.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nReturns\n\nMcadModel\n\nStride model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "LayoutObjType: Layout object type of the Primitive class.\nlayout_obj_type\nLayoutObjType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.layout_obj_type.html#pyedb.grpc.database.primitive.rectangle.Rectangle.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "Rectangle.layout_obj_type = 0\n\nLayoutObjType: Layout object type of the Primitive class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.delete",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete this primitive.\ndelete"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.delete",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.delete.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "EDBPadstackInstance.delete()\n\nDelete this primitive.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kQ3D",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kQ3D.html#kq3d",
        "title": "kQ3D",
        "section": "kQ3D",
        "text": "kQ3D"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kQ3D",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kQ3D.html#pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kQ3D",
        "title": "kQ3D > kQ3D > kQ3D",
        "section": "kQ3D > kQ3D",
        "text": "SimulationSetupType.kQ3D = 'q3d'\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_product_property_ids.html#pyedb.grpc.database.primitive.path.Path.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "Path.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.create_value",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.create_value.html#create_value",
        "title": "create_value",
        "section": "create_value",
        "text": "Create a value instance.\nThis value instance can reference variables on the variable server.\nValue, which can be any type that can be converted to a Value\ninstance.\nCreating a value from a Database instance can reference variables\nin the Database instance.\nCreating a value from a Cell instance can reference variables in\nboth the Database instance and the\nCell instance\nCreating a value from a ComponentDef\ninstance can reference variables in both the Database instance and\nthe ComponentDef instance.\ncreate_value\npython:str\npython:int\npython:float\ncomplex\nValue\nValue\nDatabase\nDatabase\nCell\nDatabase\nCell\nComponentDef\nDatabase\nComponentDef"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.create_value",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.create_value.html#pyedb.grpc.database.layout.layout.Layout.create_value",
        "title": "create_value > create_value > create_value",
        "section": "create_value > create_value",
        "text": "Layout.create_value(val)\n\nCreate a value instance.\n\nThis value instance can reference variables on the variable server.\n\nParameters\n\nval\n\npython:str, python:int, python:float, complex\n\nValue, which can be any type that can be converted to a Value\ninstance.\n\nReturns\n\nValue\n\n\n\nNotes\n\nCreating a value from a Database instance can reference variables\nin the Database instance.\n\nCreating a value from a Cell instance can reference variables in\nboth the Database instance and the\nCell instance\n\nCreating a value from a ComponentDef\ninstance can reference variables in both the Database instance and\nthe ComponentDef instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_json_schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias: Whether to use attribute aliases or not.\nref_template: The reference template.\nunion_format: The format to use when combining schemas from unions together. Can be one of:\n‘any_of’: Use the [anyOf](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\nkeyword to combine schemas (the default).\n- ‘primitive_type_array’: Use the [type](https://json-schema.org/understanding-json-schema/reference/type)\nkeyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\ntype (string, boolean, null, integer or number) or contains constraints/metadata, falls back to\nany_of.\nGenerateJsonSchema with your desired modifications\nmode: The mode in which to generate the schema.\nThe JSON schema for the given model class.\nmodel_json_schema"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_json_schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_json_schema.html#pyedb.workflows.drc.drc.BackDrillStubLength.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod BackDrillStubLength.model_json_schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}', schema_generator: type[~pydantic.json_schema.GenerateJsonSchema] = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: ~typing.Literal['validation', 'serialization'] = 'validation', *, union_format: ~typing.Literal['any_of', 'primitive_type_array'] = 'any_of') -> dict[str, Any]\n\nGenerates a JSON schema for a model class.\n\nArgs:\n\nby_alias: Whether to use attribute aliases or not.\nref_template: The reference template.\nunion_format: The format to use when combining schemas from unions together. Can be one of:\n\n‘any_of’: Use the [anyOf](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n\nkeyword to combine schemas (the default).\n- ‘primitive_type_array’: Use the [type](https://json-schema.org/understanding-json-schema/reference/type)\nkeyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\ntype (string, boolean, null, integer or number) or contains constraints/metadata, falls back to\nany_of.\n\nschema_generator: To override the logic used to generate the JSON schema, as a subclass of\n\nGenerateJsonSchema with your desired modifications\n\nmode: The mode in which to generate the schema.\n\nReturns:\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.load_from_xml",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.load_from_xml.html#load_from_xml",
        "title": "load_from_xml",
        "section": "load_from_xml",
        "text": "Load stackup from a XML file.\nPath to external XML file.\nTrue when successful, False when failed.\nload_from_xml\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.load_from_xml",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.load_from_xml.html#pyedb.dotnet.database.stackup.Stackup.load_from_xml",
        "title": "load_from_xml > load_from_xml > load_from_xml",
        "section": "load_from_xml > load_from_xml",
        "text": "Stackup.load_from_xml(file_path)\n\nLoad stackup from a XML file.\n\nParameters\n\nfile_path: str\n\nPath to external XML file.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.create_value",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.create_value.html#create_value",
        "title": "create_value",
        "section": "create_value",
        "text": "Create a value instance.\nThis value instance can reference variables on the variable server.\nValue, which can be any type that can be converted to a Value\ninstance.\nCreating a value from a Database instance can reference variables\nin the Database instance.\nCreating a value from a Cell instance can reference variables in\nboth the Database instance and the\nCell instance\nCreating a value from a ComponentDef\ninstance can reference variables in both the Database instance and\nthe ComponentDef instance.\ncreate_value\npython:str\npython:int\npython:float\ncomplex\nValue\nValue\nDatabase\nDatabase\nCell\nDatabase\nCell\nComponentDef\nDatabase\nComponentDef"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.create_value",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.create_value.html#pyedb.grpc.database.layout.cell.Cell.create_value",
        "title": "create_value > create_value > create_value",
        "section": "create_value > create_value",
        "text": "Cell.create_value(val)\n\nCreate a value instance.\n\nThis value instance can reference variables on the variable server.\n\nParameters\n\nval\n\npython:str, python:int, python:float, complex\n\nValue, which can be any type that can be converted to a Value\ninstance.\n\nReturns\n\nValue\n\n\n\nNotes\n\nCreating a value from a Database instance can reference variables\nin the Database instance.\n\nCreating a value from a Cell instance can reference variables in\nboth the Database instance and the\nCell instance\n\nCreating a value from a ComponentDef\ninstance can reference variables in both the Database instance and\nthe ComponentDef instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.expanded_extent",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.expanded_extent.html#expanded_extent",
        "title": "expanded_extent",
        "section": "expanded_extent",
        "text": "Get the expanded extent of the geometry on the specified nets.\nList of nets containing the geometry.\nType of extent to be retrieved.\nExpansion factor applied to the extent. No expansion occurs if the value\nfor this parameter is less than or equal to 0.\nWhen unitless, the distance by which the extent expands is the factor\nmultiplied by the longer dimension (X or Y distance) of the bounding box of the extent.\nWhether to use round corners or sharp corners. For round corners, this\nreturns a bounding box if its area is within 10% of the rounded expansion’s\narea.\nNumber of iterations desired to reach the full expansion.\nThis method returns the expansion of the contour, so any voids within expanded\nobjects are ignored.\nexpanded_extent\npython:list\nof\nNet\nExtentType\npython:float\npython:int\nPolygonData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.expanded_extent",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.expanded_extent.html#pyedb.grpc.database.layout.layout.Layout.expanded_extent",
        "title": "expanded_extent > expanded_extent > expanded_extent",
        "section": "expanded_extent > expanded_extent",
        "text": "Layout.expanded_extent(nets: List[Net], extent: ExtentType, expansion_factor: float, expansion_unitless: bool, use_round_corner: bool, num_increments: int) -> List[PolygonData]\n\nGet the expanded extent of the geometry on the specified nets.\n\nParameters\n\nnets\n\npython:list of Net\n\nList of nets containing the geometry.\n\nextent\n\nExtentType\n\nType of extent to be retrieved.\n\nexpansion_factor\n\npython:float\n\nExpansion factor applied to the extent. No expansion occurs if the value\nfor this parameter is less than or equal to 0.\n\nexpansion_unitless\n\nbool\n\nWhen unitless, the distance by which the extent expands is the factor\nmultiplied by the longer dimension (X or Y distance) of the bounding box of the extent.\n\nuse_round_corner\n\nbool\n\nWhether to use round corners or sharp corners. For round corners, this\nreturns a bounding box if its area is within 10% of the rounded expansion’s\narea.\n\nnum_increments\n\npython:int\n\nNumber of iterations desired to reach the full expansion.\n\nReturns\n\nPolygonData\n\n\n\nNotes\n\nThis method returns the expansion of the contour, so any voids within expanded\nobjects are ignored.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.material_property_to_id",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.material_property_to_id.html#material_property_to_id",
        "title": "material_property_to_id",
        "section": "material_property_to_id",
        "text": "Convert a material property name to a material property ID.\nName of the material property.\nmaterial_property_to_id\npython:str\nAny"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.material_property_to_id",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.material_property_to_id.html#pyedb.grpc.database.definition.materials.Materials.material_property_to_id",
        "title": "material_property_to_id > material_property_to_id > material_property_to_id",
        "section": "material_property_to_id > material_property_to_id",
        "text": "Materials.material_property_to_id(property_name)\n\nConvert a material property name to a material property ID.\n\nParameters\n\nproperty_name\n\npython:str\n\nName of the material property.\n\nReturns\n\nAny\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.generate_extended_nets",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.generate_extended_nets.html#generate_extended_nets",
        "title": "generate_extended_nets",
        "section": "generate_extended_nets",
        "text": "Get extended net and associated components.\nThreshold of resistor value. Search extended net across resistors which has value lower than the threshold.\nThreshold of inductor value. Search extended net across inductances which has value lower than the\nthreshold.\nThreshold of capacitor value. Search extended net across capacitors which has value higher than the\nthreshold.\nList of components to bypass when performing threshold checks. Components\nin the list are considered as serial components. The default is None.\nWhether to generate extended signal nets. The default is True.\nWhether to generate extended power nets. The default is True.\nList of all extended nets.\ngenerate_extended_nets\npython:int\npython:float\noptional\npython:int\npython:float\noptional\npython:int\npython:float\noptional\npython:list\noptional\nNone\npython:str\noptional\nTrue\npython:str\noptional\nTrue\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.generate_extended_nets",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.generate_extended_nets.html#pyedb.dotnet.database.nets.EdbNets.generate_extended_nets",
        "title": "generate_extended_nets > generate_extended_nets > generate_extended_nets",
        "section": "generate_extended_nets > generate_extended_nets",
        "text": "EdbNets.generate_extended_nets(resistor_below: int | float = 10, inductor_below: int | float = 1, capacitor_above: int | float = 1, exception_list: list | None = None, include_signal: bool = True, include_power: bool = True) -> list\n\nGet extended net and associated components.\n\nParameters\n\nresistor_below\n\npython:int, python:float, optional\n\nThreshold of resistor value. Search extended net across resistors which has value lower than the threshold.\n\ninductor_below\n\npython:int, python:float, optional\n\nThreshold of inductor value. Search extended net across inductances which has value lower than the\nthreshold.\n\ncapacitor_above\n\npython:int, python:float, optional\n\nThreshold of capacitor value. Search extended net across capacitors which has value higher than the\nthreshold.\n\nexception_list\n\npython:list, optional\n\nList of components to bypass when performing threshold checks. Components\nin the list are considered as serial components. The default is None.\n\ninclude_signal\n\npython:str, optional\n\nWhether to generate extended signal nets. The default is True.\n\ninclude_power\n\npython:str, optional\n\nWhether to generate extended power nets. The default is True.\n\nReturns\n\npython:list\n\nList of all extended nets.\n\nExamples\n\n>>> from pyedb import Edb\n>>> app = Edb()\n>>> app.nets.get_extended_nets()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.layout_obj_type.html#pyedb.grpc.database.hierarchy.pingroup.PinGroup.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "PinGroup.layout_obj_type = 12\n\n"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_validate_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data: The JSON data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nThe validated Pydantic model.\nValidationError: If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_validate_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_validate_json.html#pyedb.workflows.drc.drc.DiffPair.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod DiffPair.model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n\njson_data: The JSON data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nReturns:\n\nThe validated Pydantic model.\n\nRaises:\n\nValidationError: If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.place_a3dcomp_3d_placement",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.place_a3dcomp_3d_placement.html#place_a3dcomp_3d_placement",
        "title": "place_a3dcomp_3d_placement",
        "section": "place_a3dcomp_3d_placement",
        "text": "Place a 3D component into the current layout.\n3D Component ports are not visible via EDB. They will be visible after the EDB has been opened in Ansys\nElectronics Desktop as a project.\nPath to the 3D Component file (*.a3dcomp) to place.\nClockwise rotation angle applied to the a3dcomp.\nX offset value. The default is 0.0.\nY offset value. The default is 0.0.\nZ offset value (elevation). The default is 0.0.\nWhether to place the 3D component on the top or the bottom of this layout. If False, the 3D component\nwill be flipped over around its X axis.\nTrue if successful, False if not.\nplace_a3dcomp_3d_placement\npython:str\n*.a3dcomp\npython:float\noptional\npython:float\noptional\n0.0\npython:float\noptional\n0.0\npython:float\noptional\n0.0\noptional\nFalse\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.place_a3dcomp_3d_placement",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.place_a3dcomp_3d_placement.html#pyedb.grpc.database.stackup.Stackup.place_a3dcomp_3d_placement",
        "title": "place_a3dcomp_3d_placement > place_a3dcomp_3d_placement > place_a3dcomp_3d_placement",
        "section": "place_a3dcomp_3d_placement > place_a3dcomp_3d_placement",
        "text": "Stackup.place_a3dcomp_3d_placement(a3dcomp_path: str, angle: float = 0.0, offset_x: float = 0.0, offset_y: float = 0.0, offset_z: float = 0.0, place_on_top: bool = True) -> bool\n\nPlace a 3D component into the current layout.\n\n3D Component ports are not visible via EDB. They will be visible after the EDB has been opened in Ansys\nElectronics Desktop as a project.\n\nParameters\n\na3dcomp_path\n\npython:str\n\nPath to the 3D Component file (*.a3dcomp) to place.\n\nangle\n\npython:float, optional\n\nClockwise rotation angle applied to the a3dcomp.\n\noffset_x\n\npython:float, optional\n\nX offset value. The default is 0.0.\n\noffset_y\n\npython:float, optional\n\nY offset value. The default is 0.0.\n\noffset_z\n\npython:float, optional\n\nZ offset value (elevation). The default is 0.0.\n\nplace_on_top\n\nbool, optional\n\nWhether to place the 3D component on the top or the bottom of this layout. If False, the 3D component\nwill be flipped over around its X axis.\n\nReturns\n\nbool\n\nTrue if successful, False if not.\n\nExamples\n\n>>> edb1 = Edb(edbpath=targetfile1, edbversion=\"2021.2\")\n>>> a3dcomp_path = \"connector.a3dcomp\"\n>>> edb1.stackup.place_a3dcomp_3d_placement(\n...     a3dcomp_path,\n...     angle=0.0,\n...     offset_x=\"1mm\",\n...     offset_y=\"2mm\",\n...     flipped_stackup=False,\n...     place_on_top=True,\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.set_product_property.html#pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "BundleTerminal.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.set_sim_setup_info",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.set_sim_setup_info.html#set_sim_setup_info",
        "title": "set_sim_setup_info",
        "section": "set_sim_setup_info",
        "text": "set_sim_setup_info"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.set_sim_setup_info",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.set_sim_setup_info.html#pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.set_sim_setup_info",
        "title": "set_sim_setup_info > set_sim_setup_info > set_sim_setup_info",
        "section": "set_sim_setup_info > set_sim_setup_info",
        "text": "SiwaveSimulationSetup.set_sim_setup_info(sim_setup_info)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.get_property",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.get_property.html#get_property",
        "title": "get_property",
        "section": "get_property",
        "text": "Get a material property value.\nTo retrieve a simple material property, the material_property                     parameter should be provided.\nTo retrieve a component of an anisotropic material property, the material_property                     and component_id parameters should be provided.\ncomponent_id specifies the                     anisotropic component ID                     of the component to get the value of.\nTo retrieve an entry in a tensor material property, the material_property,                     col and row parameters should be provided. The entry at T[row,col]                     will be returned.\nID of the material property.\nID of the anisotropic component (only used for anisotropic material properties).\nTensor row (only used for tensor material properties).\nTensor column (only used for tensor material properties).\nget_property\nmaterial_property\nmaterial_property\ncomponent_id\ncomponent_id\nmaterial_property\ncol\nrow\nT[row,col]\nMaterialProperty\npython:int\npython:None\npython:int\npython:None\npython:int\npython:None\nValue"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.get_property",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.get_property.html#pyedb.grpc.database.definition.materials.Material.get_property",
        "title": "get_property > get_property > get_property",
        "section": "get_property > get_property",
        "text": "Material.get_property(material_property, component_id=None, row=None, col=None)\n\nGet a material property value.\n\nMaterial properties can be defined in 3 ways:\n\nSimple: A constant value.\n\nTo retrieve a simple material property, the material_property                     parameter should be provided.\n\nAnisotropic: A 3x3 tensor consisting of only diagonal entries.\n\nTo retrieve a component of an anisotropic material property, the material_property                     and component_id parameters should be provided.\n\ncomponent_id specifies the                     anisotropic component ID                     of the component to get the value of.\n\nTensor: A 3x3 tensor consisting of diagonal and off-diagonal entries.\n\nTo retrieve an entry in a tensor material property, the material_property,                     col and row parameters should be provided. The entry at T[row,col]                     will be returned.\n\nParameters\n\nmaterial_property\n\nMaterialProperty\n\nID of the material property.\n\ncomponent_id\n\npython:int, default: python:None\n\nID of the anisotropic component (only used for anisotropic material properties).\n\nrow\n\npython:int, default: python:None\n\nTensor row (only used for tensor material properties).\n\ncol\n\npython:int, default: python:None\n\nTensor column (only used for tensor material properties).\n\nReturns\n\nValue\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.spice_model.SpiceModel.remove_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.spice_model.SpiceModel.remove_terminal.html#remove_terminal",
        "title": "remove_terminal",
        "section": "remove_terminal",
        "text": "Remove a terminal.\nTerminal name.\nremove_terminal\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.spice_model.SpiceModel.remove_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.spice_model.SpiceModel.remove_terminal.html#pyedb.grpc.database.hierarchy.spice_model.SpiceModel.remove_terminal",
        "title": "remove_terminal > remove_terminal > remove_terminal",
        "section": "remove_terminal > remove_terminal",
        "text": "SpiceModel.remove_terminal(terminal)\n\nRemove a terminal.\n\nParameters\n\nterminal\n\npython:str\n\nTerminal name.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.point_3d",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.point_3d.html#point_3d",
        "title": "point_3d",
        "section": "point_3d",
        "text": "Create 3D point.\nX coordinate.\nY coordinate.\nZ coordinate.\n3D point object.\npoint_3d\npython:float\npython:int\npython:str\npython:float\npython:int\npython:str\npython:float\npython:int\npython:str\noptional\nPoint3DData"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.point_3d",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.point_3d.html#pyedb.grpc.edb.Edb.point_3d",
        "title": "point_3d > point_3d > point_3d",
        "section": "point_3d > point_3d",
        "text": "Edb.point_3d(x, y, z=0.0)\n\nCreate 3D point.\n\nParameters\n\nx\n\npython:float, python:int, python:str\n\nX coordinate.\n\ny\n\npython:float, python:int, python:str\n\nY coordinate.\n\nz\n\npython:float, python:int, python:str, optional\n\nZ coordinate.\n\nReturns\n\nPoint3DData\n\n3D point object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.closest_point",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.closest_point.html#closest_point",
        "title": "closest_point",
        "section": "closest_point",
        "text": "Compute a point on the polygon that is closest to another point.\nOther point.\nPoint closest to the given point.\nclosest_point\nPointData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.closest_point",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.closest_point.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.closest_point",
        "title": "closest_point > closest_point > closest_point",
        "section": "closest_point > closest_point",
        "text": "PolygonData.closest_point(point: PointLike) -> PointData\n\nCompute a point on the polygon that is closest to another point.\n\nParameters\n\npoint\n\nPoint2DLike\n\nOther point.\n\nReturns\n\nPointData\n\nPoint closest to the given point.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.parse_raw",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "parse_raw"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.parse_raw",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.parse_raw.html#pyedb.workflows.drc.drc.MinAnnularRing.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod MinAnnularRing.parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_3d_data.Point3DData",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_3d_data.Point3DData.html#point3ddata",
        "title": "Point3DData",
        "section": "Point3DData",
        "text": "Point 3D Data.\nPoint3DData.distance(other)\nCompute the distance from this point to another point.\nPoint3DData.equals(other[, tolerance])\nCompare the equality of two 3D points within a given tolerance.\nPoint3DData.midpoint(other)\nCompute the midpoint of this point and another point.\nPoint3DData\nPoint3DData.distance\nPoint3DData.equals\nPoint3DData.midpoint"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_3d_data.Point3DData",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_3d_data.Point3DData.html#pyedb.grpc.database.geometry.point_3d_data.Point3DData",
        "title": "Point3DData > Point3DData > Point3DData",
        "section": "Point3DData > Point3DData",
        "text": "class pyedb.grpc.database.geometry.point_3d_data.Point3DData(x, y, z)\n\nPoint 3D Data.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nPoint3DData.distance(other)\n\nCompute the distance from this point to another point.\n\nPoint3DData.equals(other[, tolerance])\n\nCompare the equality of two 3D points within a given tolerance.\n\nPoint3DData.midpoint(other)\n\nCompute the midpoint of this point and another point.\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.flip_design",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.flip_design.html#flip_design",
        "title": "flip_design",
        "section": "flip_design",
        "text": "Flip the current design of a layout.\nTrue when succeed False if not.\nflip_design\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.flip_design",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.flip_design.html#pyedb.dotnet.database.stackup.Stackup.flip_design",
        "title": "flip_design > flip_design > flip_design",
        "section": "flip_design > flip_design",
        "text": "Stackup.flip_design()\n\nFlip the current design of a layout.\n\nReturns\n\nbool\n\nTrue when succeed False if not.\n\nExamples\n\n>>> edb = Edb(edbpath=targetfile, edbversion=\"2021.2\")\n>>> edb.stackup.flip_design()\n>>> edb.save()\n>>> edb.close_edb()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.find_by_id.html#find_by_id",
        "title": "find_by_id",
        "section": "find_by_id",
        "text": "Find a Connectable object by database ID in a given layout.\nLayout to search for the Connectable object.\nDatabase ID.\nConnectable object with the given database ID.\nfind_by_id\nLayout\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.find_by_id.html#pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.find_by_id",
        "title": "find_by_id > find_by_id > find_by_id",
        "section": "find_by_id > find_by_id",
        "text": "classmethod VoltageRegulator.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the Connectable object.\n\nuid\n\npython:int\n\nDatabase ID.\n\nReturns\n\nConnectable\n\nConnectable object with the given database ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.create",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a polygon in the specified layout, layer, and net using the provided polygon data.\nThe layout in which the polygon will be created. If not provided, the active layout of the pedb\ninstance will be used.\nThe layer in which the polygon will be created. This parameter is required and must be specified.\nThe net to which the polygon will belong. If not provided, the polygon will not be associated with a\nnet.\nThe data defining the polygon. This can be a list of points or an instance of GrpcPolygonData.\nThis parameter is required and must be specified.\nThe created polygon object.\nIf the layer parameter is not provided.\nIf the polygon_data parameter is not provided.\nIf polygon_data is provided as a list, it will be converted to a GrpcPolygonData object.\nThe created polygon is added to the modeler primitives of the pedb instance.\ncreate\nLayout\noptional\nUnion\npython:str\nLayer\noptional\nUnion\npython:str\nNet\noptional\npython:list\nGrpcPolygonData\noptional\nPolygon\nValueError\nValueError"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.create",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.create.html#pyedb.grpc.database.primitive.polygon.Polygon.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "Polygon.create(layout: Layout = None, layer: str | Layer = None, net: str | Net = None, polygon_data=None)\n\nCreate a polygon in the specified layout, layer, and net using the provided polygon data.\n\nParameters\n\nlayout\n\nLayout, optional\n\nThe layout in which the polygon will be created. If not provided, the active layout of the pedb\ninstance will be used.\n\nlayer\n\nUnion[python:str, Layer], optional\n\nThe layer in which the polygon will be created. This parameter is required and must be specified.\n\nnet\n\nUnion[python:str, Net], optional\n\nThe net to which the polygon will belong. If not provided, the polygon will not be associated with a\nnet.\n\npolygon_data\n\npython:list or GrpcPolygonData, optional\n\nThe data defining the polygon. This can be a list of points or an instance of GrpcPolygonData.\nThis parameter is required and must be specified.\n\nReturns\n\nPolygon\n\nThe created polygon object.\n\nRaises\n\nValueError\n\nIf the layer parameter is not provided.\n\nValueError\n\nIf the polygon_data parameter is not provided.\n\nNotes\n\nIf polygon_data is provided as a list, it will be converted to a GrpcPolygonData object.\n\nThe created polygon is added to the modeler primitives of the pedb instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_layout_thickness",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_layout_thickness.html#get_layout_thickness",
        "title": "get_layout_thickness",
        "section": "get_layout_thickness",
        "text": "Return the layout thickness.\nThickness value.\nget_layout_thickness\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_layout_thickness",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_layout_thickness.html#pyedb.grpc.database.stackup.Stackup.get_layout_thickness",
        "title": "get_layout_thickness > get_layout_thickness > get_layout_thickness",
        "section": "get_layout_thickness > get_layout_thickness",
        "text": "Stackup.get_layout_thickness() -> float\n\nReturn the layout thickness.\n\nReturns\n\npython:float\n\nThickness value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.get_net_by_name",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.get_net_by_name.html#get_net_by_name",
        "title": "get_net_by_name",
        "section": "get_net_by_name",
        "text": "Find a net by name.\nget_net_by_name"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.get_net_by_name",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.get_net_by_name.html#pyedb.dotnet.database.nets.EdbNets.get_net_by_name",
        "title": "get_net_by_name > get_net_by_name > get_net_by_name",
        "section": "get_net_by_name > get_net_by_name",
        "text": "EdbNets.get_net_by_name(net_name)\n\nFind a net by name.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_roughness_model",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_roughness_model.html#get_roughness_model",
        "title": "get_roughness_model",
        "section": "get_roughness_model",
        "text": "Get the roughness model used by the layer.\nget_roughness_model\nRoughnessRegion"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_roughness_model",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_roughness_model.html#pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_roughness_model",
        "title": "get_roughness_model > get_roughness_model > get_roughness_model",
        "section": "get_roughness_model > get_roughness_model",
        "text": "StackupLayer.get_roughness_model(region)\n\nGet the roughness model used by the layer.\n\nParameters\n\nregion\n\nRoughnessRegion\n\n\n\nReturns\n\nRoughnessModel\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.html#waveport",
        "title": "WavePort",
        "section": "WavePort",
        "text": "Manages wave port properties.\nEDB object from the Edblib library.\nEdge terminal instance from EDB.\nThis example shows how to access the WavePort class.\nWavePort.couple_ports(port)\nCreate a bundle wave port.\nWavePort.delete()\nDelete this primitive.\nWavePort.get_connected_object_id_set()\nProduce a list of all geometries physically connected to a given layout object.\nWavePort.get_connected_objects()\nGet connected objects.\nWavePort.get_edge_terminal_reference_primitive()\nCheck and  return a primitive instance that serves Edge ports, wave ports and coupled edge ports that are directly connedted to primitives.\nWavePort.get_pad_edge_terminal_reference_pin([...])\nGet the closest pin padstack instances and serves any edge terminal connected to a pad.\nWavePort.get_padstack_terminal_reference_pin([...])\nGet a list of pad stacks instances and serves Coax wave ports, pingroup terminals, PadEdge terminals.\nWavePort.get_pin_group_terminal_reference_pin([...])\nReturn a list of pins and serves terminals connected to pingroups.\nWavePort.get_point_terminal_reference_primitive()\nFind and return the primitive reference for the point terminal or the padstack instance.\nWavePort\npyedb.edb.Edb\nEdblib\nAnsys.Ansoft.Edb.Cell.Terminal.EdgeTerminal\nWavePort\nWavePort.couple_ports\nWavePort.delete\nWavePort.get_connected_object_id_set\nWavePort.get_connected_objects\nWavePort.get_edge_terminal_reference_primitive\nWavePort.get_pad_edge_terminal_reference_pin\nWavePort.get_padstack_terminal_reference_pin\nWavePort.get_pin_group_terminal_reference_pin\nWavePort.get_point_terminal_reference_primitive"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.html#pyedb.dotnet.database.edb_data.ports.WavePort",
        "title": "WavePort > WavePort > WavePort",
        "section": "WavePort > WavePort",
        "text": "class pyedb.dotnet.database.edb_data.ports.WavePort(pedb, edb_terminal)\n\nManages wave port properties.\n\nParameters\n\npedb\n\npyedb.edb.Edb\n\nEDB object from the Edblib library.\n\nedb_object\n\nAnsys.Ansoft.Edb.Cell.Terminal.EdgeTerminal\n\nEdge terminal instance from EDB.\n\nExamples\n\nThis example shows how to access the WavePort class.\n\n>>> from pyedb import Edb\n>>> edb = Edb(\"myaedb.aedb\")\n>>> exc = edb.ports\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nWavePort.couple_ports(port)\n\nCreate a bundle wave port.\n\nWavePort.delete()\n\nDelete this primitive.\n\nWavePort.get_connected_object_id_set()\n\nProduce a list of all geometries physically connected to a given layout object.\n\nWavePort.get_connected_objects()\n\nGet connected objects.\n\nWavePort.get_edge_terminal_reference_primitive()\n\nCheck and  return a primitive instance that serves Edge ports, wave ports and coupled edge ports that are directly connedted to primitives.\n\nWavePort.get_pad_edge_terminal_reference_pin([...])\n\nGet the closest pin padstack instances and serves any edge terminal connected to a pad.\n\nWavePort.get_padstack_terminal_reference_pin([...])\n\nGet a list of pad stacks instances and serves Coax wave ports, pingroup terminals, PadEdge terminals.\n\nWavePort.get_pin_group_terminal_reference_pin([...])\n\nReturn a list of pins and serves terminals connected to pingroups.\n\nWavePort.get_point_terminal_reference_primitive()\n\nFind and return the primitive reference for the point terminal or the padstack instance.\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_djordjevicsarkar_dielectric",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_djordjevicsarkar_dielectric.html#add_djordjevicsarkar_dielectric",
        "title": "add_djordjevicsarkar_dielectric",
        "section": "add_djordjevicsarkar_dielectric",
        "text": "Add a dielectric using the Djordjevic-Sarkar model.\nName of the dielectric.\nRelative permittivity of the dielectric.\nLoss tangent for the material.\nTest frequency in GHz for the dielectric.\nadd_djordjevicsarkar_dielectric\npython:str\npython:str\npython:float\npython:int\npython:str\npython:float\npython:int\npython:str\npython:float\npython:int\npyedb.dotnet.database.materials.Material"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_djordjevicsarkar_dielectric",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_djordjevicsarkar_dielectric.html#pyedb.dotnet.database.materials.Materials.add_djordjevicsarkar_dielectric",
        "title": "add_djordjevicsarkar_dielectric > add_djordjevicsarkar_dielectric > add_djordjevicsarkar_dielectric",
        "section": "add_djordjevicsarkar_dielectric > add_djordjevicsarkar_dielectric",
        "text": "Materials.add_djordjevicsarkar_dielectric(name, permittivity_at_frequency, loss_tangent_at_frequency, dielectric_model_frequency, dc_conductivity=None, dc_permittivity=None, **kwargs)\n\nAdd a dielectric using the Djordjevic-Sarkar model.\n\nParameters\n\nname\n\npython:str\n\nName of the dielectric.\n\npermittivity_at_frequency\n\npython:str, python:float, python:int\n\nRelative permittivity of the dielectric.\n\nloss_tangent_at_frequency\n\npython:str, python:float, python:int\n\nLoss tangent for the material.\n\ndielectric_model_frequency\n\npython:str, python:float, python:int\n\nTest frequency in GHz for the dielectric.\n\nReturns\n\npyedb.dotnet.database.materials.Material\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.net2",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.net2.html#net2",
        "title": "net2",
        "section": "net2",
        "text": "net2"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.net2",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.net2.html#pyedb.workflows.drc.drc.MinClearance.net2",
        "title": "net2 > net2 > net2",
        "section": "net2 > net2",
        "text": "MinClearance.net2: str\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.product_solver_names",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.product_solver_names.html#product_solver_names",
        "title": "product_solver_names",
        "section": "product_solver_names",
        "text": "Get the list of solver names.\nID of the product.\nproduct_solver_names\nProductIdType\npython:list\nof\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.product_solver_names",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.product_solver_names.html#pyedb.grpc.database.ports.ports.CircuitPort.product_solver_names",
        "title": "product_solver_names > product_solver_names > product_solver_names",
        "section": "product_solver_names > product_solver_names",
        "text": "CircuitPort.product_solver_names(product_id)\n\nGet the list of solver names.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nReturns\n\npython:list of python:str\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_djordjevicsarkar_dielectric",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_djordjevicsarkar_dielectric.html#add_djordjevicsarkar_dielectric",
        "title": "add_djordjevicsarkar_dielectric",
        "section": "add_djordjevicsarkar_dielectric",
        "text": "Add a dielectric using the Djordjevic-Sarkar model.\nName of the dielectric.\nRelative permittivity of the dielectric.\nLoss tangent for the material.\nTest frequency in GHz for the dielectric.\nMaterial object.\nadd_djordjevicsarkar_dielectric\npython:str\npython:str\npython:float\npython:int\npython:str\npython:float\npython:int\npython:str\npython:float\npython:int\nMaterial"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_djordjevicsarkar_dielectric",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_djordjevicsarkar_dielectric.html#pyedb.grpc.database.definition.materials.Materials.add_djordjevicsarkar_dielectric",
        "title": "add_djordjevicsarkar_dielectric > add_djordjevicsarkar_dielectric > add_djordjevicsarkar_dielectric",
        "section": "add_djordjevicsarkar_dielectric > add_djordjevicsarkar_dielectric",
        "text": "Materials.add_djordjevicsarkar_dielectric(name, permittivity_at_frequency, loss_tangent_at_frequency, dielectric_model_frequency, dc_conductivity=None, dc_permittivity=None, **kwargs) -> Material\n\nAdd a dielectric using the Djordjevic-Sarkar model.\n\nParameters\n\nname\n\npython:str\n\nName of the dielectric.\n\npermittivity_at_frequency\n\npython:str, python:float, python:int\n\nRelative permittivity of the dielectric.\n\nloss_tangent_at_frequency\n\npython:str, python:float, python:int\n\nLoss tangent for the material.\n\ndielectric_model_frequency\n\npython:str, python:float, python:int\n\nTest frequency in GHz for the dielectric.\n\nReturns\n\nMaterial\n\nMaterial object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData.find_by_name",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData.find_by_name.html#find_by_name",
        "title": "find_by_name",
        "section": "find_by_name",
        "text": "Edb Dotnet Api Database Edb.ExtendedNet.FindByName.\nfind_by_name"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData.find_by_name",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData.find_by_name.html#pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData.find_by_name",
        "title": "find_by_name > find_by_name > find_by_name",
        "section": "find_by_name > find_by_name",
        "text": "EDBExtendedNetData.find_by_name(layout, net)\n\nEdb Dotnet Api Database Edb.ExtendedNet.FindByName.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.find_by_id.html#find_by_id",
        "title": "find_by_id",
        "section": "find_by_id",
        "text": "Find a package definition object by ID in a given database.\nDatabase to search for the package definition.\nUnique identifier for the package definition.\nPackage definition found, None otherwise.\nfind_by_id\npython:int\nPackageDef\nNone"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.find_by_id.html#pyedb.grpc.database.definition.package_def.PackageDef.find_by_id",
        "title": "find_by_id > find_by_id > find_by_id",
        "section": "find_by_id > find_by_id",
        "text": "classmethod PackageDef.find_by_id(db, uid)\n\nFind a package definition object by ID in a given database.\n\nParameters\n\ndb :class:`.Database`\n\nDatabase to search for the package definition.\n\nUID\n\npython:int\n\nUnique identifier for the package definition.\n\nReturns\n\nPackageDef\n\nPackage definition found, None otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup.add_sweep",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup.add_sweep.html#add_sweep",
        "title": "add_sweep",
        "section": "add_sweep",
        "text": "Add a HFSS frequency sweep.\nSweep name.\nType of the sweep. The default is “linear”. Options are:\n- “linear”\n- “linear_count”\n- “decade_count”\n- “octave_count”\n- “exponential”\nStarting frequency. The default is 1.\nStopping frequency. The default is 1e9.\nFrequency step. The default is 1e6. or used for “decade_count”, “linear_count”, “octave_count”\ndistribution. Must be integer in that case.\nWhether the sweep is discrete. The default is False.\nadd_sweep\npython:str\noptional\npython:str\noptional\npython:str\npython:float\noptional\n1\npython:str\npython:float\noptional\n1e9\npython:str\npython:float\npython:int\noptional\n1e6\noptional\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup.add_sweep",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup.add_sweep.html#pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup.add_sweep",
        "title": "add_sweep > add_sweep > add_sweep",
        "section": "add_sweep > add_sweep",
        "text": "RaptorXSimulationSetup.add_sweep(name=None, distribution='linear', start_freq='0GHz', stop_freq='20GHz', step='10MHz', discrete=False) -> bool\n\nAdd a HFSS frequency sweep.\n\nParameters\n\nname\n\npython:str, optional\n\nSweep name.\n\ndistribution\n\npython:str, optional\n\nType of the sweep. The default is “linear”. Options are:\n- “linear”\n- “linear_count”\n- “decade_count”\n- “octave_count”\n- “exponential”\n\nstart_freq\n\npython:str, python:float, optional\n\nStarting frequency. The default is 1.\n\nstop_freq\n\npython:str, python:float, optional\n\nStopping frequency. The default is 1e9.\n\nstep\n\npython:str, python:float, python:int, optional\n\nFrequency step. The default is 1e6. or used for “decade_count”, “linear_count”, “octave_count”\ndistribution. Must be integer in that case.\n\ndiscrete\n\nbool, optional\n\nWhether the sweep is discrete. The default is False.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/hfss_extent_info",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/hfss_extent_info.html#hfss-extent-info",
        "title": "HFSS extent info",
        "section": "HFSS extent info",
        "text": "This class is managing EDB HFSS extend info.\nHfssExtentInfo\nManages EDB functionalities for HFSS extent information.\nHFSS extent info\nHfssExtentInfo"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_material",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_material.html#get_material",
        "title": "get_material",
        "section": "get_material",
        "text": "Get the name of the material of the layer.\nWhether to evaluate the material if it is parameterized.\nMaterial name.\nget_material\npython:True\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_material",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_material.html#pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_material",
        "title": "get_material > get_material > get_material",
        "section": "get_material > get_material",
        "text": "StackupLayer.get_material(evaluated=True)\n\nGet the name of the material of the layer.\n\nParameters\n\nevaluated\n\nbool, default: python:True\n\nWhether to evaluate the material if it is parameterized.\n\nReturns\n\npython:str\n\nMaterial name.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.get_dcconnected_net_list",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.get_dcconnected_net_list.html#get_dcconnected_net_list",
        "title": "get_dcconnected_net_list",
        "section": "get_dcconnected_net_list",
        "text": "Get the nets connected to the direct current through inductors.\nOnly inductors are considered.\nList of ground nets. The default is [\"GND\"].\nList of nets connected to DC through inductors.\nget_dcconnected_net_list\npython:list\noptional\n[\"GND\"]\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.get_dcconnected_net_list",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.get_dcconnected_net_list.html#pyedb.dotnet.database.nets.EdbNets.get_dcconnected_net_list",
        "title": "get_dcconnected_net_list > get_dcconnected_net_list > get_dcconnected_net_list",
        "section": "get_dcconnected_net_list > get_dcconnected_net_list",
        "text": "EdbNets.get_dcconnected_net_list(ground_nets=['GND'], res_value=0.001)\n\nGet the nets connected to the direct current through inductors.\n\nOnly inductors are considered.\n\nParameters\n\nground_nets\n\npython:list, optional\n\nList of ground nets. The default is [\"GND\"].\n\nReturns\n\npython:list\n\nList of nets connected to DC through inductors.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.dict",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "dict"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.dict",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.dict.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "DiffPairLengthMatch.dict(*, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Dict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/mesh_operation",
        "href": "dotnet_api/dotnet/sim_setup_data/data/mesh_operation.html#mesh-operation",
        "title": "Mesh operation",
        "section": "Mesh operation",
        "text": "This class is the container of HFSS mesh operation.\nMeshOpType\nAn enumeration.\nMeshOperation\nMesh Operation Class.\nLengthMeshOperation\nMesh operation Length class.\nSkinDepthMeshOperation\nMesh operation Skin Depth class.\nMesh operation\nMeshOpType\nMeshOperation\nLengthMeshOperation\nSkinDepthMeshOperation"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.set_clip_info",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.set_clip_info.html#set_clip_info",
        "title": "set_clip_info",
        "section": "set_clip_info",
        "text": "Set the data used to clip the path.\nPolygon data to use to clip the path.\nWhether the part of the path inside the polygon should be preserved.\nset_clip_info\nPolygonData\npython:True"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.set_clip_info",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.set_clip_info.html#pyedb.grpc.database.primitive.path.Path.set_clip_info",
        "title": "set_clip_info > set_clip_info > set_clip_info",
        "section": "set_clip_info > set_clip_info",
        "text": "Path.set_clip_info(clipping_poly: PolygonData, keep_inside=True)\n\nSet the data used to clip the path.\n\nParameters\n\nclipping_poly\n\nPolygonData\n\nPolygon data to use to clip the path.\n\nkeep_inside\n\nbool, default: python:True\n\nWhether the part of the path inside the polygon should be preserved.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/model",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/model.html#model",
        "title": "Model",
        "section": "Model",
        "text": "This class is managing EDB model.\nModel\nManages model Model.\nModel\nModel\nModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.create_hfss.html#create_hfss",
        "title": "create_hfss",
        "section": "create_hfss",
        "text": "Create an HFSS model from an MCAD file.\nHFSS model created.\ncreate_hfss\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.create_hfss.html#pyedb.grpc.database.ports.ports.CoaxPort.create_hfss",
        "title": "create_hfss > create_hfss > create_hfss",
        "section": "create_hfss > create_hfss",
        "text": "CoaxPort.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nReturns\n\nMcadModel\n\nHFSS model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.imag",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.imag.html#imag",
        "title": "imag",
        "section": "imag",
        "text": "the imaginary part of a complex number\nimag"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.imag",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.imag.html#pyedb.grpc.database.utility.value.Value.imag",
        "title": "imag > imag > imag",
        "section": "imag > imag",
        "text": "Value.imag\n\nthe imaginary part of a complex number\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_definition_name",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_definition_name.html#get_definition_name",
        "title": "get_definition_name",
        "section": "get_definition_name",
        "text": "Get the definition name of the bondwire object.\nWhether an evaluated (in variable namespace) material name is wanted.\nBondwire definition name.\nget_definition_name\npython:True\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_definition_name",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_definition_name.html#pyedb.grpc.database.primitive.bondwire.Bondwire.get_definition_name",
        "title": "get_definition_name > get_definition_name > get_definition_name",
        "section": "get_definition_name > get_definition_name",
        "text": "Bondwire.get_definition_name(evaluated: bool = True) -> str\n\nGet the definition name of the bondwire object.\n\nParameters\n\nevaluated\n\nbool, default: python:True\n\nWhether an evaluated (in variable namespace) material name is wanted.\n\nReturns\n\npython:str\n\nBondwire definition name.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_voltage_probe_on_pin_group",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_voltage_probe_on_pin_group.html#create_voltage_probe_on_pin_group",
        "title": "create_voltage_probe_on_pin_group",
        "section": "create_voltage_probe_on_pin_group",
        "text": "Create voltage probe between two pin groups.\nName of the probe.\nName of the positive pin group.\nName of the negative pin group.\nPhase of the source.\ncreate_voltage_probe_on_pin_group\npython:str\npython:str\npython:str\npython:int\npython:float\noptional"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_voltage_probe_on_pin_group",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_voltage_probe_on_pin_group.html#pyedb.dotnet.database.siwave.EdbSiwave.create_voltage_probe_on_pin_group",
        "title": "create_voltage_probe_on_pin_group > create_voltage_probe_on_pin_group > create_voltage_probe_on_pin_group",
        "section": "create_voltage_probe_on_pin_group > create_voltage_probe_on_pin_group",
        "text": "EdbSiwave.create_voltage_probe_on_pin_group(probe_name, pos_pin_group_name, neg_pin_group_name, impedance=1000000)\n\nCreate voltage probe between two pin groups.\n\nParameters\n\nprobe_name\n\npython:str\n\nName of the probe.\n\npos_pin_group_name\n\npython:str\n\nName of the positive pin group.\n\nneg_pin_group_name\n\npython:str\n\nName of the negative pin group.\n\nimpedance\n\npython:int, python:float, optional\n\nPhase of the source.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.CPW.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.CPW.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Draw the centre strip, side grounds and bottom ground plane.\nTrue on success.\ncreate"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.CPW.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.CPW.create.html#pyedb.libraries.rf_libraries.base_functions.CPW.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "CPW.create() -> bool\n\nDraw the centre strip, side grounds and bottom ground plane.\n\nReturns\n\nbool\n\nTrue on success.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/NetData",
        "href": "dotnet_api/dotnet/edb_data/NetData.html#nets",
        "title": "Nets",
        "section": "Nets",
        "text": "Nets"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/NetData",
        "href": "dotnet_api/dotnet/edb_data/NetData.html#net-properties",
        "title": "Nets > Net properties",
        "section": "Net properties",
        "text": "The following class is the container of data management for nets, extended nets and differential pairs.\nEDBNetsData\nManages EDB functionalities for a primitives.\nEDBNetClassData\nManages EDB functionalities for a primitives.\nEDBExtendedNetData\nManages EDB functionalities for a primitives.\nEDBDifferentialPairData\nManages EDB functionalities for a primitive.\nNet properties\nEDBNetsData\nEDBNetClassData\nEDBExtendedNetData\nEDBDifferentialPairData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.subtract",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.subtract.html#subtract",
        "title": "subtract",
        "section": "subtract",
        "text": "Subtract active primitive with one or more primitives.\nor: List[Primitives]\nor: class:PolygonData <ansys.edb.core.geometry.polygon_data.PolygonData>\nList of Primitive objects.\nsubtract\nPrimitives\nPrimitives\nList\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.subtract",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.subtract.html#pyedb.grpc.database.primitive.rectangle.Rectangle.subtract",
        "title": "subtract > subtract > subtract",
        "section": "subtract > subtract",
        "text": "Rectangle.subtract(primitives) -> list[any]\n\nSubtract active primitive with one or more primitives.\n\nParameters\n\nprimitives\n\nPrimitives\n\nor: List[Primitives]\nor: class:PolygonData <ansys.edb.core.geometry.polygon_data.PolygonData>\n\nReturns\n\nList[Primitive]\n\nList of Primitive objects.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_padstack_terminal_reference_pin",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_padstack_terminal_reference_pin.html#get_padstack_terminal_reference_pin",
        "title": "get_padstack_terminal_reference_pin",
        "section": "get_padstack_terminal_reference_pin",
        "text": "Get a list of pad stacks instances and serves Coax wave ports,\npingroup terminals, PadEdge terminals.\nPreferred reference net name.\nget_padstack_terminal_reference_pin\npython:str\noptional\nPadstackInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_padstack_terminal_reference_pin",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_padstack_terminal_reference_pin.html#pyedb.grpc.database.terminal.terminal.Terminal.get_padstack_terminal_reference_pin",
        "title": "get_padstack_terminal_reference_pin > get_padstack_terminal_reference_pin > get_padstack_terminal_reference_pin",
        "section": "get_padstack_terminal_reference_pin > get_padstack_terminal_reference_pin",
        "text": "Terminal.get_padstack_terminal_reference_pin(gnd_net_name_preference=None) -> PadstackInstance\n\nGet a list of pad stacks instances and serves Coax wave ports,\npingroup terminals, PadEdge terminals.\n\nParameters\n\ngnd_net_name_preference\n\npython:str, optional\n\nPreferred reference net name.\n\nReturns\n\nPadstackInstance\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.log10",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.log10.html#log10",
        "title": "log10",
        "section": "log10",
        "text": "Base-10 logarithm of the value.\nlog10"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.log10",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.log10.html#pyedb.grpc.database.utility.value.Value.log10",
        "title": "log10 > log10 > log10",
        "section": "log10 > log10",
        "text": "Value.log10()\n\nBase-10 logarithm of the value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileMeshOp",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileMeshOp.html#controlfilemeshop",
        "title": "ControlFileMeshOp",
        "section": "ControlFileMeshOp",
        "text": "ControlFileMeshOp"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileMeshOp",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileMeshOp.html#pyedb.grpc.database.utility.xml_control_file.ControlFileMeshOp",
        "title": "ControlFileMeshOp > ControlFileMeshOp > ControlFileMeshOp",
        "section": "ControlFileMeshOp > ControlFileMeshOp",
        "text": "class pyedb.grpc.database.utility.xml_control_file.ControlFileMeshOp(name, region, type, nets_layers)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.set_product_property.html#pyedb.grpc.database.net.net.Net.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "Net.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.product_solver_option.html#product_solver_option",
        "title": "product_solver_option",
        "section": "product_solver_option",
        "text": "Get the name of the product solver option.\nID of the product.\nName of the solver.\nName of the product solver option.\nproduct_solver_option\nProductIdType\nstr\nstr"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.product_solver_option.html#pyedb.grpc.database.ports.ports.BundleWavePort.product_solver_option",
        "title": "product_solver_option > product_solver_option > product_solver_option",
        "section": "product_solver_option > product_solver_option",
        "text": "BundleWavePort.product_solver_option(product_id, solver_name)\n\nGet the name of the product solver option.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nsolver_name\n\nstr\n\nName of the solver.\n\nReturns\n\nstr\n\nName of the product solver option.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_connected_object_id_set",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_connected_object_id_set.html#get_connected_object_id_set",
        "title": "get_connected_object_id_set",
        "section": "get_connected_object_id_set",
        "text": "Produce a list of all geometries physically connected to a given layout object.\nFound connected objects IDs with Layout object.\nget_connected_object_id_set\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_connected_object_id_set",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_connected_object_id_set.html#pyedb.dotnet.database.edb_data.ports.GapPort.get_connected_object_id_set",
        "title": "get_connected_object_id_set > get_connected_object_id_set > get_connected_object_id_set",
        "section": "get_connected_object_id_set > get_connected_object_id_set",
        "text": "GapPort.get_connected_object_id_set()\n\nProduce a list of all geometries physically connected to a given layout object.\n\nReturns\n\npython:list\n\nFound connected objects IDs with Layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude: Optional set or mapping specifying which fields to include in the copied model.\nexclude: Optional set or mapping specifying which fields to exclude in the copied model.\nupdate: Optional dictionary of field-value pairs to override field values in the copied model.\ndeep: If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.copy.html#pyedb.workflows.drc.drc.BackDrillStubLength.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "BackDrillStubLength.copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -> Self\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nArgs:\n\ninclude: Optional set or mapping specifying which fields to include in the copied model.\nexclude: Optional set or mapping specifying which fields to exclude in the copied model.\nupdate: Optional dictionary of field-value pairs to override field values in the copied model.\ndeep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.hfss_extent_info.HfssExtentInfo.export_config",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.hfss_extent_info.HfssExtentInfo.export_config.html#export_config",
        "title": "export_config",
        "section": "export_config",
        "text": "Export HFSS extent information.\nReturns:\ndict\nParameters of the HFSS extent information.\nexport_config"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.hfss_extent_info.HfssExtentInfo.export_config",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.hfss_extent_info.HfssExtentInfo.export_config.html#pyedb.dotnet.database.edb_data.hfss_extent_info.HfssExtentInfo.export_config",
        "title": "export_config > export_config > export_config",
        "section": "export_config > export_config",
        "text": "HfssExtentInfo.export_config()\n\nExport HFSS extent information.\n\nReturns:\ndict\n\nParameters of the HFSS extent information.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPairs.auto_identify",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPairs.auto_identify.html#auto_identify",
        "title": "auto_identify",
        "section": "auto_identify",
        "text": "Auto identify differential pairs by naming conversion.\nDifferentiator of the positive net. The default is \"_P\".\nDifferentiator of the negative net. The default is \"_N\".\nA list containing identified differential pair names.\nauto_identify\n\"_P\"\n\"_N\"\npython:list"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPairs.auto_identify",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPairs.auto_identify.html#pyedb.grpc.database.net.differential_pair.DifferentialPairs.auto_identify",
        "title": "auto_identify > auto_identify > auto_identify",
        "section": "auto_identify > auto_identify",
        "text": "DifferentialPairs.auto_identify(positive_differentiator='_P', negative_differentiator='_N') -> list[str]\n\nAuto identify differential pairs by naming conversion.\n\nParameters\n\npositive_differentiator: str, optional\n\nDifferentiator of the positive net. The default is \"_P\".\n\nnegative_differentiator: str, optional\n\nDifferentiator of the negative net. The default is \"_N\".\n\nReturns\n\npython:list\n\nA list containing identified differential pair names.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", edbversion=\"2025.2\")\n>>> edb_nets = edbapp.differential_pairs.auto_identify()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.html#hfsssimulationsetup",
        "title": "HfssSimulationSetup",
        "section": "HfssSimulationSetup",
        "text": "Manages EDB methods for HFSS simulation setup.\nHfssSimulationSetup.add_frequency_sweep([...])\nAdd frequency sweep.\nHfssSimulationSetup.add_length_mesh_operation(...)\nAdd a mesh operation to the setup.\nHfssSimulationSetup.add_skin_depth_mesh_operation(...)\nAdd a mesh operation to the setup.\nHfssSimulationSetup.add_sweep([name, ...])\nAdd frequency sweep.\nHfssSimulationSetup.auto_mesh_operation([...])\nAutomatically create and apply a length-based mesh operation for all nets in the design.\nHfssSimulationSetup.delete()\nDelete current simulation setup.\nHfssSimulationSetup.delete_frequency_sweep(...)\nDelete a frequency sweep.\nHfssSimulationSetup.get_simulation_settings()\n\nHfssSimulationSetup.set_sim_setup_info(...)\n\nHfssSimulationSetup.set_simulation_settings(...)\n\nHfssSimulationSetup.set_solution_broadband([...])\nSet broadband solution.\nHfssSimulationSetup.set_solution_multi_frequencies([...])\nSet multi-frequency solution.\nHfssSimulationSetup.set_solution_single_frequency([...])\nSet single-frequency solution.\nHfssSimulationSetup\nHfssSimulationSetup.add_frequency_sweep\nHfssSimulationSetup.add_length_mesh_operation\nHfssSimulationSetup.add_skin_depth_mesh_operation\nHfssSimulationSetup.add_sweep\nHfssSimulationSetup.auto_mesh_operation\nHfssSimulationSetup.delete\nHfssSimulationSetup.delete_frequency_sweep\nHfssSimulationSetup.get_simulation_settings\nHfssSimulationSetup.set_sim_setup_info\nHfssSimulationSetup.set_simulation_settings\nHfssSimulationSetup.set_solution_broadband\nHfssSimulationSetup.set_solution_multi_frequencies\nHfssSimulationSetup.set_solution_single_frequency"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.html#pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup",
        "title": "HfssSimulationSetup > HfssSimulationSetup > HfssSimulationSetup",
        "section": "HfssSimulationSetup > HfssSimulationSetup",
        "text": "class pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup(pedb, edb_object=None, name: str | None = None)\n\nManages EDB methods for HFSS simulation setup.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nHfssSimulationSetup.add_frequency_sweep([...])\n\nAdd frequency sweep.\n\nHfssSimulationSetup.add_length_mesh_operation(...)\n\nAdd a mesh operation to the setup.\n\nHfssSimulationSetup.add_skin_depth_mesh_operation(...)\n\nAdd a mesh operation to the setup.\n\nHfssSimulationSetup.add_sweep([name, ...])\n\nAdd frequency sweep.\n\nHfssSimulationSetup.auto_mesh_operation([...])\n\nAutomatically create and apply a length-based mesh operation for all nets in the design.\n\nHfssSimulationSetup.delete()\n\nDelete current simulation setup.\n\nHfssSimulationSetup.delete_frequency_sweep(...)\n\nDelete a frequency sweep.\n\nHfssSimulationSetup.get_simulation_settings()\n\n\n\nHfssSimulationSetup.set_sim_setup_info(...)\n\n\n\nHfssSimulationSetup.set_simulation_settings(...)\n\n\n\nHfssSimulationSetup.set_solution_broadband([...])\n\nSet broadband solution.\n\nHfssSimulationSetup.set_solution_multi_frequencies([...])\n\nSet multi-frequency solution.\n\nHfssSimulationSetup.set_solution_single_frequency([...])\n\nSet single-frequency solution.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.unite",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.unite.html#unite",
        "title": "unite",
        "section": "unite",
        "text": "Unite active primitive with one or more primitives.\nList of Primitive objects.\nunite\nPrimitives\nList\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.unite",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.unite.html#pyedb.grpc.database.primitive.rectangle.Rectangle.unite",
        "title": "unite > unite > unite",
        "section": "unite > unite",
        "text": "Rectangle.unite(primitives) -> list[any]\n\nUnite active primitive with one or more primitives.\n\nParameters\n\nprimitives\n\nPrimitives\n\n\n\nor: List[:class:`Primitives <pyedb.grpc.database.primitive.primitive.Primitive>`]\n\n\n\nor: class:`PolygonData <ansys.edb.core.geometry.polygon_data.PolygonData>`\n\n\n\nReturns\n\nList[Primitive]\n\nList of Primitive objects.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.parse_file",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "parse_file"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.parse_file",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.parse_file.html#pyedb.workflows.drc.drc.MinLineWidth.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod MinLineWidth.parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.scale",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.scale.html#scale",
        "title": "scale",
        "section": "scale",
        "text": "Scales the polygon relative to a center point by a factor.\nScaling factor.\nIf None scaling is done from polygon center.\nTrue when successful, False when failed.\nscale\npython:float\nList\nof\npython:float\npython:str\noptional\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.scale",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.scale.html#pyedb.grpc.database.primitive.primitive.Primitive.scale",
        "title": "scale > scale > scale",
        "section": "scale > scale",
        "text": "Primitive.scale(factor, center=None) -> bool\n\nScales the polygon relative to a center point by a factor.\n\nParameters\n\nfactor\n\npython:float\n\nScaling factor.\n\ncenter\n\nList of python:float or python:str [x,y], optional\n\nIf None scaling is done from polygon center.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_via_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_via_layer.html#add_via_layer",
        "title": "add_via_layer",
        "section": "add_via_layer",
        "text": "Add a via layer to the layer collection.\nadd_via_layer\nViaLayer\nViaLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_via_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_via_layer.html#pyedb.grpc.database.stackup.LayerCollection.add_via_layer",
        "title": "add_via_layer > add_via_layer > add_via_layer",
        "section": "add_via_layer > add_via_layer",
        "text": "LayerCollection.add_via_layer(via_layer_to_add)\n\nAdd a via layer to the layer collection.\n\nParameters\n\nvia_layer_to_add\n\nViaLayer\n\n\n\nReturns\n\nViaLayer\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.schema_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "schema_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.schema_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.schema_json.html#pyedb.workflows.drc.drc.MinAnnularRing.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod MinAnnularRing.schema_json(*, by_alias: bool = True, ref_template: str = '#/$defs/{model}', **dumps_kwargs: Any) -> str\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the layer object to the correct concrete type.\ncast\nLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.cast.html#pyedb.grpc.database.layers.layer.Layer.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "Layer.cast()\n\nCast the layer object to the correct concrete type.\n\nReturns\n\nLayer\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.set_hfss_prop",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.set_hfss_prop.html#set_hfss_prop",
        "title": "set_hfss_prop",
        "section": "set_hfss_prop",
        "text": "Set HFSS properties.\nMaterial property name to be set.\nWhether to do solve inside.\nset_hfss_prop\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.set_hfss_prop",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.set_hfss_prop.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.set_hfss_prop",
        "title": "set_hfss_prop > set_hfss_prop > set_hfss_prop",
        "section": "set_hfss_prop > set_hfss_prop",
        "text": "EdbPolygon.set_hfss_prop(material, solve_inside)\n\nSet HFSS properties.\n\nParameters\n\nmaterial\n\npython:str\n\nMaterial property name to be set.\n\nsolve_inside\n\nbool\n\nWhether to do solve inside.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCSettings.restore_default",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCSettings.restore_default.html#restore_default",
        "title": "restore_default",
        "section": "restore_default",
        "text": "restore_default"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCSettings.restore_default",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCSettings.restore_default.html#pyedb.dotnet.database.sim_setup_data.io.siwave.DCSettings.restore_default",
        "title": "restore_default > restore_default > restore_default",
        "section": "restore_default > restore_default",
        "text": "DCSettings.restore_default()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.html#raptorxsimulationsetup",
        "title": "RaptorXSimulationSetup",
        "section": "RaptorXSimulationSetup",
        "text": "Manages EDB methods for RaptorX simulation setup.\nRaptorXSimulationSetup.add_frequency_sweep([...])\nAdd frequency sweep.\nRaptorXSimulationSetup.add_sweep([name, ...])\nAdd frequency sweep.\nRaptorXSimulationSetup.create([name])\nCreate an HFSS setup.\nRaptorXSimulationSetup.delete()\nDelete current simulation setup.\nRaptorXSimulationSetup.delete_frequency_sweep(...)\nDelete a frequency sweep.\nRaptorXSimulationSetup.get_simulation_settings()\n\nRaptorXSimulationSetup.set_sim_setup_info(...)\n\nRaptorXSimulationSetup.set_simulation_settings(...)\n\nRaptorXSimulationSetup\nRaptorXSimulationSetup.add_frequency_sweep\nRaptorXSimulationSetup.add_sweep\nRaptorXSimulationSetup.create\nRaptorXSimulationSetup.delete\nRaptorXSimulationSetup.delete_frequency_sweep\nRaptorXSimulationSetup.get_simulation_settings\nRaptorXSimulationSetup.set_sim_setup_info\nRaptorXSimulationSetup.set_simulation_settings"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.html#pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup",
        "title": "RaptorXSimulationSetup > RaptorXSimulationSetup > RaptorXSimulationSetup",
        "section": "RaptorXSimulationSetup > RaptorXSimulationSetup",
        "text": "class pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup(pedb, edb_object=None)\n\nManages EDB methods for RaptorX simulation setup.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nRaptorXSimulationSetup.add_frequency_sweep([...])\n\nAdd frequency sweep.\n\nRaptorXSimulationSetup.add_sweep([name, ...])\n\nAdd frequency sweep.\n\nRaptorXSimulationSetup.create([name])\n\nCreate an HFSS setup.\n\nRaptorXSimulationSetup.delete()\n\nDelete current simulation setup.\n\nRaptorXSimulationSetup.delete_frequency_sweep(...)\n\nDelete a frequency sweep.\n\nRaptorXSimulationSetup.get_simulation_settings()\n\n\n\nRaptorXSimulationSetup.set_sim_setup_info(...)\n\n\n\nRaptorXSimulationSetup.set_simulation_settings(...)\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layers",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layers.html#add_layers",
        "title": "add_layers",
        "section": "add_layers",
        "text": "Add a list of layers to the layer collection.\nList of layers.\nadd_layers\npython:list\nLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layers",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layers.html#pyedb.grpc.database.stackup.Stackup.add_layers",
        "title": "add_layers > add_layers > add_layers",
        "section": "add_layers > add_layers",
        "text": "Stackup.add_layers(layers)\n\nAdd a list of layers to the layer collection.\n\nParameters\n\nlayers\n\npython:list[Layer]\n\nList of layers.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.create_symmetric_stackup",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.create_symmetric_stackup.html#create_symmetric_stackup",
        "title": "create_symmetric_stackup",
        "section": "create_symmetric_stackup",
        "text": "Create a symmetric stackup.\nNumber of layers. Must be even.\nThickness of inner conductor layer.\nThickness of outer conductor layer.\nThickness of dielectric layer.\nMaterial of dielectric layer.\nWhether to create soldermask layers. The default is True.\nThickness of soldermask layer.\nTrue when successful, False when failed.\ncreate_symmetric_stackup\npython:int\npython:str\npython:float\noptional\npython:str\npython:float\noptional\npython:str\npython:float\noptional\npython:str\noptional\noptional\nTrue\npython:str\noptional\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.create_symmetric_stackup",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.create_symmetric_stackup.html#pyedb.grpc.database.stackup.Stackup.create_symmetric_stackup",
        "title": "create_symmetric_stackup > create_symmetric_stackup > create_symmetric_stackup",
        "section": "create_symmetric_stackup > create_symmetric_stackup",
        "text": "Stackup.create_symmetric_stackup(layer_count: int, inner_layer_thickness: str = '17um', outer_layer_thickness: str = '50um', dielectric_thickness: str = '100um', dielectric_material: str = 'FR4_epoxy', soldermask: bool = True, soldermask_thickness: str = '20um') -> bool\n\nCreate a symmetric stackup.\n\nParameters\n\nlayer_count\n\npython:int\n\nNumber of layers. Must be even.\n\ninner_layer_thickness\n\npython:str, python:float, optional\n\nThickness of inner conductor layer.\n\nouter_layer_thickness\n\npython:str, python:float, optional\n\nThickness of outer conductor layer.\n\ndielectric_thickness\n\npython:str, python:float, optional\n\nThickness of dielectric layer.\n\ndielectric_material\n\npython:str, optional\n\nMaterial of dielectric layer.\n\nsoldermask\n\nbool, optional\n\nWhether to create soldermask layers. The default is True.\n\nsoldermask_thickness\n\npython:str, optional\n\nThickness of soldermask layer.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> edb.stackup.create_symmetric_stackup(layer_count=4)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_padstack_instances_id_intersecting_polygon",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_padstack_instances_id_intersecting_polygon.html#get_padstack_instances_id_intersecting_polygon",
        "title": "get_padstack_instances_id_intersecting_polygon",
        "section": "get_padstack_instances_id_intersecting_polygon",
        "text": "Returns the list of padstack instances ID intersecting a given bounding box and nets.\nbounding box, [x1, y1, x2, y2]\nnet name of list of nets name applying filtering on padstack instances selection. If None is provided\nall instances are included in the index. Default value is None.\nCan be provided optionally to prevent computing padstack instances Rtree index again.\nList of padstack instances ID intersecting the bounding box.\nget_padstack_instances_id_intersecting_polygon\npython:tuple\npython:str\npython:list\noptional\nNone\nNone\noptional\nRtree\nList\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_padstack_instances_id_intersecting_polygon",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_padstack_instances_id_intersecting_polygon.html#pyedb.grpc.database.padstacks.Padstacks.get_padstack_instances_id_intersecting_polygon",
        "title": "get_padstack_instances_id_intersecting_polygon > get_padstack_instances_id_intersecting_polygon > get_padstack_instances_id_intersecting_polygon",
        "section": "get_padstack_instances_id_intersecting_polygon > get_padstack_instances_id_intersecting_polygon",
        "text": "Padstacks.get_padstack_instances_id_intersecting_polygon(points: List[Tuple[float, float]], nets: str | List[str] | None = None, padstack_instances_index: Dict[int, Tuple[float, float]] | None = None) -> List[int]\n\nReturns the list of padstack instances ID intersecting a given bounding box and nets.\n\nParameters\n\npoints\n\npython:tuple or list.\n\nbounding box, [x1, y1, x2, y2]\n\nnets\n\npython:str or python:list, optional\n\nnet name of list of nets name applying filtering on padstack instances selection. If None is provided\nall instances are included in the index. Default value is None.\n\npadstack_instances_index\n\noptional, Rtree object.\n\nCan be provided optionally to prevent computing padstack instances Rtree index again.\n\nReturns\n\nList[python:int]\n\nList of padstack instances ID intersecting the bounding box.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.points_raw",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.points_raw.html#points_raw",
        "title": "points_raw",
        "section": "points_raw",
        "text": "Return a list of Edb points.\nEdb Points.\npoints_raw\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.points_raw",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.points_raw.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.points_raw",
        "title": "points_raw > points_raw > points_raw",
        "section": "points_raw > points_raw",
        "text": "EdbPolygon.points_raw()\n\nReturn a list of Edb points.\n\nReturns\n\npython:list\n\nEdb Points.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/index",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/index.html#definition-classes",
        "title": "Definition classes",
        "section": "Definition classes",
        "text": "This section describes Definition classes.\nDefinition classes"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Drc.to_ipc356a",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Drc.to_ipc356a.html#to_ipc356a",
        "title": "to_ipc356a",
        "section": "to_ipc356a",
        "text": "Write a complete IPC-D-356A netlist plus DRC comments for fab review.\nThe file can be imported by any CAM tool that supports IPC-D-356A\n(Valor, Genesis, etc.).  Violations are appended as comment lines\nstarting with C.\nOutput path.  Overwrites existing files without warning.\nto_ipc356a\nC\npython:str\nos.PathLike"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Drc.to_ipc356a",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Drc.to_ipc356a.html#pyedb.workflows.drc.drc.Drc.to_ipc356a",
        "title": "to_ipc356a > to_ipc356a > to_ipc356a",
        "section": "to_ipc356a > to_ipc356a",
        "text": "Drc.to_ipc356a(file_path: str) -> None\n\nWrite a complete IPC-D-356A netlist plus DRC comments for fab review.\n\nThe file can be imported by any CAM tool that supports IPC-D-356A\n(Valor, Genesis, etc.).  Violations are appended as comment lines\nstarting with C.\n\nParameters\n\nfile_path\n\npython:str | os.PathLike\n\nOutput path.  Overwrites existing files without warning.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_fields.html#pyedb.workflows.drc.drc.MinClearance.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "MinClearance.model_fields = {'name': FieldInfo(annotation=str, required=True), 'net1': FieldInfo(annotation=str, required=True), 'net2': FieldInfo(annotation=str, required=True), 'value': FieldInfo(annotation=str, required=True)}\n\n"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_gds_file",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_gds_file.html#import_gds_file",
        "title": "import_gds_file",
        "section": "import_gds_file",
        "text": "Import GDS file.\nDo not execute this function with untrusted function argument, environment\nvariables or pyedb global settings.\nSee the security guide for details.\nGDS file path.\nAnsys translator path.\nUse PPE license. Default False.\nXML control file.\nTechnology file.\nLayer map file.\nLayer filter file.\nimport_gds_file\npython:str\npython:str\noptional\noptional\npython:str\noptional\npython:str\noptional\npython:str\noptional\npython:str\noptional"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_gds_file",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_gds_file.html#pyedb.grpc.edb.Edb.import_gds_file",
        "title": "import_gds_file > import_gds_file > import_gds_file",
        "section": "import_gds_file > import_gds_file",
        "text": "Edb.import_gds_file(inputGDS, anstranslator_full_path='', use_ppe=False, control_file=None, tech_file=None, map_file=None, layer_filter=None)\n\nImport GDS file.\n\nDo not execute this function with untrusted function argument, environment\nvariables or pyedb global settings.\nSee the security guide for details.\n\nParameters\n\ninputGDS\n\npython:str\n\nGDS file path.\n\nanstranslator_full_path\n\npython:str, optional\n\nAnsys translator path.\n\nuse_ppe\n\nbool, optional\n\nUse PPE license. Default False.\n\ncontrol_file\n\npython:str, optional\n\nXML control file.\n\ntech_file\n\npython:str, optional\n\nTechnology file.\n\nmap_file\n\npython:str, optional\n\nLayer map file.\n\nlayer_filter\n\npython:str, optional\n\nLayer filter file.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileComponents",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileComponents.html#controlfilecomponents",
        "title": "ControlFileComponents",
        "section": "ControlFileComponents",
        "text": "Class for component management.\nControlFileComponents.add_component(ref_des, ...)\nCreate a new component.\nControlFileComponents\nControlFileComponents.add_component"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileComponents",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileComponents.html#pyedb.dotnet.database.edb_data.control_file.ControlFileComponents",
        "title": "ControlFileComponents > ControlFileComponents > ControlFileComponents",
        "section": "ControlFileComponents > ControlFileComponents",
        "text": "class pyedb.dotnet.database.edb_data.control_file.ControlFileComponents\n\nClass for component management.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nControlFileComponents.add_component(ref_des, ...)\n\nCreate a new component.\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_siwave_dc_setup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_siwave_dc_setup.html#create_siwave_dc_setup",
        "title": "create_siwave_dc_setup",
        "section": "create_siwave_dc_setup",
        "text": "Create a setup from a template.\nSetup name.\ncreate_siwave_dc_setup\npython:str\noptional\nlegacy.database.edb_data.siwave_simulation_setup_data.SiwaveSYZSimulationSetup"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_siwave_dc_setup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_siwave_dc_setup.html#pyedb.dotnet.edb.Edb.create_siwave_dc_setup",
        "title": "create_siwave_dc_setup > create_siwave_dc_setup > create_siwave_dc_setup",
        "section": "create_siwave_dc_setup > create_siwave_dc_setup",
        "text": "Edb.create_siwave_dc_setup(name=None, **kwargs)\n\nCreate a setup from a template.\n\nParameters\n\nname\n\npython:str, optional\n\nSetup name.\n\nReturns\n\nlegacy.database.edb_data.siwave_simulation_setup_data.SiwaveSYZSimulationSetup\n\n\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb()\n>>> setup1 = edbapp.create_siwave_dc_setup(\"setup1\")\n>>> setup1.mesh_bondwires = True\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.html#hfsspisimulationsetup",
        "title": "HFSSPISimulationSetup",
        "section": "HFSSPISimulationSetup",
        "text": "Manages EDB methods for HFSSPI simulation setup.\nHFSSPISimulationSetup.add_frequency_sweep([...])\nAdd frequency sweep.\nHFSSPISimulationSetup.add_sweep([name, ...])\nAdd frequency sweep.\nHFSSPISimulationSetup.delete()\nDelete current simulation setup.\nHFSSPISimulationSetup.delete_frequency_sweep(...)\nDelete a frequency sweep.\nHFSSPISimulationSetup.get_simulation_settings()\n\nHFSSPISimulationSetup.set_sim_setup_info(...)\n\nHFSSPISimulationSetup.set_simulation_settings(...)\n\nHFSSPISimulationSetup\nHFSSPISimulationSetup.add_frequency_sweep\nHFSSPISimulationSetup.add_sweep\nHFSSPISimulationSetup.delete\nHFSSPISimulationSetup.delete_frequency_sweep\nHFSSPISimulationSetup.get_simulation_settings\nHFSSPISimulationSetup.set_sim_setup_info\nHFSSPISimulationSetup.set_simulation_settings"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.html#pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup",
        "title": "HFSSPISimulationSetup > HFSSPISimulationSetup > HFSSPISimulationSetup",
        "section": "HFSSPISimulationSetup > HFSSPISimulationSetup",
        "text": "class pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup(pedb, edb_object=None, name: str | None = None)\n\nManages EDB methods for HFSSPI simulation setup.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nHFSSPISimulationSetup.add_frequency_sweep([...])\n\nAdd frequency sweep.\n\nHFSSPISimulationSetup.add_sweep([name, ...])\n\nAdd frequency sweep.\n\nHFSSPISimulationSetup.delete()\n\nDelete current simulation setup.\n\nHFSSPISimulationSetup.delete_frequency_sweep(...)\n\nDelete a frequency sweep.\n\nHFSSPISimulationSetup.get_simulation_settings()\n\n\n\nHFSSPISimulationSetup.set_sim_setup_info(...)\n\n\n\nHFSSPISimulationSetup.set_simulation_settings(...)\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.ICDieProperty",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.ICDieProperty.html#icdieproperty",
        "title": "ICDieProperty",
        "section": "ICDieProperty",
        "text": "ICDieProperty"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.ICDieProperty",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.ICDieProperty.html#pyedb.grpc.database.hierarchy.component.ICDieProperty",
        "title": "ICDieProperty > ICDieProperty > ICDieProperty",
        "section": "ICDieProperty > ICDieProperty",
        "text": "class pyedb.grpc.database.hierarchy.component.ICDieProperty(component)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.TriangularPatch",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.TriangularPatch.html#triangularpatch",
        "title": "TriangularPatch",
        "section": "TriangularPatch",
        "text": "Equilateral-triangle microstrip patch antenna (optionally probe-fed).\nThe class automatically determines the physical dimensions for a\ndesired resonance frequency, creates the patch, ground plane and\neither an inset microstrip feed or a coaxial probe feed, and\noptionally sets up an HFSS simulation.\nEDB project/cell in which the antenna will be built.\nTarget resonance frequency of the patch.  A string such as\n\"2.4GHz\" or a numeric value in Hz can be given.\nRadial offset of the 50 Ω coax probe from the patch centroid.\nA value of 0 places the probe at the centroid (not recommended\nfor good matching).\nMetallization layer on which the patch polygon is drawn.\nMetallization layer on which the ground polygon is drawn.\nIf True, create a lumped port (probe feed) and add an HFSS\nsetup with a frequency sweep.\nBuild a 5.8 GHz triangular patch on a 0.787 mm Rogers RO4350B substrate:\nProbe-fed 2.4 GHz patch with default 0 offset (center feed):\nSubstrate definition (er, tand, h) used for all\nanalytical calculations.\nTriangularPatch.create()\nDraw the patch, ground plane and feed geometry in EDB.\nTriangularPatch\npyedb.Edb\noptional\npython:str\npython:float\ndefault\n\"2.4GHz\"\npython:str\npython:float\ndefault\npython:str\ndefault\npython:str\ndefault\ndefault\npython:True\nSubstrate\ner\ntand\nh\nTriangularPatch.create"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.TriangularPatch",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.TriangularPatch.html#pyedb.libraries.rf_libraries.planar_antennas.TriangularPatch",
        "title": "TriangularPatch > TriangularPatch > TriangularPatch",
        "section": "TriangularPatch > TriangularPatch",
        "text": "class pyedb.libraries.rf_libraries.planar_antennas.TriangularPatch(edb_cell=None, target_frequency: str | float = '2.4GHz', length_feeding_line: str | float = 0, layer: str = 'TOP_METAL', bottom_layer: str = 'BOT_METAL', add_port: bool = True)\n\nEquilateral-triangle microstrip patch antenna (optionally probe-fed).\n\nThe class automatically determines the physical dimensions for a\ndesired resonance frequency, creates the patch, ground plane and\neither an inset microstrip feed or a coaxial probe feed, and\noptionally sets up an HFSS simulation.\n\nParameters\n\nedb_cell\n\npyedb.Edb, optional\n\nEDB project/cell in which the antenna will be built.\n\nfreq\n\npython:str or python:float, default “2.4GHz”\n\nTarget resonance frequency of the patch.  A string such as\n\"2.4GHz\" or a numeric value in Hz can be given.\n\nprobe_offset\n\npython:str or python:float, default 0\n\nRadial offset of the 50 Ω coax probe from the patch centroid.\nA value of 0 places the probe at the centroid (not recommended\nfor good matching).\n\nlayer\n\npython:str, default “TOP_METAL”\n\nMetallization layer on which the patch polygon is drawn.\n\nbottom_layer\n\npython:str, default “BOT_METAL”\n\nMetallization layer on which the ground polygon is drawn.\n\nadd_port\n\nbool, default python:True\n\nIf True, create a lumped port (probe feed) and add an HFSS\nsetup with a frequency sweep.\n\nExamples\n\nBuild a 5.8 GHz triangular patch on a 0.787 mm Rogers RO4350B substrate:\n\n>>> edb = pyedb.Edb()\n>>> patch = TriangularPatch(edb_cell=edb, freq=\"5.8GHz\", probe_offset=\"5.6mm\", layer=\"TOP\", bottom_layer=\"GND\")\n>>> patch.substrate.er = 3.66\n>>> patch.substrate.tand = 0.0037\n>>> patch.substrate.h = 0.000787\n>>> patch.create()\n>>> edb.save_as(\"tri_patch_5p8GHz.aedb\")\n\nProbe-fed 2.4 GHz patch with default 0 offset (center feed):\n\n>>> edb = pyedb.Edb()\n>>> TriangularPatch(edb, freq=2.4e9).create()\n>>> edb.save_as(\"probe_tri_patch_2p4GHz.aedb\")\n\nAttributes\n\nsubstrate\n\nSubstrate\n\nSubstrate definition (er, tand, h) used for all\nanalytical calculations.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nTriangularPatch.create()\n\nDraw the patch, ground plane and feed geometry in EDB.\n\n"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_json_schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias: Whether to use attribute aliases or not.\nref_template: The reference template.\nunion_format: The format to use when combining schemas from unions together. Can be one of:\n‘any_of’: Use the [anyOf](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\nkeyword to combine schemas (the default).\n- ‘primitive_type_array’: Use the [type](https://json-schema.org/understanding-json-schema/reference/type)\nkeyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\ntype (string, boolean, null, integer or number) or contains constraints/metadata, falls back to\nany_of.\nGenerateJsonSchema with your desired modifications\nmode: The mode in which to generate the schema.\nThe JSON schema for the given model class.\nmodel_json_schema"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_json_schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_json_schema.html#pyedb.workflows.drc.drc.Rules.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod Rules.model_json_schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}', schema_generator: type[~pydantic.json_schema.GenerateJsonSchema] = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: ~typing.Literal['validation', 'serialization'] = 'validation', *, union_format: ~typing.Literal['any_of', 'primitive_type_array'] = 'any_of') -> dict[str, Any]\n\nGenerates a JSON schema for a model class.\n\nArgs:\n\nby_alias: Whether to use attribute aliases or not.\nref_template: The reference template.\nunion_format: The format to use when combining schemas from unions together. Can be one of:\n\n‘any_of’: Use the [anyOf](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n\nkeyword to combine schemas (the default).\n- ‘primitive_type_array’: Use the [type](https://json-schema.org/understanding-json-schema/reference/type)\nkeyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\ntype (string, boolean, null, integer or number) or contains constraints/metadata, falls back to\nany_of.\n\nschema_generator: To override the logic used to generate the JSON schema, as a subclass of\n\nGenerateJsonSchema with your desired modifications\n\nmode: The mode in which to generate the schema.\n\nReturns:\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.classify_nets",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.classify_nets.html#classify_nets",
        "title": "classify_nets",
        "section": "classify_nets",
        "text": "Reassign power/ground or signal nets based on list of nets.\nList of power nets to assign. Default is None.\nList of signal nets to assign. Default is None.\nTrue when successful, False when failed.\nclassify_nets\npython:str\npython:list\noptional\npython:str\npython:list\noptional\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.classify_nets",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.classify_nets.html#pyedb.dotnet.database.nets.EdbNets.classify_nets",
        "title": "classify_nets > classify_nets > classify_nets",
        "section": "classify_nets > classify_nets",
        "text": "EdbNets.classify_nets(power_nets=None, signal_nets=None)\n\nReassign power/ground or signal nets based on list of nets.\n\nParameters\n\npower_nets\n\npython:str, python:list, optional\n\nList of power nets to assign. Default is None.\n\nsignal_nets\n\npython:str, python:list, optional\n\nList of signal nets to assign. Default is None.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.set_zone_name",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.set_zone_name.html#set_zone_name",
        "title": "set_zone_name",
        "section": "set_zone_name",
        "text": "Set the name for a given zone.\nZone ID.\nNew name to give the zone.\nset_zone_name\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.set_zone_name",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.set_zone_name.html#pyedb.grpc.database.stackup.LayerCollection.set_zone_name",
        "title": "set_zone_name > set_zone_name > set_zone_name",
        "section": "set_zone_name > set_zone_name",
        "text": "LayerCollection.set_zone_name(zone, name)\n\nSet the name for a given zone.\n\nParameters\n\nzone\n\npython:int\n\nZone ID.\n\nname\n\npython:str\n\nNew name to give the zone.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/siwave",
        "href": "grpc_api/grpc/database/siwave.html#siwave",
        "title": "Siwave",
        "section": "Siwave",
        "text": "Class managing Siwave.\nsiwave.Siwave\nManages EDB methods related to Siwave Setup accessible from Edb.siwave property.\nSiwave\nsiwave.Siwave"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.create",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a layer collection.\nMode of the layer collection.\nLayer collection created.\ncreate\nLayerCollectionMode\nLAMINATE\nLayerCollection"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.create",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.create.html#pyedb.grpc.database.stackup.LayerCollection.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "static LayerCollection.create(mode=LayerCollectionMode.LAMINATE)\n\nCreate a layer collection.\n\nParameters\n\nmode\n\nLayerCollectionMode, default: LAMINATE\n\nMode of the layer collection.\n\nReturns\n\nLayerCollection\n\nLayer collection created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.default_dielectric_property_values",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.default_dielectric_property_values.html#default_dielectric_property_values",
        "title": "default_dielectric_property_values",
        "section": "default_dielectric_property_values",
        "text": "default_dielectric_property_values"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.default_dielectric_property_values",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.default_dielectric_property_values.html#pyedb.grpc.database.definition.materials.Materials.default_dielectric_property_values",
        "title": "default_dielectric_property_values > default_dielectric_property_values > default_dielectric_property_values",
        "section": "default_dielectric_property_values > default_dielectric_property_values",
        "text": "Materials.default_dielectric_property_values = {'conductivity': 0, 'dielectric_loss_tangent': 0.02, 'magnetic_loss_tangent': 0, 'mass_density': 1900, 'permeability': 1, 'permittivity': 4.4, 'poisson_ratio': 0.28, 'specific_heat': 1150, 'thermal_conductivity': 0.294, 'thermal_expansion_coefficient': 1.5e-05, 'youngs_modulus': 11000000000}\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the path object.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.delete.html#pyedb.grpc.database.primitive.path.Path.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "Path.delete()\n\nDelete the path object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.parse_file",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "parse_file"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.parse_file",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.parse_file.html#pyedb.workflows.drc.drc.CopperBalance.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod CopperBalance.parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.padstacks_no_name",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.padstacks_no_name.html#padstacks_no_name",
        "title": "padstacks_no_name",
        "section": "padstacks_no_name",
        "text": "Find and fix padstacks without aedt_name.\npadstacks_no_name"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.padstacks_no_name",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.padstacks_no_name.html#pyedb.dotnet.database.layout_validation.LayoutValidation.padstacks_no_name",
        "title": "padstacks_no_name > padstacks_no_name > padstacks_no_name",
        "section": "padstacks_no_name > padstacks_no_name",
        "text": "LayoutValidation.padstacks_no_name(fix=False)\n\nFind and fix padstacks without aedt_name.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSetup.add_mesh_operation",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSetup.add_mesh_operation.html#add_mesh_operation",
        "title": "add_mesh_operation",
        "section": "add_mesh_operation",
        "text": "Add a mesh operation.\nOperation name.\nRegion name.\nOperation type (“MeshOperationLength” or “MeshOperationSkinDepth”).\nDictionary of nets and layers.\nCreated mesh operation object.\nadd_mesh_operation\npython:str\npython:str\npython:str\npython:dict\nControlFileMeshOp"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSetup.add_mesh_operation",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSetup.add_mesh_operation.html#pyedb.grpc.database.control_file.ControlFileSetup.add_mesh_operation",
        "title": "add_mesh_operation > add_mesh_operation > add_mesh_operation",
        "section": "add_mesh_operation > add_mesh_operation",
        "text": "ControlFileSetup.add_mesh_operation(name: str, region: str, type: str, nets_layers: Dict[str, str]) -> ControlFileMeshOp\n\nAdd a mesh operation.\n\nParameters\n\nname\n\npython:str\n\nOperation name.\n\nregion\n\npython:str\n\nRegion name.\n\ntype\n\npython:str\n\nOperation type (“MeshOperationLength” or “MeshOperationSkinDepth”).\n\nnets_layers\n\npython:dict\n\nDictionary of nets and layers.\n\nReturns\n\nControlFileMeshOp\n\nCreated mesh operation object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.set_product_property.html#pyedb.grpc.database.hierarchy.pingroup.PinGroup.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "PinGroup.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.set_product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.set_product_solver_option.html#set_product_solver_option",
        "title": "set_product_solver_option",
        "section": "set_product_solver_option",
        "text": "Set the product solver option.\nID of the product.\nName of the solver.\nName of the product solver option.\nset_product_solver_option\nProductIdType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.set_product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.set_product_solver_option.html#pyedb.grpc.database.ports.ports.WavePort.set_product_solver_option",
        "title": "set_product_solver_option > set_product_solver_option > set_product_solver_option",
        "section": "set_product_solver_option > set_product_solver_option",
        "text": "WavePort.set_product_solver_option(product_id, solver_name, option)\n\nSet the product solver option.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nsolver_name\n\nobj:str\n\nName of the solver.\n\noption\n\nobj:str\n\nName of the product solver option.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.html#pingroupterminal",
        "title": "PinGroupTerminal",
        "section": "PinGroupTerminal",
        "text": "Manages pin group terminal properties.\nPinGroupTerminal.cast([term_type])\nCast the terminal object to the correct concrete type, fetching the type if necessary.\nPinGroupTerminal.create(layout, name, ...[, ...])\nCreate a pin group terminal.\nPinGroupTerminal.create_3d_comp()\nCreate a 3D composite model from an MCAD file.\nPinGroupTerminal.create_hfss()\nCreate an HFSS model from an MCAD file.\nPinGroupTerminal.create_stride()\nCreate a Stride model from an MCAD file.\nPinGroupTerminal.delete()\nDelete the layout object.\nPinGroupTerminal.find(layout, name)\nFind a terminal by name in a given layout.\nPinGroupTerminal.find_by_id(layout, uid)\nFind a Connectable object by database ID in a given layout.\nPinGroupTerminal.get_product_property(...)\nGet the product property of the layout object for a given product ID and attribute ID.\nPinGroupTerminal.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nPinGroupTerminal.product_solver_names(product_id)\nGet the list of solver names.\nPinGroupTerminal.product_solver_option(...)\nGet the name of the product solver option.\nPinGroupTerminal.set_product_property(...)\nSet the product property of the layout object for a given product ID and attribute ID.\nPinGroupTerminal.set_product_solver_option(...)\nSet the product solver option.\nPinGroupTerminal.layout_obj_type\n\nPinGroupTerminal.type\n\nPinGroupTerminal\nPinGroupTerminal.cast\nPinGroupTerminal.create\nPinGroupTerminal.create_3d_comp\nPinGroupTerminal.create_hfss\nPinGroupTerminal.create_stride\nPinGroupTerminal.delete\nPinGroupTerminal.find\nPinGroupTerminal.find_by_id\nPinGroupTerminal.get_product_property\nPinGroupTerminal.get_product_property_ids\nPinGroupTerminal.product_solver_names\nPinGroupTerminal.product_solver_option\nPinGroupTerminal.set_product_property\nPinGroupTerminal.set_product_solver_option\nPinGroupTerminal.layout_obj_type\nPinGroupTerminal.type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.html#pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal",
        "title": "PinGroupTerminal > PinGroupTerminal > PinGroupTerminal",
        "section": "PinGroupTerminal > PinGroupTerminal",
        "text": "class pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal(pedb, edb_object)\n\nManages pin group terminal properties.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nPinGroupTerminal.cast([term_type])\n\nCast the terminal object to the correct concrete type, fetching the type if necessary.\n\nPinGroupTerminal.create(layout, name, ...[, ...])\n\nCreate a pin group terminal.\n\nPinGroupTerminal.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nPinGroupTerminal.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nPinGroupTerminal.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nPinGroupTerminal.delete()\n\nDelete the layout object.\n\nPinGroupTerminal.find(layout, name)\n\nFind a terminal by name in a given layout.\n\nPinGroupTerminal.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nPinGroupTerminal.get_product_property(...)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nPinGroupTerminal.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nPinGroupTerminal.product_solver_names(product_id)\n\nGet the list of solver names.\n\nPinGroupTerminal.product_solver_option(...)\n\nGet the name of the product solver option.\n\nPinGroupTerminal.set_product_property(...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nPinGroupTerminal.set_product_solver_option(...)\n\nSet the product solver option.\n\n\n\nAttributes\n\n\n\n\n\n\n\nPinGroupTerminal.layout_obj_type\n\n\n\nPinGroupTerminal.type\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create_hfss.html#create_hfss",
        "title": "create_hfss",
        "section": "create_hfss",
        "text": "Create an HFSS model from an MCAD file.\nHFSS model created.\ncreate_hfss\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create_hfss.html#pyedb.grpc.database.primitive.path.Path.create_hfss",
        "title": "create_hfss > create_hfss > create_hfss",
        "section": "create_hfss > create_hfss",
        "text": "Path.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nReturns\n\nMcadModel\n\nHFSS model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.unite",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.unite.html#unite",
        "title": "unite",
        "section": "unite",
        "text": "Unite active primitive with one or more primitives.\nList of Primitive objects.\nunite\nPrimitives\nList\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.unite",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.unite.html#pyedb.grpc.database.primitive.path.Path.unite",
        "title": "unite > unite > unite",
        "section": "unite > unite",
        "text": "Path.unite(primitives) -> list[any]\n\nUnite active primitive with one or more primitives.\n\nParameters\n\nprimitives\n\nPrimitives\n\n\n\nor: List[:class:`Primitives <pyedb.grpc.database.primitive.primitive.Primitive>`]\n\n\n\nor: class:`PolygonData <ansys.edb.core.geometry.polygon_data.PolygonData>`\n\n\n\nReturns\n\nList[Primitive]\n\nList of Primitive objects.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_connected_object_id_set",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_connected_object_id_set.html#get_connected_object_id_set",
        "title": "get_connected_object_id_set",
        "section": "get_connected_object_id_set",
        "text": "Produce a list of all geometries physically connected to a given layout object.\nFound connected objects IDs with Layout object.\nget_connected_object_id_set\nList\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_connected_object_id_set",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_connected_object_id_set.html#pyedb.grpc.database.primitive.circle.Circle.get_connected_object_id_set",
        "title": "get_connected_object_id_set > get_connected_object_id_set > get_connected_object_id_set",
        "section": "get_connected_object_id_set > get_connected_object_id_set",
        "text": "Circle.get_connected_object_id_set() -> list[int]\n\nProduce a list of all geometries physically connected to a given layout object.\n\nReturns\n\nList[python:int]\n\nFound connected objects IDs with Layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/rf_basic",
        "href": "libraries/rf_basic.html#rf-basic-libraries",
        "title": "RF Basic Libraries",
        "section": "RF Basic Libraries",
        "text": "These class is the containers of RF basic libraries.\nHatchGround\nCreate a square demo board whose ground layer is made of an orthogonal hatched copper pattern.\nMeander\nFully-parametric micro-strip meander line.\nMIMCapacitor\nMetal–Insulator–Metal parallel-plate capacitor.\nSpiralInductor\nSquare spiral inductor with an optional under-pass bridge.\nCPW\nCoplanar waveguide with side ground planes.\nRadialStub\nRadial (fan) open stub for RF matching.\nRatRace\n180° rat-race (ring) hybrid coupler.\nInterdigitalCapacitor\nInter-digitated comb capacitor with fully parametric fingers.\nDifferentialTLine\nEdge-coupled differential pair with fully parametric geometry.\nRF Basic Libraries\nHatchGround\nMeander\nMIMCapacitor\nSpiralInductor\nCPW\nRadialStub\nRatRace\nInterdigitalCapacitor\nDifferentialTLine"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.load",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.load.html#load",
        "title": "load",
        "section": "load",
        "text": "Import stackup from a file.\nSupported formats: XML, CSV, JSON.\nPath to stackup file or dictionary with stackup details.\nIf False, layers in layout not found in the stackup file are deleted.\nIf True and the number of layers in the stackup file equals the number of stackup layers\nin the layout, layers are renamed according to the file.\nTrue when successful.\nload\npython:str\npython:dict\noptional\nFalse\nTrue\nTrue"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.load",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.load.html#pyedb.grpc.database.stackup.Stackup.load",
        "title": "load > load > load",
        "section": "load > load",
        "text": "Stackup.load(file_path: str | Dict, rename: bool = False) -> bool\n\nImport stackup from a file.\n\nSupported formats: XML, CSV, JSON.\n\nParameters\n\nfile_path\n\npython:str or python:dict\n\nPath to stackup file or dictionary with stackup details.\n\nrename\n\nbool, optional\n\nIf False, layers in layout not found in the stackup file are deleted.\nIf True and the number of layers in the stackup file equals the number of stackup layers\nin the layout, layers are renamed according to the file.\n\nReturns\n\nbool\n\nTrue when successful.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> edb.stackup.load(\"stackup.xml\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.find_by_id.html#find_by_id",
        "title": "find_by_id",
        "section": "find_by_id",
        "text": "Find a Connectable object by database ID in a given layout.\nLayout to search for the Connectable object.\nDatabase ID.\nConnectable object with the given database ID.\nfind_by_id\nLayout\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.find_by_id.html#pyedb.grpc.database.ports.ports.BundleWavePort.find_by_id",
        "title": "find_by_id > find_by_id > find_by_id",
        "section": "find_by_id > find_by_id",
        "text": "classmethod BundleWavePort.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the Connectable object.\n\nuid\n\npython:int\n\nDatabase ID.\n\nReturns\n\nConnectable\n\nConnectable object with the given database ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.html#polygon",
        "title": "Polygon",
        "section": "Polygon",
        "text": "Polygon.add_void(polygon)\nAdd a void to the primitive.\nPolygon.area([include_voids])\nReturn the total area.\nPolygon.cast()\nCast the primitive object to the correct concrete type.\nPolygon.clone()\nDuplicate polygon.\nPolygon.convert_to_polygon()\nConvert path to polygon.\nPolygon.create([layout, layer, net, ...])\nCreate a polygon in the specified layout, layer, and net using the provided polygon data.\nPolygon.create_3d_comp()\nCreate a 3D composite model from an MCAD file.\nPolygon.create_hfss()\nCreate an HFSS model from an MCAD file.\nPolygon.create_stride()\nCreate a Stride model from an MCAD file.\nPolygon.delete()\nDelete polygon from layout.\nPolygon.duplicate_across_layers(layers)\nDuplicate across layer a primitive object.\nPolygon.expand([offset, tolerance, ...])\nExpand the polygon shape by an absolute value in all direction.\nPolygon.find_by_id(layout, uid)\nFind a Connectable object by database ID in a given layout.\nPolygon.fix_self_intersections()\nRemove self intersections if they exist.\nPolygon.get_closest_arc_midpoint(point)\nGet the closest arc midpoint of the primitive to the input data.\nPolygon.get_closest_point(point)\nGet the closest point of the primitive to the input data.\nPolygon.get_connected_object_id_set()\nProduce a list of all geometries physically connected to a given layout object.\nPolygon.get_connected_objects()\nGet connected objects.\nPolygon.get_hfss_prop()\nGet HFSS properties.\nPolygon.get_product_property(prod_id, attr_id)\nGet the product property of the layout object for a given product ID and attribute ID.\nPolygon.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nPolygon.in_polygon(point_data[, include_partial])\nCheck if padstack Instance is in given polygon data.\nPolygon.intersect(primitives)\nIntersect active primitive with one or more primitives.\nPolygon.intersection_type(primitive)\nGet intersection type between actual primitive and another primitive or polygon data.\nPolygon.is_intersecting(primitive)\nCheck if actual primitive and another primitive or polygon data intesects.\nPolygon.make_zone_primitive(zone_id)\nMake the primitive a zone primitive with a zone specified by the provided ID.\nPolygon.move(vector)\nMove polygon along a vector.\nPolygon.move_layer(layer)\nMove polygon to given layer.\nPolygon.plot([plot_net, show, save_plot])\nPlot the current polygon on matplotlib.\nPolygon.points([arc_segments])\nReturn the list of points with arcs converted to segments.\nPolygon.remove_hfss_prop()\nRemove HFSS properties.\nPolygon.rotate(angle[, center])\nRotate polygon around a center point by an angle.\nPolygon.scale(factor[, center])\nScales the polygon relative to a center point by a factor.\nPolygon.set_hfss_prop(material, solve_inside)\nSet HFSS properties.\nPolygon.set_product_property(prod_id, ...)\nSet the product property of the layout object for a given product ID and attribute ID.\nPolygon.subtract(primitives)\nSubtract active primitive with one or more primitives.\nPolygon.unite(primitives)\nUnite active primitive with one or more primitives.\nPolygon.layout_obj_type\nLayoutObjType: Layout object type of the Primitive class.\nPolygon\nPolygon.add_void\nPolygon.area\nPolygon.cast\nPolygon.clone\nPolygon.convert_to_polygon\nPolygon.create\nPolygon.create_3d_comp\nPolygon.create_hfss\nPolygon.create_stride\nPolygon.delete\nPolygon.duplicate_across_layers\nPolygon.expand\nPolygon.find_by_id\nPolygon.fix_self_intersections\nPolygon.get_closest_arc_midpoint\nPolygon.get_closest_point\nPolygon.get_connected_object_id_set\nPolygon.get_connected_objects\nPolygon.get_hfss_prop\nPolygon.get_product_property\nPolygon.get_product_property_ids\nPolygon.in_polygon\nPolygon.intersect\nPolygon.intersection_type\nPolygon.is_intersecting\nPolygon.make_zone_primitive\nPolygon.move\nPolygon.move_layer\nPolygon.plot\nPolygon.points\nPolygon.remove_hfss_prop\nPolygon.rotate\nPolygon.scale\nPolygon.set_hfss_prop\nPolygon.set_product_property\nPolygon.subtract\nPolygon.unite\nPolygon.layout_obj_type\nLayoutObjType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.html#pyedb.grpc.database.primitive.polygon.Polygon",
        "title": "Polygon > Polygon > Polygon",
        "section": "Polygon > Polygon",
        "text": "class pyedb.grpc.database.primitive.polygon.Polygon(pedb, edb_object=None)\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nPolygon.add_void(polygon)\n\nAdd a void to the primitive.\n\nPolygon.area([include_voids])\n\nReturn the total area.\n\nPolygon.cast()\n\nCast the primitive object to the correct concrete type.\n\nPolygon.clone()\n\nDuplicate polygon.\n\nPolygon.convert_to_polygon()\n\nConvert path to polygon.\n\nPolygon.create([layout, layer, net, ...])\n\nCreate a polygon in the specified layout, layer, and net using the provided polygon data.\n\nPolygon.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nPolygon.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nPolygon.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nPolygon.delete()\n\nDelete polygon from layout.\n\nPolygon.duplicate_across_layers(layers)\n\nDuplicate across layer a primitive object.\n\nPolygon.expand([offset, tolerance, ...])\n\nExpand the polygon shape by an absolute value in all direction.\n\nPolygon.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nPolygon.fix_self_intersections()\n\nRemove self intersections if they exist.\n\nPolygon.get_closest_arc_midpoint(point)\n\nGet the closest arc midpoint of the primitive to the input data.\n\nPolygon.get_closest_point(point)\n\nGet the closest point of the primitive to the input data.\n\nPolygon.get_connected_object_id_set()\n\nProduce a list of all geometries physically connected to a given layout object.\n\nPolygon.get_connected_objects()\n\nGet connected objects.\n\nPolygon.get_hfss_prop()\n\nGet HFSS properties.\n\nPolygon.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nPolygon.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nPolygon.in_polygon(point_data[, include_partial])\n\nCheck if padstack Instance is in given polygon data.\n\nPolygon.intersect(primitives)\n\nIntersect active primitive with one or more primitives.\n\nPolygon.intersection_type(primitive)\n\nGet intersection type between actual primitive and another primitive or polygon data.\n\nPolygon.is_intersecting(primitive)\n\nCheck if actual primitive and another primitive or polygon data intesects.\n\nPolygon.make_zone_primitive(zone_id)\n\nMake the primitive a zone primitive with a zone specified by the provided ID.\n\nPolygon.move(vector)\n\nMove polygon along a vector.\n\nPolygon.move_layer(layer)\n\nMove polygon to given layer.\n\nPolygon.plot([plot_net, show, save_plot])\n\nPlot the current polygon on matplotlib.\n\nPolygon.points([arc_segments])\n\nReturn the list of points with arcs converted to segments.\n\nPolygon.remove_hfss_prop()\n\nRemove HFSS properties.\n\nPolygon.rotate(angle[, center])\n\nRotate polygon around a center point by an angle.\n\nPolygon.scale(factor[, center])\n\nScales the polygon relative to a center point by a factor.\n\nPolygon.set_hfss_prop(material, solve_inside)\n\nSet HFSS properties.\n\nPolygon.set_product_property(prod_id, ...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nPolygon.subtract(primitives)\n\nSubtract active primitive with one or more primitives.\n\nPolygon.unite(primitives)\n\nUnite active primitive with one or more primitives.\n\n\n\nAttributes\n\n\n\n\n\n\n\nPolygon.layout_obj_type\n\nLayoutObjType: Layout object type of the Primitive class.\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.material_property_to_id",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.material_property_to_id.html#material_property_to_id",
        "title": "material_property_to_id",
        "section": "material_property_to_id",
        "text": "Convert a material property name to a material property ID.\nName of the material property.\nmaterial_property_to_id\npython:str\nAny"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.material_property_to_id",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.material_property_to_id.html#pyedb.dotnet.database.materials.Materials.material_property_to_id",
        "title": "material_property_to_id > material_property_to_id > material_property_to_id",
        "section": "material_property_to_id > material_property_to_id",
        "text": "Materials.material_property_to_id(property_name)\n\nConvert a material property name to a material property ID.\n\nParameters\n\nproperty_name\n\npython:str\n\nName of the material property.\n\nReturns\n\nAny\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_differential_wave_port",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_differential_wave_port.html#create_differential_wave_port",
        "title": "create_differential_wave_port",
        "section": "create_differential_wave_port",
        "text": "Create a differential wave port.\nPrimitive ID of the positive terminal.\nCoordinate of the point to define the edge terminal.\nThe point must be close to the target edge but not on the two\nends of the edge.\nPrimitive ID of the negative terminal.\nCoordinate of the point to define the edge terminal.\nThe point must be close to the target edge but not on the two\nends of the edge.\nName of the port. The default is None.\nHorizontal extent factor. The default value is 5.\nVertical extent factor. The default value is 3.\nLaunch Width of PEC. The default value is \"0.01mm\".\nThe tuple contains: (port_name, pyedb.dotnet.database.edb_data.sources.ExcitationDifferential).\ncreate_differential_wave_port\npython:int\nEDBPrimitives\npython:list\npython:int\nEDBPrimitives\npython:list\npython:str\noptional\nNone\npython:int\npython:float\noptional\n5\npython:int\npython:float\noptional\n3\npython:str\noptional\n\"0.01mm\"\npython:tuple"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_differential_wave_port",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_differential_wave_port.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_differential_wave_port",
        "title": "create_differential_wave_port > create_differential_wave_port > create_differential_wave_port",
        "section": "create_differential_wave_port > create_differential_wave_port",
        "text": "SourceExcitation.create_differential_wave_port(positive_primitive_id: int | Primitive, positive_points_on_edge: List[float], negative_primitive_id: int | Primitive, negative_points_on_edge: List[float], port_name: str | None = None, horizontal_extent_factor: int | float = 5, vertical_extent_factor: int | float = 3, pec_launch_width: str = '0.01mm') -> Tuple[str, BundleTerminal]\n\nCreate a differential wave port.\n\nParameters\n\npositive_primitive_id\n\npython:int, EDBPrimitives\n\nPrimitive ID of the positive terminal.\n\npositive_points_on_edge\n\npython:list\n\nCoordinate of the point to define the edge terminal.\nThe point must be close to the target edge but not on the two\nends of the edge.\n\nnegative_primitive_id\n\npython:int, EDBPrimitives\n\nPrimitive ID of the negative terminal.\n\nnegative_points_on_edge\n\npython:list\n\nCoordinate of the point to define the edge terminal.\nThe point must be close to the target edge but not on the two\nends of the edge.\n\nport_name\n\npython:str, optional\n\nName of the port. The default is None.\n\nhorizontal_extent_factor\n\npython:int, python:float, optional\n\nHorizontal extent factor. The default value is 5.\n\nvertical_extent_factor\n\npython:int, python:float, optional\n\nVertical extent factor. The default value is 3.\n\npec_launch_width\n\npython:str, optional\n\nLaunch Width of PEC. The default value is \"0.01mm\".\n\nReturns\n\npython:tuple\n\nThe tuple contains: (port_name, pyedb.dotnet.database.edb_data.sources.ExcitationDifferential).\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> port_name, port = edb.source_excitation.create_differential_wave_port(0, [0, 0], 1, [0, 0.2])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "construct"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.construct.html#pyedb.workflows.drc.drc.DiffPair.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod DiffPair.construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sim_setup_info.SimSetupInfo.add_sweep_data",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sim_setup_info.SimSetupInfo.add_sweep_data.html#add_sweep_data",
        "title": "add_sweep_data",
        "section": "add_sweep_data",
        "text": "add_sweep_data"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sim_setup_info.SimSetupInfo.add_sweep_data",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sim_setup_info.SimSetupInfo.add_sweep_data.html#pyedb.dotnet.database.sim_setup_data.data.sim_setup_info.SimSetupInfo.add_sweep_data",
        "title": "add_sweep_data > add_sweep_data > add_sweep_data",
        "section": "add_sweep_data > add_sweep_data",
        "text": "SimSetupInfo.add_sweep_data(sweep_data)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.dict",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "dict"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.dict",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.dict.html#pyedb.workflows.drc.drc.BackDrillStubLength.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "BackDrillStubLength.dict(*, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Dict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.netlist_model.NetlistModel.clone",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.netlist_model.NetlistModel.clone.html#clone",
        "title": "clone",
        "section": "clone",
        "text": "Clone a model.\nclone\nModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.netlist_model.NetlistModel.clone",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.netlist_model.NetlistModel.clone.html#pyedb.grpc.database.hierarchy.netlist_model.NetlistModel.clone",
        "title": "clone > clone > clone",
        "section": "clone > clone",
        "text": "NetlistModel.clone()\n\nClone a model.\n\nReturns\n\nModel cloned.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.read_syslib_material",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.read_syslib_material.html#read_syslib_material",
        "title": "read_syslib_material",
        "section": "read_syslib_material",
        "text": "Read a specific material from syslib AMAT file.\nName of the material.\n{material name: dict of material properties}.\nread_syslib_material\npython:str\npython:dict"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.read_syslib_material",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.read_syslib_material.html#pyedb.dotnet.database.materials.Materials.read_syslib_material",
        "title": "read_syslib_material > read_syslib_material > read_syslib_material",
        "section": "read_syslib_material > read_syslib_material",
        "text": "Materials.read_syslib_material(material_name)\n\nRead a specific material from syslib AMAT file.\n\nParameters\n\nmaterial_name\n\npython:str\n\nName of the material.\n\nReturns\n\npython:dict\n\n{material name: dict of material properties}.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.save_edb",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.save_edb.html#save_edb",
        "title": "save_edb",
        "section": "save_edb",
        "text": "Save current EDB database.\nUse save() instead.\nsave_edb\nsave()"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.save_edb",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.save_edb.html#pyedb.grpc.edb.Edb.save_edb",
        "title": "save_edb > save_edb > save_edb",
        "section": "save_edb > save_edb",
        "text": "Edb.save_edb() -> bool\n\nSave current EDB database.\n\n..deprecated:: 0.51.0\n\nUse save() instead.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_pin_group",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_pin_group.html#create_pin_group",
        "title": "create_pin_group",
        "section": "create_pin_group",
        "text": "Create pin group.\nPin group name.\nList of pin IDs.\nList of pin AEDT names.\nList of pin names.\nPinGroup object if created, False otherwise.\ncreate_pin_group\npython:str\npython:list\noptional\npython:list\noptional\npython:list\noptional\npyedb.dotnet.database.siwave.pin_group.PinGroup"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_pin_group",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_pin_group.html#pyedb.grpc.database.modeler.Modeler.create_pin_group",
        "title": "create_pin_group > create_pin_group > create_pin_group",
        "section": "create_pin_group > create_pin_group",
        "text": "Modeler.create_pin_group(name: str, pins_by_id: List[int] | None = None, pins_by_aedt_name: List[str] | None = None, pins_by_name: List[str] | None = None) -> bool\n\nCreate pin group.\n\nParameters\n\nname\n\npython:str\n\nPin group name.\n\npins_by_id\n\npython:list, optional\n\nList of pin IDs.\n\npins_by_aedt_name\n\npython:list, optional\n\nList of pin AEDT names.\n\npins_by_name\n\npython:list, optional\n\nList of pin names.\n\nReturns\n\npyedb.dotnet.database.siwave.pin_group.PinGroup or bool\n\nPinGroup object if created, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.assign_s_param_model",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.assign_s_param_model.html#assign_s_param_model",
        "title": "assign_s_param_model",
        "section": "assign_s_param_model",
        "text": "Assign S-parameter to all components under this part name.\nFile path of the S-parameter model.\nName of the S-parameter model.\nName of the reference net.\nassign_s_param_model\npython:str\npython:str\noptional\npython:str\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.assign_s_param_model",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.assign_s_param_model.html#pyedb.grpc.database.definition.component_def.ComponentDef.assign_s_param_model",
        "title": "assign_s_param_model > assign_s_param_model > assign_s_param_model",
        "section": "assign_s_param_model > assign_s_param_model",
        "text": "ComponentDef.assign_s_param_model(file_path, model_name=None, reference_net=None) -> bool\n\nAssign S-parameter to all components under this part name.\n\nParameters\n\nfile_path\n\npython:str\n\nFile path of the S-parameter model.\n\nmodel_name\n\npython:str, optional\n\nName of the S-parameter model.\n\nreference_net\n\npython:str, optional\n\nName of the reference net.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_computed_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_computed_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_computed_fields.html#pyedb.workflows.drc.drc.CopperBalance.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "CopperBalance.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.add_pins",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.add_pins.html#add_pins",
        "title": "add_pins",
        "section": "add_pins",
        "text": "Add a list of padstack instances to the group.\nList of padstick instances.\nadd_pins\npython:list\nPadstackInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.add_pins",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.add_pins.html#pyedb.grpc.database.hierarchy.pingroup.PinGroup.add_pins",
        "title": "add_pins > add_pins > add_pins",
        "section": "add_pins > add_pins",
        "text": "PinGroup.add_pins(pins)\n\nAdd a list of padstack instances to the group.\n\nParameters\n\npins\n\npython:list[PadstackInstance]\n\nList of padstick instances.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_ccw",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_ccw.html#is_ccw",
        "title": "is_ccw",
        "section": "is_ccw",
        "text": "Determine if the arc rotates counter-clockwise.\nTrue when the arc rotates counter-clockwise, False otherwise.\nis_ccw\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_ccw",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_ccw.html#pyedb.grpc.database.geometry.arc_data.ArcData.is_ccw",
        "title": "is_ccw > is_ccw > is_ccw",
        "section": "is_ccw > is_ccw",
        "text": "ArcData.is_ccw() -> bool\n\nDetermine if the arc rotates counter-clockwise.\n\nReturns\n\nbool\n\nTrue when the arc rotates counter-clockwise, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.copy_cells",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.copy_cells.html#copy_cells",
        "title": "copy_cells",
        "section": "copy_cells",
        "text": "Copy Cells from other Databases or this Database into this Database.\nCells to copy.\ncopy_cells\npython:list\nCell\npython:list\nCell"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.copy_cells",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.copy_cells.html#pyedb.grpc.edb.Edb.copy_cells",
        "title": "copy_cells > copy_cells > copy_cells",
        "section": "copy_cells > copy_cells",
        "text": "Edb.copy_cells(cells_to_copy)\n\nCopy Cells from other Databases or this Database into this Database.\n\nParameters\n\ncells_to_copy\n\npython:list[Cell]\n\nCells to copy.\n\nReturns\n\npython:list[Cell]\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.delete",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Edb Dotnet Api Database Edb.Net.Delete.\ndelete"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.delete",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.delete.html#pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "EDBNetsData.delete()\n\nEdb Dotnet Api Database Edb.Net.Delete.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_polygon_points",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_polygon_points.html#get_polygon_points",
        "title": "get_polygon_points",
        "section": "get_polygon_points",
        "text": "Get points defining a polygon.\nPolygon primitive.\nList of point coordinates.\nget_polygon_points\npyedb.dotnet.database.edb_data.primitives_data.Primitive\npython:list"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_polygon_points",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_polygon_points.html#pyedb.grpc.database.modeler.Modeler.get_polygon_points",
        "title": "get_polygon_points > get_polygon_points > get_polygon_points",
        "section": "get_polygon_points > get_polygon_points",
        "text": "static Modeler.get_polygon_points(polygon) -> List[List[float]]\n\nGet points defining a polygon.\n\nParameters\n\npolygon\n\npyedb.dotnet.database.edb_data.primitives_data.Primitive\n\nPolygon primitive.\n\nReturns\n\npython:list\n\nList of point coordinates.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.find_by_name",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.find_by_name.html#find_by_name",
        "title": "find_by_name",
        "section": "find_by_name",
        "text": "Find a net by name in a given layout.\nLayout to search for the net.\nName of net.\nNet found. Check the is_null property\nof the returned net to see if it exists.\nfind_by_name\nLayout\npython:str\nNet\nis_null"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.find_by_name",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.find_by_name.html#pyedb.grpc.database.net.net.Net.find_by_name",
        "title": "find_by_name > find_by_name > find_by_name",
        "section": "find_by_name > find_by_name",
        "text": "classmethod Net.find_by_name(layout, name)\n\nFind a net by name in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the net.\n\nname\n\npython:str\n\nName of net.\n\nReturns\n\nNet\n\nNet found. Check the is_null property\nof the returned net to see if it exists.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "construct"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.construct.html#pyedb.workflows.drc.drc.BackDrillStubLength.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod BackDrillStubLength.construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_dielectric_material",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_dielectric_material.html#add_dielectric_material",
        "title": "add_dielectric_material",
        "section": "add_dielectric_material",
        "text": "Add a new dielectric material in library.\nName of the new material.\nPermittivity of the new material.\nDielectric loss tangent of the new material.\nadd_dielectric_material\npython:str\npython:str\npython:float\npython:int\noptional\npython:str\npython:float\npython:int\noptional\npyedb.dotnet.database.materials.Material"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_dielectric_material",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_dielectric_material.html#pyedb.dotnet.database.materials.Materials.add_dielectric_material",
        "title": "add_dielectric_material > add_dielectric_material > add_dielectric_material",
        "section": "add_dielectric_material > add_dielectric_material",
        "text": "Materials.add_dielectric_material(name, permittivity, dielectric_loss_tangent, **kwargs)\n\nAdd a new dielectric material in library.\n\nParameters\n\nname\n\npython:str\n\nName of the new material.\n\npermittivity\n\npython:str, python:float, python:int, optional\n\nPermittivity of the new material.\n\ndielectric_loss_tangent\n\npython:str, python:float, python:int, optional\n\nDielectric loss tangent of the new material.\n\nReturns\n\npyedb.dotnet.database.materials.Material\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.as_integer_ratio",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.as_integer_ratio.html#as_integer_ratio",
        "title": "as_integer_ratio",
        "section": "as_integer_ratio",
        "text": "Return integer ratio.\nReturn a pair of integers, whose ratio is exactly equal to the original float\nand with a positive denominator.\nRaise OverflowError on infinities and a ValueError on NaNs.\nas_integer_ratio"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.as_integer_ratio",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.as_integer_ratio.html#pyedb.grpc.database.utility.value.Value.as_integer_ratio",
        "title": "as_integer_ratio > as_integer_ratio > as_integer_ratio",
        "section": "as_integer_ratio > as_integer_ratio",
        "text": "Value.as_integer_ratio(/)\n\nReturn integer ratio.\n\nReturn a pair of integers, whose ratio is exactly equal to the original float\nand with a positive denominator.\n\nRaise OverflowError on infinities and a ValueError on NaNs.\n\n>>> (10.0).as_integer_ratio()\n(10, 1)\n>>> (0.0).as_integer_ratio()\n(0, 1)\n>>> (-.25).as_integer_ratio()\n(-1, 4)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_vlctech_stackup",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_vlctech_stackup.html#import_vlctech_stackup",
        "title": "import_vlctech_stackup",
        "section": "import_vlctech_stackup",
        "text": "Import a vlc.tech file and generate an edb.def file in the working directory containing only the stackup.\nFull path to the technology stackup file. It must be vlc.tech.\nDirectory in which to create the aedb folder. The name given to the AEDB file\nis the same as the name of the board file.\nExport technology file in XML control file format.\nimport_vlctech_stackup\nedb.def\npython:str\npython:str\noptional\naedb\npython:str\noptional\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_vlctech_stackup",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_vlctech_stackup.html#pyedb.grpc.edb.Edb.import_vlctech_stackup",
        "title": "import_vlctech_stackup > import_vlctech_stackup > import_vlctech_stackup",
        "section": "import_vlctech_stackup > import_vlctech_stackup",
        "text": "Edb.import_vlctech_stackup(vlctech_file, working_dir='', export_xml=None)\n\nImport a vlc.tech file and generate an edb.def file in the working directory containing only the stackup.\n\nParameters\n\nvlctech_file\n\npython:str\n\nFull path to the technology stackup file. It must be vlc.tech.\n\nworking_dir\n\npython:str, optional\n\nDirectory in which to create the aedb folder. The name given to the AEDB file\nis the same as the name of the board file.\n\nexport_xml\n\npython:str, optional\n\nExport technology file in XML control file format.\n\nReturns\n\nFull path to the AEDB file\n\npython:str\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_connected_object_id_set",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_connected_object_id_set.html#get_connected_object_id_set",
        "title": "get_connected_object_id_set",
        "section": "get_connected_object_id_set",
        "text": "Produce a list of all geometries physically connected to a given layout object.\nFound connected objects IDs with Layout object.\nget_connected_object_id_set\nList\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_connected_object_id_set",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_connected_object_id_set.html#pyedb.grpc.database.primitive.primitive.Primitive.get_connected_object_id_set",
        "title": "get_connected_object_id_set > get_connected_object_id_set > get_connected_object_id_set",
        "section": "get_connected_object_id_set > get_connected_object_id_set",
        "text": "Primitive.get_connected_object_id_set() -> list[int]\n\nProduce a list of all geometries physically connected to a given layout object.\n\nReturns\n\nList[python:int]\n\nFound connected objects IDs with Layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.get_powertree",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.get_powertree.html#get_powertree",
        "title": "get_powertree",
        "section": "get_powertree",
        "text": "Retrieve the power tree.\nName of the power net.\nget_powertree\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.get_powertree",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.get_powertree.html#pyedb.dotnet.database.nets.EdbNets.get_powertree",
        "title": "get_powertree > get_powertree > get_powertree",
        "section": "get_powertree > get_powertree",
        "text": "EdbNets.get_powertree(power_net_name, ground_nets)\n\nRetrieve the power tree.\n\nParameters\n\npower_net_name\n\npython:str\n\nName of the power net.\n\nground_nets\n\n\n\nReturns\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.create_symmetric_stackup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.create_symmetric_stackup.html#create_symmetric_stackup",
        "title": "create_symmetric_stackup",
        "section": "create_symmetric_stackup",
        "text": "Create a symmetric stackup.\nNumber of layer count.\nThickness of inner conductor layer.\nThickness of outer conductor layer.\nThickness of dielectric layer.\nMaterial of dielectric layer.\nWhether to create soldermask layers. The default is``True``.\nThickness of soldermask layer.\ncreate_symmetric_stackup\npython:int\npython:str\npython:float\noptional\npython:str\npython:float\noptional\npython:str\npython:float\noptional\npython:str\noptional\noptional\npython:str\noptional"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.create_symmetric_stackup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.create_symmetric_stackup.html#pyedb.dotnet.database.stackup.Stackup.create_symmetric_stackup",
        "title": "create_symmetric_stackup > create_symmetric_stackup > create_symmetric_stackup",
        "section": "create_symmetric_stackup > create_symmetric_stackup",
        "text": "Stackup.create_symmetric_stackup(layer_count, inner_layer_thickness='17um', outer_layer_thickness='50um', dielectric_thickness='100um', dielectric_material='FR4_epoxy', soldermask=True, soldermask_thickness='20um')\n\nCreate a symmetric stackup.\n\nParameters\n\nlayer_count\n\npython:int\n\nNumber of layer count.\n\ninner_layer_thickness\n\npython:str, python:float, optional\n\nThickness of inner conductor layer.\n\nouter_layer_thickness\n\npython:str, python:float, optional\n\nThickness of outer conductor layer.\n\ndielectric_thickness\n\npython:str, python:float, optional\n\nThickness of dielectric layer.\n\ndielectric_material\n\npython:str, optional\n\nMaterial of dielectric layer.\n\nsoldermask\n\nbool, optional\n\nWhether to create soldermask layers. The default is``True``.\n\nsoldermask_thickness\n\npython:str, optional\n\nThickness of soldermask layer.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_product_property_ids.html#pyedb.grpc.database.primitive.bondwire.Bondwire.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "Bondwire.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/bundle_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/bundle_terminal.html#bundle-terminal",
        "title": "Bundle terminal",
        "section": "Bundle terminal",
        "text": "This class is managing EDB bundle terminal.\nBundleTerminal\nManages bundle terminal properties.\nBundle terminal\nBundleTerminal"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_rats",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_rats.html#get_rats",
        "title": "get_rats",
        "section": "get_rats",
        "text": "Retrieve a list of dictionaries of the reference designator, pin names, and net names.\nList of dictionaries of the reference designator, pin names,\nand net names.\nget_rats\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_rats",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_rats.html#pyedb.dotnet.database.components.Components.get_rats",
        "title": "get_rats > get_rats > get_rats",
        "section": "get_rats > get_rats",
        "text": "Components.get_rats()\n\nRetrieve a list of dictionaries of the reference designator, pin names, and net names.\n\nReturns\n\npython:list\n\nList of dictionaries of the reference designator, pin names,\nand net names.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", \"project name\", \"release version\")\n>>> edbapp.components.get_rats()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.merge_nets_polygons",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.merge_nets_polygons.html#merge_nets_polygons",
        "title": "merge_nets_polygons",
        "section": "merge_nets_polygons",
        "text": "Convert paths from net into polygons, evaluate all connected polygons and perform the merge.\nNet name of list of net name.\nTrue when successful, False when failed.\nmerge_nets_polygons\npython:str\npython:list\npython:str\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.merge_nets_polygons",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.merge_nets_polygons.html#pyedb.dotnet.database.nets.EdbNets.merge_nets_polygons",
        "title": "merge_nets_polygons > merge_nets_polygons > merge_nets_polygons",
        "section": "merge_nets_polygons > merge_nets_polygons",
        "text": "EdbNets.merge_nets_polygons(net_names_list)\n\nConvert paths from net into polygons, evaluate all connected polygons and perform the merge.\n\nParameters\n\nnet_names_list\n\npython:str or python:list[python:str]\n\nNet name of list of net name.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.add_net",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.add_net.html#add_net",
        "title": "add_net",
        "section": "add_net",
        "text": "Add a net to the net class.\nadd_net"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.add_net",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.add_net.html#pyedb.grpc.database.net.net_class.NetClass.add_net",
        "title": "add_net > add_net > add_net",
        "section": "add_net > add_net",
        "text": "NetClass.add_net(net)\n\nAdd a net to the net class.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_validate_strings",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj: The object containing string data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nThe validated Pydantic model.\nmodel_validate_strings"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_validate_strings",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_validate_strings.html#pyedb.grpc.database.definition.materials.MaterialProperties.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod MaterialProperties.model_validate_strings(obj: Any, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\nValidate the given object with string data against the Pydantic model.\n\nArgs:\n\nobj: The object containing string data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nReturns:\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create new EDB database.\nTrue if successful, False otherwise.\ncreate"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create.html#pyedb.grpc.edb.Edb.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "Edb.create(restart_rpc_server=False) -> any\n\nCreate new EDB database.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.parse_raw",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "parse_raw"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.parse_raw",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.parse_raw.html#pyedb.workflows.drc.drc.MinClearance.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod MinClearance.parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.html#minlinewidth",
        "title": "MinLineWidth",
        "section": "MinLineWidth",
        "text": "Minimum-line-width rule.\nMinLineWidth.construct([_fields_set])\n\nMinLineWidth.copy(*[, include, exclude, ...])\nReturns a copy of the model.\nMinLineWidth.dict(*[, include, exclude, ...])\n\nMinLineWidth.from_orm(obj)\n\nMinLineWidth.json(*[, include, exclude, ...])\n\nMinLineWidth.model_construct([_fields_set])\nCreates a new instance of the Model class with validated data.\nMinLineWidth.model_copy(*[, update, deep])\n!!! abstract \"Usage Documentation\"\nMinLineWidth.model_dump(*[, mode, include, ...])\n!!! abstract \"Usage Documentation\"\nMinLineWidth.model_dump_json(*[, indent, ...])\n!!! abstract \"Usage Documentation\"\nMinLineWidth.model_json_schema([by_alias, ...])\nGenerates a JSON schema for a model class.\nMinLineWidth.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nMinLineWidth.model_post_init(context, /)\nOverride this method to perform additional initialization after __init__ and model_construct.\nMinLineWidth.model_rebuild(*[, force, ...])\nTry to rebuild the pydantic-core schema for the model.\nMinLineWidth.model_validate(obj, *[, ...])\nValidate a pydantic model instance.\nMinLineWidth.model_validate_json(json_data, *)\n!!! abstract \"Usage Documentation\"\nMinLineWidth.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nMinLineWidth.parse_file(path, *[, ...])\n\nMinLineWidth.parse_obj(obj)\n\nMinLineWidth.parse_raw(b, *[, content_type, ...])\n\nMinLineWidth.schema([by_alias, ref_template])\n\nMinLineWidth.schema_json(*[, by_alias, ...])\n\nMinLineWidth.update_forward_refs(**localns)\n\nMinLineWidth.validate(value)\n\nMinLineWidth.model_computed_fields\n\nMinLineWidth.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nMinLineWidth.model_fields\n\nMinLineWidth.name\nRule identifier (human readable).\nMinLineWidth.value\nMinimum width with unit, e.g. \"3.5mil\".\nMinLineWidth\nMinLineWidth.construct\nMinLineWidth.copy\nMinLineWidth.dict\nMinLineWidth.from_orm\nMinLineWidth.json\nMinLineWidth.model_construct\nMinLineWidth.model_copy\nMinLineWidth.model_dump\nMinLineWidth.model_dump_json\nMinLineWidth.model_json_schema\nMinLineWidth.model_parametrized_name\nMinLineWidth.model_post_init\nMinLineWidth.model_rebuild\nMinLineWidth.model_validate\nMinLineWidth.model_validate_json\nMinLineWidth.model_validate_strings\nMinLineWidth.parse_file\nMinLineWidth.parse_obj\nMinLineWidth.parse_raw\nMinLineWidth.schema\nMinLineWidth.schema_json\nMinLineWidth.update_forward_refs\nMinLineWidth.validate\nMinLineWidth.model_computed_fields\nMinLineWidth.model_config\nMinLineWidth.model_fields\nMinLineWidth.name\nMinLineWidth.value\n\"3.5mil\""
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.html#pyedb.workflows.drc.drc.MinLineWidth",
        "title": "MinLineWidth > MinLineWidth > MinLineWidth",
        "section": "MinLineWidth > MinLineWidth",
        "text": "class pyedb.workflows.drc.drc.MinLineWidth(*, name: str, value: str)\n\nMinimum-line-width rule.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nMinLineWidth.construct([_fields_set])\n\n\n\nMinLineWidth.copy(*[, include, exclude, ...])\n\nReturns a copy of the model.\n\nMinLineWidth.dict(*[, include, exclude, ...])\n\n\n\nMinLineWidth.from_orm(obj)\n\n\n\nMinLineWidth.json(*[, include, exclude, ...])\n\n\n\nMinLineWidth.model_construct([_fields_set])\n\nCreates a new instance of the Model class with validated data.\n\nMinLineWidth.model_copy(*[, update, deep])\n\n!!! abstract \"Usage Documentation\"\n\nMinLineWidth.model_dump(*[, mode, include, ...])\n\n!!! abstract \"Usage Documentation\"\n\nMinLineWidth.model_dump_json(*[, indent, ...])\n\n!!! abstract \"Usage Documentation\"\n\nMinLineWidth.model_json_schema([by_alias, ...])\n\nGenerates a JSON schema for a model class.\n\nMinLineWidth.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nMinLineWidth.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nMinLineWidth.model_rebuild(*[, force, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nMinLineWidth.model_validate(obj, *[, ...])\n\nValidate a pydantic model instance.\n\nMinLineWidth.model_validate_json(json_data, *)\n\n!!! abstract \"Usage Documentation\"\n\nMinLineWidth.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nMinLineWidth.parse_file(path, *[, ...])\n\n\n\nMinLineWidth.parse_obj(obj)\n\n\n\nMinLineWidth.parse_raw(b, *[, content_type, ...])\n\n\n\nMinLineWidth.schema([by_alias, ref_template])\n\n\n\nMinLineWidth.schema_json(*[, by_alias, ...])\n\n\n\nMinLineWidth.update_forward_refs(**localns)\n\n\n\nMinLineWidth.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nMinLineWidth.model_computed_fields\n\n\n\nMinLineWidth.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nMinLineWidth.model_fields\n\n\n\nMinLineWidth.name\n\nRule identifier (human readable).\n\nMinLineWidth.value\n\nMinimum width with unit, e.g. \"3.5mil\".\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.permittivity",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.permittivity.html#permittivity",
        "title": "permittivity",
        "section": "permittivity",
        "text": "permittivity"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.permittivity",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.permittivity.html#pyedb.grpc.database.definition.materials.MaterialProperties.permittivity",
        "title": "permittivity > permittivity > permittivity",
        "section": "permittivity > permittivity",
        "text": "MaterialProperties.permittivity: Annotated[float, Gt(gt=0)] | None\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/settings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/settings.html#hfss-simulation-setup-settings",
        "title": "HFSS simulation setup settings",
        "section": "HFSS simulation setup settings",
        "text": "These classes are the containers of HFSS simulation setup settings.\nAdaptiveSettings\nManages EDB methods for adaptive settings.\nDefeatureSettings\nManages EDB methods for defeature settings.\nAdvancedMeshSettings\nManages EDB methods for advanced mesh settings.\nViaSettings\nManages EDB methods for via settings.\nCurveApproxSettings\nManages EDB methods for curve approximate settings.\nDcrSettings\nManages EDB methods for DCR settings.\nHfssPortSettings\nManages EDB methods for HFSS port settings.\nHfssSolverSettings\nManages EDB methods for HFSS solver settings.\nHFSS simulation setup settings\nAdaptiveSettings\nDefeatureSettings\nAdvancedMeshSettings\nViaSettings\nCurveApproxSettings\nDcrSettings\nHfssPortSettings\nHfssSolverSettings"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_aedt_pin_name",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_aedt_pin_name.html#get_aedt_pin_name",
        "title": "get_aedt_pin_name",
        "section": "get_aedt_pin_name",
        "text": "Retrieve the pin name that is shown in AEDT.\nTo obtain the EDB core pin name, use pin.GetName().\nName of the pin in EDB core.\nName of the pin in AEDT.\nget_aedt_pin_name\npython:str\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_aedt_pin_name",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_aedt_pin_name.html#pyedb.dotnet.database.components.Components.get_aedt_pin_name",
        "title": "get_aedt_pin_name > get_aedt_pin_name > get_aedt_pin_name",
        "section": "get_aedt_pin_name > get_aedt_pin_name",
        "text": "Components.get_aedt_pin_name(pin)\n\nRetrieve the pin name that is shown in AEDT.\n\nTo obtain the EDB core pin name, use pin.GetName().\n\nParameters\n\npin\n\npython:str\n\nName of the pin in EDB core.\n\nReturns\n\npython:str\n\nName of the pin in AEDT.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", \"project name\", \"release version\")\n>>> edbapp.components.get_aedt_pin_name(pin)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_hole_overrides",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_hole_overrides.html#set_hole_overrides",
        "title": "set_hole_overrides",
        "section": "set_hole_overrides",
        "text": "Set the hole overrides of the padstack instance.\nWhether the padstack instance is a hole override.\nHole override diameter of the padstack instance.\nset_hole_overrides"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_hole_overrides",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_hole_overrides.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_hole_overrides",
        "title": "set_hole_overrides > set_hole_overrides > set_hole_overrides",
        "section": "set_hole_overrides > set_hole_overrides",
        "text": "PadstackInstance.set_hole_overrides(is_hole_override: bool, hole_override: ValueLike)\n\nSet the hole overrides of the padstack instance.\n\nParameters\n\nis_hole_override\n\nbool\n\nWhether the padstack instance is a hole override.\n\nhole_override\n\nValueLike\n\nHole override diameter of the padstack instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.update_forward_refs",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "update_forward_refs"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.update_forward_refs",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.update_forward_refs.html#pyedb.workflows.drc.drc.MinLineWidth.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod MinLineWidth.update_forward_refs(**localns: Any) -> None\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_validate_strings",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj: The object containing string data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nThe validated Pydantic model.\nmodel_validate_strings"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_validate_strings",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_validate_strings.html#pyedb.workflows.drc.drc.MinAnnularRing.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod MinAnnularRing.model_validate_strings(obj: Any, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\nValidate the given object with string data against the Pydantic model.\n\nArgs:\n\nobj: The object containing string data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nReturns:\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_backdrill_top",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_backdrill_top.html#set_backdrill_top",
        "title": "set_backdrill_top",
        "section": "set_backdrill_top",
        "text": "Set backdrill from top.\n.deprecated:: 0.55.0\nUse :method:`set_back_drill_by_depth` instead.\nName of the drill to layer.\nDiameter of backdrill size.\noffset with respect to the layer to drill to.\nTrue if success, False otherwise.\nset_backdrill_top\npython:str\npython:float\npython:str\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_backdrill_top",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_backdrill_top.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_backdrill_top",
        "title": "set_backdrill_top > set_backdrill_top > set_backdrill_top",
        "section": "set_backdrill_top > set_backdrill_top",
        "text": "PadstackInstance.set_backdrill_top(drill_depth, drill_diameter, offset=0.0)\n\nSet backdrill from top.\n\n.deprecated:: 0.55.0\nUse :method:`set_back_drill_by_depth` instead.\n\nParameters\n\ndrill_depth\n\npython:str\n\nName of the drill to layer.\n\ndrill_diameter\n\npython:float, python:str\n\nDiameter of backdrill size.\n\noffset\n\npython:str, optional.\n\noffset with respect to the layer to drill to.\n\nReturns\n\nbool\n\nTrue if success, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "LayoutObjType: Layout object type of the Primitive class.\nlayout_obj_type\nLayoutObjType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.layout_obj_type.html#pyedb.grpc.database.primitive.path.Path.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "Path.layout_obj_type = 0\n\nLayoutObjType: Layout object type of the Primitive class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.intersection_type",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.intersection_type.html#intersection_type",
        "title": "intersection_type",
        "section": "intersection_type",
        "text": "Get intersection type between actual primitive and another primitive or polygon data.\nIntersection type:\n0 - objects do not intersect,\n1 - this object fully inside other (no common contour points),\n2 - other object fully inside this,\n3 - common contour points,\n4 - undefined intersection.\nintersection_type\npyaeedt.database.edb_data.primitives_data.EDBPrimitives\npython:int"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.intersection_type",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.intersection_type.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.intersection_type",
        "title": "intersection_type > intersection_type > intersection_type",
        "section": "intersection_type > intersection_type",
        "text": "EdbPolygon.intersection_type(primitive)\n\nGet intersection type between actual primitive and another primitive or polygon data.\n\nParameters\n\nprimitive\n\npyaeedt.database.edb_data.primitives_data.EDBPrimitives or PolygonData\n\n\n\nReturns\n\npython:int\n\nIntersection type:\n0 - objects do not intersect,\n1 - this object fully inside other (no common contour points),\n2 - other object fully inside this,\n3 - common contour points,\n4 - undefined intersection.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.create",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a new component.\nList of pins.\nComponent name.\nPlacement layer name.\nPart name.\nWhether the component is RLC.\nResistance value.\nCapacitance value.\nInductance value.\nWhether RLC is parallel.\nNew component instance if successful, False otherwise.\ncreate\npython:list\npyedb.grpc.database.padstacks.PadstackInstance\npython:str\noptional\npython:str\noptional\npython:str\noptional\noptional\npython:float\noptional\npython:float\noptional\npython:float\noptional\noptional\npyedb.grpc.database.hierarchy.component.Component"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.create",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.create.html#pyedb.grpc.database.components.Components.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "Components.create(pins: List[Any], component_name: str | None = None, placement_layer: str | None = None, component_part_name: str | None = None, is_rlc: bool = False, r_value: float | None = None, c_value: float | None = None, l_value: float | None = None, is_parallel: bool = False) -> Component | bool\n\nCreate a new component.\n\nParameters\n\npins\n\npython:list[pyedb.grpc.database.padstacks.PadstackInstance]\n\nList of pins.\n\ncomponent_name\n\npython:str, optional\n\nComponent name.\n\nplacement_layer\n\npython:str, optional\n\nPlacement layer name.\n\ncomponent_part_name\n\npython:str, optional\n\nPart name.\n\nis_rlc\n\nbool, optional\n\nWhether the component is RLC.\n\nr_value\n\npython:float, optional\n\nResistance value.\n\nc_value\n\npython:float, optional\n\nCapacitance value.\n\nl_value\n\npython:float, optional\n\nInductance value.\n\nis_parallel\n\nbool, optional\n\nWhether RLC is parallel.\n\nReturns\n\npyedb.grpc.database.hierarchy.component.Component or bool\n\nNew component instance if successful, False otherwise.\n\nExamples\n\n>>> new_comp = edbapp.components.create(pins, \"R1\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_multipole_debye_material",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_multipole_debye_material.html#add_multipole_debye_material",
        "title": "add_multipole_debye_material",
        "section": "add_multipole_debye_material",
        "text": "Add a dielectric with the Multipole Debye model.\nName of the dielectric.\nFrequencies in GHz.\nRelative permittivities at each frequency.\nLoss tangents at each frequency.\nadd_multipole_debye_material\npython:str\npython:list\npython:list\npython:list\npyedb.dotnet.database.materials.Material"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_multipole_debye_material",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_multipole_debye_material.html#pyedb.dotnet.database.materials.Materials.add_multipole_debye_material",
        "title": "add_multipole_debye_material > add_multipole_debye_material > add_multipole_debye_material",
        "section": "add_multipole_debye_material > add_multipole_debye_material",
        "text": "Materials.add_multipole_debye_material(name, frequencies, permittivities, loss_tangents, **kwargs)\n\nAdd a dielectric with the Multipole Debye model.\n\nParameters\n\nname\n\npython:str\n\nName of the dielectric.\n\nfrequencies\n\npython:list\n\nFrequencies in GHz.\n\npermittivities\n\npython:list\n\nRelative permittivities at each frequency.\n\nloss_tangents\n\npython:list\n\nLoss tangents at each frequency.\n\nReturns\n\npyedb.dotnet.database.materials.Material\n\n\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> freq = [0, 2, 3, 4, 5, 6]\n>>> rel_perm = [1e9, 1.1e9, 1.2e9, 1.3e9, 1.5e9, 1.6e9]\n>>> loss_tan = [0.025, 0.026, 0.027, 0.028, 0.029, 0.030]\n>>> diel = edb.materials.add_multipole_debye_material(\"My_MP_Debye\", freq, rel_perm, loss_tan)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.utilities.EDBStatistics",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.utilities.EDBStatistics.html#edbstatistics",
        "title": "EDBStatistics",
        "section": "EDBStatistics",
        "text": "Statistics object\nObject properties example.\n>>> stat_model = EDBStatistics()\n>>> stat_model.num_capacitors\n>>> stat_model.num_resistors\n>>> stat_model.num_inductors\n>>> stat_model.layout_size\n>>> stat_model.num_discrete_components\n>>> stat_model.num_inductors\n>>> stat_model.num_resistors\n>>> stat_model.num_capacitors\n>>> stat_model.num_nets\n>>> stat_model.num_traces\n>>> stat_model.num_polygons\n>>> stat_model.num_vias\n>>> stat_model.stackup_thickness\n>>> stat_model.occupying_surface\n>>> stat_model.occupying_ratio\nEDBStatistics"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.utilities.EDBStatistics",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.utilities.EDBStatistics.html#pyedb.dotnet.database.edb_data.utilities.EDBStatistics",
        "title": "EDBStatistics > EDBStatistics > EDBStatistics",
        "section": "EDBStatistics > EDBStatistics",
        "text": "class pyedb.dotnet.database.edb_data.utilities.EDBStatistics\n\nStatistics object\n\nObject properties example.\n>>> stat_model = EDBStatistics()\n>>> stat_model.num_capacitors\n>>> stat_model.num_resistors\n>>> stat_model.num_inductors\n>>> stat_model.layout_size\n>>> stat_model.num_discrete_components\n>>> stat_model.num_inductors\n>>> stat_model.num_resistors\n>>> stat_model.num_capacitors\n>>> stat_model.num_nets\n>>> stat_model.num_traces\n>>> stat_model.num_polygons\n>>> stat_model.num_vias\n>>> stat_model.stackup_thickness\n>>> stat_model.occupying_surface\n>>> stat_model.occupying_ratio\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_post_init",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nmodel_post_init"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_post_init",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_post_init.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "DiffPairLengthMatch.model_post_init(context: Any, /) -> None\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/voltage_regulator",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/voltage_regulator.html#voltage-regulator",
        "title": "Voltage Regulator",
        "section": "Voltage Regulator",
        "text": "This class is managing EDB voltage regulator.\nVoltageRegulator\nClass managing voltage regulator.\nVoltage Regulator\nVoltageRegulator"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_layer",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_layer.html#add_layer",
        "title": "add_layer",
        "section": "add_layer",
        "text": "Insert a layer into stackup.\nName of the layer.\nName of the base layer.\nWhere to insert the new layer. The default is \"add_on_top\". Options are \"add_on_top\",\n\"add_on_bottom\", \"insert_above\", \"insert_below\", \"add_at_elevation\",.\n\"air_lines\", \"error\", \"symbol\", \"measure\", \"assembly\", \"silkscreen\",\n\"solder_mask\", \"solder_paste\", \"glue\", \"wirebond\", \"hfss_region\", \"user\".\nMaterial of the layer.\nFill material of the layer.\nThickness of the layer.\nEtch factor of the layer.\nWhether the layer is negative.\nWhether roughness is enabled.\nElevation of new layer. Only valid for Overlapping Stackup.\nadd_layer\npython:str\npython:str\noptional\npython:str\noptional\n\"add_on_top\"\n\"add_on_top\"\n\"add_on_bottom\"\n\"insert_above\"\n\"insert_below\"\n\"add_at_elevation\"\npython:str\noptional\n\"signal\"\n\"signal\"\n\"dielectric\"\n\"conducting\"\n\"air_lines\"\n\"error\"\n\"symbol\"\n\"measure\"\n\"assembly\"\n\"silkscreen\"\n\"solder_mask\"\n\"solder_paste\"\n\"glue\"\n\"wirebond\"\n\"hfss_region\"\n\"user\"\npython:str\noptional\npython:str\noptional\npython:str\npython:float\noptional\npython:int\npython:float\noptional\noptional\noptional\npython:float\noptional\npyedb.dotnet.database.edb_data.layer_data.LayerEdbClass"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_layer",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_layer.html#pyedb.dotnet.database.stackup.Stackup.add_layer",
        "title": "add_layer > add_layer > add_layer",
        "section": "add_layer > add_layer",
        "text": "Stackup.add_layer(layer_name, base_layer=None, method='add_on_top', layer_type='signal', material='copper', fillMaterial='FR4_epoxy', thickness='35um', etch_factor=None, is_negative=False, enable_roughness=False, elevation=None)\n\nInsert a layer into stackup.\n\nParameters\n\nlayer_name\n\npython:str\n\nName of the layer.\n\nbase_layer\n\npython:str, optional\n\nName of the base layer.\n\nmethod\n\npython:str, optional\n\nWhere to insert the new layer. The default is \"add_on_top\". Options are \"add_on_top\",\n\"add_on_bottom\", \"insert_above\", \"insert_below\", \"add_at_elevation\",.\n\nlayer_type\n\npython:str, optional\n\nType of layer. The default is \"signal\". Options are \"signal\", \"dielectric\", \"conducting\",\n\n\"air_lines\", \"error\", \"symbol\", \"measure\", \"assembly\", \"silkscreen\",\n\"solder_mask\", \"solder_paste\", \"glue\", \"wirebond\", \"hfss_region\", \"user\".\n\nmaterial\n\npython:str, optional\n\nMaterial of the layer.\n\nfillMaterial\n\npython:str, optional\n\nFill material of the layer.\n\nthickness\n\npython:str, python:float, optional\n\nThickness of the layer.\n\netch_factor\n\npython:int, python:float, optional\n\nEtch factor of the layer.\n\nis_negative\n\nbool, optional\n\nWhether the layer is negative.\n\nenable_roughness\n\nbool, optional\n\nWhether roughness is enabled.\n\nelevation\n\npython:float, optional\n\nElevation of new layer. Only valid for Overlapping Stackup.\n\nReturns\n\npyedb.dotnet.database.edb_data.layer_data.LayerEdbClass\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/drc",
        "href": "workflows/drc/drc.html#design-rule-checking-drcself-contained-multi-threaded-engine",
        "title": "Design-rule checking (DRC)–self-contained, multi-threaded engine",
        "section": "Design-rule checking (DRC)–self-contained, multi-threaded engine",
        "text": "”\nSelf-contained DRC engine for PyEDB.\nThis module provides a high-performance, multi-threaded design-rule checker\nthat runs inside an open PyEDB session and validates 50+ industry-standard\nrules (geometry, spacing, manufacturing, high-speed, test).\nThe pyedb.workflows.drc sub-package exposes a lightweight, high-accuracy\ndesign-rule checker (DRC) that runs inside an open PyEDB session.\nIt validates more than 50 industry-standard rules (geometry, spacing,\nmanufacturing, high-speed, test) and exports an IPC-D-356A netlist annotated\nwith violations for CAM hand-off.\nDesign-rule checking (DRC)–self-contained, multi-threaded engine\npyedb.workflows.drc"
    },
    {
        "objectID": "workflows/drc/drc",
        "href": "workflows/drc/drc.html#features",
        "title": "Design-rule checking (DRC)–self-contained, multi-threaded engine > Features",
        "section": "Features",
        "text": "Impedance checks via improved analytical formulas (Wheeler, Cohn, Hammerstad-Jensen).\nCopper-balance by layer or by arbitrary zone polygons.\nBack-drill stub / depth verification.\nR-tree spatial index for fast geometry queries.\nFeatures"
    },
    {
        "objectID": "workflows/drc/drc",
        "href": "workflows/drc/drc.html#examples",
        "title": "Design-rule checking (DRC)–self-contained, multi-threaded engine > Examples",
        "section": "Examples",
        "text": "Examples"
    },
    {
        "objectID": "workflows/drc/drc",
        "href": "workflows/drc/drc.html#features",
        "title": "Design-rule checking (DRC)–self-contained, multi-threaded engine > Features",
        "section": "Features",
        "text": "Impedance checks via improved analytical formulas (Wheeler, Cohn,\nHammerstad–Jensen).\nCopper-balance by layer or by arbitrary zone polygons.\nBack-drill stub/depth verification.\nR-tree spatial index for fast geometry queries.\nThread-safe, multi-threaded rule execution (automatic core detection).\nFluent, type-safe API to build rule decks programmatically.\nJSON/YAML round-trip serialization (via Pydantic).\nFeatures"
    },
    {
        "objectID": "workflows/drc/drc",
        "href": "workflows/drc/drc.html#quick-start",
        "title": "Design-rule checking (DRC)–self-contained, multi-threaded engine > Quick start",
        "section": "Quick start",
        "text": "Quick start"
    },
    {
        "objectID": "workflows/drc/drc",
        "href": "workflows/drc/drc.html#api-reference",
        "title": "Design-rule checking (DRC)–self-contained, multi-threaded engine > API reference",
        "section": "API reference",
        "text": "API reference"
    },
    {
        "objectID": "workflows/drc/drc",
        "href": "workflows/drc/drc.html#rules-container",
        "title": "Design-rule checking (DRC)–self-contained, multi-threaded engine > Rules container",
        "section": "Rules container",
        "text": "Rules\nCentralised, serialisable container for all design-rule categories supported by the PyEDB DRC engine.\nRules.from_dict\nAlias for model_validate.\nRules.to_dict\nAlias for model_dump.\nRules.add_min_line_width\nAppend a minimum-line-width rule.\nRules.add_min_clearance\nAppend a minimum-clearance rule between two nets (wild-cards allowed).\nRules.add_min_annular_ring\nAppend a minimum-annular-ring rule for drilled holes.\nRules.add_diff_pair_length_match\nAppend a length-matching rule for differential pairs.\nRules.add_back_drill_stub_length\nAppend a maximum-allowed back-drill stub-length rule.\nRules.add_copper_balance\nAppend a copper-density balance rule.\nRules container\nRules\nRules.from_dict\nmodel_validate\nRules.to_dict\nmodel_dump\nRules.add_min_line_width\nRules.add_min_clearance\nRules.add_min_annular_ring\nRules.add_diff_pair_length_match\nRules.add_back_drill_stub_length\nRules.add_copper_balance"
    },
    {
        "objectID": "workflows/drc/drc",
        "href": "workflows/drc/drc.html#rule-models",
        "title": "Design-rule checking (DRC)–self-contained, multi-threaded engine > Rule models",
        "section": "Rule models",
        "text": "MinLineWidth\nMinimum-line-width rule.\nMinClearance\nMinimum clearance between two nets.\nMinAnnularRing\nMinimum annular ring for drilled holes.\nDiffPair\nDifferential-pair definition.\nDiffPairLengthMatch\nLength-matching rule for differential pairs.\nBackDrillStubLength\nMaximum allowed back-drill stub length.\nCopperBalance\nCopper-density balance rule.\nRule models\nMinLineWidth\nMinClearance\nMinAnnularRing\nDiffPair\nDiffPairLengthMatch\nBackDrillStubLength\nCopperBalance"
    },
    {
        "objectID": "workflows/drc/drc",
        "href": "workflows/drc/drc.html#drc-engine",
        "title": "Design-rule checking (DRC)–self-contained, multi-threaded engine > DRC engine",
        "section": "DRC engine",
        "text": "Drc\nLightweight, high-accuracy DRC engine that runs inside an open PyEDB session.\nDrc.check\nRun all rules and return a list of violations.\nDrc.to_ipc356a\nWrite a complete IPC-D-356A netlist plus DRC comments for fab review.\nDRC engine\nDrc\nDrc.check\nDrc.to_ipc356a"
    },
    {
        "objectID": "workflows/drc/drc",
        "href": "workflows/drc/drc.html#implementation-notes",
        "title": "Design-rule checking (DRC)–self-contained, multi-threaded engine > Implementation notes",
        "section": "Implementation notes",
        "text": "Implementation notes"
    },
    {
        "objectID": "workflows/drc/drc",
        "href": "workflows/drc/drc.html#thread-safety",
        "title": "Design-rule checking (DRC)–self-contained, multi-threaded engine > Thread safety",
        "section": "Thread safety",
        "text": "All heavy geometry checks are embarrassingly parallel. The engine snapshots\nEDB data into plain Python objects before entering the worker pool, so the\nR-tree index is never accessed concurrently.\nThread safety"
    },
    {
        "objectID": "workflows/drc/drc",
        "href": "workflows/drc/drc.html#extending-the-engine",
        "title": "Design-rule checking (DRC)–self-contained, multi-threaded engine > Extending the engine",
        "section": "Extending the engine",
        "text": "Add a new rule in three steps:\nCreate a Pydantic model inheriting from Pydantic.BaseModel.\nAppend the model to the Rules container and expose a fluent helper.\nImplement _rule_<field_name> inside Drc; accept the rule instance\nand append violations to self.violations.\nExtending the engine\nPydantic.BaseModel\nRules\n_rule_<field_name>\nDrc\nself.violations"
    },
    {
        "objectID": "workflows/drc/drc",
        "href": "workflows/drc/drc.html#examples",
        "title": "Design-rule checking (DRC)–self-contained, multi-threaded engine > Examples",
        "section": "Examples",
        "text": "Examples"
    },
    {
        "objectID": "workflows/drc/drc",
        "href": "workflows/drc/drc.html#load-a-rule-deck-from-json",
        "title": "Design-rule checking (DRC)–self-contained, multi-threaded engine > Load a rule deck from JSON",
        "section": "Load a rule deck from JSON",
        "text": "Load a rule deck from JSON"
    },
    {
        "objectID": "workflows/drc/drc",
        "href": "workflows/drc/drc.html#export-violations-to-csv",
        "title": "Design-rule checking (DRC)–self-contained, multi-threaded engine > Export violations to CSV",
        "section": "Export violations to CSV",
        "text": "Export violations to CSV"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNets.auto_identify_power",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNets.auto_identify_power.html#auto_identify_power",
        "title": "auto_identify_power",
        "section": "auto_identify_power",
        "text": "Get all extended power nets and their associated components.\nThreshold for the resistor value. Search the extended net across resistors that\nhave a value lower than the threshold.\nThreshold for the inductor value. Search the extended net across inductances that\nhave a value lower than the threshold.\nThreshold for the capacitor value. Search the extended net across capacitors that\nhave a value higher than the threshold.\nList of components to bypass when performing threshold checks. Components\nin the list are considered as serial components. The default is None.\nList of all extended nets and their associated components.\nauto_identify_power\npython:int\npython:float\noptional\npython:int\npython:float\noptional\npython:int\npython:float\noptional\npython:list\noptional\nNone\nList\nExtendedNet"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNets.auto_identify_power",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNets.auto_identify_power.html#pyedb.grpc.database.net.extended_net.ExtendedNets.auto_identify_power",
        "title": "auto_identify_power > auto_identify_power > auto_identify_power",
        "section": "auto_identify_power > auto_identify_power",
        "text": "ExtendedNets.auto_identify_power(resistor_below: int | float = 10, inductor_below: int | float = 1, capacitor_above: int | float = 1, exception_list: list | None = None) -> list\n\nGet all extended power nets and their associated components.\n\nParameters\n\nresistor_below\n\npython:int, python:float, optional\n\nThreshold for the resistor value. Search the extended net across resistors that\nhave a value lower than the threshold.\n\ninductor_below\n\npython:int, python:float, optional\n\nThreshold for the inductor value. Search the extended net across inductances that\nhave a value lower than the threshold.\n\ncapacitor_above\n\npython:int, python:float, optional\n\nThreshold for the capacitor value. Search the extended net across capacitors that\nhave a value higher than the threshold.\n\nexception_list\n\npython:list, optional\n\nList of components to bypass when performing threshold checks. Components\nin the list are considered as serial components. The default is None.\n\nReturns\n\nList[ExtendedNet]\n\nList of all extended nets and their associated components.\n\nExamples\n\n>>> from pyedb import Edb\n>>> app = Edb()\n>>> app.extended_nets.auto_identify_power()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the base SimulationSetup object to correct subclass, if possible.\ncast\nSimulationSetup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup.cast.html#pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "RaptorXSimulationSetup.cast()\n\nCast the base SimulationSetup object to correct subclass, if possible.\n\nReturns\n\nSimulationSetup\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_pad_parameters",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_pad_parameters.html#get_pad_parameters",
        "title": "get_pad_parameters",
        "section": "get_pad_parameters",
        "text": "Get pad parameters for a pin on a specific layer.\nPadstack instance.\nLayer name.\nPad type (“regular_pad”, “anti_pad”, “thermal_pad”). Default is \"regular_pad\".\n(geometry_type, parameters, offset_x, offset_y, rotation) where:\n- geometry_type : str\n- parameters : list[float] or list[list[float]]\n- offset_x : float\n- offset_y : float\n- rotation : float\nget_pad_parameters\npyedb.grpc.database.primitive.padstack_instance.PadstackInstance\npython:str\npython:str\noptional\n\"regular_pad\"\npython:tuple"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_pad_parameters",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_pad_parameters.html#pyedb.grpc.database.padstacks.Padstacks.get_pad_parameters",
        "title": "get_pad_parameters > get_pad_parameters > get_pad_parameters",
        "section": "get_pad_parameters > get_pad_parameters",
        "text": "Padstacks.get_pad_parameters(pin: PadstackInstance, layername: str, pad_type: str = 'regular_pad') -> Tuple[PadGeometryType, List[float], List[float], float]\n\nGet pad parameters for a pin on a specific layer.\n\nParameters\n\npin\n\npyedb.grpc.database.primitive.padstack_instance.PadstackInstance\n\nPadstack instance.\n\nlayername\n\npython:str\n\nLayer name.\n\npad_type\n\npython:str, optional\n\nPad type (“regular_pad”, “anti_pad”, “thermal_pad”). Default is \"regular_pad\".\n\nReturns\n\npython:tuple\n\n(geometry_type, parameters, offset_x, offset_y, rotation) where:\n- geometry_type : str\n- parameters : list[float] or list[list[float]]\n- offset_x : float\n- offset_y : float\n- rotation : float\n\nExamples\n\n>>> via = edb_padstacks.instances[123]\n>>> geom_type, params, x, y, rot = edb_padstacks.get_pad_parameters(via, \"TOP\", \"regular_pad\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.conjugate",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.conjugate.html#conjugate",
        "title": "conjugate",
        "section": "conjugate",
        "text": "Return self, the complex conjugate of any float.\nconjugate"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.conjugate",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.conjugate.html#pyedb.grpc.database.utility.value.Value.conjugate",
        "title": "conjugate > conjugate > conjugate",
        "section": "conjugate > conjugate",
        "text": "Value.conjugate(/)\n\nReturn self, the complex conjugate of any float.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.reorder_pins",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.reorder_pins.html#reorder_pins",
        "title": "reorder_pins",
        "section": "reorder_pins",
        "text": "Reorders the existing pins in the components definition to be in the same order         as in the provided list.\nThe component pins in the new order. These must be the same pins             that already exist in the component definition.\nreorder_pins\npython:list\nof\nComponentPin"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.reorder_pins",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.reorder_pins.html#pyedb.grpc.database.definition.component_def.ComponentDef.reorder_pins",
        "title": "reorder_pins > reorder_pins > reorder_pins",
        "section": "reorder_pins > reorder_pins",
        "text": "ComponentDef.reorder_pins(reordered_pins: List[ComponentPin])\n\nReorders the existing pins in the components definition to be in the same order         as in the provided list.\n\nParameters\n\nreordered_pins\n\npython:list of ComponentPin\n\nThe component pins in the new order. These must be the same pins             that already exist in the component definition.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.illegal_rlc_values",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.illegal_rlc_values.html#illegal_rlc_values",
        "title": "illegal_rlc_values",
        "section": "illegal_rlc_values",
        "text": "Find and fix RLC illegal values.\nillegal_rlc_values"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.illegal_rlc_values",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.illegal_rlc_values.html#pyedb.dotnet.database.layout_validation.LayoutValidation.illegal_rlc_values",
        "title": "illegal_rlc_values > illegal_rlc_values > illegal_rlc_values",
        "section": "illegal_rlc_values > illegal_rlc_values",
        "text": "LayoutValidation.illegal_rlc_values(fix=False)\n\nFind and fix RLC illegal values.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.magnetic_loss_tangent",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.magnetic_loss_tangent.html#magnetic_loss_tangent",
        "title": "magnetic_loss_tangent",
        "section": "magnetic_loss_tangent",
        "text": "magnetic_loss_tangent"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.magnetic_loss_tangent",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.magnetic_loss_tangent.html#pyedb.grpc.database.definition.materials.MaterialProperties.magnetic_loss_tangent",
        "title": "magnetic_loss_tangent > magnetic_loss_tangent > magnetic_loss_tangent",
        "section": "magnetic_loss_tangent > magnetic_loss_tangent",
        "text": "MaterialProperties.magnetic_loss_tangent: Annotated[float, Gt(gt=0)] | None\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.product_solver_names",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.product_solver_names.html#product_solver_names",
        "title": "product_solver_names",
        "section": "product_solver_names",
        "text": "Get the list of solver names.\nID of the product.\nproduct_solver_names\nProductIdType\npython:list\nof\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.product_solver_names",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.product_solver_names.html#pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.product_solver_names",
        "title": "product_solver_names > product_solver_names > product_solver_names",
        "section": "product_solver_names > product_solver_names",
        "text": "EdgeTerminal.product_solver_names(product_id)\n\nGet the list of solver names.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nReturns\n\npython:list of python:str\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_parametrized_name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nString representing the new class where params are passed to cls as type variables.\nTypeError: Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_parametrized_name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_parametrized_name.html#pyedb.workflows.drc.drc.MinClearance.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod MinClearance.model_parametrized_name(params: tuple[type[Any], ...]) -> str\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n\nparams: Tuple of types of the class. Given a generic class\n\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturns:\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises:\n\nTypeError: Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_circuit_port_on_pin_group",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_circuit_port_on_pin_group.html#create_circuit_port_on_pin_group",
        "title": "create_circuit_port_on_pin_group",
        "section": "create_circuit_port_on_pin_group",
        "text": "Create a port between two pin groups.\nName of the positive pin group.\nName of the negative pin group.\nImpedance of the port. Default is 50.\nPort name.\ncreate_circuit_port_on_pin_group\npython:str\npython:str\npython:int\npython:float\noptional\n50\npython:str\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_circuit_port_on_pin_group",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_circuit_port_on_pin_group.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_circuit_port_on_pin_group",
        "title": "create_circuit_port_on_pin_group > create_circuit_port_on_pin_group > create_circuit_port_on_pin_group",
        "section": "create_circuit_port_on_pin_group > create_circuit_port_on_pin_group",
        "text": "SourceExcitation.create_circuit_port_on_pin_group(pos_pin_group_name: str, neg_pin_group_name: str, impedance: int | float = 50, name: str | None = None) -> bool\n\nCreate a port between two pin groups.\n\nParameters\n\npos_pin_group_name\n\npython:str\n\nName of the positive pin group.\n\nneg_pin_group_name\n\npython:str\n\nName of the negative pin group.\n\nimpedance\n\npython:int, python:float, optional\n\nImpedance of the port. Default is 50.\n\nname\n\npython:str, optional\n\nPort name.\n\nReturns\n\nbool\n\n\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> edb.source_excitation.create_circuit_port_on_pin_group(\"PG1\", \"PG2\", 50, \"Port1\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.html#components",
        "title": "Components",
        "section": "Components",
        "text": "Manages EDB components and related methods accessible from Edb.components.\nEDB object.\nComponents.add_port_on_rlc_component([...])\nDeactivate RLC component and replace it with a circuit port.\nComponents.add_rlc_boundary([component, ...])\nAdd RLC gap boundary on component and replace it with a circuit port.\nComponents.create(pins[, component_name, ...])\nCreate a new component.\nComponents.create_pin_group(...[, group_name])\nCreate pin group on a component.\nComponents.create_pin_group_on_net(...[, ...])\nCreate pin group by net name.\nComponents.create_pingroup_from_pins(pins[, ...])\nCreate pin group from pins.\nComponents.deactivate_rlc_component([...])\nDeactivate RLC component with a possibility to convert it to a circuit port.\nComponents.delete(component_name)\nDelete a component.\nComponents.delete_single_pin_rlc([...])\nDelete or deactivate single-pin RLC components.\nComponents.disable_rlc_component(component_name)\nDisable RLC component.\nComponents.export_bom(bom_file[, delimiter])\nExport BOM file.\nComponents.export_definition(file_path)\nExport component definitions to a JSON file.\nComponents.find_by_reference_designator(...)\nFind component by reference designator.\nComponents.get_aedt_pin_name(pin)\nGet AEDT pin name.\nComponents.get_component_by_name(name)\nRetrieve a component by name.\nComponents.get_component_net_connection_info(refdes)\nGet net connection info for a component.\nComponents.get_component_placement_vector(...)\nGet placement vector between two components.\nComponents.get_components_from_nets([netlist])\nGet components connected to specified nets.\nComponents.get_nets_from_pin_list(pins)\nGet nets from pin list.\nComponents.get_pin_from_component(component)\nGet pins from a component with optional filtering.\nComponents.get_pin_position(pin)\nGet pin position.\nComponents.get_pins(reference_designator[, ...])\nGet pins of a component.\nComponents.get_pins_name_from_net(net_name)\nGet pin names from net.\nComponents.get_rats()\nGet RATS (Reference Designator, Pin, Net) information.\nComponents.get_solder_ball_height(cmp)\nGet solder ball height of a component.\nComponents.get_through_resistor_list([threshold])\nGet through resistors below threshold.\nComponents.get_vendor_libraries()\nGet vendor component libraries.\nComponents.import_bom(bom_file[, delimiter, ...])\nImport BOM file.\nComponents.import_definition(file_path)\nImport component definitions from a JSON file.\nComponents.refresh_components()\nRefresh the component dictionary.\nComponents.replace_rlc_by_gap_boundaries([...])\nReplace RLC component by RLC gap boundaries.\nComponents.set_component_model(componentname)\nSet component model.\nComponents.set_component_rlc(componentname)\nSet RLC values for a component.\nComponents.set_solder_ball([component, ...])\nSet solder ball properties for a component.\nComponents.short_component_pins(component_name)\nShort component pins with traces.\nComponents.update_rlc_from_bom(bom_file[, ...])\nUpdate RLC values from BOM file.\nComponents\npyedb.grpc.edb.Edb\nComponents.add_port_on_rlc_component\nComponents.add_rlc_boundary\nComponents.create\nComponents.create_pin_group\nComponents.create_pin_group_on_net\nComponents.create_pingroup_from_pins\nComponents.deactivate_rlc_component\nComponents.delete\nComponents.delete_single_pin_rlc\nComponents.disable_rlc_component\nComponents.export_bom\nComponents.export_definition\nComponents.find_by_reference_designator\nComponents.get_aedt_pin_name\nComponents.get_component_by_name\nComponents.get_component_net_connection_info\nComponents.get_component_placement_vector\nComponents.get_components_from_nets\nComponents.get_nets_from_pin_list\nComponents.get_pin_from_component\nComponents.get_pin_position\nComponents.get_pins\nComponents.get_pins_name_from_net\nComponents.get_rats\nComponents.get_solder_ball_height\nComponents.get_through_resistor_list\nComponents.get_vendor_libraries\nComponents.import_bom\nComponents.import_definition\nComponents.refresh_components\nComponents.replace_rlc_by_gap_boundaries\nComponents.set_component_model\nComponents.set_component_rlc\nComponents.set_solder_ball\nComponents.short_component_pins\nComponents.update_rlc_from_bom"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.html#pyedb.grpc.database.components.Components",
        "title": "Components > Components > Components",
        "section": "Components > Components",
        "text": "class pyedb.grpc.database.components.Components(p_edb: Any)\n\nManages EDB components and related methods accessible from Edb.components.\n\nParameters\n\np_edb\n\npyedb.grpc.edb.Edb\n\nEDB object.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\")\n>>> edbapp.components\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nComponents.add_port_on_rlc_component([...])\n\nDeactivate RLC component and replace it with a circuit port.\n\nComponents.add_rlc_boundary([component, ...])\n\nAdd RLC gap boundary on component and replace it with a circuit port.\n\nComponents.create(pins[, component_name, ...])\n\nCreate a new component.\n\nComponents.create_pin_group(...[, group_name])\n\nCreate pin group on a component.\n\nComponents.create_pin_group_on_net(...[, ...])\n\nCreate pin group by net name.\n\nComponents.create_pingroup_from_pins(pins[, ...])\n\nCreate pin group from pins.\n\nComponents.deactivate_rlc_component([...])\n\nDeactivate RLC component with a possibility to convert it to a circuit port.\n\nComponents.delete(component_name)\n\nDelete a component.\n\nComponents.delete_single_pin_rlc([...])\n\nDelete or deactivate single-pin RLC components.\n\nComponents.disable_rlc_component(component_name)\n\nDisable RLC component.\n\nComponents.export_bom(bom_file[, delimiter])\n\nExport BOM file.\n\nComponents.export_definition(file_path)\n\nExport component definitions to a JSON file.\n\nComponents.find_by_reference_designator(...)\n\nFind component by reference designator.\n\nComponents.get_aedt_pin_name(pin)\n\nGet AEDT pin name.\n\nComponents.get_component_by_name(name)\n\nRetrieve a component by name.\n\nComponents.get_component_net_connection_info(refdes)\n\nGet net connection info for a component.\n\nComponents.get_component_placement_vector(...)\n\nGet placement vector between two components.\n\nComponents.get_components_from_nets([netlist])\n\nGet components connected to specified nets.\n\nComponents.get_nets_from_pin_list(pins)\n\nGet nets from pin list.\n\nComponents.get_pin_from_component(component)\n\nGet pins from a component with optional filtering.\n\nComponents.get_pin_position(pin)\n\nGet pin position.\n\nComponents.get_pins(reference_designator[, ...])\n\nGet pins of a component.\n\nComponents.get_pins_name_from_net(net_name)\n\nGet pin names from net.\n\nComponents.get_rats()\n\nGet RATS (Reference Designator, Pin, Net) information.\n\nComponents.get_solder_ball_height(cmp)\n\nGet solder ball height of a component.\n\nComponents.get_through_resistor_list([threshold])\n\nGet through resistors below threshold.\n\nComponents.get_vendor_libraries()\n\nGet vendor component libraries.\n\nComponents.import_bom(bom_file[, delimiter, ...])\n\nImport BOM file.\n\nComponents.import_definition(file_path)\n\nImport component definitions from a JSON file.\n\nComponents.refresh_components()\n\nRefresh the component dictionary.\n\nComponents.replace_rlc_by_gap_boundaries([...])\n\nReplace RLC component by RLC gap boundaries.\n\nComponents.set_component_model(componentname)\n\nSet component model.\n\nComponents.set_component_rlc(componentname)\n\nSet RLC values for a component.\n\nComponents.set_solder_ball([component, ...])\n\nSet solder ball properties for a component.\n\nComponents.short_component_pins(component_name)\n\nShort component pins with traces.\n\nComponents.update_rlc_from_bom(bom_file[, ...])\n\nUpdate RLC values from BOM file.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.create_3d_comp.html#create_3d_comp",
        "title": "create_3d_comp",
        "section": "create_3d_comp",
        "text": "Create a 3D composite model from an MCAD file.\nAbsolute path of the MCAD file.\n3D composite model created.\ncreate_3d_comp\npython:str\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.create_3d_comp.html#pyedb.grpc.database.layout.layout.Layout.create_3d_comp",
        "title": "create_3d_comp > create_3d_comp > create_3d_comp",
        "section": "create_3d_comp > create_3d_comp",
        "text": "Layout.create_3d_comp(filename: str) -> McadModel\n\nCreate a 3D composite model from an MCAD file.\n\nParameters\n\nfilename\n\npython:str\n\nAbsolute path of the MCAD file.\n\nReturns\n\nMcadModel\n\n3D composite model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.find",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.find.html#find",
        "title": "find",
        "section": "find",
        "text": "Find a terminal by name in a given layout.\nLayout to search for the terminal.\nName of the terminal.\nfind\nLayout\nstr\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.find",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.find.html#pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.find",
        "title": "find > find > find",
        "section": "find > find",
        "text": "classmethod EdgeTerminal.find(layout, name)\n\nFind a terminal by name in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the terminal.\n\nname\n\nstr\n\nName of the terminal.\n\nReturns\n\nTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.json.html#json",
        "title": "json",
        "section": "json",
        "text": "json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.json.html#pyedb.workflows.drc.drc.CopperBalance.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "CopperBalance.json(*, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -> str\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.create_3d_comp.html#create_3d_comp",
        "title": "create_3d_comp",
        "section": "create_3d_comp",
        "text": "Create a 3D composite model from an MCAD file.\n3D composite model created.\ncreate_3d_comp\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.create_3d_comp.html#pyedb.grpc.database.ports.ports.WavePort.create_3d_comp",
        "title": "create_3d_comp > create_3d_comp > create_3d_comp",
        "section": "create_3d_comp > create_3d_comp",
        "text": "WavePort.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nReturns\n\nMcadModel\n\n3D composite model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.set_parameters",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.set_parameters.html#set_parameters",
        "title": "set_parameters",
        "section": "set_parameters",
        "text": "Set coordinates parameters.\nType that defines given parameters meaning.\nX value of lower left point or center point.\nY value of lower left point or center point.\nX value of upper right point or width.\nY value of upper right point or height.\nCorner radius.\nRotation.\nset_parameters\nRectangleRepresentationType\nValue\nValue\nValue\nValue\nValue\nValue"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.set_parameters",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.set_parameters.html#pyedb.grpc.database.primitive.rectangle.Rectangle.set_parameters",
        "title": "set_parameters > set_parameters > set_parameters",
        "section": "set_parameters > set_parameters",
        "text": "Rectangle.set_parameters(rep_type, param1, param2, param3, param4, corner_rad, rotation)\n\nSet coordinates parameters.\n\nParameters\n\nrep_type\n\nRectangleRepresentationType\n\nType that defines given parameters meaning.\n\nparam1\n\nValue\n\nX value of lower left point or center point.\n\nparam2\n\nValue\n\nY value of lower left point or center point.\n\nparam3\n\nValue\n\nX value of upper right point or width.\n\nparam4\n\nValue\n\nY value of upper right point or height.\n\ncorner_rad\n\nValue\n\nCorner radius.\n\nrotation\n\nValue\n\nRotation.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/_autosummary/pyedb.workflows.utilities.cutout.Cutout",
        "href": "workflows/utilities/_autosummary/pyedb.workflows.utilities.cutout.Cutout.html#cutout",
        "title": "Cutout",
        "section": "Cutout",
        "text": "Cutout"
    },
    {
        "objectID": "workflows/utilities/_autosummary/pyedb.workflows.utilities.cutout.Cutout",
        "href": "workflows/utilities/_autosummary/pyedb.workflows.utilities.cutout.Cutout.html#pyedb.workflows.utilities.cutout.Cutout",
        "title": "Cutout > Cutout > Cutout",
        "section": "Cutout > Cutout",
        "text": "class pyedb.workflows.utilities.cutout.Cutout(edb)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileComponent.add_pin",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileComponent.add_pin.html#add_pin",
        "title": "add_pin",
        "section": "add_pin",
        "text": "add_pin"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileComponent.add_pin",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileComponent.add_pin.html#pyedb.dotnet.database.edb_data.control_file.ControlFileComponent.add_pin",
        "title": "add_pin > add_pin > add_pin",
        "section": "add_pin > add_pin",
        "text": "ControlFileComponent.add_pin(name, x, y, layer)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileMaterial",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileMaterial.html#controlfilematerial",
        "title": "ControlFileMaterial",
        "section": "ControlFileMaterial",
        "text": "ControlFileMaterial"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileMaterial",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileMaterial.html#pyedb.grpc.database.utility.xml_control_file.ControlFileMaterial",
        "title": "ControlFileMaterial > ControlFileMaterial > ControlFileMaterial",
        "section": "ControlFileMaterial > ControlFileMaterial",
        "text": "class pyedb.grpc.database.utility.xml_control_file.ControlFileMaterial(name, properties)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType.kNumMeshOpTypes",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType.kNumMeshOpTypes.html#knummeshoptypes",
        "title": "kNumMeshOpTypes",
        "section": "kNumMeshOpTypes",
        "text": "kNumMeshOpTypes"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType.kNumMeshOpTypes",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType.kNumMeshOpTypes.html#pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType.kNumMeshOpTypes",
        "title": "kNumMeshOpTypes > kNumMeshOpTypes > kNumMeshOpTypes",
        "section": "kNumMeshOpTypes > kNumMeshOpTypes",
        "text": "MeshOpType.kNumMeshOpTypes = 'num_mesh_op_types'\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.set_heatsink",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.set_heatsink.html#set_heatsink",
        "title": "set_heatsink",
        "section": "set_heatsink",
        "text": "Set Heat sink.\nParameters\n———-\nfin_base_height : str, float\nFin base height.\nFin height.\nFin orientation. Supported values, x_oriented, y_oriented.\nFin spacing.\nFin thickness.\nset_heatsink"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.set_heatsink",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.set_heatsink.html#pyedb.grpc.database.definition.package_def.PackageDef.set_heatsink",
        "title": "set_heatsink > set_heatsink > set_heatsink",
        "section": "set_heatsink > set_heatsink",
        "text": "PackageDef.set_heatsink(fin_base_height, fin_height, fin_orientation, fin_spacing, fin_thickness) -> HeatSink\n\nSet Heat sink.\nParameters\n———-\nfin_base_height : str, float\n\nFin base height.\n\nfin_height\n\nstr, float\n\nFin height.\n\nfin_orientation\n\nstr\n\nFin orientation. Supported values, x_oriented, y_oriented.\n\nfin_spacing\n\nstr, float\n\nFin spacing.\n\nfin_thickness\n\nstr, float\n\nFin thickness.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.add_sweep",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.add_sweep.html#add_sweep",
        "title": "add_sweep",
        "section": "add_sweep",
        "text": "Add a HFSS frequency sweep.\nSweep name.\nType of the sweep. The default is “linear”. Options are:\n- “linear”\n- “linear_count”\n- “decade_count”\n- “octave_count”\n- “exponential”\nStarting frequency. The default is 1.\nStopping frequency. The default is 1e9.\nFrequency step. The default is 1e6. or used for “decade_count”, “linear_count”, “octave_count”\ndistribution. Must be integer in that case.\nWhether the sweep is discrete. The default is False.\nFrequency set is a list adding one or more frequency sweeps. If frequency_set is provided, the other\narguments are ignored except discrete. Default value is None.\nexample of frequency_set : [[‘linear_scale’, ‘50MHz’, ‘200MHz’, ‘10MHz’]].\nadd_sweep\npython:str\noptional\npython:str\noptional\npython:str\npython:float\noptional\n1\npython:str\npython:float\noptional\n1e9\npython:str\npython:float\npython:int\noptional\n1e6\noptional\nFalse\nList\noptional\nfrequency_set\ndiscrete\nNone"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.add_sweep",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.add_sweep.html#pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.add_sweep",
        "title": "add_sweep > add_sweep > add_sweep",
        "section": "add_sweep > add_sweep",
        "text": "HfssSimulationSetup.add_sweep(name=None, distribution='linear', start_freq='0GHz', stop_freq='20GHz', step='10MHz', discrete=False, frequency_set=None)\n\nAdd a HFSS frequency sweep.\n\nParameters\n\nname\n\npython:str, optional\n\nSweep name.\n\ndistribution\n\npython:str, optional\n\nType of the sweep. The default is “linear”. Options are:\n- “linear”\n- “linear_count”\n- “decade_count”\n- “octave_count”\n- “exponential”\n\nstart_freq\n\npython:str, python:float, optional\n\nStarting frequency. The default is 1.\n\nstop_freq\n\npython:str, python:float, optional\n\nStopping frequency. The default is 1e9.\n\nstep\n\npython:str, python:float, python:int, optional\n\nFrequency step. The default is 1e6. or used for “decade_count”, “linear_count”, “octave_count”\ndistribution. Must be integer in that case.\n\ndiscrete\n\nbool, optional\n\nWhether the sweep is discrete. The default is False.\n\nfrequency_set\n\nList, optional\n\nFrequency set is a list adding one or more frequency sweeps. If frequency_set is provided, the other\narguments are ignored except discrete. Default value is None.\nexample of frequency_set : [[‘linear_scale’, ‘50MHz’, ‘200MHz’, ‘10MHz’]].\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_coax_port",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_coax_port.html#create_coax_port",
        "title": "create_coax_port",
        "section": "create_coax_port",
        "text": "Create a coax port.\nPort name, the default is None, in which case a name is automatically assigned.\nRadial extent of coaxial port.\nPort terminal.\ncreate_coax_port\npython:str\nNone\npython:int\npython:float\noptional\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_coax_port",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_coax_port.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_coax_port",
        "title": "create_coax_port > create_coax_port > create_coax_port",
        "section": "create_coax_port > create_coax_port",
        "text": "PadstackInstance.create_coax_port(name=None, radial_extent_factor=0)\n\nCreate a coax port.\n\nParameters\n\nname\n\npython:str, optional.\n\nPort name, the default is None, in which case a name is automatically assigned.\n\nradial_extent_factor\n\npython:int, python:float, optional\n\nRadial extent of coaxial port.\n\nReturns\n\nTerminal\n\nPort terminal.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_padstack_instance_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_padstack_instance_terminal.html#get_padstack_instance_terminal",
        "title": "get_padstack_instance_terminal",
        "section": "get_padstack_instance_terminal",
        "text": "PadstackInstanceTerminal:         Terminal of the padstack instance.\nget_padstack_instance_terminal\nPadstackInstanceTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_padstack_instance_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_padstack_instance_terminal.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_padstack_instance_terminal",
        "title": "get_padstack_instance_terminal > get_padstack_instance_terminal > get_padstack_instance_terminal",
        "section": "get_padstack_instance_terminal > get_padstack_instance_terminal",
        "text": "PadstackInstance.get_padstack_instance_terminal() -> PadstackInstanceTerminal\n\nPadstackInstanceTerminal:         Terminal of the padstack instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.RectangularPatch",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.RectangularPatch.html#rectangularpatch",
        "title": "RectangularPatch",
        "section": "RectangularPatch",
        "text": "Rectangular microstrip patch antenna (optionally inset-fed).\nThe class automatically determines the physical dimensions for a\ndesired resonance frequency, creates the patch, ground plane and\neither an inset microstrip feed or a coaxial probe feed, and\noptionally sets up an HFSS simulation.\nEDB project/cell in which the antenna will be built.\nTarget resonance frequency of the patch.  A string such as\n\"2.4GHz\" or a numeric value in Hz can be given.\nInset depth for a 50 Ω microstrip feed.  A value of 0 selects\na probe (via) feed instead.\nMetallization layer on which the patch polygon is drawn.\nMetallization layer on which the ground polygon is drawn.\nIf True, create a wave port (inset feed) or lumped port\n(probe feed) and add an HFSS setup with a frequency sweep.\nBuild a 5.8 GHz patch on a 0.787 mm Rogers RO4350B substrate:\nProbe-fed 2.4 GHz patch (no inset):\nSubstrate definition (er, tand, h) used for all\nanalytical calculations.\nRectangularPatch.create()\nDraw the patch, ground plane and feed geometry in EDB.\nRectangularPatch\npyedb.Edb\noptional\npython:str\npython:float\ndefault\n\"2.4GHz\"\npython:str\npython:float\ndefault\npython:str\ndefault\npython:str\ndefault\ndefault\npython:True\nSubstrate\ner\ntand\nh\nRectangularPatch.create"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.RectangularPatch",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.RectangularPatch.html#pyedb.libraries.rf_libraries.planar_antennas.RectangularPatch",
        "title": "RectangularPatch > RectangularPatch > RectangularPatch",
        "section": "RectangularPatch > RectangularPatch",
        "text": "class pyedb.libraries.rf_libraries.planar_antennas.RectangularPatch(edb_cell=None, target_frequency: str | float = '2.4Ghz', length_feeding_line: str | float = 0, layer: str = 'TOP_METAL', bottom_layer: str = 'BOT_METAL', add_port: bool = True, permittivity: float | None = None)\n\nRectangular microstrip patch antenna (optionally inset-fed).\n\nThe class automatically determines the physical dimensions for a\ndesired resonance frequency, creates the patch, ground plane and\neither an inset microstrip feed or a coaxial probe feed, and\noptionally sets up an HFSS simulation.\n\nParameters\n\nedb_cell\n\npyedb.Edb, optional\n\nEDB project/cell in which the antenna will be built.\n\nfreq\n\npython:str or python:float, default “2.4GHz”\n\nTarget resonance frequency of the patch.  A string such as\n\"2.4GHz\" or a numeric value in Hz can be given.\n\ninset\n\npython:str or python:float, default 0\n\nInset depth for a 50 Ω microstrip feed.  A value of 0 selects\na probe (via) feed instead.\n\nlayer\n\npython:str, default “TOP_METAL”\n\nMetallization layer on which the patch polygon is drawn.\n\nbottom_layer\n\npython:str, default “BOT_METAL”\n\nMetallization layer on which the ground polygon is drawn.\n\nadd_port\n\nbool, default python:True\n\nIf True, create a wave port (inset feed) or lumped port\n(probe feed) and add an HFSS setup with a frequency sweep.\n\nExamples\n\nBuild a 5.8 GHz patch on a 0.787 mm Rogers RO4350B substrate:\n\n>>> edb = pyedb.Edb()\n>>> patch = RectangularPatch(edb_cell=edb, freq=\"5.8GHz\", inset=\"4.2mm\", layer=\"TOP\", bottom_layer=\"GND\")\n>>> patch.substrate.er = 3.66\n>>> patch.substrate.tand = 0.0037\n>>> patch.substrate.h = 0.000787\n>>> patch.create()\n>>> edb.save_as(\"patch_5p8GHz.aedb\")\n\nProbe-fed 2.4 GHz patch (no inset):\n\n>>> edb = pyedb.Edb()\n>>> RectangularPatch(edb, freq=2.4e9, inset=0).create()\n>>> edb.save_as(\"probe_patch_2p4GHz.aedb\")\n\nAttributes\n\nsubstrate\n\nSubstrate\n\nSubstrate definition (er, tand, h) used for all\nanalytical calculations.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nRectangularPatch.create()\n\nDraw the patch, ground plane and feed geometry in EDB.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.create_stride.html#create_stride",
        "title": "create_stride",
        "section": "create_stride",
        "text": "Create a Stride model from an MCAD file.\nStride model created.\ncreate_stride\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.create_stride.html#pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.create_stride",
        "title": "create_stride > create_stride > create_stride",
        "section": "create_stride > create_stride",
        "text": "PadstackInstanceTerminal.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nReturns\n\nMcadModel\n\nStride model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_config",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_config",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_config.html#pyedb.workflows.drc.drc.MinAnnularRing.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "MinAnnularRing.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the layout object.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.delete.html#pyedb.grpc.database.net.net.Net.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "Net.delete()\n\nDelete the layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.create",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a package definition in a given database.\nDatabase to create the package definition in.\nName of the package definition.\nPackage definition created.\ncreate\npython:str\nPackageDef"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.create",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.create.html#pyedb.grpc.database.definition.package_def.PackageDef.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod PackageDef.create(db, name)\n\nCreate a package definition in a given database.\n\nParameters\n\ndb :class:`.Database`\n\nDatabase to create the package definition in.\n\nname\n\npython:str\n\nName of the package definition.\n\nReturns\n\nPackageDef\n\nPackage definition created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileStackup",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileStackup.html#controlfilestackup",
        "title": "ControlFileStackup",
        "section": "ControlFileStackup",
        "text": "Class that manages the Stackup info.\nControlFileStackup.add_dielectric(layer_name)\nAdd a new dielectric.\nControlFileStackup.add_layer(layer_name[, ...])\nAdd a new layer.\nControlFileStackup.add_material(material_name)\nAdd a new material with specific properties.\nControlFileStackup.add_via(layer_name[, ...])\nAdd a new via layer.\nControlFileStackup\nControlFileStackup.add_dielectric\nControlFileStackup.add_layer\nControlFileStackup.add_material\nControlFileStackup.add_via"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileStackup",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileStackup.html#pyedb.grpc.database.utility.xml_control_file.ControlFileStackup",
        "title": "ControlFileStackup > ControlFileStackup > ControlFileStackup",
        "section": "ControlFileStackup > ControlFileStackup",
        "text": "class pyedb.grpc.database.utility.xml_control_file.ControlFileStackup(units='mm')\n\nClass that manages the Stackup info.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nControlFileStackup.add_dielectric(layer_name)\n\nAdd a new dielectric.\n\nControlFileStackup.add_layer(layer_name[, ...])\n\nAdd a new layer.\n\nControlFileStackup.add_material(material_name)\n\nAdd a new material with specific properties.\n\nControlFileStackup.add_via(layer_name[, ...])\n\nAdd a new via layer.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.create_hfss.html#create_hfss",
        "title": "create_hfss",
        "section": "create_hfss",
        "text": "Create an HFSS model from an MCAD file.\nHFSS model created.\ncreate_hfss\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.create_hfss.html#pyedb.grpc.database.terminal.terminal.Terminal.create_hfss",
        "title": "create_hfss > create_hfss > create_hfss",
        "section": "create_hfss > create_hfss",
        "text": "Terminal.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nReturns\n\nMcadModel\n\nHFSS model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.place_instance",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.place_instance.html#place_instance",
        "title": "place_instance",
        "section": "place_instance",
        "text": "Place current Cell into another cell using 3d placement method.\nFlip the current layer stackup of a layout if requested. Transform parameters currently not supported.\nCell to place in the current layout.\nThe rotation angle applied on the design.\nThe x offset value.\nThe default value is 0.0.\nThe y offset value.\nThe default value is 0.0.\nThe z offset value. (i.e. elevation offset for placement relative to the top layer conductor).\nThe default value is 0.0, which places the cell layout on top of the top conductor\nlayer of the target EDB.\nEither if the current layout is inverted.\nIf True and place_on_top is True the stackup will be flipped before the merge.\nEither if place the component_edb layout on Top or Bottom of destination Layout.\nSolder Ball or Bumps eight.\nThis value will be added to the elevation to align the two layouts.\nTrue when succeed False if not.\nplace_instance\nEdb\ndouble\noptional\ndouble\noptional\n0.0\ndouble\noptional\n0.0\ndouble\noptional\n0.0\noptional\noptional\npython:float\noptional\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.place_instance",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.place_instance.html#pyedb.dotnet.database.stackup.Stackup.place_instance",
        "title": "place_instance > place_instance > place_instance",
        "section": "place_instance > place_instance",
        "text": "Stackup.place_instance(component_edb, angle=0.0, offset_x=0.0, offset_y=0.0, offset_z=0.0, flipped_stackup=True, place_on_top=True, solder_height=0)\n\nPlace current Cell into another cell using 3d placement method.\nFlip the current layer stackup of a layout if requested. Transform parameters currently not supported.\n\nParameters\n\ncomponent_edb\n\nEdb\n\nCell to place in the current layout.\n\nangle\n\ndouble, optional\n\nThe rotation angle applied on the design.\n\noffset_x\n\ndouble, optional\n\nThe x offset value.\nThe default value is 0.0.\n\noffset_y\n\ndouble, optional\n\nThe y offset value.\nThe default value is 0.0.\n\noffset_z\n\ndouble, optional\n\nThe z offset value. (i.e. elevation offset for placement relative to the top layer conductor).\nThe default value is 0.0, which places the cell layout on top of the top conductor\nlayer of the target EDB.\n\nflipped_stackup\n\nbool, optional\n\nEither if the current layout is inverted.\nIf True and place_on_top is True the stackup will be flipped before the merge.\n\nplace_on_top\n\nbool, optional\n\nEither if place the component_edb layout on Top or Bottom of destination Layout.\n\nsolder_height\n\npython:float, optional\n\nSolder Ball or Bumps eight.\nThis value will be added to the elevation to align the two layouts.\n\nReturns\n\nbool\n\nTrue when succeed False if not.\n\nExamples\n\n>>> edb1 = Edb(edbpath=targetfile1, edbversion=\"2021.2\")\n>>> edb2 = Edb(edbpath=targetfile2, edbversion=\"2021.2\")\n>>> hosting_cmp = edb1.components.get_component_by_name(\"U100\")\n>>> mounted_cmp = edb2.components.get_component_by_name(\"BGA\")\n>>> edb1.stackup.place_instance(\n...     edb2,\n...     angle=0.0,\n...     offset_x=\"1mm\",\n...     offset_y=\"2mm\",\n...     flipped_stackup=False,\n...     place_on_top=True,\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.copper_balance",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.copper_balance.html#copper_balance",
        "title": "copper_balance",
        "section": "copper_balance",
        "text": "copper_balance"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.copper_balance",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.copper_balance.html#pyedb.workflows.drc.drc.Rules.copper_balance",
        "title": "copper_balance > copper_balance > copper_balance",
        "section": "copper_balance > copper_balance",
        "text": "Rules.copper_balance: List[CopperBalance]\n\n"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "schema"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.schema.html#pyedb.workflows.drc.drc.CopperBalance.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod CopperBalance.schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}') -> Dict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/nets",
        "href": "grpc_api/grpc/database/nets.html#sources-and-excitations",
        "title": "Sources and excitations",
        "section": "Sources and excitations",
        "text": "These classes are the containers of sources methods of the EDB for both HFSS and SIwave.\nnets.Nets\nManages EDB methods for nets management accessible from Edb.nets property.\nSources and excitations\nnets.Nets"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_parametrized_name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nString representing the new class where params are passed to cls as type variables.\nTypeError: Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_parametrized_name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_parametrized_name.html#pyedb.workflows.drc.drc.BackDrillStubLength.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod BackDrillStubLength.model_parametrized_name(params: tuple[type[Any], ...]) -> str\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n\nparams: Tuple of types of the class. Given a generic class\n\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturns:\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises:\n\nTypeError: Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.create_pingroup_from_pins",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.create_pingroup_from_pins.html#create_pingroup_from_pins",
        "title": "create_pingroup_from_pins",
        "section": "create_pingroup_from_pins",
        "text": "Create pin group from pins.\nList of pins.\nGroup name.\nPin group instance if successful, False otherwise.\ncreate_pingroup_from_pins\npython:list\npyedb.grpc.database.padstacks.PadstackInstance\npython:str\noptional\npyedb.grpc.database.hierarchy.pingroup.PinGroup"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.create_pingroup_from_pins",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.create_pingroup_from_pins.html#pyedb.grpc.database.components.Components.create_pingroup_from_pins",
        "title": "create_pingroup_from_pins > create_pingroup_from_pins > create_pingroup_from_pins",
        "section": "create_pingroup_from_pins > create_pingroup_from_pins",
        "text": "Components.create_pingroup_from_pins(pins: List[Any], group_name: str | None = None) -> PinGroup | bool\n\nCreate pin group from pins.\n\nParameters\n\npins\n\npython:list[pyedb.grpc.database.padstacks.PadstackInstance]\n\nList of pins.\n\ngroup_name\n\npython:str, optional\n\nGroup name.\n\nReturns\n\npyedb.grpc.database.hierarchy.pingroup.PinGroup or bool\n\nPin group instance if successful, False otherwise.\n\nExamples\n\n>>> pingroup = edbapp.components.create_pingroup_from_pins(pins, \"GND_pins\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.html#differentialpair",
        "title": "DifferentialPair",
        "section": "DifferentialPair",
        "text": "Manages EDB functionalities for a primitive.\nIt inherits EDB object properties.\nDifferentialPair.add_net(net)\nAdd a net.\nDifferentialPair.contains_net(net)\nDetermine if a net exists in the net class.\nDifferentialPair.create(layout, name[, ...])\nCreate a differential pair.\nDifferentialPair.delete()\nDelete the layout object.\nDifferentialPair.find_by_name(layout, name)\nFind a differential pair by name in a given layout.\nDifferentialPair.get_product_property(...)\nGet the product property of the layout object for a given product ID and attribute ID.\nDifferentialPair.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nDifferentialPair.remove_net(net)\nRemove a net.\nDifferentialPair.set_product_property(...)\nSet the product property of the layout object for a given product ID and attribute ID.\nDifferentialPair.layout_obj_type\n\nDifferentialPair\nDifferentialPair.add_net\nDifferentialPair.contains_net\nDifferentialPair.create\nDifferentialPair.delete\nDifferentialPair.find_by_name\nDifferentialPair.get_product_property\nDifferentialPair.get_product_property_ids\nDifferentialPair.remove_net\nDifferentialPair.set_product_property\nDifferentialPair.layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.html#pyedb.grpc.database.net.differential_pair.DifferentialPair",
        "title": "DifferentialPair > DifferentialPair > DifferentialPair",
        "section": "DifferentialPair > DifferentialPair",
        "text": "class pyedb.grpc.database.net.differential_pair.DifferentialPair(pedb, edb_object)\n\nManages EDB functionalities for a primitive.\nIt inherits EDB object properties.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nDifferentialPair.add_net(net)\n\nAdd a net.\n\nDifferentialPair.contains_net(net)\n\nDetermine if a net exists in the net class.\n\nDifferentialPair.create(layout, name[, ...])\n\nCreate a differential pair.\n\nDifferentialPair.delete()\n\nDelete the layout object.\n\nDifferentialPair.find_by_name(layout, name)\n\nFind a differential pair by name in a given layout.\n\nDifferentialPair.get_product_property(...)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nDifferentialPair.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nDifferentialPair.remove_net(net)\n\nRemove a net.\n\nDifferentialPair.set_product_property(...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\n\n\nAttributes\n\n\n\n\n\n\n\nDifferentialPair.layout_obj_type\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup.add_frequency_sweep",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup.add_frequency_sweep.html#add_frequency_sweep",
        "title": "add_frequency_sweep",
        "section": "add_frequency_sweep",
        "text": "Add frequency sweep.\n. deprecated:: pyedb 0.31.0\nUse add sweep() instead.\nadd_frequency_sweep\nadd sweep()"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup.add_frequency_sweep",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup.add_frequency_sweep.html#pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup.add_frequency_sweep",
        "title": "add_frequency_sweep > add_frequency_sweep > add_frequency_sweep",
        "section": "add_frequency_sweep > add_frequency_sweep",
        "text": "RaptorXSimulationSetup.add_frequency_sweep(name=None, distribution='linear', start_freq='0GHz', stop_freq='20GHz', step='10MHz', discrete=False)\n\nAdd frequency sweep.\n\n. deprecated:: pyedb 0.31.0\nUse add sweep() instead.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.set_product_property.html#pyedb.grpc.database.ports.ports.CoaxPort.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "CoaxPort.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.simulation_settings.HFSSSimulationSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.simulation_settings.HFSSSimulationSettings.html#hfsssimulationsettings",
        "title": "HFSSSimulationSettings",
        "section": "HFSSSimulationSettings",
        "text": "HFSSSimulationSettings"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.simulation_settings.HFSSSimulationSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.simulation_settings.HFSSSimulationSettings.html#pyedb.dotnet.database.sim_setup_data.data.simulation_settings.HFSSSimulationSettings",
        "title": "HFSSSimulationSettings > HFSSSimulationSettings > HFSSSimulationSettings",
        "section": "HFSSSimulationSettings > HFSSSimulationSettings",
        "text": "class pyedb.dotnet.database.sim_setup_data.data.simulation_settings.HFSSSimulationSettings(pedb, sim_setup, edb_object)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDS for a given product ID for the cell.\nID representing a product that supports the EDB.\nList of user-defined attribute IDs for properties stored in this object.\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.get_product_property_ids.html#pyedb.grpc.database.layout.cell.Cell.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "Cell.get_product_property_ids(prod_id)\n\nGet a list of attribute IDS for a given product ID for the cell.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nList of user-defined attribute IDs for properties stored in this object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileBoundaries.add_port",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileBoundaries.add_port.html#add_port",
        "title": "add_port",
        "section": "add_port",
        "text": "Add a new port to the gds.\nPort name.\nPin 1 x position.\nPin 1 y position.\nPin 1 layer.\nPin 2 x position.\nPin 2 y position.\nPin 2 layer.\nCharacteristic impedance.\nadd_port\npython:str\npython:str\npython:str\npython:str\npython:str\npython:str\npython:str\npython:str\npyedb.dotnet.database.edb_data.control_file.ControlCircuitPt"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileBoundaries.add_port",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileBoundaries.add_port.html#pyedb.grpc.database.utility.xml_control_file.ControlFileBoundaries.add_port",
        "title": "add_port > add_port > add_port",
        "section": "add_port > add_port",
        "text": "ControlFileBoundaries.add_port(name, x1, y1, layer1, x2, y2, layer2, z0=50)\n\nAdd a new port to the gds.\n\nParameters\n\nname\n\npython:str\n\nPort name.\n\nx1\n\npython:str\n\nPin 1 x position.\n\ny1\n\npython:str\n\nPin 1 y position.\n\nlayer1\n\npython:str\n\nPin 1 layer.\n\nx2\n\npython:str\n\nPin 2 x position.\n\ny2\n\npython:str\n\nPin 2 y position.\n\nlayer2\n\npython:str\n\nPin 2 layer.\n\nz0\n\npython:str\n\nCharacteristic impedance.\n\nReturns\n\npyedb.dotnet.database.edb_data.control_file.ControlCircuitPt\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_layer_above",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_layer_above.html#add_layer_above",
        "title": "add_layer_above",
        "section": "add_layer_above",
        "text": "Add a layer above a layer.\nName of the layer.\nName of the base layer.\nType of the layer. The default to \"signal\". Options are \"signal\", \"dielectric\"\nadd_layer_above\npython:str\n\"signal\"\n\"signal\"\n\"dielectric\""
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_layer_above",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_layer_above.html#pyedb.dotnet.database.stackup.Stackup.add_layer_above",
        "title": "add_layer_above > add_layer_above > add_layer_above",
        "section": "add_layer_above > add_layer_above",
        "text": "Stackup.add_layer_above(name, base_layer_name, layer_type='signal', **kwargs)\n\nAdd a layer above a layer.\n\nParameters\n\nname\n\npython:str\n\nName of the layer.\n\nbase_layer_name: str\n\nName of the base layer.\n\nlayer_type: str, optional\n\nType of the layer. The default to \"signal\". Options are \"signal\", \"dielectric\"\n\nkwargs\n\n\n\nReturns\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.from_orm",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "from_orm"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.from_orm",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.from_orm.html#pyedb.workflows.drc.drc.CopperBalance.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod CopperBalance.from_orm(obj: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.add_frequency_sweep",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.add_frequency_sweep.html#add_frequency_sweep",
        "title": "add_frequency_sweep",
        "section": "add_frequency_sweep",
        "text": "Add frequency sweep.\nName of the frequency sweep.\nList of frequency points.\nadd_frequency_sweep\npython:str\noptional\npython:list\noptional\npyedb.dotnet.database.edb_data.simulation_setup.EdbFrequencySweep"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.add_frequency_sweep",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.add_frequency_sweep.html#pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.add_frequency_sweep",
        "title": "add_frequency_sweep > add_frequency_sweep > add_frequency_sweep",
        "section": "add_frequency_sweep > add_frequency_sweep",
        "text": "RaptorXSimulationSetup.add_frequency_sweep(name=None, frequency_sweep=None)\n\nAdd frequency sweep.\n\nParameters\n\nname\n\npython:str, optional\n\nName of the frequency sweep.\n\nfrequency_sweep\n\npython:list, optional\n\nList of frequency points.\n\nReturns\n\npyedb.dotnet.database.edb_data.simulation_setup.EdbFrequencySweep\n\n\n\nExamples\n\n>>> setup1 = edbapp.create_hfss_setup(\"setup1\")\n>>> setup1.add_frequency_sweep(\n...     frequency_sweep=[\n...         [\"linear count\", \"0\", \"1kHz\", 1],\n...         [\"log scale\", \"1kHz\", \"0.1GHz\", 10],\n...         [\"linear scale\", \"0.1GHz\", \"10GHz\", \"0.1GHz\"],\n...     ]\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.set_dc_slider",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.set_dc_slider.html#set_dc_slider",
        "title": "set_dc_slider",
        "section": "set_dc_slider",
        "text": "Set DC simulation accuracy level.\nOptions are:\n0: Optimal speed\n1: Balanced\n2: Optimal accuracy\nset_dc_slider\n0\n1\n2"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.set_dc_slider",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.set_dc_slider.html#pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.set_dc_slider",
        "title": "set_dc_slider > set_dc_slider > set_dc_slider",
        "section": "set_dc_slider > set_dc_slider",
        "text": "SiwaveDCSimulationSetup.set_dc_slider(value)\n\nSet DC simulation accuracy level.\n\nOptions are:\n\n0: Optimal speed\n\n1: Balanced\n\n2: Optimal accuracy\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.find_by_id.html#find_by_id",
        "title": "find_by_id",
        "section": "find_by_id",
        "text": "Find a Connectable object by database ID in a given layout.\nLayout to search for the Connectable object.\nDatabase ID.\nConnectable object with the given database ID.\nfind_by_id\nLayout\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.find_by_id.html#pyedb.grpc.database.ports.ports.GapPort.find_by_id",
        "title": "find_by_id > find_by_id > find_by_id",
        "section": "find_by_id > find_by_id",
        "text": "classmethod GapPort.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the Connectable object.\n\nuid\n\npython:int\n\nDatabase ID.\n\nReturns\n\nConnectable\n\nConnectable object with the given database ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_primitives",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_primitives.html#get_primitives",
        "title": "get_primitives",
        "section": "get_primitives",
        "text": "Get primitives with filtering.\nNet name filter.\nLayer name filter.\nPrimitive type filter.\nVoid primitive filter.\nList of filtered primitives.\nget_primitives\npython:str\noptional\npython:str\noptional\npython:str\noptional\noptional\npython:list"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_primitives",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_primitives.html#pyedb.grpc.database.modeler.Modeler.get_primitives",
        "title": "get_primitives > get_primitives > get_primitives",
        "section": "get_primitives > get_primitives",
        "text": "Modeler.get_primitives(net_name: str | None = None, layer_name: str | None = None, prim_type: str | None = None, is_void: bool = False) -> List[Primitive]\n\nGet primitives with filtering.\n\nParameters\n\nnet_name\n\npython:str, optional\n\nNet name filter.\n\nlayer_name\n\npython:str, optional\n\nLayer name filter.\n\nprim_type\n\npython:str, optional\n\nPrimitive type filter.\n\nis_void\n\nbool, optional\n\nVoid primitive filter.\n\nReturns\n\npython:list\n\nList of filtered primitives.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.convex_hull",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.convex_hull.html#convex_hull",
        "title": "convex_hull",
        "section": "convex_hull",
        "text": "Compute the convex hull of the union of a list of polygons.\nList of polygons.\nconvex_hull\npython:list\nof\nPolygonData\nPolygonData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.convex_hull",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.convex_hull.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.convex_hull",
        "title": "convex_hull > convex_hull > convex_hull",
        "section": "convex_hull > convex_hull",
        "text": "classmethod PolygonData.convex_hull(polygons: list[PolygonData]) -> PolygonData\n\nCompute the convex hull of the union of a list of polygons.\n\nParameters\n\nothers\n\npython:list of PolygonData\n\nList of polygons.\n\nReturns\n\nPolygonData\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.create",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a padstack instance terminal.\nLayout to create the padstack instance terminal in.\nName of the padstack instance terminal.\nPadstack instance.\nLayer to place the padstack instance terminal on.\nNet.\nWhether the padstack instance terminal is a reference terminal.\ncreate\nLayout\nstr\nPadstackInstance\nLayer\nstr\nNet\nstr\npython:None\nbool\npython:False\nPadstackInstanceTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.create",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.create.html#pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod PadstackInstanceTerminal.create(layout, name, padstack_instance, layer, net, is_ref=False)\n\nCreate a padstack instance terminal.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to create the padstack instance terminal in.\n\nname\n\nstr\n\nName of the padstack instance terminal.\n\npadstack_instance\n\nPadstackInstance\n\nPadstack instance.\n\nlayer\n\nLayer or str\n\nLayer to place the padstack instance terminal on.\n\nnet\n\nNet or str or python:None\n\nNet.\n\nis_ref\n\nbool, default: python:False\n\nWhether the padstack instance terminal is a reference terminal.\n\nReturns\n\nPadstackInstanceTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationAdvancedSettings",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationAdvancedSettings.html#raptorxsimulationadvancedsettings",
        "title": "RaptorXSimulationAdvancedSettings",
        "section": "RaptorXSimulationAdvancedSettings",
        "text": "RaptorXSimulationAdvancedSettings"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationAdvancedSettings",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationAdvancedSettings.html#pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationAdvancedSettings",
        "title": "RaptorXSimulationAdvancedSettings > RaptorXSimulationAdvancedSettings > RaptorXSimulationAdvancedSettings",
        "section": "RaptorXSimulationAdvancedSettings > RaptorXSimulationAdvancedSettings",
        "text": "class pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationAdvancedSettings(edb_setup_info, pedb)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.add_net",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.add_net.html#add_net",
        "title": "add_net",
        "section": "add_net",
        "text": "Add a net.\nThis method is invalid for a differential pair. Use\nansys.edb.core.net.differential_pair.DifferentialPair = (pos_net, neg_net) instead.\nadd_net\nansys.edb.core.net.differential_pair.DifferentialPair"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.add_net",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.add_net.html#pyedb.grpc.database.net.differential_pair.DifferentialPair.add_net",
        "title": "add_net > add_net > add_net",
        "section": "add_net > add_net",
        "text": "DifferentialPair.add_net(net)\n\nAdd a net.\n\nThis method is invalid for a differential pair. Use\nansys.edb.core.net.differential_pair.DifferentialPair = (pos_net, neg_net) instead.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "schema"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.schema.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod DiffPairLengthMatch.schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}') -> Dict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/PortsData",
        "href": "dotnet_api/dotnet/edb_data/PortsData.html#ports",
        "title": "Ports",
        "section": "Ports",
        "text": "These classes are the containers of ports methods of the EDB for both HFSS and SIwave.\nGapPort\nManages gap port properties.\nWavePort\nManages wave port properties.\nPorts\nGapPort\nWavePort"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.place_in_layout_3d_placement",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.place_in_layout_3d_placement.html#place_in_layout_3d_placement",
        "title": "place_in_layout_3d_placement",
        "section": "place_in_layout_3d_placement",
        "text": "Place current Cell into another cell using 3d placement method.\nFlip the current layer stackup of a layout if requested. Transform parameters currently not supported.\nCell on which to place the current layout. If None the Cell will be applied on an empty new Cell.\nThe rotation angle applied on the design.\nThe x offset value.\nThe y offset value.\nEither if the current layout is inverted.\nIf True and place_on_top is True the stackup will be flipped before the merge.\nEither if place the current layout on Top or Bottom of destination Layout.\nSolder Ball or Bumps eight.\nThis value will be added to the elevation to align the two layouts.\nTrue when succeed False if not.\nplace_in_layout_3d_placement\nEdb\ndouble\noptional\ndouble\noptional\ndouble\noptional\noptional\noptional\npython:float\noptional\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.place_in_layout_3d_placement",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.place_in_layout_3d_placement.html#pyedb.dotnet.database.stackup.Stackup.place_in_layout_3d_placement",
        "title": "place_in_layout_3d_placement > place_in_layout_3d_placement > place_in_layout_3d_placement",
        "section": "place_in_layout_3d_placement > place_in_layout_3d_placement",
        "text": "Stackup.place_in_layout_3d_placement(edb, angle=0.0, offset_x=0.0, offset_y=0.0, flipped_stackup=True, place_on_top=True, solder_height=0)\n\nPlace current Cell into another cell using 3d placement method.\nFlip the current layer stackup of a layout if requested. Transform parameters currently not supported.\n\nParameters\n\nedb\n\nEdb\n\nCell on which to place the current layout. If None the Cell will be applied on an empty new Cell.\n\nangle\n\ndouble, optional\n\nThe rotation angle applied on the design.\n\noffset_x\n\ndouble, optional\n\nThe x offset value.\n\noffset_y\n\ndouble, optional\n\nThe y offset value.\n\nflipped_stackup\n\nbool, optional\n\nEither if the current layout is inverted.\nIf True and place_on_top is True the stackup will be flipped before the merge.\n\nplace_on_top\n\nbool, optional\n\nEither if place the current layout on Top or Bottom of destination Layout.\n\nsolder_height\n\npython:float, optional\n\nSolder Ball or Bumps eight.\nThis value will be added to the elevation to align the two layouts.\n\nReturns\n\nbool\n\nTrue when succeed False if not.\n\nExamples\n\n>>> edb1 = Edb(edbpath=targetfile1, edbversion=\"2021.2\")\n>>> edb2 = Edb(edbpath=targetfile2, edbversion=\"2021.2\")\n>>> hosting_cmp = edb1.components.get_component_by_name(\"U100\")\n>>> mounted_cmp = edb2.components.get_component_by_name(\"BGA\")\n>>> edb2.stackup.place_in_layout(\n...     edb1.active_cell,\n...     angle=0.0,\n...     offset_x=\"1mm\",\n...     offset_y=\"2mm\",\n...     flipped_stackup=False,\n...     place_on_top=True,\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.save",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.save.html#save",
        "title": "save",
        "section": "save",
        "text": "Save any changes into a file.\nsave"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.save",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.save.html#pyedb.grpc.edb.Edb.save",
        "title": "save > save > save",
        "section": "save > save",
        "text": "Edb.save()\n\nSave any changes into a file.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.get_variable_desc",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.get_variable_desc.html#get_variable_desc",
        "title": "get_variable_desc",
        "section": "get_variable_desc",
        "text": "Get the description of a variable.\nVariable name.\nDescription of the variable.\nget_variable_desc\npython:str\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.get_variable_desc",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.get_variable_desc.html#pyedb.grpc.database.layout.layout.Layout.get_variable_desc",
        "title": "get_variable_desc > get_variable_desc > get_variable_desc",
        "section": "get_variable_desc > get_variable_desc",
        "text": "Layout.get_variable_desc(name)\n\nGet the description of a variable.\n\nParameters\n\nname\n\npython:str\n\nVariable name.\n\nReturns\n\npython:str\n\nDescription of the variable.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.add_menu_variable",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.add_menu_variable.html#add_menu_variable",
        "title": "add_menu_variable",
        "section": "add_menu_variable",
        "text": "Add a menu variable.\nVariable name.\nEach element can be any type that can be converted to a Value\ninstance.\nWhether the new variable is a parameter. The default is False, which means it is a local variable.\nIndex of the value that is initially selected.\nadd_menu_variable\npython:str\npython:list\npython:str\npython:int\npython:float\ncomplex\nValue\nValue\npython:False\nFalse\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.add_menu_variable",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.add_menu_variable.html#pyedb.grpc.database.layout.cell.Cell.add_menu_variable",
        "title": "add_menu_variable > add_menu_variable > add_menu_variable",
        "section": "add_menu_variable > add_menu_variable",
        "text": "Cell.add_menu_variable(name, values, is_param=False, index=0)\n\nAdd a menu variable.\n\nParameters\n\nname\n\npython:str\n\nVariable name.\n\nvalues\n\npython:list[python:str, python:int, python:float, complex, Value]\n\nEach element can be any type that can be converted to a Value\ninstance.\n\nis_param\n\nbool, default: python:False\n\nWhether the new variable is a parameter. The default is False, which means it is a local variable.\n\nindex\n\npython:int, default: 0\n\nIndex of the value that is initially selected.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.scale",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.scale.html#scale",
        "title": "scale",
        "section": "scale",
        "text": "Scales the polygon relative to a center point by a factor.\nScaling factor.\nIf None scaling is done from polygon center.\nTrue when successful, False when failed.\nscale\npython:float\nList\nof\npython:float\npython:str\noptional\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.scale",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.scale.html#pyedb.grpc.database.primitive.rectangle.Rectangle.scale",
        "title": "scale > scale > scale",
        "section": "scale > scale",
        "text": "Rectangle.scale(factor, center=None) -> bool\n\nScales the polygon relative to a center point by a factor.\n\nParameters\n\nfactor\n\npython:float\n\nScaling factor.\n\ncenter\n\nList of python:float or python:str [x,y], optional\n\nIf None scaling is done from polygon center.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.generate_via_smart_box",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.generate_via_smart_box.html#generate_via_smart_box",
        "title": "generate_via_smart_box",
        "section": "generate_via_smart_box",
        "text": "Generate a via smart box.\nThis method automatically identifies the locations of vias and significant geometry around them.\nName of the net to crawl in the search for vias.\nList of boxes, one around each via discovered.\ngenerate_via_smart_box\npython:str\npython:list\nPolygonData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.generate_via_smart_box",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.generate_via_smart_box.html#pyedb.grpc.database.layout.cell.Cell.generate_via_smart_box",
        "title": "generate_via_smart_box > generate_via_smart_box > generate_via_smart_box",
        "section": "generate_via_smart_box > generate_via_smart_box",
        "text": "Cell.generate_via_smart_box(net_name)\n\nGenerate a via smart box.\n\nThis method automatically identifies the locations of vias and significant geometry around them.\n\nParameters\n\nnet_name\n\npython:str\n\nName of the net to crawl in the search for vias.\n\nReturns\n\npython:list[PolygonData]\n\nList of boxes, one around each via discovered.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.name.html#name",
        "title": "name",
        "section": "name",
        "text": "name"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.name.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.name",
        "title": "name > name > name",
        "section": "name > name",
        "text": "DiffPairLengthMatch.name: str\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.delete",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete one or more nets from EDB.\nOne or more nets to delete.\nList of nets that were deleted.\ndelete\npython:str\npython:list\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.delete",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.delete.html#pyedb.dotnet.database.nets.EdbNets.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "EdbNets.delete(netlist)\n\nDelete one or more nets from EDB.\n\nParameters\n\nnetlist\n\npython:str or python:list\n\nOne or more nets to delete.\n\nReturns\n\npython:list\n\nList of nets that were deleted.\n\nExamples\n\n>>> deleted_nets = database.nets.delete([\"Net1\", \"Net2\"])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_anisotropic_thermal_modifier",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_anisotropic_thermal_modifier.html#set_anisotropic_thermal_modifier",
        "title": "set_anisotropic_thermal_modifier",
        "section": "set_anisotropic_thermal_modifier",
        "text": "Set the thermal modifier of an anisotropic material property.\nType of material property to set the thermal modifier on.\nAnisotropic component ID of the             material property to set the thermal modifier on.\nset_anisotropic_thermal_modifier\nMaterialProperty\npython:int\nMaterialPropertyThermalModifier"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_anisotropic_thermal_modifier",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_anisotropic_thermal_modifier.html#pyedb.grpc.database.definition.materials.Material.set_anisotropic_thermal_modifier",
        "title": "set_anisotropic_thermal_modifier > set_anisotropic_thermal_modifier > set_anisotropic_thermal_modifier",
        "section": "set_anisotropic_thermal_modifier > set_anisotropic_thermal_modifier",
        "text": "Material.set_anisotropic_thermal_modifier(material_property_id, component_id, thermal_modifier)\n\nSet the thermal modifier of an anisotropic material property.\n\nParameters\n\nmaterial_property_id\n\nMaterialProperty\n\nType of material property to set the thermal modifier on.\n\ncomponent_id\n\npython:int\n\nAnisotropic component ID of the             material property to set the thermal modifier on.\n\nthermal_modifier\n\nMaterialPropertyThermalModifier\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kVEye",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kVEye.html#kveye",
        "title": "kVEye",
        "section": "kVEye",
        "text": "kVEye"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kVEye",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kVEye.html#pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kVEye",
        "title": "kVEye > kVEye > kVEye",
        "section": "kVEye > kVEye",
        "text": "SimulationSetupType.kVEye = 'verif_eye'\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_current_source",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_current_source.html#create_current_source",
        "title": "create_current_source",
        "section": "create_current_source",
        "text": "Create a current source.\nPadstackInstanceTerminal or\nPointTerminal or\nPinGroupTerminal.\nPositive terminal of the source.\npyedb.grpc.database.terminals.PadstackInstanceTerminal or\nPadstackInstanceTerminal or\nPinGroupTerminal.\nNegative terminal of the source.\ncreate_current_source\nEdgeTerminal\nor\nPadstackInstanceTerminal\nPointTerminal\nPinGroupTerminal\nEdgeTerminal\nor\npyedb.grpc.database.terminals.PadstackInstanceTerminal\nPadstackInstanceTerminal\nPinGroupTerminal\nExcitationSources"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_current_source",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_current_source.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_current_source",
        "title": "create_current_source > create_current_source > create_current_source",
        "section": "create_current_source > create_current_source",
        "text": "SourceExcitation.create_current_source(terminal: PadstackInstanceTerminal | EdgeTerminal, ref_terminal: PadstackInstanceTerminal | EdgeTerminal) -> bool\n\nCreate a current source.\n\nParameters\n\nterminal\n\nEdgeTerminalor\n\nPadstackInstanceTerminal or\nPointTerminal or\nPinGroupTerminal.\n\nPositive terminal of the source.\n\nref_terminal\n\nEdgeTerminal or\n\npyedb.grpc.database.terminals.PadstackInstanceTerminal or\nPadstackInstanceTerminal or\nPinGroupTerminal.\n\nNegative terminal of the source.\n\nReturns\n\nExcitationSources\n\n\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> edb.source_excitation.create_current_source_on_pin_group(\"PG1\", \"PG2\", 0.1, name=\"ISource1\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.set_all_antipad_value",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.set_all_antipad_value.html#set_all_antipad_value",
        "title": "set_all_antipad_value",
        "section": "set_all_antipad_value",
        "text": "Set anti-pad value for all padstack definitions.\nAnti-pad value with units (e.g., “0.2mm”).\nTrue when successful, False when failed.\nset_all_antipad_value\npython:float\npython:str\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.set_all_antipad_value",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.set_all_antipad_value.html#pyedb.grpc.database.padstacks.Padstacks.set_all_antipad_value",
        "title": "set_all_antipad_value > set_all_antipad_value > set_all_antipad_value",
        "section": "set_all_antipad_value > set_all_antipad_value",
        "text": "Padstacks.set_all_antipad_value(value: float | str) -> bool\n\nSet anti-pad value for all padstack definitions.\n\nParameters\n\nvalue\n\npython:float or python:str\n\nAnti-pad value with units (e.g., “0.2mm”).\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> success = edb_padstacks.set_all_antipad_value(\"0.3mm\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_parametrized_name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nString representing the new class where params are passed to cls as type variables.\nTypeError: Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_parametrized_name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_parametrized_name.html#pyedb.workflows.drc.drc.MinLineWidth.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod MinLineWidth.model_parametrized_name(params: tuple[type[Any], ...]) -> str\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n\nparams: Tuple of types of the class. Given a generic class\n\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturns:\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises:\n\nTypeError: Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef.create",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a padstack definition in a given database.\nDatabase to create the padstack definition in.\nData to set on the padstack definition.\nPadstack definition created.\ncreate\nDatabase\npython:str\nPadstackDef"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef.create",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef.create.html#pyedb.grpc.database.definition.padstack_def.PadstackDef.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod PadstackDef.create(db, name)\n\nCreate a padstack definition in a given database.\n\nParameters\n\ndb\n\nDatabase\n\nDatabase to create the padstack definition in.\n\nname\n\npython:str\n\nData to set on the padstack definition.\n\nReturns\n\nPadstackDef\n\nPadstack definition created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.name.html#name",
        "title": "name",
        "section": "name",
        "text": "Rule identifier (human readable).\nname"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.name.html#pyedb.workflows.drc.drc.MinLineWidth.name",
        "title": "name > name > name",
        "section": "name > name",
        "text": "MinLineWidth.name: str\n\nRule identifier (human readable).\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_model_for_arbitrary_wave_ports",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_model_for_arbitrary_wave_ports.html#create_model_for_arbitrary_wave_ports",
        "title": "create_model_for_arbitrary_wave_ports",
        "section": "create_model_for_arbitrary_wave_ports",
        "text": "Generate EDB design to be consumed by PyAEDT to generate arbitrary wave ports shapes.\nThis model has to be considered as merged onto another one. The current opened design must have voids\nsurrounding the pad-stacks where wave ports terminal will be created. THe open design won’t be edited, only\nprimitives like voids and pads-stack definition included in the voids are collected to generate a new design.\nTemporary directory used during the method execution.\nGives the orientation to be considered for the current design. 2 options are available \"top\" and\n\"bottom\". Default value is ``\"top\". If \"top\" is selected the method will voids at the top signal\nlayer, and the bottom layer if \"bottom\" is used.\nProvides the nets to be included for the model creation. Default value is None. If None is provided,\nall nets will be included.\nWhen None, the terminal diameter is evaluated at each pads-tack instance found inside the voids. The top\nor bottom layer pad diameter will be taken, depending on mounting_side selected. If value is provided,\nit will overwrite the evaluated diameter.\nThe output EDB absolute. If None the edb is created in the temp_directory as default name\n“waveport_model.aedb”`\nLaunching box thickness  used for wave ports. Default value is \"100um\".\nTrue when succeeded, False if failed.\ncreate_model_for_arbitrary_wave_ports\npython:str\npython:str\n\"top\"\n\"bottom\". Default value is ``\"top\"\n\"top\"\n\"bottom\"\nList\npython:str\noptional\nNone\npython:float\npython:str\noptional\nNone\nmounting_side\npython:str\noptional\nNone\ntemp_directory\npython:float\npython:str\noptional\n\"100um\"\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_model_for_arbitrary_wave_ports",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_model_for_arbitrary_wave_ports.html#pyedb.dotnet.edb.Edb.create_model_for_arbitrary_wave_ports",
        "title": "create_model_for_arbitrary_wave_ports > create_model_for_arbitrary_wave_ports > create_model_for_arbitrary_wave_ports",
        "section": "create_model_for_arbitrary_wave_ports > create_model_for_arbitrary_wave_ports",
        "text": "Edb.create_model_for_arbitrary_wave_ports(temp_directory, mounting_side='top', signal_nets=None, terminal_diameter=None, output_edb=None, launching_box_thickness='100um')\n\nGenerate EDB design to be consumed by PyAEDT to generate arbitrary wave ports shapes.\nThis model has to be considered as merged onto another one. The current opened design must have voids\nsurrounding the pad-stacks where wave ports terminal will be created. THe open design won’t be edited, only\nprimitives like voids and pads-stack definition included in the voids are collected to generate a new design.\n\nParameters\n\ntemp_directory\n\npython:str\n\nTemporary directory used during the method execution.\n\nmounting_side\n\npython:str\n\nGives the orientation to be considered for the current design. 2 options are available \"top\" and\n\"bottom\". Default value is ``\"top\". If \"top\" is selected the method will voids at the top signal\nlayer, and the bottom layer if \"bottom\" is used.\n\nsignal_nets\n\nList[python:str], optional\n\nProvides the nets to be included for the model creation. Default value is None. If None is provided,\nall nets will be included.\n\nterminal_diameter\n\npython:float, python:str, optional\n\nWhen None, the terminal diameter is evaluated at each pads-tack instance found inside the voids. The top\nor bottom layer pad diameter will be taken, depending on mounting_side selected. If value is provided,\nit will overwrite the evaluated diameter.\n\noutput_edb\n\npython:str, optional\n\nThe output EDB absolute. If None the edb is created in the temp_directory as default name\n“waveport_model.aedb”`\n\nlaunching_box_thickness\n\npython:float, python:str, optional\n\nLaunching box thickness  used for wave ports. Default value is \"100um\".\n\nReturns\n\nbool\n\nTrue when succeeded, False if failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.make_zone_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.make_zone_primitive.html#make_zone_primitive",
        "title": "make_zone_primitive",
        "section": "make_zone_primitive",
        "text": "Make the primitive a zone primitive with a zone specified by the provided ID.\nID of the zone primitive to use.\nmake_zone_primitive\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.make_zone_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.make_zone_primitive.html#pyedb.grpc.database.primitive.primitive.Primitive.make_zone_primitive",
        "title": "make_zone_primitive > make_zone_primitive > make_zone_primitive",
        "section": "make_zone_primitive > make_zone_primitive",
        "text": "Primitive.make_zone_primitive(zone_id: int)\n\nMake the primitive a zone primitive with a zone specified by the provided ID.\n\nParameters\n\nzone_id\n\npython:int\n\nID of the zone primitive to use.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_voltage_source_on_pin_group",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_voltage_source_on_pin_group.html#create_voltage_source_on_pin_group",
        "title": "create_voltage_source_on_pin_group",
        "section": "create_voltage_source_on_pin_group",
        "text": "Create voltage source between two pin groups.\nName of the positive pin group.\nName of the negative pin group.\nMagnitude of the source.\nPhase of the source\ncreate_voltage_source_on_pin_group\npython:str\npython:str\npython:int\npython:float\noptional\npython:int\npython:float\noptional"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_voltage_source_on_pin_group",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_voltage_source_on_pin_group.html#pyedb.dotnet.database.siwave.EdbSiwave.create_voltage_source_on_pin_group",
        "title": "create_voltage_source_on_pin_group > create_voltage_source_on_pin_group > create_voltage_source_on_pin_group",
        "section": "create_voltage_source_on_pin_group > create_voltage_source_on_pin_group",
        "text": "EdbSiwave.create_voltage_source_on_pin_group(pos_pin_group_name, neg_pin_group_name, magnitude=1, phase=0, name=None, impedance=0.001)\n\nCreate voltage source between two pin groups.\n\nParameters\n\npos_pin_group_name\n\npython:str\n\nName of the positive pin group.\n\nneg_pin_group_name\n\npython:str\n\nName of the negative pin group.\n\nmagnitude\n\npython:int, python:float, optional\n\nMagnitude of the source.\n\nphase\n\npython:int, python:float, optional\n\nPhase of the source\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the padstack instance.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.delete.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "PadstackInstance.delete()\n\nDelete the padstack instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/value",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/value.html#value",
        "title": "Value",
        "section": "Value",
        "text": "This class is managing PyEDB value.\nValue\nClass defining Edb Value properties.\nValue\nValue"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.convert_to_polygon",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.convert_to_polygon.html#convert_to_polygon",
        "title": "convert_to_polygon",
        "section": "convert_to_polygon",
        "text": "Convert path to polygon.\nPolygon when successful, False when failed.\nconvert_to_polygon\nPolygon\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.convert_to_polygon",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.convert_to_polygon.html#pyedb.grpc.database.primitive.primitive.Primitive.convert_to_polygon",
        "title": "convert_to_polygon > convert_to_polygon > convert_to_polygon",
        "section": "convert_to_polygon > convert_to_polygon",
        "text": "Primitive.convert_to_polygon()\n\nConvert path to polygon.\n\nReturns\n\nPolygon\n\nPolygon when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.find_by_name",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.find_by_name.html#find_by_name",
        "title": "find_by_name",
        "section": "find_by_name",
        "text": "Find a net class by name in a given layout.\nLayout to search for the net class.\nName of the net class.\nNet class found. Check the is_null property\nof the returned net class to see if it exists.\nfind_by_name\nLayout\npython:str\nNetClass\nis_null"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.find_by_name",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.find_by_name.html#pyedb.grpc.database.net.net_class.NetClass.find_by_name",
        "title": "find_by_name > find_by_name > find_by_name",
        "section": "find_by_name > find_by_name",
        "text": "classmethod NetClass.find_by_name(layout, name)\n\nFind a net class by name in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the net class.\n\nname\n\npython:str\n\nName of the net class.\n\nReturns\n\nNetClass\n\nNet class found. Check the is_null property\nof the returned net class to see if it exists.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.InterdigitalCapacitor",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.InterdigitalCapacitor.html#interdigitalcapacitor",
        "title": "InterdigitalCapacitor",
        "section": "InterdigitalCapacitor",
        "text": "Inter-digitated comb capacitor with fully parametric fingers.\nAll dimensions are stored as native EDB variables so they remain\neditable inside AEDT after the library cell is imported.\nNumber of finger pairs.\nLength of each finger (string with units).\nWidth of each finger.\nGap between adjacent fingers.\nGap between the two combs at the open end.\nWidth of the top/bottom bus bars.\nLayer on which the capacitor is drawn.\nNet for the bottom comb.\nNet for the top comb.\nInterdigitalCapacitor.create()\nDraw the two bus bars and interleaved fingers.\nInterdigitalCapacitor.VAR_PREFIX\n\nInterdigitalCapacitor\npython:int\ndefault\npython:str\ndefault\npython:str\ndefault\npython:str\ndefault\npython:str\ndefault\npython:str\ndefault\npython:str\ndefault\npython:str\ndefault\npython:str\ndefault\nInterdigitalCapacitor.create\nInterdigitalCapacitor.VAR_PREFIX"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.InterdigitalCapacitor",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.InterdigitalCapacitor.html#pyedb.libraries.rf_libraries.base_functions.InterdigitalCapacitor",
        "title": "InterdigitalCapacitor > InterdigitalCapacitor > InterdigitalCapacitor",
        "section": "InterdigitalCapacitor > InterdigitalCapacitor",
        "text": "class pyedb.libraries.rf_libraries.base_functions.InterdigitalCapacitor(edb_cell: Edb | None = None, fingers: int = 8, finger_length: float | str = '0.9mm', finger_width: float | str = '0.08mm', gap: float | str = '0.04mm', comb_gap: float | str = '0.06mm', bus_width: float | str = '0.25mm', layer: str = 'TOP', net_a: str = 'PORT1', net_b: str = 'PORT2')\n\nInter-digitated comb capacitor with fully parametric fingers.\n\nAll dimensions are stored as native EDB variables so they remain\neditable inside AEDT after the library cell is imported.\n\nParameters\n\nfingers\n\npython:int, default 8\n\nNumber of finger pairs.\n\nfinger_length\n\npython:str, default “0.9 mm”\n\nLength of each finger (string with units).\n\nfinger_width\n\npython:str, default “0.08 mm”\n\nWidth of each finger.\n\ngap\n\npython:str, default “0.04 mm”\n\nGap between adjacent fingers.\n\ncomb_gap\n\npython:str, default “0.06 mm”\n\nGap between the two combs at the open end.\n\nbus_width\n\npython:str, default “0.25 mm”\n\nWidth of the top/bottom bus bars.\n\nlayer\n\npython:str, default “TOP”\n\nLayer on which the capacitor is drawn.\n\nnet_a\n\npython:str, default “PORT1”\n\nNet for the bottom comb.\n\nnet_b\n\npython:str, default “PORT2”\n\nNet for the top comb.\n\nExamples\n\n>>> idc = InterdigitalCapacitor(fingers=10, finger_length=\"0.5mm\", gap=\"0.03mm\")\n>>> edb = Edb(\"idc.aedb\")\n>>> idc._pedb = edb\n>>> idc.create()\n>>> f\"{idc.capacitance_pf:.2f} pF\"\n'0.74 pF'\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nInterdigitalCapacitor.create()\n\nDraw the two bus bars and interleaved fingers.\n\n\n\nAttributes\n\n\n\n\n\n\n\nInterdigitalCapacitor.VAR_PREFIX\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.area",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.area.html#area",
        "title": "area",
        "section": "area",
        "text": "Return the total area.\nEither if the voids have to be included in computation.\nThe default value is True.\narea\noptional\nTrue\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.area",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.area.html#pyedb.grpc.database.primitive.polygon.Polygon.area",
        "title": "area > area > area",
        "section": "area > area",
        "text": "Polygon.area(include_voids=True) -> float\n\nReturn the total area.\n\nParameters\n\ninclude_voids\n\nbool, optional\n\nEither if the voids have to be included in computation.\nThe default value is True.\n\nReturns\n\npython:float\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.set_simulation_settings",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.set_simulation_settings.html#set_simulation_settings",
        "title": "set_simulation_settings",
        "section": "set_simulation_settings",
        "text": "set_simulation_settings"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.set_simulation_settings",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.set_simulation_settings.html#pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.set_simulation_settings",
        "title": "set_simulation_settings > set_simulation_settings > set_simulation_settings",
        "section": "set_simulation_settings > set_simulation_settings",
        "text": "HFSSPISimulationSetup.set_simulation_settings(sim_settings: dict)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.unique_name",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.unique_name.html#unique_name",
        "title": "unique_name",
        "section": "unique_name",
        "text": "Get a unique pin group name in the layout using a given prefix.\nLayout to search for the pin group.\nPrefix of the unique name.\nName of the pin group found.\nunique_name\nLayout\npython:str\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.unique_name",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.unique_name.html#pyedb.grpc.database.hierarchy.pingroup.PinGroup.unique_name",
        "title": "unique_name > unique_name > unique_name",
        "section": "unique_name > unique_name",
        "text": "classmethod PinGroup.unique_name(layout, prefix)\n\nGet a unique pin group name in the layout using a given prefix.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the pin group.\n\nprefix\n\npython:str\n\nPrefix of the unique name.\n\nReturns\n\npython:str\n\nName of the pin group found.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSetups.add_setup",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSetups.add_setup.html#add_setup",
        "title": "add_setup",
        "section": "add_setup",
        "text": "Add a simulation setup.\nSetup name.\nAdaptive frequency.\nCreated setup object.\nadd_setup\npython:str\npython:str\nControlFileSetup"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSetups.add_setup",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSetups.add_setup.html#pyedb.grpc.database.control_file.ControlFileSetups.add_setup",
        "title": "add_setup > add_setup > add_setup",
        "section": "add_setup > add_setup",
        "text": "ControlFileSetups.add_setup(name: str, frequency: str) -> ControlFileSetup\n\nAdd a simulation setup.\n\nParameters\n\nname\n\npython:str\n\nSetup name.\n\nfrequency\n\npython:str\n\nAdaptive frequency.\n\nReturns\n\nControlFileSetup\n\nCreated setup object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.get_product_property_ids.html#pyedb.grpc.database.net.differential_pair.DifferentialPair.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "DifferentialPair.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadProperties",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadProperties.html#padproperties",
        "title": "PadProperties",
        "section": "PadProperties",
        "text": "Manages EDB functionalities for pad properties.\nName of the layer.\nType of the pad.\nInherited AEDT object.\nPadProperties\npython:str\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadProperties",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadProperties.html#pyedb.grpc.database.definition.padstack_def.PadProperties",
        "title": "PadProperties > PadProperties > PadProperties",
        "section": "PadProperties > PadProperties",
        "text": "class pyedb.grpc.database.definition.padstack_def.PadProperties(edb_padstack, layer_name, pad_type, p_edb_padstack)\n\nManages EDB functionalities for pad properties.\n\nParameters\n\nedb_padstack\n\n\n\nlayer_name\n\npython:str\n\nName of the layer.\n\npad_type\n\nType of the pad.\n\npedbpadstack\n\npython:str\n\nInherited AEDT object.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb(myedb, edbversion=\"2021.2\")\n>>> edb_pad_properties = edb.padstacks.definitions[\"MyPad\"].pad_by_layer[\"TOP\"]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.defeature_polygon",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.defeature_polygon.html#defeature_polygon",
        "title": "defeature_polygon",
        "section": "defeature_polygon",
        "text": "Defeature polygon.\nPolygon to defeature.\nMaximum surface deviation tolerance.\nTrue if successful, False otherwise.\ndefeature_polygon\npyedb.dotnet.database.edb_data.primitives_data.Polygon\npython:float\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.defeature_polygon",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.defeature_polygon.html#pyedb.grpc.database.modeler.Modeler.defeature_polygon",
        "title": "defeature_polygon > defeature_polygon > defeature_polygon",
        "section": "defeature_polygon > defeature_polygon",
        "text": "Modeler.defeature_polygon(poly: Polygon, tolerance: float = 0.001) -> bool\n\nDefeature polygon.\n\nParameters\n\npoly\n\npyedb.dotnet.database.edb_data.primitives_data.Polygon\n\nPolygon to defeature.\n\ntolerance\n\npython:float, optional\n\nMaximum surface deviation tolerance.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs for a given product ID for the layer.\nProduct ID.\nList of attribute IDs.\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_product_property_ids.html#pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "StackupLayer.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs for a given product ID for the layer.\n\nParameters\n\nprod_id\n\nProductIdType\n\nProduct ID.\n\nReturns\n\npython:list[python:int]\n\nList of attribute IDs.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.expand",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.expand.html#expand",
        "title": "expand",
        "section": "expand",
        "text": "Expand the polygon shape by an absolute value in all direction.\nOffset can be negative for negative expansion.\nOffset value in meters.\nTolerance in meters.\nWhether to round corners or not.\nIf True, use rounded corners in the expansion otherwise use straight edges (can be degenerate).\nThe maximum corner extension (when round corners are not used) at which point the corner is clipped.\nexpand\npython:float\noptional\npython:float\noptional\noptional\npython:float\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.expand",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.expand.html#pyedb.grpc.database.primitive.circle.Circle.expand",
        "title": "expand > expand > expand",
        "section": "expand > expand",
        "text": "Circle.expand(offset=0.001, tolerance=1e-12, round_corners=True, maximum_corner_extension=0.001) -> list[any]\n\nExpand the polygon shape by an absolute value in all direction.\nOffset can be negative for negative expansion.\n\nParameters\n\noffset\n\npython:float, optional\n\nOffset value in meters.\n\ntolerance\n\npython:float, optional\n\nTolerance in meters.\n\nround_corners\n\nbool, optional\n\nWhether to round corners or not.\nIf True, use rounded corners in the expansion otherwise use straight edges (can be degenerate).\n\nmaximum_corner_extension\n\npython:float, optional\n\nThe maximum corner extension (when round corners are not used) at which point the corner is clipped.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.layout_obj_type.html#pyedb.grpc.database.layout.cell.Cell.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "Cell.layout_obj_type = 10\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.set_product_property.html#pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "VoltageRegulator.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.html#excitationsources",
        "title": "ExcitationSources",
        "section": "ExcitationSources",
        "text": "Manage sources properties.\nEdb object from Edblib.\nEdge terminal instance from Edb.\nThis example shows how to access this class.\n>>> from pyedb import Edb\n>>> edb = Edb(“myaedb.aedb”)\n>>> all_sources = edb.sources\n>>> print(all_sources[“VSource1”].name)\nExcitationSources.delete()\nDelete this primitive.\nExcitationSources.get_connected_object_id_set()\nProduce a list of all geometries physically connected to a given layout object.\nExcitationSources.get_connected_objects()\nGet connected objects.\nExcitationSources.get_edge_terminal_reference_primitive()\nCheck and  return a primitive instance that serves Edge ports, wave ports and coupled edge ports that are directly connedted to primitives.\nExcitationSources.get_pad_edge_terminal_reference_pin([...])\nGet the closest pin padstack instances and serves any edge terminal connected to a pad.\nExcitationSources.get_padstack_terminal_reference_pin([...])\nGet a list of pad stacks instances and serves Coax wave ports, pingroup terminals, PadEdge terminals.\nExcitationSources.get_pin_group_terminal_reference_pin([...])\nReturn a list of pins and serves terminals connected to pingroups.\nExcitationSources.get_point_terminal_reference_primitive()\nFind and return the primitive reference for the point terminal or the padstack instance.\nExcitationSources\npyedb.edb.Edb\nAnsys.Ansoft.Edb.Cell.Terminal.EdgeTerminal\nExcitationSources.delete\nExcitationSources.get_connected_object_id_set\nExcitationSources.get_connected_objects\nExcitationSources.get_edge_terminal_reference_primitive\nExcitationSources.get_pad_edge_terminal_reference_pin\nExcitationSources.get_padstack_terminal_reference_pin\nExcitationSources.get_pin_group_terminal_reference_pin\nExcitationSources.get_point_terminal_reference_primitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.html#pyedb.grpc.database.ports.ports.ExcitationSources",
        "title": "ExcitationSources > ExcitationSources > ExcitationSources",
        "section": "ExcitationSources > ExcitationSources",
        "text": "class pyedb.grpc.database.ports.ports.ExcitationSources(pedb, edb_terminal)\n\nManage sources properties.\n\nParameters\n\npedb\n\npyedb.edb.Edb\n\nEdb object from Edblib.\n\nedb_terminal\n\nAnsys.Ansoft.Edb.Cell.Terminal.EdgeTerminal\n\nEdge terminal instance from Edb.\n\nExamples\n\nThis example shows how to access this class.\n>>> from pyedb import Edb\n>>> edb = Edb(“myaedb.aedb”)\n>>> all_sources = edb.sources\n>>> print(all_sources[“VSource1”].name)\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nExcitationSources.delete()\n\nDelete this primitive.\n\nExcitationSources.get_connected_object_id_set()\n\nProduce a list of all geometries physically connected to a given layout object.\n\nExcitationSources.get_connected_objects()\n\nGet connected objects.\n\nExcitationSources.get_edge_terminal_reference_primitive()\n\nCheck and  return a primitive instance that serves Edge ports, wave ports and coupled edge ports that are directly connedted to primitives.\n\nExcitationSources.get_pad_edge_terminal_reference_pin([...])\n\nGet the closest pin padstack instances and serves any edge terminal connected to a pad.\n\nExcitationSources.get_padstack_terminal_reference_pin([...])\n\nGet a list of pad stacks instances and serves Coax wave ports, pingroup terminals, PadEdge terminals.\n\nExcitationSources.get_pin_group_terminal_reference_pin([...])\n\nReturn a list of pins and serves terminals connected to pingroups.\n\nExcitationSources.get_point_terminal_reference_primitive()\n\nFind and return the primitive reference for the point terminal or the padstack instance.\n\n"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_config",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_config",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_config.html#pyedb.workflows.drc.drc.MinLineWidth.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "MinLineWidth.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.AdaptiveSettings.add_broadband_adaptive_frequency_data",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.AdaptiveSettings.add_broadband_adaptive_frequency_data.html#add_broadband_adaptive_frequency_data",
        "title": "add_broadband_adaptive_frequency_data",
        "section": "add_broadband_adaptive_frequency_data",
        "text": "Add a setup for frequency data.\nFrequency with units or float frequency (in Hz).\nFrequency with units or float frequency (in Hz).\nMaximum number of passes. The default is 10.\nMaximum delta S. The default is 0.02.\nTrue if method is successful, False otherwise.\nadd_broadband_adaptive_frequency_data\npython:str\npython:float\npython:str\npython:float\npython:int\noptional\n10\npython:float\noptional\n0.02\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.AdaptiveSettings.add_broadband_adaptive_frequency_data",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.AdaptiveSettings.add_broadband_adaptive_frequency_data.html#pyedb.dotnet.database.sim_setup_data.data.settings.AdaptiveSettings.add_broadband_adaptive_frequency_data",
        "title": "add_broadband_adaptive_frequency_data > add_broadband_adaptive_frequency_data > add_broadband_adaptive_frequency_data",
        "section": "add_broadband_adaptive_frequency_data > add_broadband_adaptive_frequency_data",
        "text": "AdaptiveSettings.add_broadband_adaptive_frequency_data(low_frequency=0, high_frequency=10000000000.0, max_num_passes=10, max_delta_s=0.02)\n\nAdd a setup for frequency data.\n\nParameters\n\nlow_frequency\n\npython:str, python:float\n\nFrequency with units or float frequency (in Hz).\n\nhigh_frequency\n\npython:str, python:float\n\nFrequency with units or float frequency (in Hz).\n\nmax_num_passes\n\npython:int, optional\n\nMaximum number of passes. The default is 10.\n\nmax_delta_s\n\npython:float, optional\n\nMaximum delta S. The default is 0.02.\n\nReturns\n\nbool\n\nTrue if method is successful, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.get_product_property_ids.html#pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "PinGroupTerminal.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_circle",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_circle.html#create_circle",
        "title": "create_circle",
        "section": "create_circle",
        "text": "Create circle primitive.\nLayer name.\nCenter x-coordinate.\nCenter y-coordinate.\nCircle radius.\nAssociated net name.\nCircle object if created, False otherwise.\ncreate_circle\npython:str\npython:float\npython:float\npython:float\npython:str\noptional\npyedb.dotnet.database.edb_data.primitives_data.Circle"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_circle",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_circle.html#pyedb.grpc.database.modeler.Modeler.create_circle",
        "title": "create_circle > create_circle > create_circle",
        "section": "create_circle > create_circle",
        "text": "Modeler.create_circle(layer_name: str, x: float | str, y: float | str, radius: float | str, net_name: str = '') -> Primitive | None\n\nCreate circle primitive.\n\nParameters\n\nlayer_name\n\npython:str\n\nLayer name.\n\nx\n\npython:float\n\nCenter x-coordinate.\n\ny\n\npython:float\n\nCenter y-coordinate.\n\nradius\n\npython:float\n\nCircle radius.\n\nnet_name\n\npython:str, optional\n\nAssociated net name.\n\nReturns\n\npyedb.dotnet.database.edb_data.primitives_data.Circle or bool\n\nCircle object if created, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.create_port",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.create_port.html#create_port",
        "title": "create_port",
        "section": "create_port",
        "text": "Create a port on the padstack.\nName of the port. The default is None, in which case a name is automatically assigned.\nNegative terminal of the port.\nWhether it is a circuit port.\ncreate_port\npython:str\noptional\nNone\noptional"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.create_port",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.create_port.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.create_port",
        "title": "create_port > create_port > create_port",
        "section": "create_port > create_port",
        "text": "EDBPadstackInstance.create_port(name=None, reference=None, is_circuit_port=False)\n\nCreate a port on the padstack.\n\nParameters\n\nname\n\npython:str, optional\n\nName of the port. The default is None, in which case a name is automatically assigned.\n\nreference\n\nclass:pyedb.dotnet.database.edb_data.nets_data.EDBNetsData,             class:pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance,             class:pyedb.dotnet.database.edb_data.sources.PinGroup, optional\n\nNegative terminal of the port.\n\nis_circuit_port\n\nbool, optional\n\nWhether it is a circuit port.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_validate_json",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data: The JSON data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nThe validated Pydantic model.\nValidationError: If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_validate_json",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_validate_json.html#pyedb.grpc.database.definition.materials.MaterialProperties.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod MaterialProperties.model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n\njson_data: The JSON data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nReturns:\n\nThe validated Pydantic model.\n\nRaises:\n\nValidationError: If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFile",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFile.html#controlfile",
        "title": "ControlFile",
        "section": "ControlFile",
        "text": "Main class for EDB control file creation and management.\nPath to existing XML file to parse.\nPath to technology file to convert.\nPath to layer map file.\nControlFile.parse_layer_map(layer_map)\nParse a layer map file and update stackup.\nControlFile.parse_technology(tecnhology[, ...])\nParse a technology file and convert to XML control file.\nControlFile.parse_xml(xml_input)\nParse an XML control file and populate the object.\nControlFile.write_xml(xml_output)\nWrite control file to XML.\nControlFile\npython:str\noptional\npython:str\noptional\npython:str\noptional\nControlFile.parse_layer_map\nControlFile.parse_technology\nControlFile.parse_xml\nControlFile.write_xml"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFile",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFile.html#pyedb.grpc.database.control_file.ControlFile",
        "title": "ControlFile > ControlFile > ControlFile",
        "section": "ControlFile > ControlFile",
        "text": "class pyedb.grpc.database.control_file.ControlFile(xml_input: str | None = None, technology: str | None = None, layer_map: str | None = None)\n\nMain class for EDB control file creation and management.\n\nParameters\n\nxml_input\n\npython:str, optional\n\nPath to existing XML file to parse.\n\ntecnhology\n\npython:str, optional\n\nPath to technology file to convert.\n\nlayer_map\n\npython:str, optional\n\nPath to layer map file.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nControlFile.parse_layer_map(layer_map)\n\nParse a layer map file and update stackup.\n\nControlFile.parse_technology(tecnhology[, ...])\n\nParse a technology file and convert to XML control file.\n\nControlFile.parse_xml(xml_input)\n\nParse an XML control file and populate the object.\n\nControlFile.write_xml(xml_output)\n\nWrite control file to XML.\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_hfss_ports_on_padstack",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_hfss_ports_on_padstack.html#create_hfss_ports_on_padstack",
        "title": "create_hfss_ports_on_padstack",
        "section": "create_hfss_ports_on_padstack",
        "text": "Create an HFSS port on a padstack.\nPosition of the pin.\nName of the port. The default is None.\nTrue when successful, False when failed.\ncreate_hfss_ports_on_padstack\npython:str\noptional\nNone\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_hfss_ports_on_padstack",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_hfss_ports_on_padstack.html#pyedb.dotnet.database.hfss.EdbHfss.create_hfss_ports_on_padstack",
        "title": "create_hfss_ports_on_padstack > create_hfss_ports_on_padstack > create_hfss_ports_on_padstack",
        "section": "create_hfss_ports_on_padstack > create_hfss_ports_on_padstack",
        "text": "EdbHfss.create_hfss_ports_on_padstack(pinpos, portname=None)\n\nCreate an HFSS port on a padstack.\n\nParameters\n\npinpos\n\nPosition of the pin.\n\nportname\n\npython:str, optional\n\nName of the port. The default is None.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileComponent.add_pin",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileComponent.add_pin.html#add_pin",
        "title": "add_pin",
        "section": "add_pin",
        "text": "add_pin"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileComponent.add_pin",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileComponent.add_pin.html#pyedb.grpc.database.utility.xml_control_file.ControlFileComponent.add_pin",
        "title": "add_pin > add_pin > add_pin",
        "section": "add_pin > add_pin",
        "text": "ControlFileComponent.add_pin(name, x, y, layer)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.clone",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.clone.html#clone",
        "title": "clone",
        "section": "clone",
        "text": "Clone a primitive object with keeping same definition and location.\nTrue when successful, False when failed.\nclone\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.clone",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.clone.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.clone",
        "title": "clone > clone > clone",
        "section": "clone > clone",
        "text": "EdbPolygon.clone()\n\nClone a primitive object with keeping same definition and location.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.get_trace_width_for_traces_with_ports",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.get_trace_width_for_traces_with_ports.html#get_trace_width_for_traces_with_ports",
        "title": "get_trace_width_for_traces_with_ports",
        "section": "get_trace_width_for_traces_with_ports",
        "text": "Retrieve the trace width for traces with ports.\nDictionary of trace width data.\nget_trace_width_for_traces_with_ports\npython:dict"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.get_trace_width_for_traces_with_ports",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.get_trace_width_for_traces_with_ports.html#pyedb.dotnet.database.hfss.EdbHfss.get_trace_width_for_traces_with_ports",
        "title": "get_trace_width_for_traces_with_ports > get_trace_width_for_traces_with_ports > get_trace_width_for_traces_with_ports",
        "section": "get_trace_width_for_traces_with_ports > get_trace_width_for_traces_with_ports",
        "text": "EdbHfss.get_trace_width_for_traces_with_ports()\n\nRetrieve the trace width for traces with ports.\n\nReturns\n\npython:dict\n\nDictionary of trace width data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/ports",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/ports.html#ports",
        "title": "Ports",
        "section": "Ports",
        "text": "This class is managing EDB ports.\nGapPort\nManages gap port properties.\nCircuitPort\nManages gap port properties. Parameters ---------- pedb : pyedb.edb.Edb     EDB object from the Edblib library. edb_object : Ansys.Ansoft.Edb.Cell.Terminal.EdgeTerminal     Edge terminal instance from EDB. Examples -------- This example shows how to access the GapPort class.\nWavePort\nManages wave port properties.\nExcitationSources\nManage sources properties.\nBundleWavePort\nManages bundle wave port properties.\nCoaxPort\nManages bundle wave port properties.\nPorts\nGapPort\nCircuitPort\nEdblib\nGapPort\nWavePort\nExcitationSources\nBundleWavePort\nCoaxPort"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kAMI",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kAMI.html#kami",
        "title": "kAMI",
        "section": "kAMI",
        "text": "kAMI"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kAMI",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kAMI.html#pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kAMI",
        "title": "kAMI > kAMI > kAMI",
        "section": "kAMI > kAMI",
        "text": "SimulationSetupType.kAMI = 'ami'\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.add_cpa_analysis",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.add_cpa_analysis.html#add_cpa_analysis",
        "title": "add_cpa_analysis",
        "section": "add_cpa_analysis",
        "text": "add_cpa_analysis"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.add_cpa_analysis",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.add_cpa_analysis.html#pyedb.dotnet.database.siwave.EdbSiwave.add_cpa_analysis",
        "title": "add_cpa_analysis > add_cpa_analysis > add_cpa_analysis",
        "section": "add_cpa_analysis > add_cpa_analysis",
        "text": "EdbSiwave.add_cpa_analysis(name=None, siwave_cpa_setup_class=None)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.import_definition",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.import_definition.html#import_definition",
        "title": "import_definition",
        "section": "import_definition",
        "text": "Import component definition from json file.\nFile path of json file.\nimport_definition\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.import_definition",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.import_definition.html#pyedb.dotnet.database.components.Components.import_definition",
        "title": "import_definition > import_definition > import_definition",
        "section": "import_definition > import_definition",
        "text": "Components.import_definition(file_path)\n\nImport component definition from json file.\n\nParameters\n\nfile_path\n\npython:str\n\nFile path of json file.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_connected_object_id_set",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_connected_object_id_set.html#get_connected_object_id_set",
        "title": "get_connected_object_id_set",
        "section": "get_connected_object_id_set",
        "text": "Produce a list of all geometries physically connected to a given layout object.\nFound connected objects IDs with Layout object.\nget_connected_object_id_set\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_connected_object_id_set",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_connected_object_id_set.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_connected_object_id_set",
        "title": "get_connected_object_id_set > get_connected_object_id_set > get_connected_object_id_set",
        "section": "get_connected_object_id_set > get_connected_object_id_set",
        "text": "EDBPadstackInstance.get_connected_object_id_set()\n\nProduce a list of all geometries physically connected to a given layout object.\n\nReturns\n\npython:list\n\nFound connected objects IDs with Layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.html#simulationsetup",
        "title": "SimulationSetup",
        "section": "SimulationSetup",
        "text": "Provide base simulation setup.\nInherited object.\nEDB object.\nSimulationSetup.add_frequency_sweep([name, ...])\nAdd frequency sweep.\nSimulationSetup.add_sweep([name, ...])\nAdd frequency sweep.\nSimulationSetup.delete()\nDelete current simulation setup.\nSimulationSetup.delete_frequency_sweep(...)\nDelete a frequency sweep.\nSimulationSetup.get_simulation_settings()\n\nSimulationSetup.set_sim_setup_info(...)\n\nSimulationSetup.set_simulation_settings(...)\n\nSimulationSetup\npyedb.dotnet.edb.Edb\nAnsys.Ansoft.Edb.Utility.SIWaveSimulationSetup\nSimulationSetup.add_frequency_sweep\nSimulationSetup.add_sweep\nSimulationSetup.delete\nSimulationSetup.delete_frequency_sweep\nSimulationSetup.get_simulation_settings\nSimulationSetup.set_sim_setup_info\nSimulationSetup.set_simulation_settings"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.html#pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup",
        "title": "SimulationSetup > SimulationSetup > SimulationSetup",
        "section": "SimulationSetup > SimulationSetup",
        "text": "class pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup(pedb, edb_object=None)\n\nProvide base simulation setup.\n\nParameters\n\npedb\n\npyedb.dotnet.edb.Edb\n\nInherited object.\n\nedb_object\n\nAnsys.Ansoft.Edb.Utility.SIWaveSimulationSetup,\n\n\n\n:class:`Ansys.Ansoft.Edb.Utility.SIWDCIRSimulationSettings`,\n\n\n\n:class:`Ansys.Ansoft.Edb.Utility.HFSSSimulationSettings`\n\nEDB object.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nSimulationSetup.add_frequency_sweep([name, ...])\n\nAdd frequency sweep.\n\nSimulationSetup.add_sweep([name, ...])\n\nAdd frequency sweep.\n\nSimulationSetup.delete()\n\nDelete current simulation setup.\n\nSimulationSetup.delete_frequency_sweep(...)\n\nDelete a frequency sweep.\n\nSimulationSetup.get_simulation_settings()\n\n\n\nSimulationSetup.set_sim_setup_info(...)\n\n\n\nSimulationSetup.set_simulation_settings(...)\n\n\n\n"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.Substrate.size",
        "href": "libraries/_autosummary/pyedb.libraries.common.Substrate.size.html#size",
        "title": "size",
        "section": "size",
        "text": "size"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.Substrate.size",
        "href": "libraries/_autosummary/pyedb.libraries.common.Substrate.size.html#pyedb.libraries.common.Substrate.size",
        "title": "size > size > size",
        "section": "size > size",
        "text": "Substrate.size: Tuple[float, float] = (0.001, 0.001)\n\n"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.copy_zones",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.copy_zones.html#copy_zones",
        "title": "copy_zones",
        "section": "copy_zones",
        "text": "Copy multi-zone EDB project to one new edb per zone.\nDirectory path where all EDB project are copied, if empty will use the current EDB project.\nReturn a dictionary with edb path as key and tuple Zone Id as first item and EDB polygon Data defining\nthe region as second item.\ncopy_zones\npython:str\npython:dict\npython:str\npython:tuple"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.copy_zones",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.copy_zones.html#pyedb.grpc.edb.Edb.copy_zones",
        "title": "copy_zones > copy_zones > copy_zones",
        "section": "copy_zones > copy_zones",
        "text": "Edb.copy_zones(working_directory=None) -> dict[str, tuple[int, PolygonData]]\n\nCopy multi-zone EDB project to one new edb per zone.\n\nParameters\n\nworking_directory\n\npython:str\n\nDirectory path where all EDB project are copied, if empty will use the current EDB project.\n\nReturns\n\npython:dict[python:str, python:tuple[int,:class:PolygonData <ansys.edb.core.geometry.polygon_data.PolygonData>]]\n\nReturn a dictionary with edb path as key and tuple Zone Id as first item and EDB polygon Data defining\nthe region as second item.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.import_definition",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.import_definition.html#import_definition",
        "title": "import_definition",
        "section": "import_definition",
        "text": "Import component definitions from a JSON file.\nPath to the JSON file.\nTrue if successful, False otherwise.\nimport_definition\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.import_definition",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.import_definition.html#pyedb.grpc.database.components.Components.import_definition",
        "title": "import_definition > import_definition > import_definition",
        "section": "import_definition > import_definition",
        "text": "Components.import_definition(file_path) -> bool\n\nImport component definitions from a JSON file.\n\nParameters\n\nfile_path\n\npython:str\n\nPath to the JSON file.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\nExamples\n\n>>> edbapp.components.import_definition(\"definitions.json\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.add_member",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.add_member.html#add_member",
        "title": "add_member",
        "section": "add_member",
        "text": "Add an object to the group.\nObject to add to the group.\nadd_member"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.add_member",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.add_member.html#pyedb.grpc.database.hierarchy.component.Component.add_member",
        "title": "add_member > add_member > add_member",
        "section": "add_member > add_member",
        "text": "Component.add_member(member)\n\nAdd an object to the group.\n\nParameters\n\nmember\n\nConnectable\n\nObject to add to the group.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.is_intersecting",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.is_intersecting.html#is_intersecting",
        "title": "is_intersecting",
        "section": "is_intersecting",
        "text": "Check if actual primitive and another primitive or polygon data intesects.\nis_intersecting\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.is_intersecting",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.is_intersecting.html#pyedb.grpc.database.primitive.polygon.Polygon.is_intersecting",
        "title": "is_intersecting > is_intersecting > is_intersecting",
        "section": "is_intersecting > is_intersecting",
        "text": "Polygon.is_intersecting(primitive) -> bool\n\nCheck if actual primitive and another primitive or polygon data intesects.\n\nParameters\n\nprimitive\n\nPrimitive or PolygonData\n\n\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.check_before_terminal_assignement",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.check_before_terminal_assignement.html#check_before_terminal_assignement",
        "title": "check_before_terminal_assignement",
        "section": "check_before_terminal_assignement",
        "text": "check_before_terminal_assignement"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.check_before_terminal_assignement",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.check_before_terminal_assignement.html#pyedb.grpc.database.source_excitations.SourceExcitation.check_before_terminal_assignement",
        "title": "check_before_terminal_assignement > check_before_terminal_assignement > check_before_terminal_assignement",
        "section": "check_before_terminal_assignement > check_before_terminal_assignement",
        "text": "SourceExcitation.check_before_terminal_assignement(connectable: Any, delete_existing_terminal: bool = False) -> bool\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_document_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_document_layer.html#add_document_layer",
        "title": "add_document_layer",
        "section": "add_document_layer",
        "text": "Add a document layer.\nName of the layer.\nType of the layer. The default is \"user\". Options are \"user\" and \"outline\".\nAdditional keyword arguments.\nLayer object created.\nadd_document_layer\npython:str\npython:str\noptional\n\"user\"\n\"user\"\n\"outline\"\npython:dict\noptional\npyedb.grpc.database.layers.layer.Layer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_document_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_document_layer.html#pyedb.grpc.database.stackup.Stackup.add_document_layer",
        "title": "add_document_layer > add_document_layer > add_document_layer",
        "section": "add_document_layer > add_document_layer",
        "text": "Stackup.add_document_layer(name: str, layer_type: str = 'user', **kwargs: Any) -> Layer | None\n\nAdd a document layer.\n\nParameters\n\nname\n\npython:str\n\nName of the layer.\n\nlayer_type\n\npython:str, optional\n\nType of the layer. The default is \"user\". Options are \"user\" and \"outline\".\n\n**kwargs\n\npython:dict, optional\n\nAdditional keyword arguments.\n\nReturns\n\npyedb.grpc.database.layers.layer.Layer\n\nLayer object created.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> outline_layer = edb.stackup.add_document_layer(\"Outline\", layer_type=\"outline\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the layout object.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.delete.html#pyedb.grpc.database.hierarchy.pingroup.PinGroup.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "PinGroup.delete()\n\nDelete the layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.InterdigitalCapacitor.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.InterdigitalCapacitor.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Draw the two bus bars and interleaved fingers.\nTrue on success.\ncreate"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.InterdigitalCapacitor.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.InterdigitalCapacitor.create.html#pyedb.libraries.rf_libraries.base_functions.InterdigitalCapacitor.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "InterdigitalCapacitor.create() -> bool\n\nDraw the two bus bars and interleaved fingers.\n\nReturns\n\nbool\n\nTrue on success.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.html#minannularring",
        "title": "MinAnnularRing",
        "section": "MinAnnularRing",
        "text": "Minimum annular ring for drilled holes.\nMinAnnularRing.construct([_fields_set])\n\nMinAnnularRing.copy(*[, include, exclude, ...])\nReturns a copy of the model.\nMinAnnularRing.dict(*[, include, exclude, ...])\n\nMinAnnularRing.from_orm(obj)\n\nMinAnnularRing.json(*[, include, exclude, ...])\n\nMinAnnularRing.model_construct([_fields_set])\nCreates a new instance of the Model class with validated data.\nMinAnnularRing.model_copy(*[, update, deep])\n!!! abstract \"Usage Documentation\"\nMinAnnularRing.model_dump(*[, mode, ...])\n!!! abstract \"Usage Documentation\"\nMinAnnularRing.model_dump_json(*[, indent, ...])\n!!! abstract \"Usage Documentation\"\nMinAnnularRing.model_json_schema([by_alias, ...])\nGenerates a JSON schema for a model class.\nMinAnnularRing.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nMinAnnularRing.model_post_init(context, /)\nOverride this method to perform additional initialization after __init__ and model_construct.\nMinAnnularRing.model_rebuild(*[, force, ...])\nTry to rebuild the pydantic-core schema for the model.\nMinAnnularRing.model_validate(obj, *[, ...])\nValidate a pydantic model instance.\nMinAnnularRing.model_validate_json(json_data, *)\n!!! abstract \"Usage Documentation\"\nMinAnnularRing.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nMinAnnularRing.parse_file(path, *[, ...])\n\nMinAnnularRing.parse_obj(obj)\n\nMinAnnularRing.parse_raw(b, *[, ...])\n\nMinAnnularRing.schema([by_alias, ref_template])\n\nMinAnnularRing.schema_json(*[, by_alias, ...])\n\nMinAnnularRing.update_forward_refs(**localns)\n\nMinAnnularRing.validate(value)\n\nMinAnnularRing.model_computed_fields\n\nMinAnnularRing.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nMinAnnularRing.model_fields\n\nMinAnnularRing.name\n\nMinAnnularRing.value\n\nMinAnnularRing\nMinAnnularRing.construct\nMinAnnularRing.copy\nMinAnnularRing.dict\nMinAnnularRing.from_orm\nMinAnnularRing.json\nMinAnnularRing.model_construct\nMinAnnularRing.model_copy\nMinAnnularRing.model_dump\nMinAnnularRing.model_dump_json\nMinAnnularRing.model_json_schema\nMinAnnularRing.model_parametrized_name\nMinAnnularRing.model_post_init\nMinAnnularRing.model_rebuild\nMinAnnularRing.model_validate\nMinAnnularRing.model_validate_json\nMinAnnularRing.model_validate_strings\nMinAnnularRing.parse_file\nMinAnnularRing.parse_obj\nMinAnnularRing.parse_raw\nMinAnnularRing.schema\nMinAnnularRing.schema_json\nMinAnnularRing.update_forward_refs\nMinAnnularRing.validate\nMinAnnularRing.model_computed_fields\nMinAnnularRing.model_config\nMinAnnularRing.model_fields\nMinAnnularRing.name\nMinAnnularRing.value"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.html#pyedb.workflows.drc.drc.MinAnnularRing",
        "title": "MinAnnularRing > MinAnnularRing > MinAnnularRing",
        "section": "MinAnnularRing > MinAnnularRing",
        "text": "class pyedb.workflows.drc.drc.MinAnnularRing(*, name: str, value: str)\n\nMinimum annular ring for drilled holes.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nMinAnnularRing.construct([_fields_set])\n\n\n\nMinAnnularRing.copy(*[, include, exclude, ...])\n\nReturns a copy of the model.\n\nMinAnnularRing.dict(*[, include, exclude, ...])\n\n\n\nMinAnnularRing.from_orm(obj)\n\n\n\nMinAnnularRing.json(*[, include, exclude, ...])\n\n\n\nMinAnnularRing.model_construct([_fields_set])\n\nCreates a new instance of the Model class with validated data.\n\nMinAnnularRing.model_copy(*[, update, deep])\n\n!!! abstract \"Usage Documentation\"\n\nMinAnnularRing.model_dump(*[, mode, ...])\n\n!!! abstract \"Usage Documentation\"\n\nMinAnnularRing.model_dump_json(*[, indent, ...])\n\n!!! abstract \"Usage Documentation\"\n\nMinAnnularRing.model_json_schema([by_alias, ...])\n\nGenerates a JSON schema for a model class.\n\nMinAnnularRing.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nMinAnnularRing.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nMinAnnularRing.model_rebuild(*[, force, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nMinAnnularRing.model_validate(obj, *[, ...])\n\nValidate a pydantic model instance.\n\nMinAnnularRing.model_validate_json(json_data, *)\n\n!!! abstract \"Usage Documentation\"\n\nMinAnnularRing.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nMinAnnularRing.parse_file(path, *[, ...])\n\n\n\nMinAnnularRing.parse_obj(obj)\n\n\n\nMinAnnularRing.parse_raw(b, *[, ...])\n\n\n\nMinAnnularRing.schema([by_alias, ref_template])\n\n\n\nMinAnnularRing.schema_json(*[, by_alias, ...])\n\n\n\nMinAnnularRing.update_forward_refs(**localns)\n\n\n\nMinAnnularRing.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nMinAnnularRing.model_computed_fields\n\n\n\nMinAnnularRing.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nMinAnnularRing.model_fields\n\n\n\nMinAnnularRing.name\n\n\n\nMinAnnularRing.value\n\n\n\n"
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#user-guide",
        "title": "User Guide",
        "section": "User Guide",
        "text": "This guide explains the core concepts of PyEDB and Ansys EDB to help you build effective automation scripts.\nUser Guide"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.product_solver_names",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.product_solver_names.html#product_solver_names",
        "title": "product_solver_names",
        "section": "product_solver_names",
        "text": "Get the list of solver names.\nID of the product.\nproduct_solver_names\nProductIdType\npython:list\nof\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.product_solver_names",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.product_solver_names.html#pyedb.grpc.database.ports.ports.BundleWavePort.product_solver_names",
        "title": "product_solver_names > product_solver_names > product_solver_names",
        "section": "product_solver_names > product_solver_names",
        "text": "BundleWavePort.product_solver_names(product_id)\n\nGet the list of solver names.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nReturns\n\npython:list of python:str\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_debye_model",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_debye_model.html#set_debye_model",
        "title": "set_debye_model",
        "section": "set_debye_model",
        "text": "Set Debye model on current material.\nset_debye_model"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_debye_model",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_debye_model.html#pyedb.grpc.database.definition.materials.Material.set_debye_model",
        "title": "set_debye_model > set_debye_model > set_debye_model",
        "section": "set_debye_model > set_debye_model",
        "text": "Material.set_debye_model()\n\nSet Debye model on current material.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_dc_simulation_report",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_dc_simulation_report.html#export_dc_simulation_report",
        "title": "export_dc_simulation_report",
        "section": "export_dc_simulation_report",
        "text": "Export the Siwave DC simulation report.\nName of the setup.\nPath to the exported report.\nColor of the report’s background. The default is \"White\".\nTrue when successful, False when failed.\nexport_dc_simulation_report\npython:str\npython:str\npython:str\noptional\n\"White\"\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_dc_simulation_report",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_dc_simulation_report.html#pyedb.siwave.Siwave.export_dc_simulation_report",
        "title": "export_dc_simulation_report > export_dc_simulation_report > export_dc_simulation_report",
        "section": "export_dc_simulation_report > export_dc_simulation_report",
        "text": "Siwave.export_dc_simulation_report(simulation_name, file_path, background_color='White')\n\nExport the Siwave DC simulation report.\n\nParameters\n\nsimulation_name\n\npython:str\n\nName of the setup.\n\nfile_path\n\npython:str\n\nPath to the exported report.\n\nbackground_color\n\npython:str, optional\n\nColor of the report’s background. The default is \"White\".\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.remove_hfss_prop",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.remove_hfss_prop.html#remove_hfss_prop",
        "title": "remove_hfss_prop",
        "section": "remove_hfss_prop",
        "text": "Remove HFSS properties.\nremove_hfss_prop"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.remove_hfss_prop",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.remove_hfss_prop.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.remove_hfss_prop",
        "title": "remove_hfss_prop > remove_hfss_prop > remove_hfss_prop",
        "section": "remove_hfss_prop > remove_hfss_prop",
        "text": "EdbPolygon.remove_hfss_prop()\n\nRemove HFSS properties.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/source_excitations",
        "href": "grpc_api/grpc/database/source_excitations.html#sources-excitations",
        "title": "Sources excitations",
        "section": "Sources excitations",
        "text": "Class managing source excitations.\nsource_excitations.SourceExcitation\nManage sources and excitations.\nSources excitations\nsource_excitations.SourceExcitation"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_pad_edge_terminal_reference_pin",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_pad_edge_terminal_reference_pin.html#get_pad_edge_terminal_reference_pin",
        "title": "get_pad_edge_terminal_reference_pin",
        "section": "get_pad_edge_terminal_reference_pin",
        "text": "Get the closest pin padstack instances and serves any edge terminal connected to a pad.\nPreferred reference net name. Optianal, default is None which will auto compute the gnd name.\nget_pad_edge_terminal_reference_pin\npython:str\noptional\npyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_pad_edge_terminal_reference_pin",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_pad_edge_terminal_reference_pin.html#pyedb.grpc.database.ports.ports.ExcitationSources.get_pad_edge_terminal_reference_pin",
        "title": "get_pad_edge_terminal_reference_pin > get_pad_edge_terminal_reference_pin > get_pad_edge_terminal_reference_pin",
        "section": "get_pad_edge_terminal_reference_pin > get_pad_edge_terminal_reference_pin",
        "text": "ExcitationSources.get_pad_edge_terminal_reference_pin(gnd_net_name_preference=None)\n\nGet the closest pin padstack instances and serves any edge terminal connected to a pad.\n\nParameters\n\ngnd_net_name_preference\n\npython:str, optional\n\nPreferred reference net name. Optianal, default is None which will auto compute the gnd name.\n\nReturns\n\npyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.set_back_drill_by_layer",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.set_back_drill_by_layer.html#set_back_drill_by_layer",
        "title": "set_back_drill_by_layer",
        "section": "set_back_drill_by_layer",
        "text": "Method added to bring compatibility with grpc.\nset_back_drill_by_layer"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.set_back_drill_by_layer",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.set_back_drill_by_layer.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.set_back_drill_by_layer",
        "title": "set_back_drill_by_layer > set_back_drill_by_layer > set_back_drill_by_layer",
        "section": "set_back_drill_by_layer > set_back_drill_by_layer",
        "text": "EDBPadstackInstance.set_back_drill_by_layer(drill_to_layer, diameter, offset, from_bottom=True)\n\nMethod added to bring compatibility with grpc.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_variable",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_variable.html#get_variable",
        "title": "get_variable",
        "section": "get_variable",
        "text": "Return Variable Value if variable exists.\nget_variable\npyedb.dotnet.database.edb_data.edbvalue.EdbValue"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_variable",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_variable.html#pyedb.dotnet.edb.Edb.get_variable",
        "title": "get_variable > get_variable > get_variable",
        "section": "get_variable > get_variable",
        "text": "Edb.get_variable(variable_name)\n\nReturn Variable Value if variable exists.\n\nParameters\n\nvariable_name\n\n\n\nReturns\n\npyedb.dotnet.database.edb_data.edbvalue.EdbValue\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.from_orm",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "from_orm"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.from_orm",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.from_orm.html#pyedb.workflows.drc.drc.MinAnnularRing.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod MinAnnularRing.from_orm(obj: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.set_product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.set_product_solver_option.html#set_product_solver_option",
        "title": "set_product_solver_option",
        "section": "set_product_solver_option",
        "text": "Set the product solver option.\nID of the product.\nName of the solver.\nName of the product solver option.\nset_product_solver_option\nProductIdType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.set_product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.set_product_solver_option.html#pyedb.grpc.database.ports.ports.CircuitPort.set_product_solver_option",
        "title": "set_product_solver_option > set_product_solver_option > set_product_solver_option",
        "section": "set_product_solver_option > set_product_solver_option",
        "text": "CircuitPort.set_product_solver_option(product_id, solver_name, option)\n\nSet the product solver option.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nsolver_name\n\nobj:str\n\nName of the solver.\n\noption\n\nobj:str\n\nName of the product solver option.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the primitive object to the correct concrete type.\ncast\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.cast.html#pyedb.grpc.database.primitive.path.Path.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "Path.cast() -> Primitive | None\n\nCast the primitive object to the correct concrete type.\n\nReturns\n\nPrimitive\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_validate_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data: The JSON data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nThe validated Pydantic model.\nValidationError: If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_validate_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_validate_json.html#pyedb.workflows.drc.drc.BackDrillStubLength.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod BackDrillStubLength.model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n\njson_data: The JSON data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nReturns:\n\nThe validated Pydantic model.\n\nRaises:\n\nValidationError: If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileBoundaries.add_port",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileBoundaries.add_port.html#add_port",
        "title": "add_port",
        "section": "add_port",
        "text": "Add a port.\nPort name.\nX-coordinate of first point.\nY-coordinate of first point.\nLayer of first point.\nX-coordinate of second point.\nY-coordinate of second point.\nLayer of second point.\nCharacteristic impedance. Default is 50.\nCreated port object.\nadd_port\npython:str\npython:float\npython:float\npython:str\npython:float\npython:float\npython:str\npython:float\noptional\nControlCircuitPt"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileBoundaries.add_port",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileBoundaries.add_port.html#pyedb.grpc.database.control_file.ControlFileBoundaries.add_port",
        "title": "add_port > add_port > add_port",
        "section": "add_port > add_port",
        "text": "ControlFileBoundaries.add_port(name: str, x1: float, y1: float, layer1: str, x2: float, y2: float, layer2: str, z0: float = 50) -> ControlCircuitPt\n\nAdd a port.\n\nParameters\n\nname\n\npython:str\n\nPort name.\n\nx1\n\npython:float\n\nX-coordinate of first point.\n\ny1\n\npython:float\n\nY-coordinate of first point.\n\nlayer1\n\npython:str\n\nLayer of first point.\n\nx2\n\npython:float\n\nX-coordinate of second point.\n\ny2\n\npython:float\n\nY-coordinate of second point.\n\nlayer2\n\npython:str\n\nLayer of second point.\n\nz0\n\npython:float, optional\n\nCharacteristic impedance. Default is 50.\n\nReturns\n\nControlCircuitPt\n\nCreated port object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.create_stride.html#create_stride",
        "title": "create_stride",
        "section": "create_stride",
        "text": "Create a Stride model from an MCAD file.\nStride model created.\ncreate_stride\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.create_stride.html#pyedb.grpc.database.terminal.terminal.Terminal.create_stride",
        "title": "create_stride > create_stride > create_stride",
        "section": "create_stride > create_stride",
        "text": "Terminal.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nReturns\n\nMcadModel\n\nStride model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_rebuild",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce: Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors: Whether to raise errors, defaults to True.\n_parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n_types_namespace: The types namespace, defaults to None.\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_rebuild",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_rebuild.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod DiffPairLengthMatch.model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -> bool | None\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n\nforce: Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors: Whether to raise errors, defaults to True.\n_parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n_types_namespace: The types namespace, defaults to None.\n\nReturns:\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/index",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/index.html#port-classes",
        "title": "Port classes",
        "section": "Port classes",
        "text": "This section describes EDB port classes.\nPort classes"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.atan",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.atan.html#atan",
        "title": "atan",
        "section": "atan",
        "text": "Arctangent of the value.\natan"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.atan",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.atan.html#pyedb.grpc.database.utility.value.Value.atan",
        "title": "atan > atan > atan",
        "section": "atan > atan",
        "text": "Value.atan()\n\nArctangent of the value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.update_material",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.update_material.html#update_material",
        "title": "update_material",
        "section": "update_material",
        "text": "Update material attributes.\nupdate_material"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.update_material",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.update_material.html#pyedb.dotnet.database.materials.Materials.update_material",
        "title": "update_material > update_material > update_material",
        "section": "update_material > update_material",
        "text": "Materials.update_material(material_name, input_dict)\n\nUpdate material attributes.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/primitive.html#primitive",
        "title": "Primitive",
        "section": "Primitive",
        "text": "This class is managing EDB primitive.\nPrimitive\nManages EDB functionalities for a primitives.\nPrimitive\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.create_3d_comp.html#create_3d_comp",
        "title": "create_3d_comp",
        "section": "create_3d_comp",
        "text": "Create a 3D composite model from an MCAD file.\n3D composite model created.\ncreate_3d_comp\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.create_3d_comp.html#pyedb.grpc.database.terminal.terminal.Terminal.create_3d_comp",
        "title": "create_3d_comp > create_3d_comp > create_3d_comp",
        "section": "create_3d_comp > create_3d_comp",
        "text": "Terminal.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nReturns\n\nMcadModel\n\n3D composite model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.cross",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.cross.html#cross",
        "title": "cross",
        "section": "cross",
        "text": "Compute the cross product of the point vector with another point vector.\nOther point vector.\nCross product value or None if either point is an arc.\ncross\nValue\nNone\nNone"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.cross",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.cross.html#pyedb.grpc.database.geometry.point_data.PointData.cross",
        "title": "cross > cross > cross",
        "section": "cross > cross",
        "text": "PointData.cross(other: PointLike) -> Value | None\n\nCompute the cross product of the point vector with another point vector.\n\nParameters\n\nother\n\nPoint2DLike\n\nOther point vector.\n\nReturns\n\nValue or None\n\nCross product value or None if either point is an arc.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_position_and_rotation",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_position_and_rotation.html#set_position_and_rotation",
        "title": "set_position_and_rotation",
        "section": "set_position_and_rotation",
        "text": "Set the position and rotation of the padstack instance.\nx : X coordinate.\ny : Y coordinate.\nRotation in radians.\nset_position_and_rotation"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_position_and_rotation",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_position_and_rotation.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_position_and_rotation",
        "title": "set_position_and_rotation > set_position_and_rotation > set_position_and_rotation",
        "section": "set_position_and_rotation > set_position_and_rotation",
        "text": "PadstackInstance.set_position_and_rotation(x: ValueLike, y: ValueLike, rotation: ValueLike)\n\nSet the position and rotation of the padstack instance.\n\nParameters\n\nx\n\nValueLike\n\nx : X coordinate.\n\ny\n\nValueLike\n\ny : Y coordinate.\n\nrotation\n\nValueLike\n\nRotation in radians.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.create_stride.html#create_stride",
        "title": "create_stride",
        "section": "create_stride",
        "text": "Create a Stride model from an MCAD file.\nStride model created.\ncreate_stride\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.create_stride.html#pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.create_stride",
        "title": "create_stride > create_stride > create_stride",
        "section": "create_stride > create_stride",
        "text": "VoltageRegulator.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nReturns\n\nMcadModel\n\nStride model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.intersection_type",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.intersection_type.html#intersection_type",
        "title": "intersection_type",
        "section": "intersection_type",
        "text": "Get the intersection type with another polygon.\nOther polygon.\nTolerance.\nintersection_type\nPolygonData\npython:float\nIntersectionType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.intersection_type",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.intersection_type.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.intersection_type",
        "title": "intersection_type > intersection_type > intersection_type",
        "section": "intersection_type > intersection_type",
        "text": "PolygonData.intersection_type(other: PolygonData, tol: float = 1e-09) -> IntersectionType\n\nGet the intersection type with another polygon.\n\nParameters\n\nother\n\nPolygonData\n\nOther polygon.\n\ntol\n\npython:float, default: 1e-9\n\nTolerance.\n\nReturns\n\nIntersectionType\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.unite_primitives",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.unite_primitives.html#unite_primitives",
        "title": "unite_primitives",
        "section": "unite_primitives",
        "text": "Unite primitives on a layer.\nLayers to unite primitives on.\nunite_primitives\npython:list\nof"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.unite_primitives",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.unite_primitives.html#pyedb.grpc.database.layout.layout.Layout.unite_primitives",
        "title": "unite_primitives > unite_primitives > unite_primitives",
        "section": "unite_primitives > unite_primitives",
        "text": "Layout.unite_primitives(layer: LayerListLike)\n\nUnite primitives on a layer.\n\nParameters\n\nlayer\n\nLayerLike or python:list of LayerLike\n\nLayers to unite primitives on.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/raptor_x_advanced_settings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/raptor_x_advanced_settings.html#raptor-x-advanced-settings",
        "title": "Raptor X advanced settings",
        "section": "Raptor X advanced settings",
        "text": "This class is managing EDB raptor x advanced settings.\nRaptorXAdvancedSettings\nRaptor X advanced settings class.\nRaptor X advanced settings\nRaptorXAdvancedSettings"
    },
    {
        "objectID": "grpc_api/grpc/database/control_file",
        "href": "grpc_api/grpc/database/control_file.html#control-file",
        "title": "Control file",
        "section": "Control file",
        "text": "These classes are the containers of the GDS control file.\ncontrol_file.ControlFile\nMain class for EDB control file creation and management.\ncontrol_file.ControlProperty\nRepresents a property in the control file with name, value, and type.\ncontrol_file.ControlFileMaterial\nRepresents a material in the control file.\ncontrol_file.ControlFileDielectric\nRepresents a dielectric layer in the control file.\ncontrol_file.ControlFileLayer\nRepresents a general layer in the control file.\ncontrol_file.ControlFileVia\nRepresents a via layer in the control file.\ncontrol_file.ControlFileStackup\nManages stackup information for the control file.\ncontrol_file.ControlFileImportOptions\nManages import options for the control file.\ncontrol_file.ControlExtent\nRepresents extent options for boundaries.\ncontrol_file.ControlCircuitPt\nRepresents a circuit port.\ncontrol_file.ControlFileComponent\nRepresents a component in the control file.\ncontrol_file.ControlFileComponents\nManages components for the control file.\ncontrol_file.ControlFileBoundaries\nManages boundaries for the control file.\ncontrol_file.ControlFileSweep\nRepresents a frequency sweep.\ncontrol_file.ControlFileMeshOp\nRepresents a mesh operation.\ncontrol_file.ControlFileSetup\nRepresents a simulation setup.\ncontrol_file.ControlFileSetups\nManages simulation setups.\nControl file\ncontrol_file.ControlFile\ncontrol_file.ControlProperty\ncontrol_file.ControlFileMaterial\ncontrol_file.ControlFileDielectric\ncontrol_file.ControlFileLayer\ncontrol_file.ControlFileVia\ncontrol_file.ControlFileStackup\ncontrol_file.ControlFileImportOptions\ncontrol_file.ControlExtent\ncontrol_file.ControlCircuitPt\ncontrol_file.ControlFileComponent\ncontrol_file.ControlFileComponents\ncontrol_file.ControlFileBoundaries\ncontrol_file.ControlFileSweep\ncontrol_file.ControlFileMeshOp\ncontrol_file.ControlFileSetup\ncontrol_file.ControlFileSetups"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_document_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_document_layer.html#add_document_layer",
        "title": "add_document_layer",
        "section": "add_document_layer",
        "text": "Add a document layer.\nName of the layer.\nType of the layer. The default is \"user\". Options are \"user\" and \"outline\".\nAdditional keyword arguments.\nLayer object created.\nadd_document_layer\npython:str\npython:str\noptional\n\"user\"\n\"user\"\n\"outline\"\npython:dict\noptional\npyedb.grpc.database.layers.layer.Layer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_document_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_document_layer.html#pyedb.grpc.database.stackup.LayerCollection.add_document_layer",
        "title": "add_document_layer > add_document_layer > add_document_layer",
        "section": "add_document_layer > add_document_layer",
        "text": "LayerCollection.add_document_layer(name: str, layer_type: str = 'user', **kwargs: Any) -> Layer | None\n\nAdd a document layer.\n\nParameters\n\nname\n\npython:str\n\nName of the layer.\n\nlayer_type\n\npython:str, optional\n\nType of the layer. The default is \"user\". Options are \"user\" and \"outline\".\n\n**kwargs\n\npython:dict, optional\n\nAdditional keyword arguments.\n\nReturns\n\npyedb.grpc.database.layers.layer.Layer\n\nLayer object created.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> outline_layer = edb.stackup.add_document_layer(\"Outline\", layer_type=\"outline\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.set_product_property.html#pyedb.grpc.database.net.net_class.NetClass.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "NetClass.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_material",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_material.html#set_material",
        "title": "set_material",
        "section": "set_material",
        "text": "Set the material of the bondwire.\nMaterial name.\nset_material\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_material",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_material.html#pyedb.grpc.database.primitive.bondwire.Bondwire.set_material",
        "title": "set_material > set_material > set_material",
        "section": "set_material > set_material",
        "text": "Bondwire.set_material(material: str)\n\nSet the material of the bondwire.\n\nParameters\n\nmaterial\n\npython:str\n\nMaterial name.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef.split_to_microvias",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef.split_to_microvias.html#split_to_microvias",
        "title": "split_to_microvias",
        "section": "split_to_microvias",
        "text": "Convert actual padstack definition to multiple microvias definitions.\nsplit_to_microvias\nList\nPadstackInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef.split_to_microvias",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef.split_to_microvias.html#pyedb.grpc.database.definition.padstack_def.PadstackDef.split_to_microvias",
        "title": "split_to_microvias > split_to_microvias > split_to_microvias",
        "section": "split_to_microvias > split_to_microvias",
        "text": "PadstackDef.split_to_microvias() -> list[any]\n\nConvert actual padstack definition to multiple microvias definitions.\n\nReturns\n\nList[PadstackInstance]\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "schema"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.schema.html#pyedb.workflows.drc.drc.Rules.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod Rules.schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}') -> Dict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.create_stride.html#create_stride",
        "title": "create_stride",
        "section": "create_stride",
        "text": "Create a Stride model from an MCAD file.\nAbsolute path of the MCAD file.\nStride model created.\ncreate_stride\npython:str\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.create_stride.html#pyedb.grpc.database.layout.layout.Layout.create_stride",
        "title": "create_stride > create_stride > create_stride",
        "section": "create_stride > create_stride",
        "text": "Layout.create_stride(filename: str) -> McadModel\n\nCreate a Stride model from an MCAD file.\n\nParameters\n\nfilename\n\npython:str\n\nAbsolute path of the MCAD file.\n\nReturns\n\nMcadModel\n\nStride model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/index",
        "href": "workflows/drc/index.html#drc-workflows",
        "title": "DRC workflows",
        "section": "DRC workflows",
        "text": "This section describes PyEDB DRC workflows features.\nDRC workflows"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.get_layout_thickness",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.get_layout_thickness.html#get_layout_thickness",
        "title": "get_layout_thickness",
        "section": "get_layout_thickness",
        "text": "Return the layout thickness.\nThe thickness value.\nget_layout_thickness\npython:float"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.get_layout_thickness",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.get_layout_thickness.html#pyedb.dotnet.database.stackup.Stackup.get_layout_thickness",
        "title": "get_layout_thickness > get_layout_thickness > get_layout_thickness",
        "section": "get_layout_thickness > get_layout_thickness",
        "text": "Stackup.get_layout_thickness()\n\nReturn the layout thickness.\n\nReturns\n\npython:float\n\nThe thickness value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileComponent.add_port",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileComponent.add_port.html#add_port",
        "title": "add_port",
        "section": "add_port",
        "text": "Add a port to the component.\nPort name.\nCharacteristic impedance.\nPositive pin/group name.\nReference pin/group name.\nPositive element type (“pin” or “pingroup”). Default is “pin”.\nReference element type (“pin”, “pingroup”, or “net”). Default is “pin”.\nadd_port\npython:str\npython:float\npython:str\npython:str\noptional\npython:str\noptional\npython:str\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileComponent.add_port",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileComponent.add_port.html#pyedb.grpc.database.control_file.ControlFileComponent.add_port",
        "title": "add_port > add_port > add_port",
        "section": "add_port > add_port",
        "text": "ControlFileComponent.add_port(name: str, z0: float, pospin: str, refpin: str | None = None, pos_type: str = 'pin', ref_type: str = 'pin') -> None\n\nAdd a port to the component.\n\nParameters\n\nname\n\npython:str\n\nPort name.\n\nz0\n\npython:float\n\nCharacteristic impedance.\n\npospin\n\npython:str\n\nPositive pin/group name.\n\nrefpin\n\npython:str, optional\n\nReference pin/group name.\n\npos_type\n\npython:str, optional\n\nPositive element type (“pin” or “pingroup”). Default is “pin”.\n\nref_type\n\npython:str, optional\n\nReference element type (“pin”, “pingroup”, or “net”). Default is “pin”.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_product_property.html#pyedb.grpc.database.primitive.circle.Circle.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "Circle.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_config",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_config",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_config.html#pyedb.grpc.database.definition.materials.MaterialProperties.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "MaterialProperties.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.get_configurations",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.get_configurations.html#get_configurations",
        "title": "get_configurations",
        "section": "get_configurations",
        "text": "Get SIwave DC simulation settings.\nDictionary of SIwave DC simulation settings.\nget_configurations\npython:dict"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.get_configurations",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.get_configurations.html#pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.get_configurations",
        "title": "get_configurations > get_configurations > get_configurations",
        "section": "get_configurations > get_configurations",
        "text": "SiwaveDCSimulationSetup.get_configurations()\n\nGet SIwave DC simulation settings.\n\nReturns\n\npython:dict\n\nDictionary of SIwave DC simulation settings.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_connected_objects",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_connected_objects.html#get_connected_objects",
        "title": "get_connected_objects",
        "section": "get_connected_objects",
        "text": "Get connected objects.\nget_connected_objects\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_connected_objects",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_connected_objects.html#pyedb.dotnet.edb.Edb.get_connected_objects",
        "title": "get_connected_objects > get_connected_objects > get_connected_objects",
        "section": "get_connected_objects > get_connected_objects",
        "text": "Edb.get_connected_objects(layout_object_instance)\n\nGet connected objects.\n\nReturns\n\npython:list\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.html#bondwire",
        "title": "Bondwire",
        "section": "Bondwire",
        "text": "Class representing a bond-wire object.\nBondwire.add_void(hole)\nAdd a void to the primitive.\nBondwire.cast()\nCast the primitive object to the correct concrete type.\nBondwire.create(layout, bondwire_type, ...)\nCreate a bondwire.\nBondwire.create_3d_comp()\nCreate a 3D composite model from an MCAD file.\nBondwire.create_hfss()\nCreate an HFSS model from an MCAD file.\nBondwire.create_stride()\nCreate a Stride model from an MCAD file.\nBondwire.delete()\nDelete the layout object.\nBondwire.find_by_id(layout, uid)\nFind a Connectable object by database ID in a given layout.\nBondwire.get_definition_name([evaluated])\nGet the definition name of the bondwire object.\nBondwire.get_end_elevation(end_context)\nGet the end elevation layer of the bondwire.\nBondwire.get_hfss_prop()\nGet HFSS properties.\nBondwire.get_material([evaluated])\nGet the material of the bondwire.\nBondwire.get_product_property(prod_id, attr_id)\nGet the product property of the layout object for a given product ID and attribute ID.\nBondwire.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nBondwire.get_start_elevation(start_context)\nGet the start elevation layer of the bondwire.\nBondwire.get_traj()\nGet trajectory parameters of the bondwire.\nBondwire.make_zone_primitive(zone_id)\nMake the primitive a zone primitive with a zone specified by the provided ID.\nBondwire.remove_hfss_prop()\nRemove HFSS properties.\nBondwire.set_definition_name(definition_name)\nSet the definition name of a bondwire.\nBondwire.set_end_elevation(end_context, layer)\nSet the end elevation of the bondwire.\nBondwire.set_hfss_prop(material, solve_inside)\nSet HFSS properties.\nBondwire.set_material(material)\nSet the material of the bondwire.\nBondwire.set_product_property(prod_id, ...)\nSet the product property of the layout object for a given product ID and attribute ID.\nBondwire.set_start_elevation(start_context, ...)\nSet the start elevation of the bondwire.\nBondwire.set_traj(x1, y1, x2, y2)\nSet the parameters of the trajectory of the bondwire.\nBondwire.layout_obj_type\nLayoutObjType: Layout object type of the Primitive class.\nBondwire\nBondwire.add_void\nBondwire.cast\nBondwire.create\nBondwire.create_3d_comp\nBondwire.create_hfss\nBondwire.create_stride\nBondwire.delete\nBondwire.find_by_id\nBondwire.get_definition_name\nBondwire.get_end_elevation\nBondwire.get_hfss_prop\nBondwire.get_material\nBondwire.get_product_property\nBondwire.get_product_property_ids\nBondwire.get_start_elevation\nBondwire.get_traj\nBondwire.make_zone_primitive\nBondwire.remove_hfss_prop\nBondwire.set_definition_name\nBondwire.set_end_elevation\nBondwire.set_hfss_prop\nBondwire.set_material\nBondwire.set_product_property\nBondwire.set_start_elevation\nBondwire.set_traj\nBondwire.layout_obj_type\nLayoutObjType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.html#pyedb.grpc.database.primitive.bondwire.Bondwire",
        "title": "Bondwire > Bondwire > Bondwire",
        "section": "Bondwire > Bondwire",
        "text": "class pyedb.grpc.database.primitive.bondwire.Bondwire(_pedb, edb_object)\n\nClass representing a bond-wire object.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nBondwire.add_void(hole)\n\nAdd a void to the primitive.\n\nBondwire.cast()\n\nCast the primitive object to the correct concrete type.\n\nBondwire.create(layout, bondwire_type, ...)\n\nCreate a bondwire.\n\nBondwire.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nBondwire.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nBondwire.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nBondwire.delete()\n\nDelete the layout object.\n\nBondwire.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nBondwire.get_definition_name([evaluated])\n\nGet the definition name of the bondwire object.\n\nBondwire.get_end_elevation(end_context)\n\nGet the end elevation layer of the bondwire.\n\nBondwire.get_hfss_prop()\n\nGet HFSS properties.\n\nBondwire.get_material([evaluated])\n\nGet the material of the bondwire.\n\nBondwire.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nBondwire.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nBondwire.get_start_elevation(start_context)\n\nGet the start elevation layer of the bondwire.\n\nBondwire.get_traj()\n\nGet trajectory parameters of the bondwire.\n\nBondwire.make_zone_primitive(zone_id)\n\nMake the primitive a zone primitive with a zone specified by the provided ID.\n\nBondwire.remove_hfss_prop()\n\nRemove HFSS properties.\n\nBondwire.set_definition_name(definition_name)\n\nSet the definition name of a bondwire.\n\nBondwire.set_end_elevation(end_context, layer)\n\nSet the end elevation of the bondwire.\n\nBondwire.set_hfss_prop(material, solve_inside)\n\nSet HFSS properties.\n\nBondwire.set_material(material)\n\nSet the material of the bondwire.\n\nBondwire.set_product_property(prod_id, ...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nBondwire.set_start_elevation(start_context, ...)\n\nSet the start elevation of the bondwire.\n\nBondwire.set_traj(x1, y1, x2, y2)\n\nSet the parameters of the trajectory of the bondwire.\n\n\n\nAttributes\n\n\n\n\n\n\n\nBondwire.layout_obj_type\n\nLayoutObjType: Layout object type of the Primitive class.\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.fix_circle_void_for_clipping",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.fix_circle_void_for_clipping.html#fix_circle_void_for_clipping",
        "title": "fix_circle_void_for_clipping",
        "section": "fix_circle_void_for_clipping",
        "text": "Fix issues when circle void are clipped due to a bug in EDB.\nTrue when successful, False when no changes were applied.\nfix_circle_void_for_clipping\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.fix_circle_void_for_clipping",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.fix_circle_void_for_clipping.html#pyedb.dotnet.database.modeler.Modeler.fix_circle_void_for_clipping",
        "title": "fix_circle_void_for_clipping > fix_circle_void_for_clipping > fix_circle_void_for_clipping",
        "section": "fix_circle_void_for_clipping > fix_circle_void_for_clipping",
        "text": "Modeler.fix_circle_void_for_clipping()\n\nFix issues when circle void are clipped due to a bug in EDB.\n\nReturns\n\nbool\n\nTrue when successful, False when no changes were applied.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.clone",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.clone.html#clone",
        "title": "clone",
        "section": "clone",
        "text": "Duplicate polygon.\nCloned polygon.\nclone\nPolygon"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.clone",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.clone.html#pyedb.grpc.database.primitive.polygon.Polygon.clone",
        "title": "clone > clone > clone",
        "section": "clone > clone",
        "text": "Polygon.clone()\n\nDuplicate polygon.\n\nReturns\n\nPolygon\n\nCloned polygon.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.plot",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.plot.html#plot",
        "title": "plot",
        "section": "plot",
        "text": "Plot current stackup and, optionally, overlap padstack definitions.\nPlot supports only ‘Laminate’ and ‘Overlapping’ stackup types.\nIf a path is specified the plot will be saved in this location.\nIf save_plot is provided, the show parameter is ignored.\nImage size in pixel (width, height). Default value is (2000, 1500)\nList of padstack definitions to plot on the stackup.\nIt is supported only for Laminate mode.\nFirst layer to plot from the bottom. Default is None to start plotting from bottom.\nLast layer to plot from the bottom. Default is None to plot up to top layer.\nThe real layer thickness is scaled so that max_thickness = 3 * min_thickness.\nDefault is True.\nWhether to show the plot or not. Default is True.\nplot\npython:str\noptional\nsave_plot\nshow\npython:tuple\noptional\n(2000, 1500)\npython:str\npython:list\noptional\npython:str\npyedb.dotnet.database.edb_data.layer_data.LayerEdbClass\npython:str\npyedb.dotnet.database.edb_data.layer_data.LayerEdbClass\noptional\noptional\nmatplotlib.plt"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.plot",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.plot.html#pyedb.dotnet.database.stackup.Stackup.plot",
        "title": "plot > plot > plot",
        "section": "plot > plot",
        "text": "Stackup.plot(save_plot=None, size=(2000, 1500), plot_definitions=None, first_layer=None, last_layer=None, scale_elevation=True, show=True)\n\nPlot current stackup and, optionally, overlap padstack definitions.\nPlot supports only ‘Laminate’ and ‘Overlapping’ stackup types.\n\nParameters\n\nsave_plot\n\npython:str, optional\n\nIf a path is specified the plot will be saved in this location.\nIf save_plot is provided, the show parameter is ignored.\n\nsize\n\npython:tuple, optional\n\nImage size in pixel (width, height). Default value is (2000, 1500)\n\nplot_definitions\n\npython:str, python:list, optional\n\nList of padstack definitions to plot on the stackup.\nIt is supported only for Laminate mode.\n\nfirst_layer\n\npython:str or pyedb.dotnet.database.edb_data.layer_data.LayerEdbClass\n\nFirst layer to plot from the bottom. Default is None to start plotting from bottom.\n\nlast_layer\n\npython:str or pyedb.dotnet.database.edb_data.layer_data.LayerEdbClass\n\nLast layer to plot from the bottom. Default is None to plot up to top layer.\n\nscale_elevation\n\nbool, optional\n\nThe real layer thickness is scaled so that max_thickness = 3 * min_thickness.\nDefault is True.\n\nshow\n\nbool, optional\n\nWhether to show the plot or not. Default is True.\n\nReturns\n\nmatplotlib.plt\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.render",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.render.html#render",
        "title": "render",
        "section": "render",
        "text": "Render a path.\nPath width.\nEnd cap style for the start of the path.\nEnd cap style for the end of the path.\nCorner style.\nPolygon data to set.\nPath rendered.\nrender\nPathEndCapType\nPathEndCapType\nPathCornerType\nPolygonData\nPolygonData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.render",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.render.html#pyedb.grpc.database.primitive.path.Path.render",
        "title": "render > render > render",
        "section": "render > render",
        "text": "classmethod Path.render(width: ValueLike, end_cap1: PathEndCapType, end_cap2: PathEndCapType, corner_style: PathCornerType, path: PolygonData) -> PolygonData\n\nRender a path.\n\nParameters\n\nwidth\n\nValueLike\n\nPath width.\n\nend_cap1\n\nPathEndCapType\n\nEnd cap style for the start of the path.\n\nend_cap2\n\nPathEndCapType\n\nEnd cap style for the end of the path.\n\ncorner_style\n\nPathCornerType\n\nCorner style.\n\npath\n\nPolygonData\n\nPolygon data to set.\n\nReturns\n\nPolygonData\n\nPath rendered.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/index",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/index.html#geometry-classes",
        "title": "Geometry classes",
        "section": "Geometry classes",
        "text": "This section describes EDB geometry classes.\nGeometry classes"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_hfss.html#create_hfss",
        "title": "create_hfss",
        "section": "create_hfss",
        "text": "Create an HFSS model from an MCAD file.\nHFSS model created.\ncreate_hfss\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_hfss.html#pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_hfss",
        "title": "create_hfss > create_hfss > create_hfss",
        "section": "create_hfss > create_hfss",
        "text": "PinGroup.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nReturns\n\nMcadModel\n\nHFSS model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.ViaSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.ViaSettings.html#viasettings",
        "title": "ViaSettings",
        "section": "ViaSettings",
        "text": "Manages EDB methods for via settings.\nViaSettings"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.ViaSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.ViaSettings.html#pyedb.dotnet.database.sim_setup_data.data.settings.ViaSettings",
        "title": "ViaSettings > ViaSettings > ViaSettings",
        "section": "ViaSettings > ViaSettings",
        "text": "class pyedb.dotnet.database.sim_setup_data.data.settings.ViaSettings(parent)\n\nManages EDB methods for via settings.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_edge_terminal_reference_primitive",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_edge_terminal_reference_primitive.html#get_edge_terminal_reference_primitive",
        "title": "get_edge_terminal_reference_primitive",
        "section": "get_edge_terminal_reference_primitive",
        "text": "Check and  return a primitive instance that serves Edge ports,\nwave ports and coupled edge ports that are directly connedted to primitives.\nget_edge_terminal_reference_primitive\npyedb.dotnet.database.edb_data.primitives_data.EDBPrimitives"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_edge_terminal_reference_primitive",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_edge_terminal_reference_primitive.html#pyedb.dotnet.database.edb_data.ports.WavePort.get_edge_terminal_reference_primitive",
        "title": "get_edge_terminal_reference_primitive > get_edge_terminal_reference_primitive > get_edge_terminal_reference_primitive",
        "section": "get_edge_terminal_reference_primitive > get_edge_terminal_reference_primitive",
        "text": "WavePort.get_edge_terminal_reference_primitive()\n\nCheck and  return a primitive instance that serves Edge ports,\nwave ports and coupled edge ports that are directly connedted to primitives.\n\nReturns\n\npyedb.dotnet.database.edb_data.primitives_data.EDBPrimitives\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layer_above",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layer_above.html#add_layer_above",
        "title": "add_layer_above",
        "section": "add_layer_above",
        "text": "Add a layer above a specified layer.\nName of the layer.\nName of the base layer.\nType of the layer. The default is \"signal\". Options are \"signal\" and \"dielectric\".\nAdditional keyword arguments. Possible keys are:\n- thickness : float, layer thickness.\n- material : str, layer material.\nLayer object created.\nadd_layer_above\npython:str\npython:str\npython:str\noptional\n\"signal\"\n\"signal\"\n\"dielectric\"\npython:dict\noptional\nthickness\nmaterial\npyedb.grpc.database.layers.stackup_layer.StackupLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layer_above",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layer_above.html#pyedb.grpc.database.stackup.Stackup.add_layer_above",
        "title": "add_layer_above > add_layer_above > add_layer_above",
        "section": "add_layer_above > add_layer_above",
        "text": "Stackup.add_layer_above(name: str, base_layer_name: str, layer_type: str = 'signal', **kwargs) -> Layer | None\n\nAdd a layer above a specified layer.\n\nParameters\n\nname\n\npython:str\n\nName of the layer.\n\nbase_layer_name\n\npython:str\n\nName of the base layer.\n\nlayer_type\n\npython:str, optional\n\nType of the layer. The default is \"signal\". Options are \"signal\" and \"dielectric\".\n\n**kwargs\n\npython:dict, optional\n\nAdditional keyword arguments. Possible keys are:\n- thickness : float, layer thickness.\n- material : str, layer material.\n\nReturns\n\npyedb.grpc.database.layers.stackup_layer.StackupLayer\n\nLayer object created.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> new_layer = edb.stackup.add_layer_above(\"NewLayer\", \"BottomLayer\", layer_type=\"signal\", thickness=\"0.05mm\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_primitive",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_primitive.html#get_primitive",
        "title": "get_primitive",
        "section": "get_primitive",
        "text": "Retrieve primitive by ID.\nPrimitive ID.\nPrimitive object if found, False otherwise.\nget_primitive\npython:int\npyedb.dotnet.database.edb_data.primitives_data.Primitive"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_primitive",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_primitive.html#pyedb.grpc.database.modeler.Modeler.get_primitive",
        "title": "get_primitive > get_primitive > get_primitive",
        "section": "get_primitive > get_primitive",
        "text": "Modeler.get_primitive(primitive_id: int, edb_uid=True) -> Primitive | None\n\nRetrieve primitive by ID.\n\nParameters\n\nprimitive_id\n\npython:int\n\nPrimitive ID.\n\nReturns\n\npyedb.dotnet.database.edb_data.primitives_data.Primitive or bool\n\nPrimitive object if found, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.update_forward_refs",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "update_forward_refs"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.update_forward_refs",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.update_forward_refs.html#pyedb.workflows.drc.drc.MinClearance.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod MinClearance.update_forward_refs(**localns: Any) -> None\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj: The object to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\nfrom_attributes: Whether to extract data from object attributes.\ncontext: Additional context to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nValidationError: If the object could not be validated.\nThe validated model instance.\nmodel_validate"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_validate.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod DiffPairLengthMatch.model_validate(obj: Any, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\nValidate a pydantic model instance.\n\nArgs:\n\nobj: The object to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\nfrom_attributes: Whether to extract data from object attributes.\ncontext: Additional context to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nRaises:\n\nValidationError: If the object could not be validated.\n\nReturns:\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.get_ports_number",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.get_ports_number.html#get_ports_number",
        "title": "get_ports_number",
        "section": "get_ports_number",
        "text": "Return the total number of excitation ports in a layout.\nNumber of ports.\nget_ports_number\npython:int"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.get_ports_number",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.get_ports_number.html#pyedb.dotnet.database.hfss.EdbHfss.get_ports_number",
        "title": "get_ports_number > get_ports_number > get_ports_number",
        "section": "get_ports_number > get_ports_number",
        "text": "EdbHfss.get_ports_number()\n\nReturn the total number of excitation ports in a layout.\n\nParameters\n\nNone\n\n\n\nReturns\n\npython:int\n\nNumber of ports.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.change_design_variable_value",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.change_design_variable_value.html#change_design_variable_value",
        "title": "change_design_variable_value",
        "section": "change_design_variable_value",
        "text": "Update variable value.\nVariable name.\nNew value with units.\nchange_design_variable_value\npython:str\npython:str\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.change_design_variable_value",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.change_design_variable_value.html#pyedb.grpc.edb.Edb.change_design_variable_value",
        "title": "change_design_variable_value > change_design_variable_value > change_design_variable_value",
        "section": "change_design_variable_value > change_design_variable_value",
        "text": "Edb.change_design_variable_value(variable_name, variable_value)\n\nUpdate variable value.\n\nParameters\n\nvariable_name\n\npython:str\n\nVariable name.\n\nvariable_value\n\npython:str, python:float\n\nNew value with units.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.update_material",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.update_material.html#update_material",
        "title": "update_material",
        "section": "update_material",
        "text": "Update material attributes.\nupdate_material"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.update_material",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.update_material.html#pyedb.grpc.database.definition.materials.Materials.update_material",
        "title": "update_material > update_material > update_material",
        "section": "update_material > update_material",
        "text": "Materials.update_material(material_name, input_dict)\n\nUpdate material attributes.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlProperty",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlProperty.html#controlproperty",
        "title": "ControlProperty",
        "section": "ControlProperty",
        "text": "Represents a property in the control file with name, value, and type.\nName of the property.\nValue of the property.\nControlProperty\npython:str\npython:str\npython:float\nor\npython:list"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlProperty",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlProperty.html#pyedb.grpc.database.control_file.ControlProperty",
        "title": "ControlProperty > ControlProperty > ControlProperty",
        "section": "ControlProperty > ControlProperty",
        "text": "class pyedb.grpc.database.control_file.ControlProperty(property_name: str, value: str | float | list)\n\nRepresents a property in the control file with name, value, and type.\n\nParameters\n\nproperty_name\n\npython:str\n\nName of the property.\n\nvalue\n\npython:str, python:float, or python:list\n\nValue of the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.get_variable_value",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.get_variable_value.html#get_variable_value",
        "title": "get_variable_value",
        "section": "get_variable_value",
        "text": "Get the value for a given variable.\nVariable name.\nVariable value.\nget_variable_value\npython:str\nValue"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.get_variable_value",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.get_variable_value.html#pyedb.grpc.database.layout.cell.Cell.get_variable_value",
        "title": "get_variable_value > get_variable_value > get_variable_value",
        "section": "get_variable_value > get_variable_value",
        "text": "Cell.get_variable_value(name)\n\nGet the value for a given variable.\n\nParameters\n\nname\n\npython:str\n\nVariable name.\n\nReturns\n\nValue\n\nVariable value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_edge_terminal_reference_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_edge_terminal_reference_primitive.html#get_edge_terminal_reference_primitive",
        "title": "get_edge_terminal_reference_primitive",
        "section": "get_edge_terminal_reference_primitive",
        "text": "Check and  return a primitive instance that serves Edge ports,\nwave ports and coupled edge ports that are directly connedted to primitives.\nget_edge_terminal_reference_primitive\npyedb.dotnet.database.edb_data.primitives_data.EDBPrimitives"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_edge_terminal_reference_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_edge_terminal_reference_primitive.html#pyedb.grpc.database.ports.ports.ExcitationSources.get_edge_terminal_reference_primitive",
        "title": "get_edge_terminal_reference_primitive > get_edge_terminal_reference_primitive > get_edge_terminal_reference_primitive",
        "section": "get_edge_terminal_reference_primitive > get_edge_terminal_reference_primitive",
        "text": "ExcitationSources.get_edge_terminal_reference_primitive()\n\nCheck and  return a primitive instance that serves Edge ports,\nwave ports and coupled edge ports that are directly connedted to primitives.\n\nReturns\n\npyedb.dotnet.database.edb_data.primitives_data.EDBPrimitives\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup.create",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a RaptorX simulation setup.\nCell to create the simulation setup in.\nName of the simulation setup.\nRaptorX simulation setup created.\ncreate\nCell\npython:str\nRaptorXSimulationSetup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup.create",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup.create.html#pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod RaptorXSimulationSetup.create(cell, name)\n\nCreate a RaptorX simulation setup.\n\nParameters\n\ncell\n\nCell\n\nCell to create the simulation setup in.\n\nname\n\npython:str\n\nName of the simulation setup.\n\nReturns\n\nRaptorXSimulationSetup\n\nRaptorX simulation setup created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_layer_above",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_layer_above.html#add_layer_above",
        "title": "add_layer_above",
        "section": "add_layer_above",
        "text": "Add a layer above a specified layer.\nName of the layer.\nName of the base layer.\nType of the layer. The default is \"signal\". Options are \"signal\" and \"dielectric\".\nAdditional keyword arguments. Possible keys are:\n- thickness : float, layer thickness.\n- material : str, layer material.\nLayer object created.\nadd_layer_above\npython:str\npython:str\npython:str\noptional\n\"signal\"\n\"signal\"\n\"dielectric\"\npython:dict\noptional\nthickness\nmaterial\npyedb.grpc.database.layers.stackup_layer.StackupLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_layer_above",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_layer_above.html#pyedb.grpc.database.stackup.LayerCollection.add_layer_above",
        "title": "add_layer_above > add_layer_above > add_layer_above",
        "section": "add_layer_above > add_layer_above",
        "text": "LayerCollection.add_layer_above(name: str, base_layer_name: str, layer_type: str = 'signal', **kwargs) -> Layer | None\n\nAdd a layer above a specified layer.\n\nParameters\n\nname\n\npython:str\n\nName of the layer.\n\nbase_layer_name\n\npython:str\n\nName of the base layer.\n\nlayer_type\n\npython:str, optional\n\nType of the layer. The default is \"signal\". Options are \"signal\" and \"dielectric\".\n\n**kwargs\n\npython:dict, optional\n\nAdditional keyword arguments. Possible keys are:\n- thickness : float, layer thickness.\n- material : str, layer material.\n\nReturns\n\npyedb.grpc.database.layers.stackup_layer.StackupLayer\n\nLayer object created.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> new_layer = edb.stackup.add_layer_above(\"NewLayer\", \"BottomLayer\", layer_type=\"signal\", thickness=\"0.05mm\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.contains_net",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.contains_net.html#contains_net",
        "title": "contains_net",
        "section": "contains_net",
        "text": "Determine if a net exists in the net class.\nNet to search for.\nTrue if the net is in the net class, False otherwise.\ncontains_net\nNet\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.contains_net",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.contains_net.html#pyedb.grpc.database.net.extended_net.ExtendedNet.contains_net",
        "title": "contains_net > contains_net > contains_net",
        "section": "contains_net > contains_net",
        "text": "ExtendedNet.contains_net(net)\n\nDetermine if a net exists in the net class.\n\nParameters\n\nnet\n\nNet\n\nNet to search for.\n\nReturns\n\nbool\n\nTrue if the net is in the net class, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_product_property.html#pyedb.grpc.database.primitive.polygon.Polygon.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "Polygon.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_dc_terminal",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_dc_terminal.html#create_dc_terminal",
        "title": "create_dc_terminal",
        "section": "create_dc_terminal",
        "text": "Create a dc terminal.\nName of the positive component.\nName of the positive net.\nName of the source. The default is \"\".\nThe name of the source.\ncreate_dc_terminal\npython:str\npython:str\npython:str\noptional\n\"\"\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_dc_terminal",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_dc_terminal.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_dc_terminal",
        "title": "create_dc_terminal > create_dc_terminal > create_dc_terminal",
        "section": "create_dc_terminal > create_dc_terminal",
        "text": "SourceExcitation.create_dc_terminal(component_name: str, net_name: str, source_name: str | None = None) -> str | None\n\nCreate a dc terminal.\n\nParameters\n\ncomponent_name\n\npython:str\n\nName of the positive component.\n\nnet_name\n\npython:str\n\nName of the positive net.\n\nsource_name\n\npython:str, optional\n\nName of the source. The default is \"\".\n\nReturns\n\npython:str\n\nThe name of the source.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> edb.source_excitation.create_dc_terminal(\"U1\", \"VCC\", \"DC_VCC\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.create_3d_comp.html#create_3d_comp",
        "title": "create_3d_comp",
        "section": "create_3d_comp",
        "text": "Create a 3D composite model from an MCAD file.\n3D composite model created.\ncreate_3d_comp\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.create_3d_comp.html#pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.create_3d_comp",
        "title": "create_3d_comp > create_3d_comp > create_3d_comp",
        "section": "create_3d_comp > create_3d_comp",
        "text": "VoltageRegulator.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nReturns\n\nMcadModel\n\n3D composite model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.eligible_power_nets",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.eligible_power_nets.html#eligible_power_nets",
        "title": "eligible_power_nets",
        "section": "eligible_power_nets",
        "text": "It uses the same algorithm implemented in SIwave.\nArea ratio used by the get_power_ground_nets method.\neligible_power_nets\npython:float\noptional\nget_power_ground_nets\npython:list\nof\npyedb.dotnet.database.edb_data.EDBNetsData"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.eligible_power_nets",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.eligible_power_nets.html#pyedb.dotnet.database.nets.EdbNets.eligible_power_nets",
        "title": "eligible_power_nets > eligible_power_nets > eligible_power_nets",
        "section": "eligible_power_nets > eligible_power_nets",
        "text": "EdbNets.eligible_power_nets(threshold=0.3)\n\nReturn a list of nets calculated by area to be eligible for PWR/Ground net classification.\n\nIt uses the same algorithm implemented in SIwave.\n\nParameters\n\nthreshold\n\npython:float, optional\n\nArea ratio used by the get_power_ground_nets method.\n\nReturns\n\npython:list of  pyedb.dotnet.database.edb_data.EDBNetsData\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetClassData.api_create",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetClassData.api_create.html#api_create",
        "title": "api_create",
        "section": "api_create",
        "text": "Edb Dotnet Api Database Edb.NetClass.Create.\napi_create"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetClassData.api_create",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetClassData.api_create.html#pyedb.dotnet.database.edb_data.nets_data.EDBNetClassData.api_create",
        "title": "api_create > api_create > api_create",
        "section": "api_create > api_create",
        "text": "EDBNetClassData.api_create(name)\n\nEdb Dotnet Api Database Edb.NetClass.Create.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_circle",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_circle.html#create_circle",
        "title": "create_circle",
        "section": "create_circle",
        "text": "Create a circle on a specified layer.\nName of the layer.\nPosition on the X axis.\nPosition on the Y axis.\nRadius of the circle.\nName of the net. The default is None, in which case the\ndefault name is assigned.\nObjects of the circle created when successful.\ncreate_circle\npython:str\npython:float\npython:float\npython:float\npython:str\noptional\nNone\npyedb.dotnet.database.edb_data.primitives_data.Primitive"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_circle",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_circle.html#pyedb.dotnet.database.modeler.Modeler.create_circle",
        "title": "create_circle > create_circle > create_circle",
        "section": "create_circle > create_circle",
        "text": "Modeler.create_circle(layer_name, x, y, radius, net_name='')\n\nCreate a circle on a specified layer.\n\nParameters\n\nlayer_name\n\npython:str\n\nName of the layer.\n\nx\n\npython:float\n\nPosition on the X axis.\n\ny\n\npython:float\n\nPosition on the Y axis.\n\nradius\n\npython:float\n\nRadius of the circle.\n\nnet_name\n\npython:str, optional\n\nName of the net. The default is None, in which case the\ndefault name is assigned.\n\nReturns\n\npyedb.dotnet.database.edb_data.primitives_data.Primitive\n\nObjects of the circle created when successful.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_validate_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data: The JSON data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nThe validated Pydantic model.\nValidationError: If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_validate_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_validate_json.html#pyedb.workflows.drc.drc.Rules.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod Rules.model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n\njson_data: The JSON data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nReturns:\n\nThe validated Pydantic model.\n\nRaises:\n\nValidationError: If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData.delete",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Edb Dotnet Api Database Delete.\ndelete"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData.delete",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData.delete.html#pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "EDBDifferentialPairData.delete()\n\nEdb Dotnet Api Database Delete.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_circuit_port_on_net",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_circuit_port_on_net.html#create_circuit_port_on_net",
        "title": "create_circuit_port_on_net",
        "section": "create_circuit_port_on_net",
        "text": "Create a circuit port on a NET.\nIt groups all pins belonging to the specified net and then applies the port on PinGroups.\nName of the positive component.\nName of the positive net.\nName of the negative component. The default is None, in which case the name of\nthe positive net is assigned.\nName of the negative net name. The default is None which will look for GND Nets.\nPort impedance value. The default is 50.\nName of the port. The default is \"\".\nThe name of the port.\ncreate_circuit_port_on_net\npython:str\npython:str\npython:str\noptional\nNone\npython:str\noptional\nNone\npython:float\noptional\n50\npython:str\noptional\n\"\"\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_circuit_port_on_net",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_circuit_port_on_net.html#pyedb.dotnet.database.siwave.EdbSiwave.create_circuit_port_on_net",
        "title": "create_circuit_port_on_net > create_circuit_port_on_net > create_circuit_port_on_net",
        "section": "create_circuit_port_on_net > create_circuit_port_on_net",
        "text": "EdbSiwave.create_circuit_port_on_net(positive_component_name, positive_net_name, negative_component_name=None, negative_net_name=None, impedance_value=50, port_name='')\n\nCreate a circuit port on a NET.\n\nIt groups all pins belonging to the specified net and then applies the port on PinGroups.\n\nParameters\n\npositive_component_name\n\npython:str\n\nName of the positive component.\n\npositive_net_name\n\npython:str\n\nName of the positive net.\n\nnegative_component_name\n\npython:str, optional\n\nName of the negative component. The default is None, in which case the name of\nthe positive net is assigned.\n\nnegative_net_name\n\npython:str, optional\n\nName of the negative net name. The default is None which will look for GND Nets.\n\nimpedance_value\n\npython:float, optional\n\nPort impedance value. The default is 50.\n\nport_name\n\npython:str, optional\n\nName of the port. The default is \"\".\n\nReturns\n\npython:str\n\nThe name of the port.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", \"project name\", \"release version\")\n>>> edbapp.siwave.create_circuit_port_on_net(\"U2A5\", \"V1P5_S3\", \"U2A5\", \"GND\", 50, \"port_name\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property for the given product ID and attribute ID.\nProduct ID.\nAttribute ID.\nNew value for the product property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.set_product_property.html#pyedb.grpc.database.definition.component_def.ComponentDef.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "ComponentDef.set_product_property(prod_id: ProductIdType, attr_it: int, prop_value: str)\n\nSet the product property for the given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nProduct ID.\n\nattr_it\n\npython:int\n\nAttribute ID.\n\nprop_value\n\npython:str\n\nNew value for the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_layer_top",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_layer_top.html#add_layer_top",
        "title": "add_layer_top",
        "section": "add_layer_top",
        "text": "Add a layer on top of the stackup.\nName of the layer.\nType of the layer. The default to \"signal\". Options are \"signal\", \"dielectric\"\nadd_layer_top\npython:str\n\"signal\"\n\"signal\"\n\"dielectric\""
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_layer_top",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_layer_top.html#pyedb.dotnet.database.stackup.Stackup.add_layer_top",
        "title": "add_layer_top > add_layer_top > add_layer_top",
        "section": "add_layer_top > add_layer_top",
        "text": "Stackup.add_layer_top(name, layer_type='signal', **kwargs)\n\nAdd a layer on top of the stackup.\n\nParameters\n\nname\n\npython:str\n\nName of the layer.\n\nlayer_type: str, optional\n\nType of the layer. The default to \"signal\". Options are \"signal\", \"dielectric\"\n\nkwargs\n\n\n\nReturns\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.parse_file",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "parse_file"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.parse_file",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.parse_file.html#pyedb.workflows.drc.drc.DiffPair.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod DiffPair.parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "schema"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.schema.html#pyedb.workflows.drc.drc.MinAnnularRing.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod MinAnnularRing.schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}') -> Dict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_post_init",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nmodel_post_init"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_post_init",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_post_init.html#pyedb.workflows.drc.drc.Rules.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "Rules.model_post_init(context: Any, /) -> None\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_bondwire",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_bondwire.html#create_bondwire",
        "title": "create_bondwire",
        "section": "create_bondwire",
        "text": "Create a bondwire object.\nType of bondwire: kAPDBondWire or kJDECBondWire types.\nBondwire definition name.\nLayer name this bondwire will be on.\nBondwire width.\nBondwire material name.\nName of start layer.\nX value of start point.\nY value of start point.\nName of end layer.\nX value of end point.\nY value of end point.\nNet of the Bondwire.\nAdded for grpc compatibility.\nBondwire object created.\ncreate_bondwire\nBondwireType\npython:str\npython:str\nValue\npython:str\npython:str\nValue\nValue\npython:str\nValue\nValue\npython:str\nNet\npython:None\npython:None\npyedb.dotnet.database.dotnet.primitive.BondwireDotNet"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_bondwire",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_bondwire.html#pyedb.dotnet.database.modeler.Modeler.create_bondwire",
        "title": "create_bondwire > create_bondwire > create_bondwire",
        "section": "create_bondwire > create_bondwire",
        "text": "Modeler.create_bondwire(definition_name, placement_layer, width, material, start_layer_name, start_x, start_y, end_layer_name, end_x, end_y, net, bondwire_type='jedec4', start_cell_instance_name=None)\n\nCreate a bondwire object.\n\nParameters\n\nbondwire_type\n\nBondwireType\n\nType of bondwire: kAPDBondWire or kJDECBondWire types.\n\ndefinition_name\n\npython:str\n\nBondwire definition name.\n\nplacement_layer\n\npython:str\n\nLayer name this bondwire will be on.\n\nwidth\n\nValue\n\nBondwire width.\n\nmaterial\n\npython:str\n\nBondwire material name.\n\nstart_layer_name\n\npython:str\n\nName of start layer.\n\nstart_x\n\nValue\n\nX value of start point.\n\nstart_y\n\nValue\n\nY value of start point.\n\nend_layer_name\n\npython:str\n\nName of end layer.\n\nend_x\n\nValue\n\nX value of end point.\n\nend_y\n\nValue\n\nY value of end point.\n\nnet\n\npython:str or Net or python:None\n\nNet of the Bondwire.\n\nstart_cell_instance_name\n\npython:None\n\nAdded for grpc compatibility.\n\nReturns\n\npyedb.dotnet.database.dotnet.primitive.BondwireDotNet\n\nBondwire object created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/arc_data",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/arc_data.html#arc-data",
        "title": "Arc Data",
        "section": "Arc Data",
        "text": "This class manages arc data.\nArcData\nClass managing ArcData.\nArc Data\nArcData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.plot",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.plot.html#plot",
        "title": "plot",
        "section": "plot",
        "text": "Plot the current polygon on matplotlib.\nWhether if plot the entire net or only the selected polygon. Default is False.\nWhether if show the plot or not. Default is True.\nSave the plot path.\nMatplotlib ax and figures.\nplot\noptional\nFalse\noptional\nTrue\npython:str\noptional\nax\nfig"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.plot",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.plot.html#pyedb.grpc.database.primitive.rectangle.Rectangle.plot",
        "title": "plot > plot > plot",
        "section": "plot > plot",
        "text": "Rectangle.plot(plot_net=False, show=True, save_plot=None)\n\nPlot the current polygon on matplotlib.\n\nParameters\n\nplot_net\n\nbool, optional\n\nWhether if plot the entire net or only the selected polygon. Default is False.\n\nshow\n\nbool, optional\n\nWhether if show the plot or not. Default is True.\n\nsave_plot\n\npython:str, optional\n\nSave the plot path.\n\nReturns\n\n(ax, fig)\n\nMatplotlib ax and figures.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFile.parse_technology",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFile.parse_technology.html#parse_technology",
        "title": "parse_technology",
        "section": "parse_technology",
        "text": "Parse a technology file and convert to XML control file.\nPath to technology file.\nEDB version to use for conversion.\nTrue if successful, False otherwise.\nparse_technology\npython:str\npython:str\noptional\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFile.parse_technology",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFile.parse_technology.html#pyedb.grpc.database.control_file.ControlFile.parse_technology",
        "title": "parse_technology > parse_technology > parse_technology",
        "section": "parse_technology > parse_technology",
        "text": "ControlFile.parse_technology(tecnhology: str, edbversion: str | None = None) -> bool\n\nParse a technology file and convert to XML control file.\n\nParameters\n\ntecnhology\n\npython:str\n\nPath to technology file.\n\nedbversion\n\npython:str, optional\n\nEDB version to use for conversion.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_to_ipc2581",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_to_ipc2581.html#export_to_ipc2581",
        "title": "export_to_ipc2581",
        "section": "export_to_ipc2581",
        "text": "Export design to IPC2581 format.\nFull path to aedb folder of the design to convert.\nPath to Ansys translator executable.\nOutput XML file path. Default: <edb_path>.xml.\nPath to output IPC2581 file, and corresponding log file.\nexport_to_ipc2581\npython:str\noptional\npython:str\noptional\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_to_ipc2581",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_to_ipc2581.html#pyedb.grpc.edb.Edb.export_to_ipc2581",
        "title": "export_to_ipc2581 > export_to_ipc2581 > export_to_ipc2581",
        "section": "export_to_ipc2581 > export_to_ipc2581",
        "text": "Edb.export_to_ipc2581(edbpath='', anstranslator_full_path='', ipc_path=None) -> str\n\nExport design to IPC2581 format.\n\nParameters\n\nedbpath: str\n\nFull path to aedb folder of the design to convert.\n\nanstranslator_full_path\n\npython:str, optional\n\nPath to Ansys translator executable.\n\nipc_path\n\npython:str, optional\n\nOutput XML file path. Default: <edb_path>.xml.\n\nReturns\n\npython:str\n\nPath to output IPC2581 file, and corresponding log file.\n\nExamples\n\n>>> # Export to IPC2581 format:\n>>> edb.export_to_ipc2581(\"output.xml\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/index",
        "href": "grpc_api/grpc/index.html#pyedb",
        "title": "PyEDB",
        "section": "PyEDB",
        "text": "This section describes EDB gRPC main class.\nPyEDB"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.parse_raw",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "parse_raw"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.parse_raw",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.parse_raw.html#pyedb.grpc.database.definition.materials.MaterialProperties.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod MaterialProperties.parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.add_rlc_boundary",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.add_rlc_boundary.html#add_rlc_boundary",
        "title": "add_rlc_boundary",
        "section": "add_rlc_boundary",
        "text": "Add RLC gap boundary on component and replace it with a circuit port.\nThe circuit port supports only 2-pin components.\nReference designator of the RLC component.\nWhen True circuit type are defined, if False gap type will be used instead (compatible with HFSS 3D\nmodeler). Default value is True.\nTrue when successful, False when failed.\nadd_rlc_boundary\npython:str\nTrue\nFalse\nTrue\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.add_rlc_boundary",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.add_rlc_boundary.html#pyedb.dotnet.database.components.Components.add_rlc_boundary",
        "title": "add_rlc_boundary > add_rlc_boundary > add_rlc_boundary",
        "section": "add_rlc_boundary > add_rlc_boundary",
        "text": "Components.add_rlc_boundary(component=None, circuit_type=True)\n\nAdd RLC gap boundary on component and replace it with a circuit port.\nThe circuit port supports only 2-pin components.\n\nParameters\n\ncomponent\n\npython:str\n\nReference designator of the RLC component.\n\ncircuit_type\n\nbool\n\nWhen True circuit type are defined, if False gap type will be used instead (compatible with HFSS 3D\nmodeler). Default value is True.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.html#value",
        "title": "Value",
        "section": "Value",
        "text": "Class defining Edb Value properties.\nValue.acos()\nArccosine of the value.\nValue.as_integer_ratio(/)\nReturn integer ratio.\nValue.asin()\nArcsine of the value.\nValue.atan()\nArctangent of the value.\nValue.conjugate(/)\nReturn self, the complex conjugate of any float.\nValue.cos()\nCosine of the value.\nValue.equals(other[, tolerance])\nCheck if this value and other value are equivalent when evaluated.\nValue.fromhex(string, /)\nCreate a floating-point number from a hexadecimal string.\nValue.hex(/)\nReturn a hexadecimal representation of a floating-point number.\nValue.is_integer(/)\nReturn True if the float is an integer.\nValue.log10()\nBase-10 logarithm of the value.\nValue.sin()\nSine of the value.\nValue.sqrt()\nSquare root of the value.\nValue.tan()\nTangent of the value.\nValue.imag\nthe imaginary part of a complex number\nValue.real\nthe real part of a complex number\nValue\nValue.acos\nValue.as_integer_ratio\nValue.asin\nValue.atan\nValue.conjugate\nValue.cos\nValue.equals\nValue.fromhex\nValue.hex\nValue.is_integer\nValue.log10\nValue.sin\nValue.sqrt\nValue.tan\nValue.imag\nValue.real"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.html#pyedb.grpc.database.utility.value.Value",
        "title": "Value > Value > Value",
        "section": "Value > Value",
        "text": "class pyedb.grpc.database.utility.value.Value(edb_obj, owner=None)\n\nClass defining Edb Value properties.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nValue.acos()\n\nArccosine of the value.\n\nValue.as_integer_ratio(/)\n\nReturn integer ratio.\n\nValue.asin()\n\nArcsine of the value.\n\nValue.atan()\n\nArctangent of the value.\n\nValue.conjugate(/)\n\nReturn self, the complex conjugate of any float.\n\nValue.cos()\n\nCosine of the value.\n\nValue.equals(other[, tolerance])\n\nCheck if this value and other value are equivalent when evaluated.\n\nValue.fromhex(string, /)\n\nCreate a floating-point number from a hexadecimal string.\n\nValue.hex(/)\n\nReturn a hexadecimal representation of a floating-point number.\n\nValue.is_integer(/)\n\nReturn True if the float is an integer.\n\nValue.log10()\n\nBase-10 logarithm of the value.\n\nValue.sin()\n\nSine of the value.\n\nValue.sqrt()\n\nSquare root of the value.\n\nValue.tan()\n\nTangent of the value.\n\n\n\nAttributes\n\n\n\n\n\n\n\nValue.imag\n\nthe imaginary part of a complex number\n\nValue.real\n\nthe real part of a complex number\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "LayoutObjType: Layout object type of the Primitive class.\nlayout_obj_type\nLayoutObjType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.layout_obj_type.html#pyedb.grpc.database.primitive.polygon.Polygon.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "Polygon.layout_obj_type = 0\n\nLayoutObjType: Layout object type of the Primitive class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.get_product_property.html#pyedb.grpc.database.ports.ports.CoaxPort.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "CoaxPort.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.in_polygon",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.in_polygon.html#in_polygon",
        "title": "in_polygon",
        "section": "in_polygon",
        "text": "Check if padstack Instance is in given polygon data.\nWhether to include partial intersecting instances. The default is True.\nTrue when successful, False when failed.\nin_polygon\nPointData\nObject\npython:list\nof\npython:float\noptional\nTrue\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.in_polygon",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.in_polygon.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.in_polygon",
        "title": "in_polygon > in_polygon > in_polygon",
        "section": "in_polygon > in_polygon",
        "text": "EdbPolygon.in_polygon(point_data, include_partial=True)\n\nCheck if padstack Instance is in given polygon data.\n\nParameters\n\npoint_data\n\nPointData Object or python:list of python:float\n\n\n\ninclude_partial\n\nbool, optional\n\nWhether to include partial intersecting instances. The default is True.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/index",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/index.html#terminal-classes",
        "title": "Terminal classes",
        "section": "Terminal classes",
        "text": "This section describes EDB terminal classes.\nTerminal classes"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.set_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.set_hfss_prop.html#set_hfss_prop",
        "title": "set_hfss_prop",
        "section": "set_hfss_prop",
        "text": "Set HFSS properties.\nMaterial property name to set.\nWhether to solve inside.\nset_hfss_prop\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.set_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.set_hfss_prop.html#pyedb.grpc.database.primitive.circle.Circle.set_hfss_prop",
        "title": "set_hfss_prop > set_hfss_prop > set_hfss_prop",
        "section": "set_hfss_prop > set_hfss_prop",
        "text": "Circle.set_hfss_prop(material: str, solve_inside: bool)\n\nSet HFSS properties.\n\nParameters\n\nmaterial\n\npython:str\n\nMaterial property name to set.\n\nsolve_inside\n\nbool\n\nWhether to solve inside.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.min_clearance",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.min_clearance.html#min_clearance",
        "title": "min_clearance",
        "section": "min_clearance",
        "text": "min_clearance"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.min_clearance",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.min_clearance.html#pyedb.workflows.drc.drc.Rules.min_clearance",
        "title": "min_clearance > min_clearance > min_clearance",
        "section": "min_clearance > min_clearance",
        "text": "Rules.min_clearance: List[MinClearance]\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_siwave_report",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_siwave_report.html#export_siwave_report",
        "title": "export_siwave_report",
        "section": "export_siwave_report",
        "text": "Export the Siwave report.\nName of the setup.\nPath to the exported report.\nColor of the report’s background. The default is \"White\".\nTrue when successful, False when failed.\nexport_siwave_report\npython:str\npython:str\npython:str\noptional\n\"White\"\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_siwave_report",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_siwave_report.html#pyedb.siwave.Siwave.export_siwave_report",
        "title": "export_siwave_report > export_siwave_report > export_siwave_report",
        "section": "export_siwave_report > export_siwave_report",
        "text": "Siwave.export_siwave_report(simulation_name, file_path, bkground_color='White')\n\nExport the Siwave report.\n\nParameters\n\nsimulation_name\n\npython:str\n\nName of the setup.\n\nfile_path\n\npython:str\n\nPath to the exported report.\n\nbkground_color\n\npython:str, optional\n\nColor of the report’s background. The default is \"White\".\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_fields.html#pyedb.workflows.drc.drc.MinLineWidth.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "MinLineWidth.model_fields = {'name': FieldInfo(annotation=str, required=True), 'value': FieldInfo(annotation=str, required=True)}\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.create_3d_comp.html#create_3d_comp",
        "title": "create_3d_comp",
        "section": "create_3d_comp",
        "text": "Create a 3D composite model from an MCAD file.\n3D composite model created.\ncreate_3d_comp\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.create_3d_comp.html#pyedb.grpc.database.primitive.rectangle.Rectangle.create_3d_comp",
        "title": "create_3d_comp > create_3d_comp > create_3d_comp",
        "section": "create_3d_comp > create_3d_comp",
        "text": "Rectangle.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nReturns\n\nMcadModel\n\n3D composite model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave.html#siwave",
        "title": "Siwave",
        "section": "Siwave",
        "text": "Manages EDB methods related to Siwave Setup accessible from Edb.siwave property.\nInherited parent object.\nSiwave.add_cpa_analysis([name, ...])\n\nSiwave.add_siwave_dc_analysis([name])\nAdd a Siwave DC analysis in EDB.\nSiwave.add_siwave_syz_analysis([...])\nAdd a SIwave AC analysis to EDB.\nSiwave.create_exec_file([add_dc, add_ac, ...])\nCreate an executable file.\nSiwave.create_impedance_crosstalk_scan([...])\nCreate Siwave crosstalk scan object.\nSiwave\npyedb.edb.Edb\nSiwave.add_cpa_analysis\nSiwave.add_siwave_dc_analysis\nSiwave.add_siwave_syz_analysis\nSiwave.create_exec_file\nSiwave.create_impedance_crosstalk_scan"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave.html#pyedb.grpc.database.siwave.Siwave",
        "title": "Siwave > Siwave > Siwave",
        "section": "Siwave > Siwave",
        "text": "class pyedb.grpc.database.siwave.Siwave(p_edb)\n\nManages EDB methods related to Siwave Setup accessible from Edb.siwave property.\n\nParameters\n\nedb_class\n\npyedb.edb.Edb\n\nInherited parent object.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", edbversion=\"2021.2\")\n>>> edb_siwave = edbapp.siwave\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nSiwave.add_cpa_analysis([name, ...])\n\n\n\nSiwave.add_siwave_dc_analysis([name])\n\nAdd a Siwave DC analysis in EDB.\n\nSiwave.add_siwave_syz_analysis([...])\n\nAdd a SIwave AC analysis to EDB.\n\nSiwave.create_exec_file([add_dc, add_ac, ...])\n\nCreate an executable file.\n\nSiwave.create_impedance_crosstalk_scan([...])\n\nCreate Siwave crosstalk scan object.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.angle",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.angle.html#angle",
        "title": "angle",
        "section": "angle",
        "text": "Get the angle between this vector and another vector.\nOther vector.\nAngle in radians.\nangle\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.angle",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.angle.html#pyedb.grpc.database.geometry.point_data.PointData.angle",
        "title": "angle > angle > angle",
        "section": "angle > angle",
        "text": "PointData.angle(other: PointLike) -> float\n\nGet the angle between this vector and another vector.\n\nParameters\n\nother\n\nPoint2DLike\n\nOther vector.\n\nReturns\n\npython:float\n\nAngle in radians.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.get_product_property.html#pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "PinGroupTerminal.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.subtract",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.subtract.html#subtract",
        "title": "subtract",
        "section": "subtract",
        "text": "Subtract active primitive with one or more primitives.\nor: List[Primitives]\nor: class:PolygonData <ansys.edb.core.geometry.polygon_data.PolygonData>\nList of Primitive objects.\nsubtract\nPrimitives\nPrimitives\nList\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.subtract",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.subtract.html#pyedb.grpc.database.primitive.path.Path.subtract",
        "title": "subtract > subtract > subtract",
        "section": "subtract > subtract",
        "text": "Path.subtract(primitives) -> list[any]\n\nSubtract active primitive with one or more primitives.\n\nParameters\n\nprimitives\n\nPrimitives\n\nor: List[Primitives]\nor: class:PolygonData <ansys.edb.core.geometry.polygon_data.PolygonData>\n\nReturns\n\nList[Primitive]\n\nList of Primitive objects.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.equals",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.equals.html#equals",
        "title": "equals",
        "section": "equals",
        "text": "Check if this value and other value are equivalent when evaluated.\nOther value to compare to.\nTolerance.\nTrue` if this value and the other value are equivalent when evaluated.\nequals\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.equals",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.equals.html#pyedb.grpc.database.utility.value.Value.equals",
        "title": "equals > equals > equals",
        "section": "equals > equals",
        "text": "Value.equals(other: ValueLike, tolerance: float = 1e-09)\n\nCheck if this value and other value are equivalent when evaluated.\n\nParameters\n\nother\n\nValueLike\n\nOther value to compare to.\n\ntolerance\n\npython:float, default: 1e-9\n\nTolerance.\n\nReturns\n\nbool\n\nTrue` if this value and the other value are equivalent when evaluated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.set_component_model",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.set_component_model.html#set_component_model",
        "title": "set_component_model",
        "section": "set_component_model",
        "text": "Assign a Spice or Touchstone model to a component.\nName of the component.\nType of the model. Options are \"Spice\" and\n\"Touchstone\".  The default is \"Spice\".\nFull path to the model file. The default is None.\nName of the model. The default is None.\nTrue when successful, False when failed.\nset_component_model\npython:str\npython:str\noptional\n\"Spice\"\n\"Touchstone\"\n\"Spice\"\npython:str\noptional\nNone\npython:str\noptional\nNone\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.set_component_model",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.set_component_model.html#pyedb.dotnet.database.components.Components.set_component_model",
        "title": "set_component_model > set_component_model > set_component_model",
        "section": "set_component_model > set_component_model",
        "text": "Components.set_component_model(componentname, model_type='Spice', modelpath=None, modelname=None)\n\nAssign a Spice or Touchstone model to a component.\n\nParameters\n\ncomponentname\n\npython:str\n\nName of the component.\n\nmodel_type\n\npython:str, optional\n\nType of the model. Options are \"Spice\" and\n\"Touchstone\".  The default is \"Spice\".\n\nmodelpath\n\npython:str, optional\n\nFull path to the model file. The default is None.\n\nmodelname\n\npython:str, optional\n\nName of the model. The default is None.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\")\n>>> edbapp.components.set_component_model(\n...     \"A1\", model_type=\"Spice\", modelpath=\"pathtospfile\", modelname=\"spicemodelname\"\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_layout_component",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_layout_component.html#export_layout_component",
        "title": "export_layout_component",
        "section": "export_layout_component",
        "text": "Export a layout component from the current layout.\nThis feature is only supported with PyEDB gRPC. Encryption is not yet supported.\nLayout component path (.aedbcomp file).\nTrue if layout component is successfully exported, False otherwise.\nexport_layout_component\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_layout_component",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_layout_component.html#pyedb.grpc.edb.Edb.export_layout_component",
        "title": "export_layout_component > export_layout_component > export_layout_component",
        "section": "export_layout_component > export_layout_component",
        "text": "Edb.export_layout_component(component_path) -> bool\n\nExport a layout component from the current layout.\nThis feature is only supported with PyEDB gRPC. Encryption is not yet supported.\n\nParameters\n\ncomponent_path\n\npython:str\n\nLayout component path (.aedbcomp file).\n\nReturns\n\nbool\n\nTrue if layout component is successfully exported, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.create",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create an HFSS simulation setup.\nCell to create the simulation setup in.\nName of the simulation setup.\nHFSS simulation setup created.\ncreate\nCell\npython:str\nHfssSimulationSetup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.create",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.create.html#pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod HfssSimulationSetup.create(cell, name)\n\nCreate an HFSS simulation setup.\n\nParameters\n\ncell\n\nCell\n\nCell to create the simulation setup in.\n\nname\n\npython:str\n\nName of the simulation setup.\n\nReturns\n\nHfssSimulationSetup\n\nHFSS simulation setup created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_computed_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_computed_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_computed_fields.html#pyedb.workflows.drc.drc.Rules.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "Rules.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_source_on_pin",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_source_on_pin.html#create_voltage_source_on_pin",
        "title": "create_voltage_source_on_pin",
        "section": "create_voltage_source_on_pin",
        "text": "Create a voltage source.\nPositive Pin.\nNegative Pin.\nValue for the voltage. The default is 3.3.\nValue for the phase. The default is 0.\nName of the source. The default is \"\".\nSource Name.\ncreate_voltage_source_on_pin\nObject\nObject\npython:float\noptional\n3.3\noptional\n0\npython:str\noptional\n\"\"\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_source_on_pin",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_source_on_pin.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_source_on_pin",
        "title": "create_voltage_source_on_pin > create_voltage_source_on_pin > create_voltage_source_on_pin",
        "section": "create_voltage_source_on_pin > create_voltage_source_on_pin",
        "text": "SourceExcitation.create_voltage_source_on_pin(pos_pin: str | PadstackInstance, neg_pin: str | PadstackInstance, voltage_value: int | float = 0, phase_value: int | float = 0, source_name: str | None = None) -> str | None\n\nCreate a voltage source.\n\nParameters\n\npos_pin\n\nObject\n\nPositive Pin.\n\nneg_pin\n\nObject\n\nNegative Pin.\n\nvoltage_value\n\npython:float, optional\n\nValue for the voltage. The default is 3.3.\n\nphase_value\n\noptional\n\nValue for the phase. The default is 0.\n\nsource_name\n\npython:str, optional\n\nName of the source. The default is \"\".\n\nReturns\n\npython:str\n\nSource Name.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> pin1 = edb.components[\"U1\"].pins[\"VCC\"]\n>>> pin2 = edb.components[\"U1\"].pins[\"GND\"]\n>>> edb.source_excitation.create_voltage_source_on_pin(pin1, pin2, 3.3, name=\"VSource1\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the primitive object to the correct concrete type.\ncast\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.cast.html#pyedb.grpc.database.primitive.bondwire.Bondwire.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "Bondwire.cast() -> Primitive | None\n\nCast the primitive object to the correct concrete type.\n\nReturns\n\nPrimitive\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.get_product_property",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layer collection for a given product ID and attribute ID.\nProduct ID.\nAttribute ID.\nProduct property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.get_product_property",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.get_product_property.html#pyedb.grpc.database.stackup.LayerCollection.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "LayerCollection.get_product_property(prod_id, attr_it)\n\nGet the product property of the layer collection for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nProduct ID.\n\nattr_it\n\npython:int\n\nAttribute ID.\n\nReturns\n\npython:str\n\nProduct property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_back_drill_by_layer",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_back_drill_by_layer.html#set_back_drill_by_layer",
        "title": "set_back_drill_by_layer",
        "section": "set_back_drill_by_layer",
        "text": "Set back drill layer.\nLayer to drill to.\nOffset value\nDrill diameter\nDefault value is True\nset_back_drill_by_layer\npython:str\nLayer\npython:str\npython:float\npython:str\npython:float\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_back_drill_by_layer",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_back_drill_by_layer.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_back_drill_by_layer",
        "title": "set_back_drill_by_layer > set_back_drill_by_layer > set_back_drill_by_layer",
        "section": "set_back_drill_by_layer > set_back_drill_by_layer",
        "text": "PadstackInstance.set_back_drill_by_layer(drill_to_layer, offset, diameter, from_bottom=True)\n\nSet back drill layer.\n\nParameters\n\ndrill_to_layer\n\npython:str, Layer\n\nLayer to drill to.\n\noffset\n\npython:str, python:float\n\nOffset value\n\ndiameter\n\npython:str, python:float\n\nDrill diameter\n\nfrom_bottom\n\nbool, optional\n\nDefault value is True\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.layout_obj_type.html#pyedb.grpc.database.ports.ports.CoaxPort.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "CoaxPort.layout_obj_type = 2\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layer_bottom",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layer_bottom.html#add_layer_bottom",
        "title": "add_layer_bottom",
        "section": "add_layer_bottom",
        "text": "Add a layer at the bottom of the stackup.\nName of the layer.\nType of the layer. The default is \"signal\". Options are \"signal\" and \"dielectric\".\nAdditional keyword arguments. Possible keys are:\n- thickness : float, layer thickness.\n- material : str, layer material.\n- fill_material : str, fill material.\nLayer object created.\nadd_layer_bottom\npython:str\npython:str\noptional\n\"signal\"\n\"signal\"\n\"dielectric\"\npython:dict\noptional\nthickness\nmaterial\nfill_material\npyedb.grpc.database.layers.stackup_layer.StackupLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layer_bottom",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layer_bottom.html#pyedb.grpc.database.stackup.Stackup.add_layer_bottom",
        "title": "add_layer_bottom > add_layer_bottom > add_layer_bottom",
        "section": "add_layer_bottom > add_layer_bottom",
        "text": "Stackup.add_layer_bottom(name: str, layer_type: str = 'signal', **kwargs) -> Layer | None\n\nAdd a layer at the bottom of the stackup.\n\nParameters\n\nname\n\npython:str\n\nName of the layer.\n\nlayer_type\n\npython:str, optional\n\nType of the layer. The default is \"signal\". Options are \"signal\" and \"dielectric\".\n\n**kwargs\n\npython:dict, optional\n\nAdditional keyword arguments. Possible keys are:\n- thickness : float, layer thickness.\n- material : str, layer material.\n- fill_material : str, fill material.\n\nReturns\n\npyedb.grpc.database.layers.stackup_layer.StackupLayer\n\nLayer object created.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> bot_layer = edb.stackup.add_layer_bottom(\n...     \"NewBottomLayer\", layer_type=\"signal\", thickness=\"0.1mm\", material=\"copper\"\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.delete",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete a component.\nComponent name.\nTrue if successful, False otherwise.\ndelete\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.delete",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.delete.html#pyedb.grpc.database.components.Components.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "Components.delete(component_name: str) -> bool\n\nDelete a component.\n\nParameters\n\ncomponent_name\n\npython:str\n\nComponent name.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\nExamples\n\n>>> edbapp.components.delete(\"R1\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.is_intersecting",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.is_intersecting.html#is_intersecting",
        "title": "is_intersecting",
        "section": "is_intersecting",
        "text": "Check if actual primitive and another primitive or polygon data intesects.\nis_intersecting\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.is_intersecting",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.is_intersecting.html#pyedb.grpc.database.primitive.rectangle.Rectangle.is_intersecting",
        "title": "is_intersecting > is_intersecting > is_intersecting",
        "section": "is_intersecting > is_intersecting",
        "text": "Rectangle.is_intersecting(primitive) -> bool\n\nCheck if actual primitive and another primitive or polygon data intesects.\n\nParameters\n\nprimitive\n\nPrimitive or PolygonData\n\n\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.type.html#type",
        "title": "type",
        "section": "type",
        "text": "type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.type.html#pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.type",
        "title": "type > type > type",
        "section": "type > type",
        "text": "BundleTerminal.type = 4\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.add_power_modules",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.add_power_modules.html#add_power_modules",
        "title": "add_power_modules",
        "section": "add_power_modules",
        "text": "Add multiple power modules to the voltage regulator.\nList of power modules to add.\nadd_power_modules\npython:list\nPowerModule"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.add_power_modules",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.add_power_modules.html#pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.add_power_modules",
        "title": "add_power_modules > add_power_modules > add_power_modules",
        "section": "add_power_modules > add_power_modules",
        "text": "VoltageRegulator.add_power_modules(power_modules)\n\nAdd multiple power modules to the voltage regulator.\n\nParameters\n\npower_modules\n\npython:list[PowerModule]\n\nList of power modules to add.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.DifferentialTLine",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.DifferentialTLine.html#differentialtline",
        "title": "DifferentialTLine",
        "section": "DifferentialTLine",
        "text": "Edge-coupled differential pair with fully parametric geometry.\nTotal length of the pair.\nWidth of each individual trace.\nEdge-to-edge separation between the traces.\nStart x-coordinate (metres).\nStart y-coordinate (metres).\nRotation angle of the pair (radians, CCW).\nLayer on which the traces are drawn.\nNet name for the positive trace.\nNet name for the negative trace.\nDifferentialTLine.create()\nCreate the two traces using only parameter strings so the geometry stays fully editable in AEDT.\nDifferentialTLine.List\nalias of List\nDifferentialTLine.Optional\n\nDifferentialTLine\npython:float\ndefault\nmm\npython:float\ndefault\nmm\npython:float\ndefault\nmm\npython:float\ndefault\npython:float\ndefault\npython:float\ndefault\nrad\npython:str\ndefault\npython:str\ndefault\npython:str\ndefault\nDifferentialTLine.create\nDifferentialTLine.List\nList\nDifferentialTLine.Optional"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.DifferentialTLine",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.DifferentialTLine.html#pyedb.libraries.rf_libraries.base_functions.DifferentialTLine",
        "title": "DifferentialTLine > DifferentialTLine > DifferentialTLine",
        "section": "DifferentialTLine > DifferentialTLine",
        "text": "class pyedb.libraries.rf_libraries.base_functions.DifferentialTLine(edb: Edb, length: float | str = 0.01, width: float | str = 0.0002, spacing: float | str = 0.0002, x0: float | str = 0.0, y0: float | str = 0.0, angle: float | str = 0.0, layer: str = 'TOP', net_p: str = 'P', net_n: str = 'N')\n\nEdge-coupled differential pair with fully parametric geometry.\n\nParameters\n\nlength\n\npython:float, default 10 mm\n\nTotal length of the pair.\n\nwidth\n\npython:float, default 0.2 mm\n\nWidth of each individual trace.\n\nspacing\n\npython:float, default 0.2 mm\n\nEdge-to-edge separation between the traces.\n\nx0\n\npython:float, default 0\n\nStart x-coordinate (metres).\n\ny0\n\npython:float, default 0\n\nStart y-coordinate (metres).\n\nangle\n\npython:float, default 0 rad\n\nRotation angle of the pair (radians, CCW).\n\nlayer\n\npython:str, default “TOP”\n\nLayer on which the traces are drawn.\n\nnet_p\n\npython:str, default “P”\n\nNet name for the positive trace.\n\nnet_n\n\npython:str, default “N”\n\nNet name for the negative trace.\n\nExamples\n\n>>> diff = DifferentialTLine(Edb(\"diff.aedb\"), length=5e-3, width=0.15e-3, spacing=0.1e-3, angle=math.pi / 4)\n>>> traces = diff.create()\n>>> f\"{diff.diff_impedance:.1f} Ω\"\n'95.6 Ω'\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nDifferentialTLine.create()\n\nCreate the two traces using only parameter strings so the geometry stays fully editable in AEDT.\n\n\n\nAttributes\n\n\n\n\n\n\n\nDifferentialTLine.List\n\nalias of List\n\nDifferentialTLine.Optional\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.add_skin_depth_mesh_operation",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.add_skin_depth_mesh_operation.html#add_skin_depth_mesh_operation",
        "title": "add_skin_depth_mesh_operation",
        "section": "add_skin_depth_mesh_operation",
        "text": "Add a mesh operation to the setup.\nDictionary containing nets and layers on which enable Mesh operation. Example {\"A0_N\": [\"TOP\", \"PWR\"]}.\nMesh operation name.\nMaximum number of elements. Default is 1000.\nSkin Depth. Default is 1um.\nWhether to restrict number of elements. Default is True.\nSurface Triangle length. Default is 1mm.\nNumber of layers. Default is 2.\nMesh region name.\nWhether to refine inside or not.  Default is False.\nadd_skin_depth_mesh_operation\npython:dict\n{\"A0_N\": [\"TOP\", \"PWR\"]}\npython:str\noptional\npython:int\noptional\n1000\npython:str\noptional\n1um\noptional\nTrue\noptional\n1mm\npython:int\npython:str\noptional\n2\npython:str\noptional\noptional\nFalse\nLengthMeshOperation"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.add_skin_depth_mesh_operation",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.add_skin_depth_mesh_operation.html#pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.add_skin_depth_mesh_operation",
        "title": "add_skin_depth_mesh_operation > add_skin_depth_mesh_operation > add_skin_depth_mesh_operation",
        "section": "add_skin_depth_mesh_operation > add_skin_depth_mesh_operation",
        "text": "HfssSimulationSetup.add_skin_depth_mesh_operation(net_layer_list, name=None, max_elements=1000, skin_depth='1um', restrict_elements=True, surface_triangle_length='1mm', number_of_layers=2, refine_inside=False, mesh_region=None)\n\nAdd a mesh operation to the setup.\n\nParameters\n\nnet_layer_list\n\npython:dict\n\nDictionary containing nets and layers on which enable Mesh operation. Example {\"A0_N\": [\"TOP\", \"PWR\"]}.\n\nname\n\npython:str, optional\n\nMesh operation name.\n\nmax_elements\n\npython:int, optional\n\nMaximum number of elements. Default is 1000.\n\nskin_depth\n\npython:str, optional\n\nSkin Depth. Default is 1um.\n\nrestrict_elements\n\nbool, optional\n\nWhether to restrict number of elements. Default is True.\n\nsurface_triangle_length\n\nbool, optional\n\nSurface Triangle length. Default is 1mm.\n\nnumber_of_layers\n\npython:int, python:str, optional\n\nNumber of layers. Default is 2.\n\nmesh_region\n\npython:str, optional\n\nMesh region name.\n\nrefine_inside\n\nbool, optional\n\nWhether to refine inside or not.  Default is False.\n\nReturns\n\nLengthMeshOperation\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "construct"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.construct.html#pyedb.workflows.drc.drc.MinLineWidth.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod MinLineWidth.construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.set_component_model",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.set_component_model.html#set_component_model",
        "title": "set_component_model",
        "section": "set_component_model",
        "text": "Set component model.\nComponent name.\nModel type (“Spice” or “Touchstone”).\nModel file path.\nModel name.\nTrue if successful, False otherwise.\nset_component_model\npython:str\npython:str\noptional\npython:str\noptional\npython:str\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.set_component_model",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.set_component_model.html#pyedb.grpc.database.components.Components.set_component_model",
        "title": "set_component_model > set_component_model > set_component_model",
        "section": "set_component_model > set_component_model",
        "text": "Components.set_component_model(componentname: str, model_type: str = 'Spice', modelpath: str | None = None, modelname: str | None = None) -> bool\n\nSet component model.\n\nParameters\n\ncomponentname\n\npython:str\n\nComponent name.\n\nmodel_type\n\npython:str, optional\n\nModel type (“Spice” or “Touchstone”).\n\nmodelpath\n\npython:str, optional\n\nModel file path.\n\nmodelname\n\npython:str, optional\n\nModel name.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\nExamples\n\n>>> edbapp.components.set_component_model(\"U1\", \"Spice\", \"path/to/model.sp\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_end_elevation",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_end_elevation.html#get_end_elevation",
        "title": "get_end_elevation",
        "section": "get_end_elevation",
        "text": "Get the end elevation layer of the bondwire.\nEnd cell context of the bondwire.\nEnd elevation layer of the bondwire.\nget_end_elevation\nCellInstance\nLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_end_elevation",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_end_elevation.html#pyedb.grpc.database.primitive.bondwire.Bondwire.get_end_elevation",
        "title": "get_end_elevation > get_end_elevation > get_end_elevation",
        "section": "get_end_elevation > get_end_elevation",
        "text": "Bondwire.get_end_elevation(end_context: CellInstance) -> Layer\n\nGet the end elevation layer of the bondwire.\n\nParameters\n\nend_context\n\nCellInstance\n\nEnd cell context of the bondwire.\n\nReturns\n\nLayer\n\nEnd elevation layer of the bondwire.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_solder_ball_height",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_solder_ball_height.html#get_solder_ball_height",
        "title": "get_solder_ball_height",
        "section": "get_solder_ball_height",
        "text": "Get component solder ball height.\nEDB component or str component name.\nSalder ball height vale, False when failed.\nget_solder_ball_height\npython:str\nself._pedb.component\ndouble\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_solder_ball_height",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_solder_ball_height.html#pyedb.dotnet.database.components.Components.get_solder_ball_height",
        "title": "get_solder_ball_height > get_solder_ball_height > get_solder_ball_height",
        "section": "get_solder_ball_height > get_solder_ball_height",
        "text": "Components.get_solder_ball_height(cmp)\n\nGet component solder ball height.\n\nParameters\n\ncmp\n\npython:str or  self._pedb.component\n\nEDB component or str component name.\n\nReturns\n\ndouble, bool\n\nSalder ball height vale, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.html#siwavesimulationsetup",
        "title": "SiwaveSimulationSetup",
        "section": "SiwaveSimulationSetup",
        "text": "Manages EDB methods for SIwave simulation setup.\nSiwaveSimulationSetup.add_frequency_sweep([...])\nAdd frequency sweep.\nSiwaveSimulationSetup.add_sweep([name, ...])\nAdd frequency sweep.\nSiwaveSimulationSetup.create([name])\nCreate a SIwave SYZ setup.\nSiwaveSimulationSetup.delete()\nDelete current simulation setup.\nSiwaveSimulationSetup.delete_frequency_sweep(...)\nDelete a frequency sweep.\nSiwaveSimulationSetup.get_configurations()\nGet SIwave SYZ simulation settings.\nSiwaveSimulationSetup.get_simulation_settings()\n\nSiwaveSimulationSetup.set_si_slider(value)\nSet SIwave SI simulation accuracy level.\nSiwaveSimulationSetup.set_sim_setup_info(...)\n\nSiwaveSimulationSetup.set_simulation_settings(...)\n\nSiwaveSimulationSetup\nSiwaveSimulationSetup.add_frequency_sweep\nSiwaveSimulationSetup.add_sweep\nSiwaveSimulationSetup.create\nSiwaveSimulationSetup.delete\nSiwaveSimulationSetup.delete_frequency_sweep\nSiwaveSimulationSetup.get_configurations\nSiwaveSimulationSetup.get_simulation_settings\nSiwaveSimulationSetup.set_si_slider\nSiwaveSimulationSetup.set_sim_setup_info\nSiwaveSimulationSetup.set_simulation_settings"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.html#pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup",
        "title": "SiwaveSimulationSetup > SiwaveSimulationSetup > SiwaveSimulationSetup",
        "section": "SiwaveSimulationSetup > SiwaveSimulationSetup",
        "text": "class pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup(pedb, edb_object=None, name: str | None = None)\n\nManages EDB methods for SIwave simulation setup.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nSiwaveSimulationSetup.add_frequency_sweep([...])\n\nAdd frequency sweep.\n\nSiwaveSimulationSetup.add_sweep([name, ...])\n\nAdd frequency sweep.\n\nSiwaveSimulationSetup.create([name])\n\nCreate a SIwave SYZ setup.\n\nSiwaveSimulationSetup.delete()\n\nDelete current simulation setup.\n\nSiwaveSimulationSetup.delete_frequency_sweep(...)\n\nDelete a frequency sweep.\n\nSiwaveSimulationSetup.get_configurations()\n\nGet SIwave SYZ simulation settings.\n\nSiwaveSimulationSetup.get_simulation_settings()\n\n\n\nSiwaveSimulationSetup.set_si_slider(value)\n\nSet SIwave SI simulation accuracy level.\n\nSiwaveSimulationSetup.set_sim_setup_info(...)\n\n\n\nSiwaveSimulationSetup.set_simulation_settings(...)\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_maxwell",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_maxwell.html#export_maxwell",
        "title": "export_maxwell",
        "section": "export_maxwell",
        "text": "Export to Maxwell project.\nOutput directory.\nNets to export.\nProcessing cores to use.\nCustom AEDT filename.\nRun Siwave in background. Default False.\nPath to generated AEDT file.\nexport_maxwell\npython:str\npython:list\noptional\npython:int\noptional\npython:str\noptional\noptional\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_maxwell",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_maxwell.html#pyedb.grpc.edb.Edb.export_maxwell",
        "title": "export_maxwell > export_maxwell > export_maxwell",
        "section": "export_maxwell > export_maxwell",
        "text": "Edb.export_maxwell(path_to_output, net_list=None, num_cores=None, aedt_file_name=None, hidden=False)\n\nExport to Maxwell project.\n\nParameters\n\npath_to_output\n\npython:str\n\nOutput directory.\n\nnet_list\n\npython:list, optional\n\nNets to export.\n\nnum_cores\n\npython:int, optional\n\nProcessing cores to use.\n\naedt_file_name\n\npython:str, optional\n\nCustom AEDT filename.\n\nhidden\n\nbool, optional\n\nRun Siwave in background. Default False.\n\nReturns\n\npython:str\n\nPath to generated AEDT file.\n\nExamples\n\n>>> # Export to Maxwell project:\n>>> edb.export_maxwell(r\"C:/output\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_component_by_name",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_component_by_name.html#get_component_by_name",
        "title": "get_component_by_name",
        "section": "get_component_by_name",
        "text": "Retrieve a component by name.\nName of the component.\nTrue when successful, False when failed.\nget_component_by_name\npython:str\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_component_by_name",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_component_by_name.html#pyedb.dotnet.database.components.Components.get_component_by_name",
        "title": "get_component_by_name > get_component_by_name > get_component_by_name",
        "section": "get_component_by_name > get_component_by_name",
        "text": "Components.get_component_by_name(name)\n\nRetrieve a component by name.\n\nParameters\n\nname\n\npython:str\n\nName of the component.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/PrimitivesData",
        "href": "dotnet_api/dotnet/edb_data/PrimitivesData.html#modeler--primitives",
        "title": "Modeler & primitives",
        "section": "Modeler & primitives",
        "text": "These classes are the containers of primitives and all relative methods.\nPrimitives are planes, lines, rectangles, and circles.\nModeler & primitives"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/PrimitivesData",
        "href": "dotnet_api/dotnet/edb_data/PrimitivesData.html#primitives-properties",
        "title": "Modeler & primitives > Primitives properties",
        "section": "Primitives properties",
        "text": "These classes are the containers of data management for primitives and arcs.\nEDBArcs\nManages EDB Arc Data functionalities.\nEdbPolygon\n\nPrimitives properties\nEDBArcs\nEdbPolygon"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.duplicate",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.duplicate.html#duplicate",
        "title": "duplicate",
        "section": "duplicate",
        "text": "Duplicate a material from the database.\nName of the existing material.\nName of the new duplicated material.\nMaterial object.\nduplicate\npython:str\npython:str\nMaterial"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.duplicate",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.duplicate.html#pyedb.grpc.database.definition.materials.Materials.duplicate",
        "title": "duplicate > duplicate > duplicate",
        "section": "duplicate > duplicate",
        "text": "Materials.duplicate(material_name, new_material_name) -> Material\n\nDuplicate a material from the database.\n\nParameters\n\nmaterial_name\n\npython:str\n\nName of the existing material.\n\nnew_material_name\n\npython:str\n\nName of the new duplicated material.\n\nReturns\n\nMaterial\n\nMaterial object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create_clearance_on_component",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create_clearance_on_component.html#create_clearance_on_component",
        "title": "create_clearance_on_component",
        "section": "create_clearance_on_component",
        "text": "Create a Clearance on Soldermask layer by drawing a rectangle.\nExtra Soldermask value in meter to be applied on component bounding box.\ncreate_clearance_on_component\npython:float\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create_clearance_on_component",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create_clearance_on_component.html#pyedb.grpc.database.hierarchy.component.Component.create_clearance_on_component",
        "title": "create_clearance_on_component > create_clearance_on_component > create_clearance_on_component",
        "section": "create_clearance_on_component > create_clearance_on_component",
        "text": "Component.create_clearance_on_component(extra_soldermask_clearance=0.0001) -> bool\n\nCreate a Clearance on Soldermask layer by drawing a rectangle.\n\nParameters\n\nextra_soldermask_clearance\n\npython:float, optional\n\nExtra Soldermask value in meter to be applied on component bounding box.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileImportOptions",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileImportOptions.html#controlfileimportoptions",
        "title": "ControlFileImportOptions",
        "section": "ControlFileImportOptions",
        "text": "Import Options.\nControlFileImportOptions"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileImportOptions",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileImportOptions.html#pyedb.grpc.database.utility.xml_control_file.ControlFileImportOptions",
        "title": "ControlFileImportOptions > ControlFileImportOptions > ControlFileImportOptions",
        "section": "ControlFileImportOptions > ControlFileImportOptions",
        "text": "class pyedb.grpc.database.utility.xml_control_file.ControlFileImportOptions\n\nImport Options.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.product_solver_option.html#product_solver_option",
        "title": "product_solver_option",
        "section": "product_solver_option",
        "text": "Get the name of the product solver option.\nID of the product.\nName of the solver.\nName of the product solver option.\nproduct_solver_option\nProductIdType\nstr\nstr"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.product_solver_option.html#pyedb.grpc.database.terminal.terminal.Terminal.product_solver_option",
        "title": "product_solver_option > product_solver_option > product_solver_option",
        "section": "product_solver_option > product_solver_option",
        "text": "Terminal.product_solver_option(product_id, solver_name)\n\nGet the name of the product solver option.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nsolver_name\n\nstr\n\nName of the solver.\n\nReturns\n\nstr\n\nName of the product solver option.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_hfss_prop.html#get_hfss_prop",
        "title": "get_hfss_prop",
        "section": "get_hfss_prop",
        "text": "Get HFSS properties.\nReturns a tuple in this format:\n(material, solve_inside)\nmaterial :  Name of the material property.\nsolve_inside : Whether to solve inside.\nget_hfss_prop\npython:tuple\nof\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_hfss_prop.html#pyedb.grpc.database.primitive.path.Path.get_hfss_prop",
        "title": "get_hfss_prop > get_hfss_prop > get_hfss_prop",
        "section": "get_hfss_prop > get_hfss_prop",
        "text": "Path.get_hfss_prop() -> tuple[str, bool]\n\nGet HFSS properties.\n\nReturns\n\npython:tuple of (python:str, bool)\n\nReturns a tuple in this format:\n\n(material, solve_inside)\n\nmaterial :  Name of the material property.\n\nsolve_inside : Whether to solve inside.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.intersect",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.intersect.html#intersect",
        "title": "intersect",
        "section": "intersect",
        "text": "Intersect active primitive with one or more primitives.\nList of Primitive objects.\nintersect\nList\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.intersect",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.intersect.html#pyedb.grpc.database.primitive.circle.Circle.intersect",
        "title": "intersect > intersect > intersect",
        "section": "intersect > intersect",
        "text": "Circle.intersect(primitives) -> list[any]\n\nIntersect active primitive with one or more primitives.\n\nParameters\n\nprimitives :class:`Primitives <pyedb.grpc.database.primitive.primitive.Primitive>`\n\n\n\nor: List[:class:`Primitives <pyedb.grpc.database.primitive.primitive.Primitive>`]\n\n\n\nor: class:`PolygonData <ansys.edb.core.geometry.polygon_data.PolygonData>`\n\n\n\nReturns\n\nList[Primitive]\n\nList of Primitive objects.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_closest_arc_midpoint",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_closest_arc_midpoint.html#get_closest_arc_midpoint",
        "title": "get_closest_arc_midpoint",
        "section": "get_closest_arc_midpoint",
        "text": "Get the closest arc midpoint of the primitive to the input data.\n[x, y].\nget_closest_arc_midpoint\nList\npython:float\nor\nList\nPointData\nLIst\npython:float\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_closest_arc_midpoint",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_closest_arc_midpoint.html#pyedb.grpc.database.primitive.path.Path.get_closest_arc_midpoint",
        "title": "get_closest_arc_midpoint > get_closest_arc_midpoint > get_closest_arc_midpoint",
        "section": "get_closest_arc_midpoint > get_closest_arc_midpoint",
        "text": "Path.get_closest_arc_midpoint(point) -> list[float]\n\nGet the closest arc midpoint of the primitive to the input data.\n\nParameters\n\npoint\n\nList[python:float] or List[PointData]\n\n\n\nReturns\n\nLIst[python:float, python:float]\n\n[x, y].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.create_coax_port",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.create_coax_port.html#create_coax_port",
        "title": "create_coax_port",
        "section": "create_coax_port",
        "text": "Create a coax port.\ncreate_coax_port"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.create_coax_port",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.create_coax_port.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.create_coax_port",
        "title": "create_coax_port > create_coax_port > create_coax_port",
        "section": "create_coax_port > create_coax_port",
        "text": "EDBPadstackInstance.create_coax_port(name=None, radial_extent_factor=0)\n\nCreate a coax port.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.calculate_initial_extent",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.calculate_initial_extent.html#calculate_initial_extent",
        "title": "calculate_initial_extent",
        "section": "calculate_initial_extent",
        "text": "Compute a float representing the larger number between the dielectric thickness or trace width\nmultiplied by the nW factor. The trace width search is limited to nets with ports attached.\nValue for the width multiplier (nW factor).\ncalculate_initial_extent\npython:float\npython:float"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.calculate_initial_extent",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.calculate_initial_extent.html#pyedb.dotnet.edb.Edb.calculate_initial_extent",
        "title": "calculate_initial_extent > calculate_initial_extent > calculate_initial_extent",
        "section": "calculate_initial_extent > calculate_initial_extent",
        "text": "Edb.calculate_initial_extent(expansion_factor)\n\nCompute a float representing the larger number between the dielectric thickness or trace width\nmultiplied by the nW factor. The trace width search is limited to nets with ports attached.\n\nParameters\n\nexpansion_factor\n\npython:float\n\nValue for the width multiplier (nW factor).\n\nReturns\n\npython:float\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "validate"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.validate.html#pyedb.workflows.drc.drc.BackDrillStubLength.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod BackDrillStubLength.validate(value: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_pin_group",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_pin_group.html#create_pin_group",
        "title": "create_pin_group",
        "section": "create_pin_group",
        "text": "Create a PinGroup.\nName of the PinGroup.\nList of pins by ID.\nList of pins by AEDT name.\nList of pins by name.\ncreate_pin_group\npython:str\npython:list\npython:int\nor\npython:None\npython:list\npython:str\nor\npython:None\npython:list\npython:str\nor\npython:None"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_pin_group",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_pin_group.html#pyedb.dotnet.database.modeler.Modeler.create_pin_group",
        "title": "create_pin_group > create_pin_group > create_pin_group",
        "section": "create_pin_group > create_pin_group",
        "text": "Modeler.create_pin_group(name: str, pins_by_id=None, pins_by_aedt_name=None, pins_by_name=None)\n\nCreate a PinGroup.\n\nParameters\n\nname\n\npython:str\n\nName of the PinGroup.\n\npins_by_id\n\npython:list[python:int] or python:None\n\nList of pins by ID.\n\npins_by_aedt_name\n\npython:list[python:str] or python:None\n\nList of pins by AEDT name.\n\npins_by_name\n\npython:list[python:str] or python:None\n\nList of pins by name.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.add_rlc_boundary",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.add_rlc_boundary.html#add_rlc_boundary",
        "title": "add_rlc_boundary",
        "section": "add_rlc_boundary",
        "text": "Add RLC gap boundary on component and replace it with a circuit port.\nThe circuit port supports only 2-pin components.\nReference designator of the RLC component.\nWhen True circuit type are defined, if False gap type will be used instead (compatible with HFSS 3D\nmodeler). Default value is True.\nTrue when successful, False when failed.\nadd_rlc_boundary\npython:str\nTrue\nFalse\nTrue\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.add_rlc_boundary",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.add_rlc_boundary.html#pyedb.grpc.database.source_excitations.SourceExcitation.add_rlc_boundary",
        "title": "add_rlc_boundary > add_rlc_boundary > add_rlc_boundary",
        "section": "add_rlc_boundary > add_rlc_boundary",
        "text": "SourceExcitation.add_rlc_boundary(component: str | Component | None = None, circuit_type: bool = True) -> bool\n\nAdd RLC gap boundary on component and replace it with a circuit port.\nThe circuit port supports only 2-pin components.\n\nParameters\n\ncomponent\n\npython:str\n\nReference designator of the RLC component.\n\ncircuit_type\n\nbool\n\nWhen True circuit type are defined, if False gap type will be used instead (compatible with HFSS 3D\nmodeler). Default value is True.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_circuit_port_on_pin_group",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_circuit_port_on_pin_group.html#create_circuit_port_on_pin_group",
        "title": "create_circuit_port_on_pin_group",
        "section": "create_circuit_port_on_pin_group",
        "text": "Create a port between two pin groups.\nName of the positive pin group.\nName of the negative pin group.\nImpedance of the port. Default is 50.\nPort name.\ncreate_circuit_port_on_pin_group\npython:str\npython:str\npython:int\npython:float\noptional\n50\npython:str\noptional"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_circuit_port_on_pin_group",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_circuit_port_on_pin_group.html#pyedb.dotnet.database.siwave.EdbSiwave.create_circuit_port_on_pin_group",
        "title": "create_circuit_port_on_pin_group > create_circuit_port_on_pin_group > create_circuit_port_on_pin_group",
        "section": "create_circuit_port_on_pin_group > create_circuit_port_on_pin_group",
        "text": "EdbSiwave.create_circuit_port_on_pin_group(pos_pin_group_name, neg_pin_group_name, impedance=50, name=None)\n\nCreate a port between two pin groups.\n\nParameters\n\npos_pin_group_name\n\npython:str\n\nName of the positive pin group.\n\nneg_pin_group_name\n\npython:str\n\nName of the negative pin group.\n\nimpedance\n\npython:int, python:float, optional\n\nImpedance of the port. Default is 50.\n\nname\n\npython:str, optional\n\nPort name.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_validate_strings",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj: The object containing string data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nThe validated Pydantic model.\nmodel_validate_strings"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_validate_strings",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_validate_strings.html#pyedb.workflows.drc.drc.MinLineWidth.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod MinLineWidth.model_validate_strings(obj: Any, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\nValidate the given object with string data against the Pydantic model.\n\nArgs:\n\nobj: The object containing string data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nReturns:\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.deactivate_rlc_component",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.deactivate_rlc_component.html#deactivate_rlc_component",
        "title": "deactivate_rlc_component",
        "section": "deactivate_rlc_component",
        "text": "Deactivate RLC component with a possibility to convert it to a circuit port.\nReference designator of the RLC component.\nWhether to replace the deactivated RLC component with a circuit port. The default\nis False.\nWhether to define the PEC boundary, The default is False. If set to True,\na perfect short is created between the pin and impedance is ignored. This\nparameter is only supported on a port created between two pins, such as\nwhen there is no pin group.\nTrue when successful, False when failed.\ndeactivate_rlc_component\npython:str\noptional\nFalse\noptional\nFalse\nTrue\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.deactivate_rlc_component",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.deactivate_rlc_component.html#pyedb.dotnet.database.components.Components.deactivate_rlc_component",
        "title": "deactivate_rlc_component > deactivate_rlc_component > deactivate_rlc_component",
        "section": "deactivate_rlc_component > deactivate_rlc_component",
        "text": "Components.deactivate_rlc_component(component=None, create_circuit_port=False, pec_boundary=False)\n\nDeactivate RLC component with a possibility to convert it to a circuit port.\n\nParameters\n\ncomponent\n\npython:str\n\nReference designator of the RLC component.\n\ncreate_circuit_port\n\nbool, optional\n\nWhether to replace the deactivated RLC component with a circuit port. The default\nis False.\n\npec_boundary\n\nbool, optional\n\nWhether to define the PEC boundary, The default is False. If set to True,\na perfect short is created between the pin and impedance is ignored. This\nparameter is only supported on a port created between two pins, such as\nwhen there is no pin group.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb_file = r\"C:\\my_edb_file.aedb\"\n>>> edb = Edb(edb_file)\n>>> for cmp in list(edb.components.instances.keys()):\n>>>     edb.components.deactivate_rlc_component(component=cmp, create_circuit_port=False)\n>>> edb.save_edb()\n>>> edb.close_edb()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.create_3d_comp.html#create_3d_comp",
        "title": "create_3d_comp",
        "section": "create_3d_comp",
        "text": "Create a 3D composite model from an MCAD file.\n3D composite model created.\ncreate_3d_comp\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.create_3d_comp.html#pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.create_3d_comp",
        "title": "create_3d_comp > create_3d_comp > create_3d_comp",
        "section": "create_3d_comp > create_3d_comp",
        "text": "EdgeTerminal.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nReturns\n\nMcadModel\n\n3D composite model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layer for a given product ID and attribute ID.\nProduct ID.\nAttribute ID.\nNew product property value.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_product_property.html#pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "StackupLayer.set_product_property(prod_id, attr_it, prop_value)\n\nSet the product property of the layer for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nProduct ID.\n\nattr_it\n\npython:int\n\nAttribute ID.\n\nprop_value\n\npython:str\n\nNew product property value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_validate_strings",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj: The object containing string data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nThe validated Pydantic model.\nmodel_validate_strings"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_validate_strings",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_validate_strings.html#pyedb.workflows.drc.drc.DiffPair.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod DiffPair.model_validate_strings(obj: Any, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\nValidate the given object with string data against the Pydantic model.\n\nArgs:\n\nobj: The object containing string data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nReturns:\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.MIMCapacitor",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.MIMCapacitor.html#mimcapacitor",
        "title": "MIMCapacitor",
        "section": "MIMCapacitor",
        "text": "Metal–Insulator–Metal parallel-plate capacitor.\nPlate area [m²].\nDielectric thickness between plates [m].\nRelative permittivity of the dielectric.\nTop plate layer.\nBottom plate layer.\nNet name for both plates.\nMIMCapacitor.create()\nCreate the top plate, bottom plate and assign variables.\nMIMCapacitor\npython:float\ndefault\nmm²\npython:float\ndefault\npython:float\ndefault\npython:str\ndefault\npython:str\ndefault\npython:str\ndefault\nMIMCapacitor.create"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.MIMCapacitor",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.MIMCapacitor.html#pyedb.libraries.rf_libraries.base_functions.MIMCapacitor",
        "title": "MIMCapacitor > MIMCapacitor > MIMCapacitor",
        "section": "MIMCapacitor > MIMCapacitor",
        "text": "class pyedb.libraries.rf_libraries.base_functions.MIMCapacitor(edb_cell: Edb, area: str | float = 1e-07, gap: str | float = 1e-06, layer_top: str = 'M1', layer_bottom: str = 'M2', net: str = 'RF')\n\nMetal–Insulator–Metal parallel-plate capacitor.\n\nParameters\n\narea\n\npython:float, default 0.1 mm²\n\nPlate area [m²].\n\ngap\n\npython:float, default 1 µm\n\nDielectric thickness between plates [m].\n\ner\n\npython:float, default 7\n\nRelative permittivity of the dielectric.\n\nlayer_top\n\npython:str, default “M1”\n\nTop plate layer.\n\nlayer_bottom\n\npython:str, default “M2”\n\nBottom plate layer.\n\nnet\n\npython:str, default “RF”\n\nNet name for both plates.\n\nExamples\n\n>>> cap = MIMCapacitor(area=200e-12, gap=0.5e-6, er=4.1)\n>>> edb = Edb(\"mim.aedb\")\n>>> cap._pedb = edb\n>>> cap.create()\n>>> f\"{cap.capacitance_f * 1e12:.2f} pF\"\n'1.45 pF'\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nMIMCapacitor.create()\n\nCreate the top plate, bottom plate and assign variables.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the ConnObj object to the correct concrete type.\ncast\nConnObj"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.cast.html#pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "VoltageRegulator.cast()\n\nCast the ConnObj object to the correct concrete type.\n\nReturns\n\nConnObj\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.find_by_id.html#find_by_id",
        "title": "find_by_id",
        "section": "find_by_id",
        "text": "Find a Connectable object by database ID in a given layout.\nLayout to search for the Connectable object.\nDatabase ID.\nConnectable object with the given database ID.\nfind_by_id\nLayout\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.find_by_id.html#pyedb.grpc.database.ports.ports.WavePort.find_by_id",
        "title": "find_by_id > find_by_id > find_by_id",
        "section": "find_by_id > find_by_id",
        "text": "classmethod WavePort.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the Connectable object.\n\nuid\n\npython:int\n\nDatabase ID.\n\nReturns\n\nConnectable\n\nConnectable object with the given database ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.layout_obj_type.html#pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "PadstackInstanceTerminal.layout_obj_type = 2\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.get_variable_value",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.get_variable_value.html#get_variable_value",
        "title": "get_variable_value",
        "section": "get_variable_value",
        "text": "Get the value for a given variable.\nVariable name.\nVariable value.\nget_variable_value\npython:str\nValue"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.get_variable_value",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.get_variable_value.html#pyedb.grpc.database.layout.layout.Layout.get_variable_value",
        "title": "get_variable_value > get_variable_value > get_variable_value",
        "section": "get_variable_value > get_variable_value",
        "text": "Layout.get_variable_value(name)\n\nGet the value for a given variable.\n\nParameters\n\nname\n\npython:str\n\nVariable name.\n\nReturns\n\nValue\n\nVariable value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.parse_file",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "parse_file"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.parse_file",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.parse_file.html#pyedb.workflows.drc.drc.MinClearance.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod MinClearance.parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.parse_raw",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "parse_raw"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.parse_raw",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.parse_raw.html#pyedb.workflows.drc.drc.BackDrillStubLength.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod BackDrillStubLength.parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.plot",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.plot.html#plot",
        "title": "plot",
        "section": "plot",
        "text": "Plot a net to Matplotlib 2D chart.\nName of the layers to include in the plot. If None all the signal layers will be considered.\nIf True the legend is shown in the plot. (default)\nIf False the legend is not shown.\nIf a path is specified the plot will be saved in this location.\nIf save_plot is provided, the show parameter is ignored.\nList of points of the outline to plot.\nImage size in pixel (width, height).\nWhether to show the plot or not. Default is True.\nplot\npython:str\npython:list\noptional\noptional\npython:str\noptional\nsave_plot\nshow\npython:list\noptional\npython:tuple\noptional\noptional"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.plot",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.plot.html#pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.plot",
        "title": "plot > plot > plot",
        "section": "plot > plot",
        "text": "EDBNetsData.plot(layers=None, show_legend=True, save_plot=None, outline=None, size=(2000, 1000), show=True)\n\nPlot a net to Matplotlib 2D chart.\n\nParameters\n\nlayers\n\npython:str, python:list, optional\n\nName of the layers to include in the plot. If None all the signal layers will be considered.\n\nshow_legend\n\nbool, optional\n\nIf True the legend is shown in the plot. (default)\nIf False the legend is not shown.\n\nsave_plot\n\npython:str, optional\n\nIf a path is specified the plot will be saved in this location.\nIf save_plot is provided, the show parameter is ignored.\n\noutline\n\npython:list, optional\n\nList of points of the outline to plot.\n\nsize\n\npython:tuple, optional\n\nImage size in pixel (width, height).\n\nshow\n\nbool, optional\n\nWhether to show the plot or not. Default is True.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj: The object to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\nfrom_attributes: Whether to extract data from object attributes.\ncontext: Additional context to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nValidationError: If the object could not be validated.\nThe validated model instance.\nmodel_validate"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_validate.html#pyedb.workflows.drc.drc.MinAnnularRing.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod MinAnnularRing.model_validate(obj: Any, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\nValidate a pydantic model instance.\n\nArgs:\n\nobj: The object to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\nfrom_attributes: Whether to extract data from object attributes.\ncontext: Additional context to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nRaises:\n\nValidationError: If the object could not be validated.\n\nReturns:\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.no_net_name",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.no_net_name.html#no_net_name",
        "title": "no_net_name",
        "section": "no_net_name",
        "text": "no_net_name"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.no_net_name",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.no_net_name.html#pyedb.grpc.database.net.net.Net.no_net_name",
        "title": "no_net_name > no_net_name > no_net_name",
        "section": "no_net_name > no_net_name",
        "text": "Net.no_net_name = '<NO-NET>'\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.type",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.type.html#type",
        "title": "type",
        "section": "type",
        "text": "type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.type",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.type.html#pyedb.grpc.database.ports.ports.WavePort.type",
        "title": "type > type > type",
        "section": "type > type",
        "text": "WavePort.type = 0\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.permeability",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.permeability.html#permeability",
        "title": "permeability",
        "section": "permeability",
        "text": "permeability"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.permeability",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.permeability.html#pyedb.grpc.database.definition.materials.MaterialProperties.permeability",
        "title": "permeability > permeability > permeability",
        "section": "permeability > permeability",
        "text": "MaterialProperties.permeability: Annotated[float, Gt(gt=0)] | None\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.SettingsBase",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.SettingsBase.html#settingsbase",
        "title": "SettingsBase",
        "section": "SettingsBase",
        "text": "Provide base settings.\nSettingsBase.get_configurations()\nGet all attributes.\nSettingsBase.restore_default()\n\nSettingsBase\nSettingsBase.get_configurations\nSettingsBase.restore_default"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.SettingsBase",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.SettingsBase.html#pyedb.dotnet.database.sim_setup_data.io.siwave.SettingsBase",
        "title": "SettingsBase > SettingsBase > SettingsBase",
        "section": "SettingsBase > SettingsBase",
        "text": "class pyedb.dotnet.database.sim_setup_data.io.siwave.SettingsBase(parent)\n\nProvide base settings.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nSettingsBase.get_configurations()\n\nGet all attributes.\n\nSettingsBase.restore_default()\n\n\n\n"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.Substrate",
        "href": "libraries/_autosummary/pyedb.libraries.common.Substrate.html#substrate",
        "title": "Substrate",
        "section": "Substrate",
        "text": "Small helper that groups the four basic substrate parameters used\nthroughout the library.\nSubstrate height in metres.\nRelative permittivity.\nLoss tangent.\nLogical name used for layer creation.\n(width, length) of the surrounding ground plane in metres.\nSubstrate.er\n\nSubstrate.h\n\nSubstrate.name\n\nSubstrate.size\n\nSubstrate.tan_d\n\nSubstrate\npython:float\ndefault\npython:float\ndefault\npython:float\ndefault\npython:str\ndefault\npython:tuple\npython:float\npython:float\ndefault\nmm\nmm\nSubstrate.er\nSubstrate.h\nSubstrate.name\nSubstrate.size\nSubstrate.tan_d"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.Substrate",
        "href": "libraries/_autosummary/pyedb.libraries.common.Substrate.html#pyedb.libraries.common.Substrate",
        "title": "Substrate > Substrate > Substrate",
        "section": "Substrate > Substrate",
        "text": "class pyedb.libraries.common.Substrate(h: float = 0.0001, er: float = 4.4, tan_d: float = 0, name: str = 'SUB', size: Tuple[float, float] = (0.001, 0.001))\n\nSmall helper that groups the four basic substrate parameters used\nthroughout the library.\n\nParameters\n\nh\n\npython:float, default 100 µm\n\nSubstrate height in metres.\n\ner\n\npython:float, default 4.4\n\nRelative permittivity.\n\ntan_d\n\npython:float, default 0\n\nLoss tangent.\n\nname\n\npython:str, default “SUB”\n\nLogical name used for layer creation.\n\nsize\n\npython:tuple[python:float, python:float], default (1 mm, 1 mm)\n\n(width, length) of the surrounding ground plane in metres.\n\nExamples\n\n>>> sub = Substrate(h=1.6e-3, er=4.4, tan_d=0.02, name=\"FR4\", size=(10e-3, 15e-3))\n>>> sub.h\n0.0016\n\n!! processed by numpydoc !!\n\nAttributes\n\n\n\n\n\n\n\nSubstrate.er\n\n\n\nSubstrate.h\n\n\n\nSubstrate.name\n\n\n\nSubstrate.size\n\n\n\nSubstrate.tan_d\n\n\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.number_with_units",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.number_with_units.html#number_with_units",
        "title": "number_with_units",
        "section": "number_with_units",
        "text": "Convert a number to a string with units. If value is a string, it’s returned as is.\nInput number or string.\nUnits for formatting. The default is None, which uses \"meter\".\nString concatenating the value and unit.\nnumber_with_units\npython:float\npython:int\npython:str\noptional\nNone\n\"meter\"\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.number_with_units",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.number_with_units.html#pyedb.dotnet.edb.Edb.number_with_units",
        "title": "number_with_units > number_with_units > number_with_units",
        "section": "number_with_units > number_with_units",
        "text": "Edb.number_with_units(value, units=None)\n\nConvert a number to a string with units. If value is a string, it’s returned as is.\n\nParameters\n\nvalue\n\npython:float, python:int, python:str\n\nInput number or string.\n\nunits\n\noptional\n\nUnits for formatting. The default is None, which uses \"meter\".\n\nReturns\n\npython:str\n\nString concatenating the value and unit.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_left",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_left.html#is_left",
        "title": "is_left",
        "section": "is_left",
        "text": "Determine if the arc rotates clockwise.\nThis method is the same as the is_cw method.\nTrue when the arc rotates clockwise, False otherwise.\nis_left\nis_cw\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_left",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_left.html#pyedb.grpc.database.geometry.arc_data.ArcData.is_left",
        "title": "is_left > is_left > is_left",
        "section": "is_left > is_left",
        "text": "ArcData.is_left() -> bool\n\nDetermine if the arc rotates clockwise.\n\nThis method is the same as the is_cw method.\n\nReturns\n\nbool\n\nTrue when the arc rotates clockwise, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.get_top_bottom_stackup_layers",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.get_top_bottom_stackup_layers.html#get_top_bottom_stackup_layers",
        "title": "get_top_bottom_stackup_layers",
        "section": "get_top_bottom_stackup_layers",
        "text": "Get the top and bottom stackup layers of a specific type and their elevations.\nLayer type set indicating the layer types to retrieve.\nReturns a tuple in this format:\n(upper_layer, upper_layer_top_elevation, lower_layer, lower_layer_lower_elevation)\nget_top_bottom_stackup_layers\nLayerTypeSet\npython:tuple\nLayer\npython:float\nLayer\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.get_top_bottom_stackup_layers",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.get_top_bottom_stackup_layers.html#pyedb.grpc.database.stackup.LayerCollection.get_top_bottom_stackup_layers",
        "title": "get_top_bottom_stackup_layers > get_top_bottom_stackup_layers > get_top_bottom_stackup_layers",
        "section": "get_top_bottom_stackup_layers > get_top_bottom_stackup_layers",
        "text": "LayerCollection.get_top_bottom_stackup_layers(layer_type_set)\n\nGet the top and bottom stackup layers of a specific type and their elevations.\n\nParameters\n\nlayer_type_set\n\nLayerTypeSet\n\nLayer type set indicating the layer types to retrieve.\n\nReturns\n\npython:tuple[Layer, python:float, Layer, python:float]\n\nReturns a tuple in this format:\n(upper_layer, upper_layer_top_elevation, lower_layer, lower_layer_lower_elevation)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_dump_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#json-mode)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent: Indentation to use in the JSON output. If None is passed, the output will be compact.\nensure_ascii: If True, the output is guaranteed to have all incoming non-ASCII characters escaped.\nIf False (the default), these characters will be output as-is.\ninclude: Field(s) to include in the JSON output.\nexclude: Field(s) to exclude from the JSON output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to serialize using field aliases.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\nA JSON string representation of the model.\nmodel_dump_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_dump_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_dump_json.html#pyedb.workflows.drc.drc.MinLineWidth.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "MinLineWidth.model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -> str\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#json-mode)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nArgs:\n\nindent: Indentation to use in the JSON output. If None is passed, the output will be compact.\nensure_ascii: If True, the output is guaranteed to have all incoming non-ASCII characters escaped.\n\nIf False (the default), these characters will be output as-is.\n\ninclude: Field(s) to include in the JSON output.\nexclude: Field(s) to exclude from the JSON output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to serialize using field aliases.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\n\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\n\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback: A function to call when an unknown value is encountered. If not provided,\n\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.remove_pins",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.remove_pins.html#remove_pins",
        "title": "remove_pins",
        "section": "remove_pins",
        "text": "Remove a list of padstack instances from the group.\nList of padstick instances.\nremove_pins\npython:list\nPadstackInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.remove_pins",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.remove_pins.html#pyedb.grpc.database.hierarchy.pingroup.PinGroup.remove_pins",
        "title": "remove_pins > remove_pins > remove_pins",
        "section": "remove_pins > remove_pins",
        "text": "PinGroup.remove_pins(pins)\n\nRemove a list of padstack instances from the group.\n\nParameters\n\npins\n\npython:list[PadstackInstance]\n\nList of padstick instances.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/simulation_settings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/simulation_settings.html#simulation-settings",
        "title": "Simulation settings",
        "section": "Simulation settings",
        "text": "These classes are the containers of simulation settings.\nBaseSimulationSettings\n\nSimulationSettings\n\nHFSSSimulationSettings\n\nHFSSPISimulationSettings\n\nSimulation settings\nBaseSimulationSettings\nSimulationSettings\nHFSSSimulationSettings\nHFSSPISimulationSettings"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.html#pingroup",
        "title": "PinGroup",
        "section": "PinGroup",
        "text": "Manages pin groups.\nPinGroup.add_pins(pins)\nAdd a list of padstack instances to the group.\nPinGroup.cast()\nCast the ConnObj object to the correct concrete type.\nPinGroup.create(layout, name, padstack_instances)\nCreate a pin group.\nPinGroup.create_3d_comp()\nCreate a 3D composite model from an MCAD file.\nPinGroup.create_current_source_terminal([...])\nCreate current source terminal.\nPinGroup.create_hfss()\nCreate an HFSS model from an MCAD file.\nPinGroup.create_port_terminal([impedance])\nCreate port terminal.\nPinGroup.create_stride()\nCreate a Stride model from an MCAD file.\nPinGroup.create_terminal([name])\nCreate a terminal.\nPinGroup.create_voltage_probe_terminal([...])\nCreate voltage probe terminal.\nPinGroup.create_voltage_source_terminal([...])\nCreate voltage source terminal.\nPinGroup.delete()\nDelete the layout object.\nPinGroup.find(layout, name)\nFind a pin group by name in a given layout.\nPinGroup.find_by_id(layout, uid)\nFind a Connectable object by database ID in a given layout.\nPinGroup.get_product_property(prod_id, attr_id)\nGet the product property of the layout object for a given product ID and attribute ID.\nPinGroup.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nPinGroup.remove_pins(pins)\nRemove a list of padstack instances from the group.\nPinGroup.set_product_property(prod_id, ...)\nSet the product property of the layout object for a given product ID and attribute ID.\nPinGroup.unique_name(layout, prefix)\nGet a unique pin group name in the layout using a given prefix.\nPinGroup.layout_obj_type\n\nPinGroup\nPinGroup.add_pins\nPinGroup.cast\nPinGroup.create\nPinGroup.create_3d_comp\nPinGroup.create_current_source_terminal\nPinGroup.create_hfss\nPinGroup.create_port_terminal\nPinGroup.create_stride\nPinGroup.create_terminal\nPinGroup.create_voltage_probe_terminal\nPinGroup.create_voltage_source_terminal\nPinGroup.delete\nPinGroup.find\nPinGroup.find_by_id\nPinGroup.get_product_property\nPinGroup.get_product_property_ids\nPinGroup.remove_pins\nPinGroup.set_product_property\nPinGroup.unique_name\nPinGroup.layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.html#pyedb.grpc.database.hierarchy.pingroup.PinGroup",
        "title": "PinGroup > PinGroup > PinGroup",
        "section": "PinGroup > PinGroup",
        "text": "class pyedb.grpc.database.hierarchy.pingroup.PinGroup(pedb, edb_pin_group=None)\n\nManages pin groups.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nPinGroup.add_pins(pins)\n\nAdd a list of padstack instances to the group.\n\nPinGroup.cast()\n\nCast the ConnObj object to the correct concrete type.\n\nPinGroup.create(layout, name, padstack_instances)\n\nCreate a pin group.\n\nPinGroup.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nPinGroup.create_current_source_terminal([...])\n\nCreate current source terminal.\n\nPinGroup.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nPinGroup.create_port_terminal([impedance])\n\nCreate port terminal.\n\nPinGroup.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nPinGroup.create_terminal([name])\n\nCreate a terminal.\n\nPinGroup.create_voltage_probe_terminal([...])\n\nCreate voltage probe terminal.\n\nPinGroup.create_voltage_source_terminal([...])\n\nCreate voltage source terminal.\n\nPinGroup.delete()\n\nDelete the layout object.\n\nPinGroup.find(layout, name)\n\nFind a pin group by name in a given layout.\n\nPinGroup.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nPinGroup.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nPinGroup.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nPinGroup.remove_pins(pins)\n\nRemove a list of padstack instances from the group.\n\nPinGroup.set_product_property(prod_id, ...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nPinGroup.unique_name(layout, prefix)\n\nGet a unique pin group name in the layout using a given prefix.\n\n\n\nAttributes\n\n\n\n\n\n\n\nPinGroup.layout_obj_type\n\n\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.html#siwavedcsimulationsetup",
        "title": "SiwaveDCSimulationSetup",
        "section": "SiwaveDCSimulationSetup",
        "text": "Manages EDB methods for SIwave DC simulation setup.\nSiwaveDCSimulationSetup.add_frequency_sweep([...])\nAdd frequency sweep.\nSiwaveDCSimulationSetup.add_sweep([name, ...])\nAdd frequency sweep.\nSiwaveDCSimulationSetup.create([name])\nCreate a SIwave DCIR setup.\nSiwaveDCSimulationSetup.delete()\nDelete current simulation setup.\nSiwaveDCSimulationSetup.delete_frequency_sweep(...)\nDelete a frequency sweep.\nSiwaveDCSimulationSetup.get_configurations()\nGet SIwave DC simulation settings.\nSiwaveDCSimulationSetup.get_simulation_settings()\n\nSiwaveDCSimulationSetup.set_dc_slider(value)\nSet DC simulation accuracy level.\nSiwaveDCSimulationSetup.set_sim_setup_info(...)\n\nSiwaveDCSimulationSetup.set_simulation_settings(...)\n\nSiwaveDCSimulationSetup\nSiwaveDCSimulationSetup.add_frequency_sweep\nSiwaveDCSimulationSetup.add_sweep\nSiwaveDCSimulationSetup.create\nSiwaveDCSimulationSetup.delete\nSiwaveDCSimulationSetup.delete_frequency_sweep\nSiwaveDCSimulationSetup.get_configurations\nSiwaveDCSimulationSetup.get_simulation_settings\nSiwaveDCSimulationSetup.set_dc_slider\nSiwaveDCSimulationSetup.set_sim_setup_info\nSiwaveDCSimulationSetup.set_simulation_settings"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.html#pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup",
        "title": "SiwaveDCSimulationSetup > SiwaveDCSimulationSetup > SiwaveDCSimulationSetup",
        "section": "SiwaveDCSimulationSetup > SiwaveDCSimulationSetup",
        "text": "class pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup(pedb, edb_object=None, name: str | None = None)\n\nManages EDB methods for SIwave DC simulation setup.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nSiwaveDCSimulationSetup.add_frequency_sweep([...])\n\nAdd frequency sweep.\n\nSiwaveDCSimulationSetup.add_sweep([name, ...])\n\nAdd frequency sweep.\n\nSiwaveDCSimulationSetup.create([name])\n\nCreate a SIwave DCIR setup.\n\nSiwaveDCSimulationSetup.delete()\n\nDelete current simulation setup.\n\nSiwaveDCSimulationSetup.delete_frequency_sweep(...)\n\nDelete a frequency sweep.\n\nSiwaveDCSimulationSetup.get_configurations()\n\nGet SIwave DC simulation settings.\n\nSiwaveDCSimulationSetup.get_simulation_settings()\n\n\n\nSiwaveDCSimulationSetup.set_dc_slider(value)\n\nSet DC simulation accuracy level.\n\nSiwaveDCSimulationSetup.set_sim_setup_info(...)\n\n\n\nSiwaveDCSimulationSetup.set_simulation_settings(...)\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_rats",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_rats.html#get_rats",
        "title": "get_rats",
        "section": "get_rats",
        "text": "Get RATS (Reference Designator, Pin, Net) information.\nList of dictionaries with refdes, pin_name, and net_name.\nget_rats\npython:list\npython:dict"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_rats",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_rats.html#pyedb.grpc.database.components.Components.get_rats",
        "title": "get_rats > get_rats > get_rats",
        "section": "get_rats > get_rats",
        "text": "Components.get_rats() -> List[Dict[str, List[str]]]\n\nGet RATS (Reference Designator, Pin, Net) information.\n\nReturns\n\npython:list[python:dict]\n\nList of dictionaries with refdes, pin_name, and net_name.\n\nExamples\n\n>>> rats = edbapp.components.get_rats()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.xor",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.xor.html#xor",
        "title": "xor",
        "section": "xor",
        "text": "Compute an exclusive OR between a set of polygons and another set of polygons.\nFirst list of polygons.\nSecond list of polygons.\nxor\npython:list\nof\nPolygonData\nPolygonData\npython:list\nof\nPolygonData\nPolygonData\npython:list\nof\nPolygonData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.xor",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.xor.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.xor",
        "title": "xor > xor > xor",
        "section": "xor > xor",
        "text": "classmethod PolygonData.xor(polygons1: list[PolygonData] | PolygonData, polygons2: list[PolygonData] | PolygonData) -> list[PolygonData]\n\nCompute an exclusive OR between a set of polygons and another set of polygons.\n\nParameters\n\npolygons1\n\npython:list of PolygonData or PolygonData\n\nFirst list of polygons.\n\npolygons2\n\npython:list of PolygonData or PolygonData\n\nSecond list of polygons.\n\nReturns\n\npython:list of PolygonData\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.plot",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.plot.html#plot",
        "title": "plot",
        "section": "plot",
        "text": "Plot the current polygon on matplotlib.\nWhether if plot the entire net or only the selected polygon. Default is False.\nWhether if show the plot or not. Default is True.\nSave the plot path.\nMatplotlib ax and figures.\nplot\noptional\nFalse\noptional\nTrue\npython:str\noptional\nax\nfig"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.plot",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.plot.html#pyedb.grpc.database.primitive.circle.Circle.plot",
        "title": "plot > plot > plot",
        "section": "plot > plot",
        "text": "Circle.plot(plot_net=False, show=True, save_plot=None)\n\nPlot the current polygon on matplotlib.\n\nParameters\n\nplot_net\n\nbool, optional\n\nWhether if plot the entire net or only the selected polygon. Default is False.\n\nshow\n\nbool, optional\n\nWhether if show the plot or not. Default is True.\n\nsave_plot\n\npython:str, optional\n\nSave the plot path.\n\nReturns\n\n(ax, fig)\n\nMatplotlib ax and figures.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.int_to_pad_type",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.int_to_pad_type.html#int_to_pad_type",
        "title": "int_to_pad_type",
        "section": "int_to_pad_type",
        "text": "Convert an integer to an EDB.PadGeometryType.\nEDB.PadType enumerator value.\nint_to_pad_type\npython:int\nobject"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.int_to_pad_type",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.int_to_pad_type.html#pyedb.grpc.database.padstacks.Padstacks.int_to_pad_type",
        "title": "int_to_pad_type > int_to_pad_type > int_to_pad_type",
        "section": "int_to_pad_type > int_to_pad_type",
        "text": "static Padstacks.int_to_pad_type(val=0) -> PadType\n\nConvert an integer to an EDB.PadGeometryType.\n\nParameters\n\nval\n\npython:int\n\n\n\nReturns\n\nobject\n\nEDB.PadType enumerator value.\n\nExamples\n\n>>> pad_type = edb_padstacks.int_to_pad_type(0)  # Returns REGULAR_PAD\n>>> pad_type = edb_padstacks.int_to_pad_type(1)  # Returns ANTI_PAD\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.unite",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.unite.html#unite",
        "title": "unite",
        "section": "unite",
        "text": "Unite active primitive with one or more primitives.\nList of Primitive objects.\nunite\nPrimitives\nList\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.unite",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.unite.html#pyedb.grpc.database.primitive.circle.Circle.unite",
        "title": "unite > unite > unite",
        "section": "unite > unite",
        "text": "Circle.unite(primitives) -> list[any]\n\nUnite active primitive with one or more primitives.\n\nParameters\n\nprimitives\n\nPrimitives\n\n\n\nor: List[:class:`Primitives <pyedb.grpc.database.primitive.primitive.Primitive>`]\n\n\n\nor: class:`PolygonData <ansys.edb.core.geometry.polygon_data.PolygonData>`\n\n\n\nReturns\n\nList[Primitive]\n\nList of Primitive objects.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.add_port_on_rlc_component",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.add_port_on_rlc_component.html#add_port_on_rlc_component",
        "title": "add_port_on_rlc_component",
        "section": "add_port_on_rlc_component",
        "text": "Deactivate RLC component and replace it with a circuit port.\nThe circuit port supports only two-pin components.\nReference designator of the RLC component.\nTrue will replace RLC component by circuit ports, False gap ports compatible with HFSS 3D modeler\nexport.\nWhether to define the PEC boundary, The default is False. If set to True,\na perfect short is created between the pin and impedance is ignored. This\nparameter is only supported on a port created between two pins, such as\nwhen there is no pin group.\nTrue when successful, False when failed.\nadd_port_on_rlc_component\npython:str\nTrue\nFalse\noptional\nFalse\nTrue\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.add_port_on_rlc_component",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.add_port_on_rlc_component.html#pyedb.dotnet.database.components.Components.add_port_on_rlc_component",
        "title": "add_port_on_rlc_component > add_port_on_rlc_component > add_port_on_rlc_component",
        "section": "add_port_on_rlc_component > add_port_on_rlc_component",
        "text": "Components.add_port_on_rlc_component(component=None, circuit_ports=True, pec_boundary=False)\n\nDeactivate RLC component and replace it with a circuit port.\nThe circuit port supports only two-pin components.\n\nParameters\n\ncomponent\n\npython:str\n\nReference designator of the RLC component.\n\ncircuit_ports\n\nbool\n\nTrue will replace RLC component by circuit ports, False gap ports compatible with HFSS 3D modeler\nexport.\n\npec_boundary\n\nbool, optional\n\nWhether to define the PEC boundary, The default is False. If set to True,\na perfect short is created between the pin and impedance is ignored. This\nparameter is only supported on a port created between two pins, such as\nwhen there is no pin group.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.get_product_property_ids.html#pyedb.grpc.database.net.net_class.NetClass.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "NetClass.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.real",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.real.html#real",
        "title": "real",
        "section": "real",
        "text": "the real part of a complex number\nreal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.real",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.real.html#pyedb.grpc.database.utility.value.Value.real",
        "title": "real > real > real",
        "section": "real > real",
        "text": "Value.real\n\nthe real part of a complex number\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType.kMeshSetupBase",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType.kMeshSetupBase.html#kmeshsetupbase",
        "title": "kMeshSetupBase",
        "section": "kMeshSetupBase",
        "text": "kMeshSetupBase"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType.kMeshSetupBase",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType.kMeshSetupBase.html#pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType.kMeshSetupBase",
        "title": "kMeshSetupBase > kMeshSetupBase > kMeshSetupBase",
        "section": "kMeshSetupBase > kMeshSetupBase",
        "text": "MeshOpType.kMeshSetupBase = 'base'\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.find_or_create_net",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.find_or_create_net.html#find_or_create_net",
        "title": "find_or_create_net",
        "section": "find_or_create_net",
        "text": "Find or create a net based on given criteria.\nExact name of the net to find or create.\nFind nets starting with this string.\nFind nets containing this string.\nFind nets ending with this string.\nNet object or list of matching net objects.\nfind_or_create_net\npython:str\noptional\npython:str\noptional\npython:str\noptional\npython:str\noptional\npyedb.grpc.database.net.net.Net\npython:list\npyedb.grpc.database.net.net.Net"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.find_or_create_net",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.find_or_create_net.html#pyedb.grpc.database.nets.Nets.find_or_create_net",
        "title": "find_or_create_net > find_or_create_net > find_or_create_net",
        "section": "find_or_create_net > find_or_create_net",
        "text": "Nets.find_or_create_net(net_name: str = '', start_with: str = '', contain: str = '', end_with: str = '') -> Net | List[Net]\n\nFind or create a net based on given criteria.\n\nParameters\n\nnet_name\n\npython:str, optional\n\nExact name of the net to find or create.\n\nstart_with\n\npython:str, optional\n\nFind nets starting with this string.\n\ncontain\n\npython:str, optional\n\nFind nets containing this string.\n\nend_with\n\npython:str, optional\n\nFind nets ending with this string.\n\nReturns\n\npyedb.grpc.database.net.net.Net | python:list[pyedb.grpc.database.net.net.Net]\n\nNet object or list of matching net objects.\n\nExamples\n\n>>> # Create new net\n>>> new_net = edb_nets.find_or_create_net(net_name=\"New_Net\")\n>>>\n>>> # Find existing net\n>>> existing_net = edb_nets.find_or_create_net(net_name=\"GND\")\n>>>\n>>> # Find nets starting with \"VDD\"\n>>> vdd_nets = edb_nets.find_or_create_net(start_with=\"VDD\")\n>>>\n>>> # Find nets ending with \"_P\"\n>>> pos_nets = edb_nets.find_or_create_net(end_with=\"_P\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.read_materials",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.read_materials.html#read_materials",
        "title": "read_materials",
        "section": "read_materials",
        "text": "Read materials from an AMAT file.\nFull path to the AMAT file to read.\n{material name: dict of material properties}.\nread_materials\npython:str\npython:dict"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.read_materials",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.read_materials.html#pyedb.dotnet.database.materials.Materials.read_materials",
        "title": "read_materials > read_materials > read_materials",
        "section": "read_materials > read_materials",
        "text": "Materials.read_materials(amat_file)\n\nRead materials from an AMAT file.\n\nParameters\n\namat_file\n\npython:str\n\nFull path to the AMAT file to read.\n\nReturns\n\npython:dict\n\n{material name: dict of material properties}.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.unite",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.unite.html#unite",
        "title": "unite",
        "section": "unite",
        "text": "Unite active primitive with one or more primitives.\nList of Primitive objects.\nunite\nPrimitives\nList\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.unite",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.unite.html#pyedb.grpc.database.primitive.primitive.Primitive.unite",
        "title": "unite > unite > unite",
        "section": "unite > unite",
        "text": "Primitive.unite(primitives) -> list[any]\n\nUnite active primitive with one or more primitives.\n\nParameters\n\nprimitives\n\nPrimitives\n\n\n\nor: List[:class:`Primitives <pyedb.grpc.database.primitive.primitive.Primitive>`]\n\n\n\nor: class:`PolygonData <ansys.edb.core.geometry.polygon_data.PolygonData>`\n\n\n\nReturns\n\nList[Primitive]\n\nList of Primitive objects.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.AdaptiveType",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.AdaptiveType.html#adaptivetype",
        "title": "AdaptiveType",
        "section": "AdaptiveType",
        "text": "AdaptiveType.BroadBand\n\nAdaptiveType.MultiFrequency\n\nAdaptiveType.SingleFrequency\n\nAdaptiveType\nAdaptiveType.BroadBand\nAdaptiveType.MultiFrequency\nAdaptiveType.SingleFrequency"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.AdaptiveType",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.AdaptiveType.html#pyedb.dotnet.database.utilities.simulation_setup.AdaptiveType",
        "title": "AdaptiveType > AdaptiveType > AdaptiveType",
        "section": "AdaptiveType > AdaptiveType",
        "text": "class pyedb.dotnet.database.utilities.simulation_setup.AdaptiveType\n\n!! processed by numpydoc !!\n\nAttributes\n\n\n\n\n\n\n\nAdaptiveType.BroadBand\n\n\n\nAdaptiveType.MultiFrequency\n\n\n\nAdaptiveType.SingleFrequency\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_inside",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_inside.html#is_inside",
        "title": "is_inside",
        "section": "is_inside",
        "text": "Determine whether the point is inside the polygon.\nTrue if the point is inside the polygon, False otherwise.\nis_inside\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_inside",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_inside.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.is_inside",
        "title": "is_inside > is_inside > is_inside",
        "section": "is_inside > is_inside",
        "text": "PolygonData.is_inside(point: PointLike) -> bool\n\nDetermine whether the point is inside the polygon.\n\nParameters\n\npoint\n\nPoint2DLike\n\n\n\nReturns\n\nbool\n\nTrue if the point is inside the polygon, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.get_smallest_trace_width",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.get_smallest_trace_width.html#get_smallest_trace_width",
        "title": "get_smallest_trace_width",
        "section": "get_smallest_trace_width",
        "text": "Get the minimum trace width from path primitives in this net.\nSmallest width found in database units. Returns 1e10 if no paths exist.\nget_smallest_trace_width\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.get_smallest_trace_width",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.get_smallest_trace_width.html#pyedb.grpc.database.net.net.Net.get_smallest_trace_width",
        "title": "get_smallest_trace_width > get_smallest_trace_width > get_smallest_trace_width",
        "section": "get_smallest_trace_width > get_smallest_trace_width",
        "text": "Net.get_smallest_trace_width() -> float\n\nGet the minimum trace width from path primitives in this net.\n\nReturns\n\npython:float\n\nSmallest width found in database units. Returns 1e10 if no paths exist.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.replace_rlc_by_gap_boundaries",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.replace_rlc_by_gap_boundaries.html#replace_rlc_by_gap_boundaries",
        "title": "replace_rlc_by_gap_boundaries",
        "section": "replace_rlc_by_gap_boundaries",
        "text": "Replace RLC component by RLC gap boundaries. These boundary types are compatible with 3D modeler export.\nOnly 2 pins RLC components are supported in this command.\nReference designator of the RLC component.\nreplace_rlc_by_gap_boundaries\npython:str\nTrue\nwhen\nsucceed\nFalse\nif\nit"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.replace_rlc_by_gap_boundaries",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.replace_rlc_by_gap_boundaries.html#pyedb.dotnet.database.components.Components.replace_rlc_by_gap_boundaries",
        "title": "replace_rlc_by_gap_boundaries > replace_rlc_by_gap_boundaries > replace_rlc_by_gap_boundaries",
        "section": "replace_rlc_by_gap_boundaries > replace_rlc_by_gap_boundaries",
        "text": "Components.replace_rlc_by_gap_boundaries(component=None)\n\nReplace RLC component by RLC gap boundaries. These boundary types are compatible with 3D modeler export.\nOnly 2 pins RLC components are supported in this command.\n\nParameters\n\ncomponent\n\npython:str\n\nReference designator of the RLC component.\n\nReturns\n\nbool\n\n\n\nTrue when succeed, False if it failed.\n\n\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb(edb_file)\n>>>  for refdes, cmp in edb.components.capacitors.items():\n>>>     edb.components.replace_rlc_by_gap_boundaries(refdes)\n>>> edb.save_edb()\n>>> edb.close_edb()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileComponents",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileComponents.html#controlfilecomponents",
        "title": "ControlFileComponents",
        "section": "ControlFileComponents",
        "text": "Manages components for the control file.\nControlFileComponents.add_component(ref_des, ...)\nAdd a new component.\nControlFileComponents\nControlFileComponents.add_component"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileComponents",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileComponents.html#pyedb.grpc.database.control_file.ControlFileComponents",
        "title": "ControlFileComponents > ControlFileComponents > ControlFileComponents",
        "section": "ControlFileComponents > ControlFileComponents",
        "text": "class pyedb.grpc.database.control_file.ControlFileComponents\n\nManages components for the control file.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nControlFileComponents.add_component(ref_des, ...)\n\nAdd a new component.\n\n"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.CPW",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.CPW.html#cpw",
        "title": "CPW",
        "section": "CPW",
        "text": "Coplanar waveguide with side ground planes.\nPhysical length of the line.\nWidth of the centre conductor.\nGap between centre conductor and ground planes.\nLayer on which the CPW is drawn.\nNet name for the ground planes.\nWidth of the side ground strips.\nLayer for the underlying ground plane.\nNet name for the centre conductor.\nSubstrate definition.\nCPW.create()\nDraw the centre strip, side grounds and bottom ground plane.\nCPW\npython:float\ndefault\nmm\npython:float\ndefault\nmm\npython:float\ndefault\nmm\npython:str\ndefault\npython:str\ndefault\npython:float\ndefault\nmm\npython:str\ndefault\npython:str\ndefault\nSubstrate\ndefault\nFR4\nCPW.create"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.CPW",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.CPW.html#pyedb.libraries.rf_libraries.base_functions.CPW",
        "title": "CPW > CPW > CPW",
        "section": "CPW > CPW",
        "text": "class pyedb.libraries.rf_libraries.base_functions.CPW(edb_cell: Edb | None = None, length: str | float = 0.001, width: str | float = 0.0003, gap: str | float = 0.0001, layer: str = 'TOP', ground_net: str = 'GND', ground_width: float = 0.0001, ground_layer: str = 'GND', net: str = 'SIG', substrate: Substrate = Substrate(h=0.0001, er=4.4, tan_d=0.02, name='SUB', size=(0.001, 0.001)))\n\nCoplanar waveguide with side ground planes.\n\nParameters\n\nlength\n\npython:float, default 1 mm\n\nPhysical length of the line.\n\nwidth\n\npython:float, default 0.3 mm\n\nWidth of the centre conductor.\n\ngap\n\npython:float, default 0.1 mm\n\nGap between centre conductor and ground planes.\n\nlayer\n\npython:str, default “TOP”\n\nLayer on which the CPW is drawn.\n\nground_net\n\npython:str, default “GND”\n\nNet name for the ground planes.\n\nground_width\n\npython:float, default 0.1 mm\n\nWidth of the side ground strips.\n\nground_layer\n\npython:str, default “GND”\n\nLayer for the underlying ground plane.\n\nnet\n\npython:str, default “SIG”\n\nNet name for the centre conductor.\n\nsubstrate\n\nSubstrate, default 100 µm FR4\n\nSubstrate definition.\n\nExamples\n\n>>> cpw = CPW(length=5e-3, width=0.4e-3, gap=0.2e-3)\n>>> edb = Edb(\"cpw.aedb\")\n>>> cpw._pedb = edb\n>>> cpw.create()\n>>> f\"{cpw.analytical_z0:.1f} Ω\"\n'46.5 Ω'\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nCPW.create()\n\nDraw the centre strip, side grounds and bottom ground plane.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_closest_arc_midpoint",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_closest_arc_midpoint.html#get_closest_arc_midpoint",
        "title": "get_closest_arc_midpoint",
        "section": "get_closest_arc_midpoint",
        "text": "Get the closest arc midpoint of the primitive to the input data.\n[x, y].\nget_closest_arc_midpoint\nList\npython:float\nor\nList\nPointData\nLIst\npython:float\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_closest_arc_midpoint",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_closest_arc_midpoint.html#pyedb.grpc.database.primitive.circle.Circle.get_closest_arc_midpoint",
        "title": "get_closest_arc_midpoint > get_closest_arc_midpoint > get_closest_arc_midpoint",
        "section": "get_closest_arc_midpoint > get_closest_arc_midpoint",
        "text": "Circle.get_closest_arc_midpoint(point) -> list[float]\n\nGet the closest arc midpoint of the primitive to the input data.\n\nParameters\n\npoint\n\nList[python:float] or List[PointData]\n\n\n\nReturns\n\nLIst[python:float, python:float]\n\n[x, y].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.set_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.set_hfss_prop.html#set_hfss_prop",
        "title": "set_hfss_prop",
        "section": "set_hfss_prop",
        "text": "Set HFSS properties.\nMaterial property name to set.\nWhether to solve inside.\nset_hfss_prop\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.set_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.set_hfss_prop.html#pyedb.grpc.database.primitive.polygon.Polygon.set_hfss_prop",
        "title": "set_hfss_prop > set_hfss_prop > set_hfss_prop",
        "section": "set_hfss_prop > set_hfss_prop",
        "text": "Polygon.set_hfss_prop(material: str, solve_inside: bool)\n\nSet HFSS properties.\n\nParameters\n\nmaterial\n\npython:str\n\nMaterial property name to set.\n\nsolve_inside\n\nbool\n\nWhether to solve inside.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_polygon_bounding_box",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_polygon_bounding_box.html#get_polygon_bounding_box",
        "title": "get_polygon_bounding_box",
        "section": "get_polygon_bounding_box",
        "text": "Get bounding box of polygon.\nPolygon primitive.\nBounding box coordinates [min_x, min_y, max_x, max_y].\nget_polygon_bounding_box\npyedb.dotnet.database.edb_data.primitives_data.Primitive\npython:list"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_polygon_bounding_box",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_polygon_bounding_box.html#pyedb.grpc.database.modeler.Modeler.get_polygon_bounding_box",
        "title": "get_polygon_bounding_box > get_polygon_bounding_box > get_polygon_bounding_box",
        "section": "get_polygon_bounding_box > get_polygon_bounding_box",
        "text": "static Modeler.get_polygon_bounding_box(polygon: Primitive) -> List[float]\n\nGet bounding box of polygon.\n\nParameters\n\npolygon\n\npyedb.dotnet.database.edb_data.primitives_data.Primitive\n\nPolygon primitive.\n\nReturns\n\npython:list\n\nBounding box coordinates [min_x, min_y, max_x, max_y].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave.add_cpa_analysis",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave.add_cpa_analysis.html#add_cpa_analysis",
        "title": "add_cpa_analysis",
        "section": "add_cpa_analysis",
        "text": "add_cpa_analysis"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave.add_cpa_analysis",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave.add_cpa_analysis.html#pyedb.grpc.database.siwave.Siwave.add_cpa_analysis",
        "title": "add_cpa_analysis > add_cpa_analysis > add_cpa_analysis",
        "section": "add_cpa_analysis > add_cpa_analysis",
        "text": "Siwave.add_cpa_analysis(name=None, siwave_cpa_setup_class=None)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.create_coax_port",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.create_coax_port.html#create_coax_port",
        "title": "create_coax_port",
        "section": "create_coax_port",
        "text": "Create HFSS 3Dlayout coaxial lumped port on a pastack\nRequires to have solder ball defined before calling this method.\n. deprecated:: pyedb 0.28.0\nUse pyedb.grpc.core.excitations.create_source_on_component() instead.\nPadstack instance object.\nWhether to use . as the separator for the naming convention, which\nis [component][net][pin]. The default is True. If False, _ is\nused as the separator instead.\nPort name for overwriting the default port-naming convention,\nwhich is [component][net][pin]. The port name must be unique.\nIf a port with the specified name already exists, the\ndefault naming convention is used so that port creation does\nnot fail.\nTerminal name.\ncreate_coax_port\npyedb.grpc.core.excitations.create_source_on_component()\npython:int\noptional\n.\n[component][net][pin]\nTrue\nFalse\n_\npython:str\n[component][net][pin]\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.create_coax_port",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.create_coax_port.html#pyedb.grpc.database.padstacks.Padstacks.create_coax_port",
        "title": "create_coax_port > create_coax_port > create_coax_port",
        "section": "create_coax_port > create_coax_port",
        "text": "Padstacks.create_coax_port(padstackinstance, use_dot_separator=True, name=None)\n\nCreate HFSS 3Dlayout coaxial lumped port on a pastack\nRequires to have solder ball defined before calling this method.\n\n. deprecated:: pyedb 0.28.0\nUse pyedb.grpc.core.excitations.create_source_on_component() instead.\n\nParameters\n\npadstackinstance\n\nEdb.Cell.Primitive.PadstackInstance or python:int\n\nPadstack instance object.\n\nuse_dot_separator\n\nbool, optional\n\nWhether to use . as the separator for the naming convention, which\nis [component][net][pin]. The default is True. If False, _ is\nused as the separator instead.\n\nname\n\npython:str\n\nPort name for overwriting the default port-naming convention,\nwhich is [component][net][pin]. The port name must be unique.\nIf a port with the specified name already exists, the\ndefault naming convention is used so that port creation does\nnot fail.\n\nReturns\n\npython:str\n\nTerminal name.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.find_by_id.html#find_by_id",
        "title": "find_by_id",
        "section": "find_by_id",
        "text": "Find a Connectable object by database ID in a given layout.\nLayout to search for the Connectable object.\nDatabase ID.\nConnectable object with the given database ID.\nfind_by_id\nLayout\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.find_by_id.html#pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.find_by_id",
        "title": "find_by_id > find_by_id > find_by_id",
        "section": "find_by_id > find_by_id",
        "text": "classmethod PinGroupTerminal.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the Connectable object.\n\nuid\n\npython:int\n\nDatabase ID.\n\nReturns\n\nConnectable\n\nConnectable object with the given database ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.add_power_module",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.add_power_module.html#add_power_module",
        "title": "add_power_module",
        "section": "add_power_module",
        "text": "Add a power module to the voltage regulator.\nPower module.\nadd_power_module\nPowerModule"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.add_power_module",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.add_power_module.html#pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.add_power_module",
        "title": "add_power_module > add_power_module > add_power_module",
        "section": "add_power_module > add_power_module",
        "text": "VoltageRegulator.add_power_module(power_module)\n\nAdd a power module to the voltage regulator.\n\nParameters\n\npower_module\n\nPowerModule\n\nPower module.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.type",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.type.html#type",
        "title": "type",
        "section": "type",
        "text": "type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.type",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.type.html#pyedb.grpc.database.ports.ports.CoaxPort.type",
        "title": "type > type > type",
        "section": "type > type",
        "text": "CoaxPort.type = 3\n\n"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.Material",
        "href": "libraries/_autosummary/pyedb.libraries.common.Material.html#material",
        "title": "Material",
        "section": "Material",
        "text": "Generic material definition.\nWhen the material name is set, the object automatically registers\nitself in the provided PyEDB material database if the name is not\nalready present.\nActive EDB session.\nMaterial name (e.g. \"Copper\").\nMaterial\nansys.edb.core.database.Database\npython:str\n\"Copper\""
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.Material",
        "href": "libraries/_autosummary/pyedb.libraries.common.Material.html#pyedb.libraries.common.Material",
        "title": "Material > Material > Material",
        "section": "Material > Material",
        "text": "class pyedb.libraries.common.Material(pedb, name)\n\nGeneric material definition.\n\nWhen the material name is set, the object automatically registers\nitself in the provided PyEDB material database if the name is not\nalready present.\n\nParameters\n\npedb\n\nansys.edb.core.database.Database\n\nActive EDB session.\n\nname\n\npython:str\n\nMaterial name (e.g. \"Copper\").\n\nExamples\n\n>>> m = Material(edb, \"MyMaterial\")\n>>> m.name\n'MyMaterial'\n>>> edb.materials[\"MyMaterial\"]  # now exists in the database\n<Material object at ...>\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.points",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.points.html#points",
        "title": "points",
        "section": "points",
        "text": "Return the list of points with arcs converted to segments.\nNumber of facets to convert an arc. Default is 6.\n(X, Y).\npoints\npython:int\npython:tuple\npython:float\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.points",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.points.html#pyedb.grpc.database.primitive.path.Path.points",
        "title": "points > points > points",
        "section": "points > points",
        "text": "Path.points(arc_segments=6) -> tuple[float, float]\n\nReturn the list of points with arcs converted to segments.\n\nParameters\n\narc_segments\n\npython:int\n\nNumber of facets to convert an arc. Default is 6.\n\nReturns\n\npython:tuple(python:float, python:float)\n\n(X, Y).\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_parameters",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_parameters.html#get_parameters",
        "title": "get_parameters",
        "section": "get_parameters",
        "text": "Returns parameters.\nValue,\nValue,\nValue\nReturns a tuple in this format:\n(center_x, center_y, radius)\ncenter_x : X value of center point.\ncenter_y : Y value of center point.\nradius : Radius value of the circle.\nget_parameters\npython:tuple\nValue\nValue\nValue"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_parameters",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_parameters.html#pyedb.grpc.database.primitive.circle.Circle.get_parameters",
        "title": "get_parameters > get_parameters > get_parameters",
        "section": "get_parameters > get_parameters",
        "text": "Circle.get_parameters() -> tuple[float, float, float]\n\nReturns parameters.\n\nReturns\n\npython:tuple[\n\nValue,\nValue,\nValue\n\n]\n\nReturns a tuple in this format:\n\n(center_x, center_y, radius)\n\ncenter_x : X value of center point.\n\ncenter_y : Y value of center point.\n\nradius : Radius value of the circle.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the layout object.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.delete.html#pyedb.grpc.database.ports.ports.GapPort.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "GapPort.delete()\n\nDelete the layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_resistor_on_pin",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_resistor_on_pin.html#create_resistor_on_pin",
        "title": "create_resistor_on_pin",
        "section": "create_resistor_on_pin",
        "text": "Create a Resistor boundary between two given pins..\nPositive Pin.\nNegative Pin.\nResistance value. The default is 1.\nName of the resistor. The default is \"\".\nName of the resistor.\ncreate_resistor_on_pin\nObject\nObject\npython:float\noptional\n1\npython:str\noptional\n\"\"\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_resistor_on_pin",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_resistor_on_pin.html#pyedb.dotnet.database.siwave.EdbSiwave.create_resistor_on_pin",
        "title": "create_resistor_on_pin > create_resistor_on_pin > create_resistor_on_pin",
        "section": "create_resistor_on_pin > create_resistor_on_pin",
        "text": "EdbSiwave.create_resistor_on_pin(pos_pin, neg_pin, rvalue=1, resistor_name='')\n\nCreate a Resistor boundary between two given pins..\n\nParameters\n\npos_pin\n\nObject\n\nPositive Pin.\n\nneg_pin\n\nObject\n\nNegative Pin.\n\nrvalue\n\npython:float, optional\n\nResistance value. The default is 1.\n\nresistor_name\n\npython:str, optional\n\nName of the resistor. The default is \"\".\n\nReturns\n\npython:str\n\nName of the resistor.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", \"project name\", \"release version\")\n>>> pins = edbapp.components.get_pin_from_component(\"U2A5\")\n>>> edbapp.siwave.create_resistor_on_pin(pins[0], pins[1], 50, \"res_name\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/raptor_x_simulation_settings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/raptor_x_simulation_settings.html#raptor-x-simulation-settings",
        "title": "Raptor X simulation settings",
        "section": "Raptor X simulation settings",
        "text": "This class is managing EDB raptor x simulation settings.\nRaptorXSimulationSettings\nRaptor X simulation settings class.\nRaptor X simulation settings\nRaptorXSimulationSettings"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData.add_net",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData.add_net.html#add_net",
        "title": "add_net",
        "section": "add_net",
        "text": "Add a new net.\nThe name of the net to be added.\nadd_net\npython:str\nobject"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData.add_net",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData.add_net.html#pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData.add_net",
        "title": "add_net > add_net > add_net",
        "section": "add_net > add_net",
        "text": "EDBDifferentialPairData.add_net(name)\n\nAdd a new net.\n\nParameters\n\nname\n\npython:str\n\nThe name of the net to be added.\n\nReturns\n\nobject\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_instances",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_instances.html#get_instances",
        "title": "get_instances",
        "section": "get_instances",
        "text": "Get padstack instances by search criteria.\nInstance name.\nDatabase ID.\nPadstack definition name(s).\nNet name(s).\nComponent reference designator(s).\nComponent pin number(s).\nList of matching padstack instances.\nget_instances\npython:str\noptional\npython:int\noptional\npython:str\npython:list\noptional\npython:str\npython:list\noptional\npython:str\npython:list\noptional\npython:str\npython:list\noptional\npython:list\npyedb.grpc.database.primitive.padstack_instance.PadstackInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_instances",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_instances.html#pyedb.grpc.database.padstacks.Padstacks.get_instances",
        "title": "get_instances > get_instances > get_instances",
        "section": "get_instances > get_instances",
        "text": "Padstacks.get_instances(name: str | None = None, pid: int | None = None, definition_name: str | None = None, net_name: str | List[str] | None = None, component_reference_designator: str | None = None, component_pin: str | None = None) -> List[PadstackInstance]\n\nGet padstack instances by search criteria.\n\nParameters\n\nname\n\npython:str, optional\n\nInstance name.\n\npid\n\npython:int, optional\n\nDatabase ID.\n\ndefinition_name\n\npython:str or python:list, optional\n\nPadstack definition name(s).\n\nnet_name\n\npython:str or python:list, optional\n\nNet name(s).\n\ncomponent_reference_designator\n\npython:str or python:list, optional\n\nComponent reference designator(s).\n\ncomponent_pin\n\npython:str or python:list, optional\n\nComponent pin number(s).\n\nReturns\n\npython:list[pyedb.grpc.database.primitive.padstack_instance.PadstackInstance]\n\nList of matching padstack instances.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_coax_port",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_coax_port.html#create_coax_port",
        "title": "create_coax_port",
        "section": "create_coax_port",
        "text": "Create HFSS 3Dlayout coaxial lumped port on a pastack\nRequires to have solder ball defined before calling this method.\nPadstack instance object.\nWhether to use . as the separator for the naming convention, which\nis [component][net][pin]. The default is True. If False, _ is\nused as the separator instead.\nPort name for overwriting the default port-naming convention,\nwhich is [component][net][pin]. The port name must be unique.\nIf a port with the specified name already exists, the\ndefault naming convention is used so that port creation does\nnot fail.\nTerminal name.\ncreate_coax_port\npython:int\noptional\n.\n[component][net][pin]\nTrue\nFalse\n_\npython:str\n[component][net][pin]\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_coax_port",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_coax_port.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_coax_port",
        "title": "create_coax_port > create_coax_port > create_coax_port",
        "section": "create_coax_port > create_coax_port",
        "text": "SourceExcitation.create_coax_port(padstackinstance: PadstackInstance | int, use_dot_separator: bool = True, name: str | None = None, create_on_top: bool = True) -> str | None\n\nCreate HFSS 3Dlayout coaxial lumped port on a pastack\nRequires to have solder ball defined before calling this method.\n\nParameters\n\npadstackinstance\n\nEdb.Cell.Primitive.PadstackInstance or python:int\n\nPadstack instance object.\n\nuse_dot_separator\n\nbool, optional\n\nWhether to use . as the separator for the naming convention, which\nis [component][net][pin]. The default is True. If False, _ is\nused as the separator instead.\n\nname\n\npython:str\n\nPort name for overwriting the default port-naming convention,\nwhich is [component][net][pin]. The port name must be unique.\nIf a port with the specified name already exists, the\ndefault naming convention is used so that port creation does\nnot fail.\n\nReturns\n\npython:str\n\nTerminal name.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> pin = edb.padstacks.instances[0]\n>>> edb.source_excitation.create_coax_port(pin, name=\"CoaxPort1\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_polygon_bounding_box",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_polygon_bounding_box.html#get_polygon_bounding_box",
        "title": "get_polygon_bounding_box",
        "section": "get_polygon_bounding_box",
        "text": "Retrieve a polygon bounding box.\nName of the polygon.\nList of bounding box coordinates in the format [-x, -y, +x, +y].\nget_polygon_bounding_box\npython:list\n[-x, -y, +x, +y]"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_polygon_bounding_box",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_polygon_bounding_box.html#pyedb.dotnet.database.modeler.Modeler.get_polygon_bounding_box",
        "title": "get_polygon_bounding_box > get_polygon_bounding_box > get_polygon_bounding_box",
        "section": "get_polygon_bounding_box > get_polygon_bounding_box",
        "text": "Modeler.get_polygon_bounding_box(polygon)\n\nRetrieve a polygon bounding box.\n\nParameters\n\npolygon\n\nName of the polygon.\n\nReturns\n\npython:list\n\nList of bounding box coordinates in the format [-x, -y, +x, +y].\n\nExamples\n\n>>> poly = database.modeler.get_polygons_by_layer(\"GND\")\n>>> bounding = database.modeler.get_polygon_bounding_box(poly[0])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_rlc_boundary_on_pins",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_rlc_boundary_on_pins.html#create_rlc_boundary_on_pins",
        "title": "create_rlc_boundary_on_pins",
        "section": "create_rlc_boundary_on_pins",
        "text": "Create hfss rlc boundary on pins.\nEdb.Cell.Primitive.PadstackInstance\nEdb.Cell.Primitive.PadstackInstance\nTrue when successful, False when failed.\ncreate_rlc_boundary_on_pins\nPositive\nNegative\nResistance\nvalue\nInductance\nvalue\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_rlc_boundary_on_pins",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_rlc_boundary_on_pins.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_rlc_boundary_on_pins",
        "title": "create_rlc_boundary_on_pins > create_rlc_boundary_on_pins > create_rlc_boundary_on_pins",
        "section": "create_rlc_boundary_on_pins > create_rlc_boundary_on_pins",
        "text": "SourceExcitation.create_rlc_boundary_on_pins(positive_pin: PadstackInstance | None = None, negative_pin: PadstackInstance | None = None, rvalue: float = 0.0, lvalue: float = 0.0, cvalue: float = 0.0) -> Terminal | bool\n\nCreate hfss rlc boundary on pins.\n\nParameters\n\npositive_pin\n\nPositive pin.\n\nEdb.Cell.Primitive.PadstackInstance\n\nnegative_pin\n\nNegative pin.\n\nEdb.Cell.Primitive.PadstackInstance\n\nrvalue\n\nResistance value\n\n\n\nlvalue\n\nInductance value\n\n\n\ncvalue . Capacitance value.\n\n\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> pin1 = edb.components[\"U1\"].pins[\"Pin1\"]\n>>> pin2 = edb.components[\"U1\"].pins[\"Pin2\"]\n>>> term = edb.source_excitation.create_rlc_boundary_on_pins(pin1, pin2, rvalue=50)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.clone",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.clone.html#clone",
        "title": "clone",
        "section": "clone",
        "text": "Create a clone of the layer collection.\nLayer collection cloned.\nclone\nLayerCollection"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.clone",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.clone.html#pyedb.grpc.database.stackup.Stackup.clone",
        "title": "clone > clone > clone",
        "section": "clone > clone",
        "text": "Stackup.clone()\n\nCreate a clone of the layer collection.\n\nReturns\n\nLayerCollection\n\nLayer collection cloned.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_vendor_libraries",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_vendor_libraries.html#get_vendor_libraries",
        "title": "get_vendor_libraries",
        "section": "get_vendor_libraries",
        "text": "Get vendor component libraries.\nComponent library object.\nget_vendor_libraries\npyedb.component_libraries.ansys_components.ComponentLib"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_vendor_libraries",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_vendor_libraries.html#pyedb.grpc.database.components.Components.get_vendor_libraries",
        "title": "get_vendor_libraries > get_vendor_libraries > get_vendor_libraries",
        "section": "get_vendor_libraries > get_vendor_libraries",
        "text": "Components.get_vendor_libraries() -> ComponentLib\n\nGet vendor component libraries.\n\nReturns\n\npyedb.component_libraries.ansys_components.ComponentLib\n\nComponent library object.\n\nExamples\n\n>>> lib = edbapp.components.get_vendor_libraries()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_pin_from_component",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_pin_from_component.html#get_pin_from_component",
        "title": "get_pin_from_component",
        "section": "get_pin_from_component",
        "text": "Retrieve the pins of a component.\nName of the component or the EDB component object.\nFilter on the net name as an alternative to\npinName. The default is None.\nFilter on the pin name an alternative to\nnetName. The default is None.\nFilter on the net name as an alternative to\npin_name. The default is None. This parameter is added to add compatibility with grpc and is\nrecommended using it rather than netName.\nFilter on the pin name an alternative to\nnetName. The default is None. This parameter is added to add compatibility with grpc and is\nrecommended using it rather than pinName.\nList of pins when the component is found or [] otherwise.\nget_pin_from_component\npython:str\nEDB\ncomponent\npython:str\noptional\npinName\nNone\npython:str\noptional\nnetName\nNone\npython:str\noptional\npin_name\nNone\npython:str\noptional\nnetName\nNone\npython:list\n[]"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_pin_from_component",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_pin_from_component.html#pyedb.dotnet.database.components.Components.get_pin_from_component",
        "title": "get_pin_from_component > get_pin_from_component > get_pin_from_component",
        "section": "get_pin_from_component > get_pin_from_component",
        "text": "Components.get_pin_from_component(component, netName=None, pinName=None, net_name=None, pin_name=None)\n\nRetrieve the pins of a component.\n\nParameters\n\ncomponent\n\npython:str or EDB component\n\nName of the component or the EDB component object.\n\nnetName\n\npython:str, optional\n\nFilter on the net name as an alternative to\npinName. The default is None.\n\npinName\n\npython:str, optional\n\nFilter on the pin name an alternative to\nnetName. The default is None.\n\nnet_name\n\npython:str, optional\n\nFilter on the net name as an alternative to\npin_name. The default is None. This parameter is added to add compatibility with grpc and is\nrecommended using it rather than netName.\n\npin_name\n\npython:str, optional\n\nFilter on the pin name an alternative to\nnetName. The default is None. This parameter is added to add compatibility with grpc and is\nrecommended using it rather than pinName.\n\nReturns\n\npython:list\n\nList of pins when the component is found or [] otherwise.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", \"project name\", \"release version\")\n>>> edbapp.components.get_pin_from_component(\"R1\", refdes)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSetup.add_mesh_operation",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSetup.add_mesh_operation.html#add_mesh_operation",
        "title": "add_mesh_operation",
        "section": "add_mesh_operation",
        "text": "Add mesh operations.\nMesh name.\nRegion to apply mesh operation.\nMesh operation type. It can be “MeshOperationLength” or  “MeshOperationSkinDepth”.\nDictionary containing nets and layers on which apply mesh.\nadd_mesh_operation\npython:str\npython:str\npython:str\npython:dict\npyedb.dotnet.database.edb_data.control_file.ControlFileMeshOp"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSetup.add_mesh_operation",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSetup.add_mesh_operation.html#pyedb.grpc.database.utility.xml_control_file.ControlFileSetup.add_mesh_operation",
        "title": "add_mesh_operation > add_mesh_operation > add_mesh_operation",
        "section": "add_mesh_operation > add_mesh_operation",
        "text": "ControlFileSetup.add_mesh_operation(name, region, type, nets_layers)\n\nAdd mesh operations.\n\nParameters\n\nname\n\npython:str\n\nMesh name.\n\nregion\n\npython:str\n\nRegion to apply mesh operation.\n\ntype\n\npython:str\n\nMesh operation type. It can be “MeshOperationLength” or  “MeshOperationSkinDepth”.\n\nnets_layers\n\npython:dict\n\nDictionary containing nets and layers on which apply mesh.\n\nReturns\n\npyedb.dotnet.database.edb_data.control_file.ControlFileMeshOp\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.find_by_name",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.find_by_name.html#find_by_name",
        "title": "find_by_name",
        "section": "find_by_name",
        "text": "Find a differential pair by name in a given layout.\nLayout to search for the differential pair.\nName of the differential pair.\nDifferential pair that was found. Check the is_null\nproperty of the returned differential pair to see if it exists.\nfind_by_name\nLayout\npython:str\nDifferentialPair\nis_null"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.find_by_name",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.find_by_name.html#pyedb.grpc.database.net.differential_pair.DifferentialPair.find_by_name",
        "title": "find_by_name > find_by_name > find_by_name",
        "section": "find_by_name > find_by_name",
        "text": "classmethod DifferentialPair.find_by_name(layout, name)\n\nFind a differential pair by name in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the differential pair.\n\nname\n\npython:str\n\nName of the differential pair.\n\nReturns\n\nDifferentialPair\n\nDifferential pair that was found. Check the is_null\nproperty of the returned differential pair to see if it exists.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.create_hfss.html#create_hfss",
        "title": "create_hfss",
        "section": "create_hfss",
        "text": "Create an HFSS model from an MCAD file.\nHFSS model created.\ncreate_hfss\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.create_hfss.html#pyedb.grpc.database.ports.ports.BundleWavePort.create_hfss",
        "title": "create_hfss > create_hfss > create_hfss",
        "section": "create_hfss > create_hfss",
        "text": "BundleWavePort.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nReturns\n\nMcadModel\n\nHFSS model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues: Trusted or pre-validated data dictionary.\nA new instance of the Model class with validated data.\nmodel_construct"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_construct.html#pyedb.workflows.drc.drc.MinLineWidth.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod MinLineWidth.model_construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nArgs:\n\n_fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues: Trusted or pre-validated data dictionary.\n\nReturns:\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.remove_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.remove_hfss_prop.html#remove_hfss_prop",
        "title": "remove_hfss_prop",
        "section": "remove_hfss_prop",
        "text": "Remove HFSS properties.\nremove_hfss_prop"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.remove_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.remove_hfss_prop.html#pyedb.grpc.database.primitive.polygon.Polygon.remove_hfss_prop",
        "title": "remove_hfss_prop > remove_hfss_prop > remove_hfss_prop",
        "section": "remove_hfss_prop > remove_hfss_prop",
        "text": "Polygon.remove_hfss_prop()\n\nRemove HFSS properties.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.html#hfsssimulationsetup",
        "title": "HfssSimulationSetup",
        "section": "HfssSimulationSetup",
        "text": "HFSS simulation setup class.\nHfssSimulationSetup.add_adaptive_frequency_data([...])\nAdd adaptive frequency data to simulation setup.\nHfssSimulationSetup.add_length_mesh_operation(...)\nAdd a mesh operation to the setup.\nHfssSimulationSetup.add_skin_depth_mesh_operation(...)\nAdd a mesh operation to the setup.\nHfssSimulationSetup.add_sweep([name, ...])\nAdd a HFSS frequency sweep.\nHfssSimulationSetup.auto_mesh_operation([...])\nAutomatically create and apply a length-based mesh operation for all nets in the design.\nHfssSimulationSetup.cast()\nCast the base SimulationSetup object to correct subclass, if possible.\nHfssSimulationSetup.create(cell, name)\nCreate an HFSS simulation setup.\nHfssSimulationSetup.set_solution_broadband([...])\nSet solution to broadband.\nHfssSimulationSetup.set_solution_multi_frequencies([...])\nSet HFSS setup multi frequencies adaptive.\nHfssSimulationSetup.set_solution_single_frequency([...])\nSet HFSS single frequency solution. Parameters ---------- frequency : str, optional     Adaptive frequency. max_num_passes : int, optional     Maxmímum passes number. Default value 10. max_delta_s : float, optional     Maximum delta S value. Default value 0.02,.\nHfssSimulationSetup\nHfssSimulationSetup.add_adaptive_frequency_data\nHfssSimulationSetup.add_length_mesh_operation\nHfssSimulationSetup.add_skin_depth_mesh_operation\nHfssSimulationSetup.add_sweep\nHfssSimulationSetup.auto_mesh_operation\nHfssSimulationSetup.cast\nHfssSimulationSetup.create\nHfssSimulationSetup.set_solution_broadband\nHfssSimulationSetup.set_solution_multi_frequencies\nHfssSimulationSetup.set_solution_single_frequency"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.html#pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup",
        "title": "HfssSimulationSetup > HfssSimulationSetup > HfssSimulationSetup",
        "section": "HfssSimulationSetup > HfssSimulationSetup",
        "text": "class pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup(pedb, edb_object, name: str | None = None)\n\nHFSS simulation setup class.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nHfssSimulationSetup.add_adaptive_frequency_data([...])\n\nAdd adaptive frequency data to simulation setup.\n\nHfssSimulationSetup.add_length_mesh_operation(...)\n\nAdd a mesh operation to the setup.\n\nHfssSimulationSetup.add_skin_depth_mesh_operation(...)\n\nAdd a mesh operation to the setup.\n\nHfssSimulationSetup.add_sweep([name, ...])\n\nAdd a HFSS frequency sweep.\n\nHfssSimulationSetup.auto_mesh_operation([...])\n\nAutomatically create and apply a length-based mesh operation for all nets in the design.\n\nHfssSimulationSetup.cast()\n\nCast the base SimulationSetup object to correct subclass, if possible.\n\nHfssSimulationSetup.create(cell, name)\n\nCreate an HFSS simulation setup.\n\nHfssSimulationSetup.set_solution_broadband([...])\n\nSet solution to broadband.\n\nHfssSimulationSetup.set_solution_multi_frequencies([...])\n\nSet HFSS setup multi frequencies adaptive.\n\nHfssSimulationSetup.set_solution_single_frequency([...])\n\nSet HFSS single frequency solution. Parameters ---------- frequency : str, optional     Adaptive frequency. max_num_passes : int, optional     Maxmímum passes number. Default value 10. max_delta_s : float, optional     Maximum delta S value. Default value 0.02,.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_hfss_prop.html#get_hfss_prop",
        "title": "get_hfss_prop",
        "section": "get_hfss_prop",
        "text": "Get HFSS properties.\nReturns a tuple in this format:\n(material, solve_inside)\nmaterial :  Name of the material property.\nsolve_inside : Whether to solve inside.\nget_hfss_prop\npython:tuple\nof\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_hfss_prop.html#pyedb.grpc.database.primitive.circle.Circle.get_hfss_prop",
        "title": "get_hfss_prop > get_hfss_prop > get_hfss_prop",
        "section": "get_hfss_prop > get_hfss_prop",
        "text": "Circle.get_hfss_prop() -> tuple[str, bool]\n\nGet HFSS properties.\n\nReturns\n\npython:tuple of (python:str, bool)\n\nReturns a tuple in this format:\n\n(material, solve_inside)\n\nmaterial :  Name of the material property.\n\nsolve_inside : Whether to solve inside.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_center_line",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_center_line.html#get_center_line",
        "title": "get_center_line",
        "section": "get_center_line",
        "text": "Retrieve center line points list.\nget_center_line\nList\nList\npython:float\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_center_line",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_center_line.html#pyedb.grpc.database.primitive.path.Path.get_center_line",
        "title": "get_center_line > get_center_line > get_center_line",
        "section": "get_center_line > get_center_line",
        "text": "Path.get_center_line() -> list[list[float]]\n\nRetrieve center line points list.\n\nReturns\n\nList[List[python:float, python:float]].\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.remove_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.remove_hfss_prop.html#remove_hfss_prop",
        "title": "remove_hfss_prop",
        "section": "remove_hfss_prop",
        "text": "Remove HFSS properties.\nremove_hfss_prop"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.remove_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.remove_hfss_prop.html#pyedb.grpc.database.primitive.rectangle.Rectangle.remove_hfss_prop",
        "title": "remove_hfss_prop > remove_hfss_prop > remove_hfss_prop",
        "section": "remove_hfss_prop > remove_hfss_prop",
        "text": "Rectangle.remove_hfss_prop()\n\nRemove HFSS properties.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.RatRace",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.RatRace.html#ratrace",
        "title": "RatRace",
        "section": "RatRace",
        "text": "180° rat-race (ring) hybrid coupler.\nCharacteristic impedance of the ring.\nCentre frequency.\nLayer on which the ring is drawn.\nLayer for the ground plane (if None, no ground is drawn).\nNet name.\nMicro-strip width for the ring and port stubs.\nNumber of straight segments per 90° arc.\nRatRace.create()\nDraw the discretised ring and four 50 Ω port stubs.\nRatRace\npython:float\ndefault\npython:float\ndefault\nGHz\npython:str\ndefault\npython:str\npython:None\npython:str\ndefault\npython:float\ndefault\nmm\npython:int\ndefault\nRatRace.create"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.RatRace",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.RatRace.html#pyedb.libraries.rf_libraries.base_functions.RatRace",
        "title": "RatRace > RatRace > RatRace",
        "section": "RatRace > RatRace",
        "text": "class pyedb.libraries.rf_libraries.base_functions.RatRace(edb_cell: Edb | None = None, z0: float | str = 50, freq: float | str = 10000000000.0, layer: str = 'TOP', bottom_layer: str | None = None, net: str = 'RR', width: float | str = 0.0002, nr_segments: int = 32)\n\n180° rat-race (ring) hybrid coupler.\n\nParameters\n\nz0\n\npython:float, default 50 Ω\n\nCharacteristic impedance of the ring.\n\nfreq\n\npython:float, default 10 GHz\n\nCentre frequency.\n\nlayer\n\npython:str, default “TOP”\n\nLayer on which the ring is drawn.\n\nbottom_layer\n\npython:str | python:None\n\nLayer for the ground plane (if None, no ground is drawn).\n\nnet\n\npython:str, default “RR”\n\nNet name.\n\nwidth\n\npython:float, default 0.2 mm\n\nMicro-strip width for the ring and port stubs.\n\nnr_segments\n\npython:int, default 32\n\nNumber of straight segments per 90° arc.\n\nExamples\n\n>>> rr = RatRace(freq=5e9)\n>>> edb = Edb(\"ratrace.aedb\")\n>>> rr._pedb = edb\n>>> rr.create()\n>>> f\"{rr.circumference * 1e3:.2f} mm\"\n'45.00 mm'\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nRatRace.create()\n\nDraw the discretised ring and four 50 Ω port stubs.\n\n"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.InterdigitalCapacitor.VAR_PREFIX",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.InterdigitalCapacitor.VAR_PREFIX.html#var_prefix",
        "title": "VAR_PREFIX",
        "section": "VAR_PREFIX",
        "text": "VAR_PREFIX"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.InterdigitalCapacitor.VAR_PREFIX",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.InterdigitalCapacitor.VAR_PREFIX.html#pyedb.libraries.rf_libraries.base_functions.InterdigitalCapacitor.VAR_PREFIX",
        "title": "VAR_PREFIX > VAR_PREFIX > VAR_PREFIX",
        "section": "VAR_PREFIX > VAR_PREFIX",
        "text": "InterdigitalCapacitor.VAR_PREFIX = 'IDC'\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_bounding_box",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_bounding_box.html#get_bounding_box",
        "title": "get_bounding_box",
        "section": "get_bounding_box",
        "text": "Get the layout bounding box.\nBounding box as a [lower-left X, lower-left Y], [upper-right X, upper-right Y]) pair in meters.\nget_bounding_box\npython:list\nof\npython:list\nof\ndouble"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_bounding_box",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_bounding_box.html#pyedb.dotnet.edb.Edb.get_bounding_box",
        "title": "get_bounding_box > get_bounding_box > get_bounding_box",
        "section": "get_bounding_box > get_bounding_box",
        "text": "Edb.get_bounding_box()\n\nGet the layout bounding box.\n\nReturns\n\npython:list of python:list of double\n\nBounding box as a [lower-left X, lower-left Y], [upper-right X, upper-right Y]) pair in meters.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "LayoutObjType: Layout object type of the PadstackInstance class.\nlayout_obj_type\nLayoutObjType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.layout_obj_type.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "PadstackInstance.layout_obj_type = 1\n\nLayoutObjType: Layout object type of the PadstackInstance class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.create_3d_comp.html#create_3d_comp",
        "title": "create_3d_comp",
        "section": "create_3d_comp",
        "text": "Create a 3D composite model from an MCAD file.\n3D composite model created.\ncreate_3d_comp\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.create_3d_comp.html#pyedb.grpc.database.ports.ports.CircuitPort.create_3d_comp",
        "title": "create_3d_comp > create_3d_comp > create_3d_comp",
        "section": "create_3d_comp > create_3d_comp",
        "text": "CircuitPort.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nReturns\n\nMcadModel\n\n3D composite model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.html#arcdata",
        "title": "ArcData",
        "section": "ArcData",
        "text": "Class managing ArcData.\nArcData.angle([arc])\nGet the angle between this arc and another arc if provided or the angle of this arc.\nArcData.closest_points(other)\nGet the closest points from this arc to another arc, and vice versa.\nArcData.is_big()\nDetermine if the arc is big.\nArcData.is_ccw()\nDetermine if the arc rotates counter-clockwise.\nArcData.is_cw()\nDetermine if the arc rotates clockwise.\nArcData.is_left()\nDetermine if the arc rotates clockwise.\nArcData.is_point([tolerance])\nDetermine if the arc is a point.\nArcData.is_segment([tolerance])\nDetermine if the arc is a straight line segment.\nArcData.tangent_at(point)\nGet the tangent vector of the arc at a given point.\nArcData\nArcData.angle\nArcData.closest_points\nArcData.is_big\nArcData.is_ccw\nArcData.is_cw\nArcData.is_left\nArcData.is_point\nArcData.is_segment\nArcData.tangent_at"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.html#pyedb.grpc.database.geometry.arc_data.ArcData",
        "title": "ArcData > ArcData > ArcData",
        "section": "ArcData > ArcData",
        "text": "class pyedb.grpc.database.geometry.arc_data.ArcData(pedb, edb_object)\n\nClass managing ArcData.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nArcData.angle([arc])\n\nGet the angle between this arc and another arc if provided or the angle of this arc.\n\nArcData.closest_points(other)\n\nGet the closest points from this arc to another arc, and vice versa.\n\nArcData.is_big()\n\nDetermine if the arc is big.\n\nArcData.is_ccw()\n\nDetermine if the arc rotates counter-clockwise.\n\nArcData.is_cw()\n\nDetermine if the arc rotates clockwise.\n\nArcData.is_left()\n\nDetermine if the arc rotates clockwise.\n\nArcData.is_point([tolerance])\n\nDetermine if the arc is a point.\n\nArcData.is_segment([tolerance])\n\nDetermine if the arc is a straight line segment.\n\nArcData.tangent_at(point)\n\nGet the tangent vector of the arc at a given point.\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_polygons_by_layer",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_polygons_by_layer.html#get_polygons_by_layer",
        "title": "get_polygons_by_layer",
        "section": "get_polygons_by_layer",
        "text": "Retrieve polygons by a layer.\nName of the layer.\nList of net names.\nList of primitive objects.\nget_polygons_by_layer\npython:str\npython:list\noptional\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_polygons_by_layer",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_polygons_by_layer.html#pyedb.dotnet.database.modeler.Modeler.get_polygons_by_layer",
        "title": "get_polygons_by_layer > get_polygons_by_layer > get_polygons_by_layer",
        "section": "get_polygons_by_layer > get_polygons_by_layer",
        "text": "Modeler.get_polygons_by_layer(layer_name, net_list=None)\n\nRetrieve polygons by a layer.\n\nParameters\n\nlayer_name\n\npython:str\n\nName of the layer.\n\nnet_list\n\npython:list, optional\n\nList of net names.\n\nReturns\n\npython:list\n\nList of primitive objects.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "not_found",
        "href": "not_found.html#page-not-found",
        "title": "Page Not Found",
        "section": "Page Not Found",
        "text": "The page you’re looking for doesn’t exist or has been moved.\nTry one of these instead:\nGetting Started\nUser Guide\nAPI Reference\nIf you believe this is an error, please report it on GitHub.\nPage Not Found"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.AdaptiveSettings.add_adaptive_frequency_data",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.AdaptiveSettings.add_adaptive_frequency_data.html#add_adaptive_frequency_data",
        "title": "add_adaptive_frequency_data",
        "section": "add_adaptive_frequency_data",
        "text": "Add a setup for frequency data.\nFrequency with units or float frequency (in Hz).\nMaximum number of passes. The default is 10.\nMaximum delta S. The default is 0.02.\nTrue if method is successful, False otherwise.\nadd_adaptive_frequency_data\npython:str\npython:float\npython:int\noptional\n10\npython:float\noptional\n0.02\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.AdaptiveSettings.add_adaptive_frequency_data",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.AdaptiveSettings.add_adaptive_frequency_data.html#pyedb.dotnet.database.sim_setup_data.data.settings.AdaptiveSettings.add_adaptive_frequency_data",
        "title": "add_adaptive_frequency_data > add_adaptive_frequency_data > add_adaptive_frequency_data",
        "section": "add_adaptive_frequency_data > add_adaptive_frequency_data",
        "text": "AdaptiveSettings.add_adaptive_frequency_data(frequency=0, max_num_passes=10, max_delta_s=0.02)\n\nAdd a setup for frequency data.\n\nParameters\n\nfrequency\n\npython:str, python:float\n\nFrequency with units or float frequency (in Hz).\n\nmax_num_passes\n\npython:int, optional\n\nMaximum number of passes. The default is 10.\n\nmax_delta_s\n\npython:float, optional\n\nMaximum delta S. The default is 0.02.\n\nReturns\n\nbool\n\nTrue if method is successful, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.find_by_id.html#find_by_id",
        "title": "find_by_id",
        "section": "find_by_id",
        "text": "Find a Connectable object by database ID in a given layout.\nLayout to search for the Connectable object.\nDatabase ID.\nConnectable object with the given database ID.\nfind_by_id\nLayout\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.find_by_id.html#pyedb.grpc.database.hierarchy.component.Component.find_by_id",
        "title": "find_by_id > find_by_id > find_by_id",
        "section": "find_by_id > find_by_id",
        "text": "classmethod Component.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the Connectable object.\n\nuid\n\npython:int\n\nDatabase ID.\n\nReturns\n\nConnectable\n\nConnectable object with the given database ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.set_product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.set_product_solver_option.html#set_product_solver_option",
        "title": "set_product_solver_option",
        "section": "set_product_solver_option",
        "text": "Set the product solver option.\nID of the product.\nName of the solver.\nName of the product solver option.\nset_product_solver_option\nProductIdType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.set_product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.set_product_solver_option.html#pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.set_product_solver_option",
        "title": "set_product_solver_option > set_product_solver_option > set_product_solver_option",
        "section": "set_product_solver_option > set_product_solver_option",
        "text": "PadstackInstanceTerminal.set_product_solver_option(product_id, solver_name, option)\n\nSet the product solver option.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nsolver_name\n\nobj:str\n\nName of the solver.\n\noption\n\nobj:str\n\nName of the product solver option.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_simulation_setup.SiwaveSimulationSetup.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_simulation_setup.SiwaveSimulationSetup.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the base SimulationSetup object to correct subclass, if possible.\ncast\nSimulationSetup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_simulation_setup.SiwaveSimulationSetup.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_simulation_setup.SiwaveSimulationSetup.cast.html#pyedb.grpc.database.simulation_setup.siwave_simulation_setup.SiwaveSimulationSetup.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "SiwaveSimulationSetup.cast()\n\nCast the base SimulationSetup object to correct subclass, if possible.\n\nReturns\n\nSimulationSetup\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.delete",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete this primitive.\ndelete"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.delete",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.delete.html#pyedb.dotnet.database.edb_data.ports.GapPort.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "GapPort.delete()\n\nDelete this primitive.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_connected_objects",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_connected_objects.html#get_connected_objects",
        "title": "get_connected_objects",
        "section": "get_connected_objects",
        "text": "Get connected objects.\nget_connected_objects\nList\nLayoutObjInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_connected_objects",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_connected_objects.html#pyedb.grpc.database.primitive.circle.Circle.get_connected_objects",
        "title": "get_connected_objects > get_connected_objects > get_connected_objects",
        "section": "get_connected_objects > get_connected_objects",
        "text": "Circle.get_connected_objects()\n\nGet connected objects.\n\nReturns\n\nList[LayoutObjInstance]\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData.add_net",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData.add_net.html#add_net",
        "title": "add_net",
        "section": "add_net",
        "text": "Add a new net.\nThe name of the net to be added.\nadd_net\npython:str\nobject"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData.add_net",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData.add_net.html#pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData.add_net",
        "title": "add_net > add_net > add_net",
        "section": "add_net > add_net",
        "text": "EDBExtendedNetData.add_net(name)\n\nAdd a new net.\n\nParameters\n\nname\n\npython:str\n\nThe name of the net to be added.\n\nReturns\n\nobject\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.html#circle",
        "title": "Circle",
        "section": "Circle",
        "text": "Circle.add_void(point_list)\nAdd a void to current primitive.\nCircle.area([include_voids])\nReturn the total area.\nCircle.can_be_zone_primitive()\nbool: Flag indicating if a circle can be a zone.\nCircle.cast()\nCast the primitive object to the correct concrete type.\nCircle.convert_to_polygon()\nConvert path to polygon.\nCircle.create([layout, layer, net, ...])\nCreate a circle.\nCircle.create_3d_comp()\nCreate a 3D composite model from an MCAD file.\nCircle.create_hfss()\nCreate an HFSS model from an MCAD file.\nCircle.create_stride()\nCreate a Stride model from an MCAD file.\nCircle.delete()\nDelete the circle from the layout.\nCircle.expand([offset, tolerance, ...])\nExpand the polygon shape by an absolute value in all direction.\nCircle.find_by_id(layout, uid)\nFind a Connectable object by database ID in a given layout.\nCircle.get_closest_arc_midpoint(point)\nGet the closest arc midpoint of the primitive to the input data.\nCircle.get_closest_point(point)\nGet the closest point of the primitive to the input data.\nCircle.get_connected_object_id_set()\nProduce a list of all geometries physically connected to a given layout object.\nCircle.get_connected_objects()\nGet connected objects.\nCircle.get_hfss_prop()\nGet HFSS properties.\nCircle.get_parameters()\nReturns parameters.\nCircle.get_product_property(prod_id, attr_id)\nGet the product property of the layout object for a given product ID and attribute ID.\nCircle.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nCircle.intersect(primitives)\nIntersect active primitive with one or more primitives.\nCircle.intersection_type(primitive)\nGet intersection type between actual primitive and another primitive or polygon data.\nCircle.is_intersecting(primitive)\nCheck if actual primitive and another primitive or polygon data intesects.\nCircle.make_zone_primitive(zone_id)\nMake the primitive a zone primitive with a zone specified by the provided ID.\nCircle.plot([plot_net, show, save_plot])\nPlot the current polygon on matplotlib.\nCircle.points([arc_segments])\nReturn the list of points with arcs converted to segments.\nCircle.remove_hfss_prop()\nRemove HFSS properties.\nCircle.render(center_x, center_y, radius, ...)\nRender a circle.\nCircle.scale(factor[, center])\nScales the polygon relative to a center point by a factor.\nCircle.set_hfss_prop(material, solve_inside)\nSet HFSS properties.\nCircle.set_parameters(center_x, center_y, radius)\nSet parameters.\nCircle.set_product_property(prod_id, ...)\nSet the product property of the layout object for a given product ID and attribute ID.\nCircle.subtract(primitives)\nSubtract active primitive with one or more primitives.\nCircle.unite(primitives)\nUnite active primitive with one or more primitives.\nCircle.layout_obj_type\nLayoutObjType: Layout object type of the Primitive class.\nCircle\nCircle.add_void\nCircle.area\nCircle.can_be_zone_primitive\nbool\nCircle.cast\nCircle.convert_to_polygon\nCircle.create\nCircle.create_3d_comp\nCircle.create_hfss\nCircle.create_stride\nCircle.delete\nCircle.expand\nCircle.find_by_id\nCircle.get_closest_arc_midpoint\nCircle.get_closest_point\nCircle.get_connected_object_id_set\nCircle.get_connected_objects\nCircle.get_hfss_prop\nCircle.get_parameters\nCircle.get_product_property\nCircle.get_product_property_ids\nCircle.intersect\nCircle.intersection_type\nCircle.is_intersecting\nCircle.make_zone_primitive\nCircle.plot\nCircle.points\nCircle.remove_hfss_prop\nCircle.render\nCircle.scale\nCircle.set_hfss_prop\nCircle.set_parameters\nCircle.set_product_property\nCircle.subtract\nCircle.unite\nCircle.layout_obj_type\nLayoutObjType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.html#pyedb.grpc.database.primitive.circle.Circle",
        "title": "Circle > Circle > Circle",
        "section": "Circle > Circle",
        "text": "class pyedb.grpc.database.primitive.circle.Circle(pedb, edb_object=None)\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nCircle.add_void(point_list)\n\nAdd a void to current primitive.\n\nCircle.area([include_voids])\n\nReturn the total area.\n\nCircle.can_be_zone_primitive()\n\nbool: Flag indicating if a circle can be a zone.\n\nCircle.cast()\n\nCast the primitive object to the correct concrete type.\n\nCircle.convert_to_polygon()\n\nConvert path to polygon.\n\nCircle.create([layout, layer, net, ...])\n\nCreate a circle.\n\nCircle.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nCircle.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nCircle.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nCircle.delete()\n\nDelete the circle from the layout.\n\nCircle.expand([offset, tolerance, ...])\n\nExpand the polygon shape by an absolute value in all direction.\n\nCircle.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nCircle.get_closest_arc_midpoint(point)\n\nGet the closest arc midpoint of the primitive to the input data.\n\nCircle.get_closest_point(point)\n\nGet the closest point of the primitive to the input data.\n\nCircle.get_connected_object_id_set()\n\nProduce a list of all geometries physically connected to a given layout object.\n\nCircle.get_connected_objects()\n\nGet connected objects.\n\nCircle.get_hfss_prop()\n\nGet HFSS properties.\n\nCircle.get_parameters()\n\nReturns parameters.\n\nCircle.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nCircle.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nCircle.intersect(primitives)\n\nIntersect active primitive with one or more primitives.\n\nCircle.intersection_type(primitive)\n\nGet intersection type between actual primitive and another primitive or polygon data.\n\nCircle.is_intersecting(primitive)\n\nCheck if actual primitive and another primitive or polygon data intesects.\n\nCircle.make_zone_primitive(zone_id)\n\nMake the primitive a zone primitive with a zone specified by the provided ID.\n\nCircle.plot([plot_net, show, save_plot])\n\nPlot the current polygon on matplotlib.\n\nCircle.points([arc_segments])\n\nReturn the list of points with arcs converted to segments.\n\nCircle.remove_hfss_prop()\n\nRemove HFSS properties.\n\nCircle.render(center_x, center_y, radius, ...)\n\nRender a circle.\n\nCircle.scale(factor[, center])\n\nScales the polygon relative to a center point by a factor.\n\nCircle.set_hfss_prop(material, solve_inside)\n\nSet HFSS properties.\n\nCircle.set_parameters(center_x, center_y, radius)\n\nSet parameters.\n\nCircle.set_product_property(prod_id, ...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nCircle.subtract(primitives)\n\nSubtract active primitive with one or more primitives.\n\nCircle.unite(primitives)\n\nUnite active primitive with one or more primitives.\n\n\n\nAttributes\n\n\n\n\n\n\n\nCircle.layout_obj_type\n\nLayoutObjType: Layout object type of the Primitive class.\n\n"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.json.html#json",
        "title": "json",
        "section": "json",
        "text": "json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.json.html#pyedb.workflows.drc.drc.MinAnnularRing.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "MinAnnularRing.json(*, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -> str\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_point_terminal_reference_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_point_terminal_reference_primitive.html#get_point_terminal_reference_primitive",
        "title": "get_point_terminal_reference_primitive",
        "section": "get_point_terminal_reference_primitive",
        "text": "Find and return the primitive reference for the point terminal or the padstack instance.\nThe primitive reference for the point terminal or the padstack instance.\nReturns an instance of PadstackInstance\nor Primitive.\nget_point_terminal_reference_primitive\nPrimitive\nPadstackInstance\nPadstackInstance\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_point_terminal_reference_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_point_terminal_reference_primitive.html#pyedb.grpc.database.terminal.terminal.Terminal.get_point_terminal_reference_primitive",
        "title": "get_point_terminal_reference_primitive > get_point_terminal_reference_primitive > get_point_terminal_reference_primitive",
        "section": "get_point_terminal_reference_primitive > get_point_terminal_reference_primitive",
        "text": "Terminal.get_point_terminal_reference_primitive() -> Primitive\n\nFind and return the primitive reference for the point terminal or the padstack instance.\n\nReturns\n\nPrimitive or PadstackInstance\n\nThe primitive reference for the point terminal or the padstack instance.\nReturns an instance of PadstackInstance\nor Primitive.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.find_dc_short",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.find_dc_short.html#find_dc_short",
        "title": "find_dc_short",
        "section": "find_dc_short",
        "text": "Find DC-shorted nets connected to this net.\nWhether to automatically rename nets to resolve shorts.\nDefault: False (only report shorts).\nList of shorted net pairs in the format [[net_name1, net_name2], …].\nfind_dc_short\noptional\nFalse\npython:list\npython:list\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.find_dc_short",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.find_dc_short.html#pyedb.grpc.database.net.net.Net.find_dc_short",
        "title": "find_dc_short > find_dc_short > find_dc_short",
        "section": "find_dc_short > find_dc_short",
        "text": "Net.find_dc_short(fix=False) -> list[list[str, str]]\n\nFind DC-shorted nets connected to this net.\n\nParameters\n\nfix\n\nbool, optional\n\nWhether to automatically rename nets to resolve shorts.\nDefault: False (only report shorts).\n\nReturns\n\npython:list[python:list[python:str]]\n\nList of shorted net pairs in the format [[net_name1, net_name2], …].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.Substrate.h",
        "href": "libraries/_autosummary/pyedb.libraries.common.Substrate.h.html#h",
        "title": "h",
        "section": "h",
        "text": "h"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.Substrate.h",
        "href": "libraries/_autosummary/pyedb.libraries.common.Substrate.h.html#pyedb.libraries.common.Substrate.h",
        "title": "h > h > h",
        "section": "h > h",
        "text": "Substrate.h: float = 0.0001\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.find",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.find.html#find",
        "title": "find",
        "section": "find",
        "text": "Find a terminal by name in a given layout.\nLayout to search for the terminal.\nName of the terminal.\nfind\nLayout\nstr\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.find",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.find.html#pyedb.grpc.database.ports.ports.GapPort.find",
        "title": "find > find > find",
        "section": "find > find",
        "text": "classmethod GapPort.find(layout, name)\n\nFind a terminal by name in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the terminal.\n\nname\n\nstr\n\nName of the terminal.\n\nReturns\n\nTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.intersection_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.intersection_type.html#intersection_type",
        "title": "intersection_type",
        "section": "intersection_type",
        "text": "Get intersection type between actual primitive and another primitive or polygon data.\nIntersection type:\n0 - objects do not intersect,\n1 - this object fully inside other (no common contour points),\n2 - other object fully inside this,\n3 - common contour points,\n4 - undefined intersection.\nintersection_type\nPolygon\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.intersection_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.intersection_type.html#pyedb.grpc.database.primitive.polygon.Polygon.intersection_type",
        "title": "intersection_type > intersection_type > intersection_type",
        "section": "intersection_type > intersection_type",
        "text": "Polygon.intersection_type(primitive)\n\nGet intersection type between actual primitive and another primitive or polygon data.\n\nParameters\n\nprimitive\n\nPolygon or PolygonData\n\n\n\nReturns\n\npython:int\n\nIntersection type:\n0 - objects do not intersect,\n1 - this object fully inside other (no common contour points),\n2 - other object fully inside this,\n3 - common contour points,\n4 - undefined intersection.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.convert_to_3d_microvias",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.convert_to_3d_microvias.html#convert_to_3d_microvias",
        "title": "convert_to_3d_microvias",
        "section": "convert_to_3d_microvias",
        "text": "Convert actual padstack instance to microvias 3D Objects with a given aspect ratio.\nEither to convert only vias belonging to signal nets or all vias. Defaults is True.\nAngle of laser penetration in degrees. The angle defines the lowest hole diameter with this formula:\nHoleDiameter -2*tan(laser_angle* Hole depth). Hole depth is the height of the via (dielectric thickness).\nThe default is 15.\nThe lowest hole is 0.75*HoleDepth/HoleDiam.\nWhether to delete the padstack definition. The default is True.\nIf False, the padstack definition is not deleted and the hole size is set to zero.\nconvert_to_3d_microvias\noptional\nTrue\npython:float\noptional\n15\n0.75*HoleDepth/HoleDiam\noptional\nTrue\nFalse\nTrue\nwhen\nsuccessful\nFalse\nwhen"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.convert_to_3d_microvias",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.convert_to_3d_microvias.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.convert_to_3d_microvias",
        "title": "convert_to_3d_microvias > convert_to_3d_microvias > convert_to_3d_microvias",
        "section": "convert_to_3d_microvias > convert_to_3d_microvias",
        "text": "EDBPadstack.convert_to_3d_microvias(convert_only_signal_vias=True, hole_wall_angle=75, delete_padstack_def=True)\n\nConvert actual padstack instance to microvias 3D Objects with a given aspect ratio.\n\nParameters\n\nconvert_only_signal_vias\n\nbool, optional\n\nEither to convert only vias belonging to signal nets or all vias. Defaults is True.\n\nhole_wall_angle\n\npython:float, optional\n\nAngle of laser penetration in degrees. The angle defines the lowest hole diameter with this formula:\nHoleDiameter -2*tan(laser_angle* Hole depth). Hole depth is the height of the via (dielectric thickness).\nThe default is 15.\nThe lowest hole is 0.75*HoleDepth/HoleDiam.\n\ndelete_padstack_def\n\nbool, optional\n\nWhether to delete the padstack definition. The default is True.\nIf False, the padstack definition is not deleted and the hole size is set to zero.\n\nReturns\n\nTrue when successful, False when failed.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_simulation_settings",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_simulation_settings.html#set_simulation_settings",
        "title": "set_simulation_settings",
        "section": "set_simulation_settings",
        "text": "set_simulation_settings"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_simulation_settings",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_simulation_settings.html#pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_simulation_settings",
        "title": "set_simulation_settings > set_simulation_settings > set_simulation_settings",
        "section": "set_simulation_settings > set_simulation_settings",
        "text": "HfssSimulationSetup.set_simulation_settings(sim_settings: dict)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.HfssSolverSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.HfssSolverSettings.html#hfsssolversettings",
        "title": "HfssSolverSettings",
        "section": "HfssSolverSettings",
        "text": "Manages EDB methods for HFSS solver settings.\nHfssSolverSettings"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.HfssSolverSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.HfssSolverSettings.html#pyedb.dotnet.database.sim_setup_data.data.settings.HfssSolverSettings",
        "title": "HfssSolverSettings > HfssSolverSettings > HfssSolverSettings",
        "section": "HfssSolverSettings > HfssSolverSettings",
        "text": "class pyedb.dotnet.database.sim_setup_data.data.settings.HfssSolverSettings(sim_setup)\n\nManages EDB methods for HFSS solver settings.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.name.html#name",
        "title": "name",
        "section": "name",
        "text": "name"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.name.html#pyedb.workflows.drc.drc.CopperBalance.name",
        "title": "name > name > name",
        "section": "name > name",
        "text": "CopperBalance.name: str\n\n"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_raptorx_setup",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_raptorx_setup.html#create_raptorx_setup",
        "title": "create_raptorx_setup",
        "section": "create_raptorx_setup",
        "text": "Create RaptorX analysis setup (2024R2+ only).\nSetup name. Auto-generated if None.\nRaptorX setup or False if unsupported.\ncreate_raptorx_setup\npython:str\noptional\nRaptorXSimulationSetup"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_raptorx_setup",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_raptorx_setup.html#pyedb.grpc.edb.Edb.create_raptorx_setup",
        "title": "create_raptorx_setup > create_raptorx_setup > create_raptorx_setup",
        "section": "create_raptorx_setup > create_raptorx_setup",
        "text": "Edb.create_raptorx_setup(name=None) -> RaptorXSimulationSetup\n\nCreate RaptorX analysis setup (2024R2+ only).\n\nParameters\n\nname\n\npython:str, optional\n\nSetup name. Auto-generated if None.\n\nReturns\n\nRaptorXSimulationSetup\n\nRaptorX setup or False if unsupported.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_voltage_probe",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_voltage_probe.html#create_voltage_probe",
        "title": "create_voltage_probe",
        "section": "create_voltage_probe",
        "text": "Create a voltage probe.\nUse create_voltage_probe() has been moved to edb.source_excitation.create_voltage_probe.\ncreate_voltage_probe\ncreate_voltage_probe()"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_voltage_probe",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_voltage_probe.html#pyedb.grpc.edb.Edb.create_voltage_probe",
        "title": "create_voltage_probe > create_voltage_probe > create_voltage_probe",
        "section": "create_voltage_probe > create_voltage_probe",
        "text": "Edb.create_voltage_probe(terminal, ref_terminal)\n\nCreate a voltage probe.\n\n..deprecated:: 0.50.0\n\nUse create_voltage_probe() has been moved to edb.source_excitation.create_voltage_probe.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.convert_to_polygon",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.convert_to_polygon.html#convert_to_polygon",
        "title": "convert_to_polygon",
        "section": "convert_to_polygon",
        "text": "Convert path to polygon.\nPolygon when successful, False when failed.\nconvert_to_polygon\nPolygon\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.convert_to_polygon",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.convert_to_polygon.html#pyedb.grpc.database.primitive.polygon.Polygon.convert_to_polygon",
        "title": "convert_to_polygon > convert_to_polygon > convert_to_polygon",
        "section": "convert_to_polygon > convert_to_polygon",
        "text": "Polygon.convert_to_polygon()\n\nConvert path to polygon.\n\nReturns\n\nPolygon\n\nPolygon when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_settings_options.HFSSSettingsOptions",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_settings_options.HFSSSettingsOptions.html#hfsssettingsoptions",
        "title": "HFSSSettingsOptions",
        "section": "HFSSSettingsOptions",
        "text": "PyEDB-core HFSS settings options class.\nHFSSSettingsOptions"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_settings_options.HFSSSettingsOptions",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_settings_options.HFSSSettingsOptions.html#pyedb.grpc.database.simulation_setup.hfss_settings_options.HFSSSettingsOptions",
        "title": "HFSSSettingsOptions > HFSSSettingsOptions > HFSSSettingsOptions",
        "section": "HFSSSettingsOptions > HFSSSettingsOptions",
        "text": "class pyedb.grpc.database.simulation_setup.hfss_settings_options.HFSSSettingsOptions(_pedb, edb_object)\n\nPyEDB-core HFSS settings options class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.set_product_property.html#pyedb.grpc.database.primitive.circle.Circle.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "Circle.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.specific_heat",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.specific_heat.html#specific_heat",
        "title": "specific_heat",
        "section": "specific_heat",
        "text": "specific_heat"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.specific_heat",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.specific_heat.html#pyedb.grpc.database.definition.materials.MaterialProperties.specific_heat",
        "title": "specific_heat > specific_heat > specific_heat",
        "section": "specific_heat > specific_heat",
        "text": "MaterialProperties.specific_heat: Annotated[float, Gt(gt=0)] | None\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.set_frequencies_linear_count",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.set_frequencies_linear_count.html#set_frequencies_linear_count",
        "title": "set_frequencies_linear_count",
        "section": "set_frequencies_linear_count",
        "text": "Set a linear count frequency sweep.\nStart frequency. The default is \"1kHz\".\nStop frequency. The default is \"0.1GHz\".\nStep frequency. The default is 10.\nTrue if correctly executed, False otherwise.\nset_frequencies_linear_count\npython:str\npython:float\noptional\n\"1kHz\"\npython:str\npython:float\noptional\n\"0.1GHz\"\npython:int\noptional\n10\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.set_frequencies_linear_count",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.set_frequencies_linear_count.html#pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.set_frequencies_linear_count",
        "title": "set_frequencies_linear_count > set_frequencies_linear_count > set_frequencies_linear_count",
        "section": "set_frequencies_linear_count > set_frequencies_linear_count",
        "text": "SweepData.set_frequencies_linear_count(start='1kHz', stop='0.1GHz', count=10)\n\nSet a linear count frequency sweep.\n\nParameters\n\nstart\n\npython:str, python:float, optional\n\nStart frequency. The default is \"1kHz\".\n\nstop\n\npython:str, python:float, optional\n\nStop frequency. The default is \"0.1GHz\".\n\ncount\n\npython:int, optional\n\nStep frequency. The default is 10.\n\nReturns\n\nbool\n\nTrue if correctly executed, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.html#stackup",
        "title": "Stackup",
        "section": "Stackup",
        "text": "Manages EDB methods for stackup accessible from Edb.stackup property.\nStackup.add_document_layer(name[, layer_type])\nAdd a document layer.\nStackup.add_layer(layer_name[, base_layer, ...])\nInsert a layer into stackup.\nStackup.add_layer_above(name, base_layer_name)\nAdd a layer above a layer.\nStackup.add_layer_below(name, base_layer_name)\nAdd a layer below a layer.\nStackup.add_layer_bottom(name[, layer_type])\nAdd a layer on bottom of the stackup.\nStackup.add_layer_top(name[, layer_type])\nAdd a layer on top of the stackup.\nStackup.add_outline_layer([outline_name])\nAdd an outline layer named \"Outline\" if it is not present.\nStackup.adjust_solder_dielectrics()\nAdjust the stack-up by adding or modifying dielectric layers that contains Solder Balls.\nStackup.create_symmetric_stackup(layer_count)\nCreate a symmetric stackup.\nStackup.export(fpath[, file_format, ...])\nExport stackup definition to a CSV or JSON file.\nStackup.find_layer_by_name(name)\nFinds a layer with the given name.\nStackup.flip_design()\nFlip the current design of a layout.\nStackup.get_layout_thickness()\nReturn the layout thickness.\nStackup.limits([only_metals])\nRetrieve stackup limits.\nStackup.load(file_path[, rename])\nImport stackup from a file.\nStackup.load_from_xml(file_path)\nLoad stackup from a XML file.\nStackup.place_a3dcomp_3d_placement(a3dcomp_path)\nPlace a 3D Component into current layout.\nStackup.place_in_layout(edb[, angle, ...])\nPlace current Cell into another cell using layer placement method.\nStackup.place_in_layout_3d_placement(edb[, ...])\nPlace current Cell into another cell using 3d placement method.\nStackup.place_instance(component_edb[, ...])\nPlace current Cell into another cell using 3d placement method.\nStackup.plot([save_plot, size, ...])\nPlot current stackup and, optionally, overlap padstack definitions.\nStackup.refresh_layer_collection()\nRefresh layer collection from Edb.\nStackup.remove_layer(name)\nRemove a layer from stackup.\nStackup.residual_copper_area_per_layer()\nReport residual copper area per layer in percentage.\nStackup.set_layer_clone(layer_clone)\n\nStackup.update_layout()\nSet layer collection into edb.\nStackup\nStackup.add_document_layer\nStackup.add_layer\nStackup.add_layer_above\nStackup.add_layer_below\nStackup.add_layer_bottom\nStackup.add_layer_top\nStackup.add_outline_layer\n\"Outline\"\nStackup.adjust_solder_dielectrics\nStackup.create_symmetric_stackup\nStackup.export\nStackup.find_layer_by_name\nStackup.flip_design\nStackup.get_layout_thickness\nStackup.limits\nStackup.load\nStackup.load_from_xml\nStackup.place_a3dcomp_3d_placement\nStackup.place_in_layout\nStackup.place_in_layout_3d_placement\nStackup.place_instance\nStackup.plot\nStackup.refresh_layer_collection\nStackup.remove_layer\nStackup.residual_copper_area_per_layer\nStackup.set_layer_clone\nStackup.update_layout"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.html#pyedb.dotnet.database.stackup.Stackup",
        "title": "Stackup > Stackup > Stackup",
        "section": "Stackup > Stackup",
        "text": "class pyedb.dotnet.database.stackup.Stackup(pedb, edb_object=None)\n\nManages EDB methods for stackup accessible from Edb.stackup property.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nStackup.add_document_layer(name[, layer_type])\n\nAdd a document layer.\n\nStackup.add_layer(layer_name[, base_layer, ...])\n\nInsert a layer into stackup.\n\nStackup.add_layer_above(name, base_layer_name)\n\nAdd a layer above a layer.\n\nStackup.add_layer_below(name, base_layer_name)\n\nAdd a layer below a layer.\n\nStackup.add_layer_bottom(name[, layer_type])\n\nAdd a layer on bottom of the stackup.\n\nStackup.add_layer_top(name[, layer_type])\n\nAdd a layer on top of the stackup.\n\nStackup.add_outline_layer([outline_name])\n\nAdd an outline layer named \"Outline\" if it is not present.\n\nStackup.adjust_solder_dielectrics()\n\nAdjust the stack-up by adding or modifying dielectric layers that contains Solder Balls.\n\nStackup.create_symmetric_stackup(layer_count)\n\nCreate a symmetric stackup.\n\nStackup.export(fpath[, file_format, ...])\n\nExport stackup definition to a CSV or JSON file.\n\nStackup.find_layer_by_name(name)\n\nFinds a layer with the given name.\n\nStackup.flip_design()\n\nFlip the current design of a layout.\n\nStackup.get_layout_thickness()\n\nReturn the layout thickness.\n\nStackup.limits([only_metals])\n\nRetrieve stackup limits.\n\nStackup.load(file_path[, rename])\n\nImport stackup from a file.\n\nStackup.load_from_xml(file_path)\n\nLoad stackup from a XML file.\n\nStackup.place_a3dcomp_3d_placement(a3dcomp_path)\n\nPlace a 3D Component into current layout.\n\nStackup.place_in_layout(edb[, angle, ...])\n\nPlace current Cell into another cell using layer placement method.\n\nStackup.place_in_layout_3d_placement(edb[, ...])\n\nPlace current Cell into another cell using 3d placement method.\n\nStackup.place_instance(component_edb[, ...])\n\nPlace current Cell into another cell using 3d placement method.\n\nStackup.plot([save_plot, size, ...])\n\nPlot current stackup and, optionally, overlap padstack definitions.\n\nStackup.refresh_layer_collection()\n\nRefresh layer collection from Edb.\n\nStackup.remove_layer(name)\n\nRemove a layer from stackup.\n\nStackup.residual_copper_area_per_layer()\n\nReport residual copper area per layer in percentage.\n\nStackup.set_layer_clone(layer_clone)\n\n\n\nStackup.update_layout()\n\nSet layer collection into edb.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.spice_model.SpiceModel",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.spice_model.SpiceModel.html#spicemodel",
        "title": "SpiceModel",
        "section": "SpiceModel",
        "text": "Manage SpiceModel\nSpiceModel.add_terminal(terminal, pin)\nAdd a terminal with a pin number.\nSpiceModel.clone()\nClone a model.\nSpiceModel.create(name, path, sub_circuit)\nCreate a SPICE model.\nSpiceModel.remove_terminal(terminal)\nRemove a terminal.\nSpiceModel\nSpiceModel\nSpiceModel.add_terminal\nSpiceModel.clone\nSpiceModel.create\nSpiceModel.remove_terminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.spice_model.SpiceModel",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.spice_model.SpiceModel.html#pyedb.grpc.database.hierarchy.spice_model.SpiceModel",
        "title": "SpiceModel > SpiceModel > SpiceModel",
        "section": "SpiceModel > SpiceModel",
        "text": "class pyedb.grpc.database.hierarchy.spice_model.SpiceModel(edb_object=None, name=None, file_path=None, sub_circuit=None)\n\nManage SpiceModel\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nSpiceModel.add_terminal(terminal, pin)\n\nAdd a terminal with a pin number.\n\nSpiceModel.clone()\n\nClone a model.\n\nSpiceModel.create(name, path, sub_circuit)\n\nCreate a SPICE model.\n\nSpiceModel.remove_terminal(terminal)\n\nRemove a terminal.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the base SimulationSetup object to correct subclass, if possible.\ncast\nSimulationSetup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.cast.html#pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "HfssSimulationSetup.cast()\n\nCast the base SimulationSetup object to correct subclass, if possible.\n\nReturns\n\nSimulationSetup\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.delete",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete this primitive.\ndelete"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.delete",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.delete.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "EdbPolygon.delete()\n\nDelete this primitive.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_dump",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#python-mode)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude: A set of fields to include in the output.\nexclude: A set of fields to exclude from the output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\nA dictionary representation of the model.\nmodel_dump"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_dump",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_dump.html#pyedb.workflows.drc.drc.MinLineWidth.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "MinLineWidth.model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -> dict[str, Any]\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#python-mode)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n\nmode: The mode in which to_python should run.\n\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude: A set of fields to include in the output.\nexclude: A set of fields to exclude from the output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\n\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\n\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback: A function to call when an unknown value is encountered. If not provided,\n\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.cutout",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.cutout.html#cutout",
        "title": "cutout",
        "section": "cutout",
        "text": "Create a cutout using an approach entirely based on PyAEDT.\nThis method replaces all legacy cutout methods in PyAEDT.\nIt does in sequence:\n- delete all nets not in list,\n- create a extent of the nets,\n- check and delete all vias not in the extent,\n- check and delete all the primitives not in extent,\n- check and intersect all the primitives that intersect the extent.\nList of signal strings.\nList of references to add. The default is [\"GND\"].\nType of the extension. Options are \"Conforming\", \"ConvexHull\", and\n\"Bounding\". The default is \"Conforming\".\nExpansion size ratio in meters. The default is 0.002.\nWhether to use round corners. The default is False.\nFull path and name for the new AEDB file. If None, then current aedb will be cutout.\nWhether to open the cutout at the end. The default is True.\nWhether to use new PyAEDT cutout method or EDB API method.\nNew method is faster than native API method since it benefits of multithread.\nNumber of thread to use. Default is 4. Valid only if use_pyaedt_cutout is set to True.\nWhether to use legacy extent computing (experimental) or EDB API.\nDefeature the cutout before applying it to produce simpler geometry for mesh (Experimental).\nIt applies only to Conforming bounding box. Default value is 0 which disable it.\nRemove all Single Pin RLC after the cutout is completed. Default is False.\nPoints list defining the cutout shape. This setting will override extent_type field.\nUnits of the point list. The default is \"mm\". Valid only if custom_extend is provided.\nWhether to include padstack instances that have bounding boxes intersecting with point list polygons.\nThis operation may slow down the cutout export.Valid only if custom_extend and\nuse_pyaedt_cutout is provided.\nBoolean used for keep or not the voids intersecting the polygon used for clipping the layout.\nDefault value is True, False will remove the voids.Valid only if custom_extend is provided.\nWhether to check for all reference terminals and increase extent to include them into the cutout.\nThis applies to components which have a model (spice, touchstone or netlist) associated.\nWhether to check for all pingroups terminals and increase extent to include them into the cutout.\nIt requires check_terminals.\nThe method computes a float representing the largest number between\nthe dielectric thickness or trace width multiplied by the expansion_factor factor.\nThe trace width search is limited to nets with ports attached. Works only if use_pyaedt_cutout.\nDefault is 0 to disable the search.\nMaximum number of iterations before stopping a search for a cutout with an error.\nDefault is 10.\nWhether to preserve all pins of components that have associated models (Spice or NPort).\nThis parameter is applicable only for a PyAEDT cutout (except point list).\nWhether to use the center of the pad to find the intersection with extent or use the bounding box.\nSecond method is much slower and requires to disable multithread on padstack removal.\nDefault is True.\nWhether to keep the lines as Path after they are cutout or convert them to PolygonData.\nThis feature works only in Electronics Desktop (3D Layout).\nIf the flag is set to True it can cause issues in SiWave once the Edb is imported.\nDefault is False to generate PolygonData of cut lines.\nWhether to compute and include voids in pyaedt extent before the cutout. Cutout time can be affected.\nIt works only with Conforming cutout.\nDefault is False to generate extent without voids.\nList of coordinate points defining the extent used for clipping the design. If it failed return an empty\nlist.\ncutout\npython:list\npython:list\noptional\n[\"GND\"]\npython:str\noptional\n\"Conforming\"\n\"ConvexHull\"\n\"Bounding\"\n\"Conforming\"\npython:float\npython:str\noptional\n0.002\noptional\nFalse\npython:str\noptional\noptional\nTrue\noptional\npython:int\noptional\nuse_pyaedt_cutout\nTrue\noptional\npython:float\noptional\n0\noptional\npython:list\npython:str\n\"mm\"\noptional\nTrue\nFalse\noptional\noptional\ncheck_terminals\npython:int\noptional\npython:int\noptional\noptional\noptional\noptional\nTrue\nFalse\noptional\nFalse\nList"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.cutout",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.cutout.html#pyedb.dotnet.edb.Edb.cutout",
        "title": "cutout > cutout > cutout",
        "section": "cutout > cutout",
        "text": "Edb.cutout(signal_nets=None, reference_nets=None, extent_type='ConvexHull', expansion_size=0.002, use_round_corner=False, output_aedb_path=None, open_cutout_at_end=True, use_pyaedt_cutout=True, number_of_threads=1, use_pyaedt_extent_computing=True, extent_defeature=0, remove_single_pin_components=False, custom_extent=None, custom_extent_units='mm', include_partial_instances=False, keep_voids=True, check_terminals=False, include_pingroups=False, expansion_factor=0, maximum_iterations=10, preserve_components_with_model=False, simple_pad_check=True, keep_lines_as_path=False, include_voids_in_extents=False)\n\nCreate a cutout using an approach entirely based on PyAEDT.\nThis method replaces all legacy cutout methods in PyAEDT.\nIt does in sequence:\n- delete all nets not in list,\n- create a extent of the nets,\n- check and delete all vias not in the extent,\n- check and delete all the primitives not in extent,\n- check and intersect all the primitives that intersect the extent.\n\nParameters\n\nsignal_nets\n\npython:list\n\nList of signal strings.\n\nreference_nets\n\npython:list, optional\n\nList of references to add. The default is [\"GND\"].\n\nextent_type\n\npython:str, optional\n\nType of the extension. Options are \"Conforming\", \"ConvexHull\", and\n\"Bounding\". The default is \"Conforming\".\n\nexpansion_size\n\npython:float, python:str, optional\n\nExpansion size ratio in meters. The default is 0.002.\n\nuse_round_corner\n\nbool, optional\n\nWhether to use round corners. The default is False.\n\noutput_aedb_path\n\npython:str, optional\n\nFull path and name for the new AEDB file. If None, then current aedb will be cutout.\n\nopen_cutout_at_end\n\nbool, optional\n\nWhether to open the cutout at the end. The default is True.\n\nuse_pyaedt_cutout\n\nbool, optional\n\nWhether to use new PyAEDT cutout method or EDB API method.\nNew method is faster than native API method since it benefits of multithread.\n\nnumber_of_threads\n\npython:int, optional\n\nNumber of thread to use. Default is 4. Valid only if use_pyaedt_cutout is set to True.\n\nuse_pyaedt_extent_computing\n\nbool, optional\n\nWhether to use legacy extent computing (experimental) or EDB API.\n\nextent_defeature\n\npython:float, optional\n\nDefeature the cutout before applying it to produce simpler geometry for mesh (Experimental).\nIt applies only to Conforming bounding box. Default value is 0 which disable it.\n\nremove_single_pin_components\n\nbool, optional\n\nRemove all Single Pin RLC after the cutout is completed. Default is False.\n\ncustom_extent\n\npython:list\n\nPoints list defining the cutout shape. This setting will override extent_type field.\n\ncustom_extent_units\n\npython:str\n\nUnits of the point list. The default is \"mm\". Valid only if custom_extend is provided.\n\ninclude_partial_instances\n\nbool, optional\n\nWhether to include padstack instances that have bounding boxes intersecting with point list polygons.\nThis operation may slow down the cutout export.Valid only if custom_extend and\nuse_pyaedt_cutout is provided.\n\nkeep_voids\n\nbool\n\nBoolean used for keep or not the voids intersecting the polygon used for clipping the layout.\nDefault value is True, False will remove the voids.Valid only if custom_extend is provided.\n\ncheck_terminals\n\nbool, optional\n\nWhether to check for all reference terminals and increase extent to include them into the cutout.\nThis applies to components which have a model (spice, touchstone or netlist) associated.\n\ninclude_pingroups\n\nbool, optional\n\nWhether to check for all pingroups terminals and increase extent to include them into the cutout.\nIt requires check_terminals.\n\nexpansion_factor\n\npython:int, optional\n\nThe method computes a float representing the largest number between\nthe dielectric thickness or trace width multiplied by the expansion_factor factor.\nThe trace width search is limited to nets with ports attached. Works only if use_pyaedt_cutout.\nDefault is 0 to disable the search.\n\nmaximum_iterations\n\npython:int, optional\n\nMaximum number of iterations before stopping a search for a cutout with an error.\nDefault is 10.\n\npreserve_components_with_model\n\nbool, optional\n\nWhether to preserve all pins of components that have associated models (Spice or NPort).\nThis parameter is applicable only for a PyAEDT cutout (except point list).\n\nsimple_pad_check\n\nbool, optional\n\nWhether to use the center of the pad to find the intersection with extent or use the bounding box.\nSecond method is much slower and requires to disable multithread on padstack removal.\nDefault is True.\n\nkeep_lines_as_path\n\nbool, optional\n\nWhether to keep the lines as Path after they are cutout or convert them to PolygonData.\nThis feature works only in Electronics Desktop (3D Layout).\nIf the flag is set to True it can cause issues in SiWave once the Edb is imported.\nDefault is False to generate PolygonData of cut lines.\n\ninclude_voids_in_extents\n\nbool, optional\n\nWhether to compute and include voids in pyaedt extent before the cutout. Cutout time can be affected.\nIt works only with Conforming cutout.\nDefault is False to generate extent without voids.\n\nReturns\n\nList\n\nList of coordinate points defining the extent used for clipping the design. If it failed return an empty\nlist.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb(r\"C:\\test.aedb\", version=\"2022.2\")\n>>> edb.logger.info_timer(\"Edb Opening\")\n>>> edb.logger.reset_timer()\n>>> start = time.time()\n>>> signal_list = []\n>>> for net in edb.nets.netlist:\n>>>      if \"3V3\" in net:\n>>>           signal_list.append(net)\n>>> power_list = [\"PGND\"]\n>>> edb.cutout(signal_nets=signal_list, reference_nets=power_list, extent_type=\"Conforming\")\n>>> end_time = str((time.time() - start) / 60)\n>>> edb.logger.info(\"Total legacy cutout time in min %s\", end_time)\n>>> edb.nets.plot(signal_list, None, color_by_net=True)\n>>> edb.nets.plot(power_list, None, color_by_net=True)\n>>> edb.save()\n>>> edb.close()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/index",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/index.html#simulation-setup-classes",
        "title": "Simulation setup classes",
        "section": "Simulation setup classes",
        "text": "This section describes EDB simulation setup classes.\nSimulation setup classes"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.snap_primitives",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.snap_primitives.html#snap_primitives",
        "title": "snap_primitives",
        "section": "snap_primitives",
        "text": "Snap primitives on the specified layer to touching geometry.\nLayers containing the primitives to be snapped.\nTolerance for snapping primitives.\nIf True, the connectivity of primitives is checked and enforced to prevent\nshort circuits in geometry connecting to the primitives. If false, primitives are\nsnapped regardless of the connectivity of touching geometry.\nsnap_primitives\npython:str\npython:list\nof\npython:str\nLayer\npython:list\nof\nLayer\nTrue"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.snap_primitives",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.snap_primitives.html#pyedb.grpc.database.layout.layout.Layout.snap_primitives",
        "title": "snap_primitives > snap_primitives > snap_primitives",
        "section": "snap_primitives > snap_primitives",
        "text": "Layout.snap_primitives(layer: LayerListLike, tol: ValueLike = '0.05um', check_connectivity: bool = True)\n\nSnap primitives on the specified layer to touching geometry.\n\nParameters\n\nlayer\n\npython:str or python:list of python:str or Layer or python:list of Layer\n\nLayers containing the primitives to be snapped.\n\ntol\n\nValueLike\n\nTolerance for snapping primitives.\n\ncheck_connectivity\n\nbool\n\nIf True, the connectivity of primitives is checked and enforced to prevent\nshort circuits in geometry connecting to the primitives. If false, primitives are\nsnapped regardless of the connectivity of touching geometry.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.area",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.area.html#area",
        "title": "area",
        "section": "area",
        "text": "Return the total area.\nEither if the voids have to be included in computation.\nThe default value is True.\narea\noptional\nTrue\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.area",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.area.html#pyedb.grpc.database.primitive.path.Path.area",
        "title": "area > area > area",
        "section": "area > area",
        "text": "Path.area(include_voids=True) -> float\n\nReturn the total area.\n\nParameters\n\ninclude_voids\n\nbool, optional\n\nEither if the voids have to be included in computation.\nThe default value is True.\n\nReturns\n\npython:float\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/common",
        "href": "libraries/common.html#rf-basic-libraries",
        "title": "RF Basic Libraries",
        "section": "RF Basic Libraries",
        "text": "These class is the containers of RF basic libraries.\nSubstrate\nSmall helper that groups the four basic substrate parameters used throughout the library.\nMaterial\nGeneric material definition.\nConductor\nMetallic conductor material with electrical conductivity.\nDielectric\nDielectric material with relative permittivity and loss tangent.\nLayer\nPhysical layer inside a stackup.\nMetalLayer\nConvenience wrapper for metallic layers.\nDielectricLayer\nConvenience wrapper for dielectric layers.\nMicroStripTechnologyStackup\nPre-defined micro-strip stackup with bottom metal, substrate and top metal.\nRF Basic Libraries\nSubstrate\nMaterial\nConductor\nDielectric\nLayer\nMetalLayer\nDielectricLayer\nMicroStripTechnologyStackup"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_dump_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#json-mode)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent: Indentation to use in the JSON output. If None is passed, the output will be compact.\nensure_ascii: If True, the output is guaranteed to have all incoming non-ASCII characters escaped.\nIf False (the default), these characters will be output as-is.\ninclude: Field(s) to include in the JSON output.\nexclude: Field(s) to exclude from the JSON output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to serialize using field aliases.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\nA JSON string representation of the model.\nmodel_dump_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_dump_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_dump_json.html#pyedb.workflows.drc.drc.MinClearance.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "MinClearance.model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -> str\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#json-mode)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nArgs:\n\nindent: Indentation to use in the JSON output. If None is passed, the output will be compact.\nensure_ascii: If True, the output is guaranteed to have all incoming non-ASCII characters escaped.\n\nIf False (the default), these characters will be output as-is.\n\ninclude: Field(s) to include in the JSON output.\nexclude: Field(s) to exclude from the JSON output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to serialize using field aliases.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\n\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\n\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback: A function to call when an unknown value is encountered. If not provided,\n\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.find_by_id.html#find_by_id",
        "title": "find_by_id",
        "section": "find_by_id",
        "text": "Find a Connectable object by database ID in a given layout.\nLayout to search for the Connectable object.\nDatabase ID.\nConnectable object with the given database ID.\nfind_by_id\nLayout\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.find_by_id.html#pyedb.grpc.database.terminal.terminal.Terminal.find_by_id",
        "title": "find_by_id > find_by_id > find_by_id",
        "section": "find_by_id > find_by_id",
        "text": "classmethod Terminal.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the Connectable object.\n\nuid\n\npython:int\n\nDatabase ID.\n\nReturns\n\nConnectable\n\nConnectable object with the given database ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_config",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_config",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_config.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "DiffPairLengthMatch.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSetup.add_sweep",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSetup.add_sweep.html#add_sweep",
        "title": "add_sweep",
        "section": "add_sweep",
        "text": "Add a new sweep.\nSweep name.\nFrequency start.\nFrequency stop.\nFrequency step or count.\nSweep type. It can be “Discrete” or  “Interpolating”.\nSweep type. It can be “LinearStep”, “DecadeCount” or  “LinearCount”.\nadd_sweep\npython:str\npython:str\npython:str\npython:str\npython:str\npython:str\npyedb.dotnet.database.edb_data.control_file.ControlFileSweep"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSetup.add_sweep",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSetup.add_sweep.html#pyedb.grpc.database.utility.xml_control_file.ControlFileSetup.add_sweep",
        "title": "add_sweep > add_sweep > add_sweep",
        "section": "add_sweep > add_sweep",
        "text": "ControlFileSetup.add_sweep(name, start, stop, step, sweep_type='Interpolating', step_type='LinearStep', use_q3d=True)\n\nAdd a new sweep.\n\nParameters\n\nname\n\npython:str\n\nSweep name.\n\nstart\n\npython:str\n\nFrequency start.\n\nstop\n\npython:str\n\nFrequency stop.\n\nstep\n\npython:str\n\nFrequency step or count.\n\nsweep_type\n\npython:str\n\nSweep type. It can be “Discrete” or  “Interpolating”.\n\nstep_type\n\npython:str\n\nSweep type. It can be “LinearStep”, “DecadeCount” or  “LinearCount”.\n\nuse_q3d\n\n\n\nReturns\n\npyedb.dotnet.database.edb_data.control_file.ControlFileSweep\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.Conductor",
        "href": "libraries/_autosummary/pyedb.libraries.common.Conductor.html#conductor",
        "title": "Conductor",
        "section": "Conductor",
        "text": "Metallic conductor material with electrical conductivity.\nActive EDB session.\nMaterial name.\nElectrical conductivity in S/m.  Default is 5.8e7 (Copper).\nConductor\nansys.edb.core.database.Database\npython:str\npython:float\noptional"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.Conductor",
        "href": "libraries/_autosummary/pyedb.libraries.common.Conductor.html#pyedb.libraries.common.Conductor",
        "title": "Conductor > Conductor > Conductor",
        "section": "Conductor > Conductor",
        "text": "class pyedb.libraries.common.Conductor(pedb, name: str, conductivity: float = 58000000.0)\n\nMetallic conductor material with electrical conductivity.\n\nParameters\n\npedb\n\nansys.edb.core.database.Database\n\nActive EDB session.\n\nname\n\npython:str\n\nMaterial name.\n\nconductivity\n\npython:float, optional\n\nElectrical conductivity in S/m.  Default is 5.8e7 (Copper).\n\nExamples\n\n>>> cu = Conductor(edb, \"Copper\", conductivity=5.8e7)\n>>> cu.conductivity\n58000000.0\n>>> cu.conductivity = 3.5e7  # update on-the-fly\n>>> edb.materials[\"Copper\"].conductivity\n35000000.0\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_pad_edge_terminal_reference_pin",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_pad_edge_terminal_reference_pin.html#get_pad_edge_terminal_reference_pin",
        "title": "get_pad_edge_terminal_reference_pin",
        "section": "get_pad_edge_terminal_reference_pin",
        "text": "Get the closest pin padstack instances and serves any edge terminal connected to a pad.\nPreferred reference net name. Optianal, default is None which will auto compute the gnd name.\nget_pad_edge_terminal_reference_pin\npython:str\noptional\npyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_pad_edge_terminal_reference_pin",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_pad_edge_terminal_reference_pin.html#pyedb.dotnet.database.edb_data.ports.GapPort.get_pad_edge_terminal_reference_pin",
        "title": "get_pad_edge_terminal_reference_pin > get_pad_edge_terminal_reference_pin > get_pad_edge_terminal_reference_pin",
        "section": "get_pad_edge_terminal_reference_pin > get_pad_edge_terminal_reference_pin",
        "text": "GapPort.get_pad_edge_terminal_reference_pin(gnd_net_name_preference=None)\n\nGet the closest pin padstack instances and serves any edge terminal connected to a pad.\n\nParameters\n\ngnd_net_name_preference\n\npython:str, optional\n\nPreferred reference net name. Optianal, default is None which will auto compute the gnd name.\n\nReturns\n\npyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kHFSSPI",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kHFSSPI.html#khfsspi",
        "title": "kHFSSPI",
        "section": "kHFSSPI",
        "text": "kHFSSPI"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kHFSSPI",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kHFSSPI.html#pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kHFSSPI",
        "title": "kHFSSPI > kHFSSPI > kHFSSPI",
        "section": "kHFSSPI > kHFSSPI",
        "text": "SimulationSetupType.kHFSSPI = 'hfss_pi'\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property for the given product ID and attribute ID.\nProduct ID.\nAttribute ID.\nNew value for the product property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.set_product_property.html#pyedb.grpc.database.definition.package_def.PackageDef.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "PackageDef.set_product_property(prod_id, attr_it, prop_value)\n\nSet the product property for the given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nProduct ID.\n\nattr_it\n\npython:int\n\nAttribute ID.\n\nprop_value\n\npython:str\n\nNew value for the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.get_product_property.html#pyedb.grpc.database.ports.ports.BundleWavePort.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "BundleWavePort.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.intersect",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.intersect.html#intersect",
        "title": "intersect",
        "section": "intersect",
        "text": "Compute the intersection of one or more lists of polygons.\nFirst list of polygons.\nSecond optional list of polygons.\nintersect\npython:list\nof\nPolygonData\nPolygonData\npython:list\nof\nPolygonData\nPolygonData\npython:list\nof\nPolygonData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.intersect",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.intersect.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.intersect",
        "title": "intersect > intersect > intersect",
        "section": "intersect > intersect",
        "text": "classmethod PolygonData.intersect(polygons1: list[PolygonData] | PolygonData, polygons2: list[PolygonData] | PolygonData) -> list[PolygonData]\n\nCompute the intersection of one or more lists of polygons.\n\nParameters\n\npolygons1\n\npython:list of PolygonData or PolygonData\n\nFirst list of polygons.\n\npolygons2\n\npython:list of PolygonData or PolygonData\n\nSecond optional list of polygons.\n\nReturns\n\npython:list of PolygonData\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.parametrize_position",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.parametrize_position.html#parametrize_position",
        "title": "parametrize_position",
        "section": "parametrize_position",
        "text": "Parametrize the instance position.\nPrefix for the variable name. Default is None.\nExample “MyVariableName” will create 2 Project variables $MyVariableNamesX and $MyVariableNamesY.\nList of variables created.\nparametrize_position\npython:str\noptional\nNone\nList"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.parametrize_position",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.parametrize_position.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.parametrize_position",
        "title": "parametrize_position > parametrize_position > parametrize_position",
        "section": "parametrize_position > parametrize_position",
        "text": "EDBPadstackInstance.parametrize_position(prefix=None)\n\nParametrize the instance position.\n\nParameters\n\nprefix\n\npython:str, optional\n\nPrefix for the variable name. Default is None.\nExample “MyVariableName” will create 2 Project variables $MyVariableNamesX and $MyVariableNamesY.\n\nReturns\n\nList\n\nList of variables created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kPEM",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kPEM.html#kpem",
        "title": "kPEM",
        "section": "kPEM",
        "text": "kPEM"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kPEM",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kPEM.html#pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kPEM",
        "title": "kPEM > kPEM > kPEM",
        "section": "kPEM > kPEM",
        "text": "SimulationSetupType.kPEM = None\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/layout",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/layout.html#layout",
        "title": "Layout",
        "section": "Layout",
        "text": "This class is managing EDB layout.\nLayout\nManage Layout class.\nLayout\nLayout"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the terminal object to the correct concrete type, fetching the type if necessary.\ncast\nTerminalType\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.cast.html#pyedb.grpc.database.ports.ports.GapPort.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "GapPort.cast(term_type=None)\n\nCast the terminal object to the correct concrete type, fetching the type if necessary.\n\nParameters\n\nterm_type\n\nTerminalType\n\n\n\nReturns\n\nTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/index",
        "href": "dotnet_api/dotnet/edb_data/index.html#edb-data-classes",
        "title": "EDB data classes",
        "section": "EDB data classes",
        "text": "This section describes EDB data classes.\nEDB data classes"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.export",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.export.html#export",
        "title": "export",
        "section": "export",
        "text": "Export stackup definition to a file.\nFile path to export to.\nFormat of the file to export. The default is \"xml\". Options are:\n- \"csv\"\n- \"xlsx\"\n- \"json\"\n- \"xml\"\nWhether to include the material definition inside layer objects. This parameter is only used\nwhen a JSON file is exported. The default is False.\nTrue when successful.\nexport\npython:str\npython:str\noptional\n\"xml\"\n\"csv\"\n\"xlsx\"\n\"json\"\n\"xml\"\noptional\nFalse\nTrue"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.export",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.export.html#pyedb.grpc.database.stackup.Stackup.export",
        "title": "export > export > export",
        "section": "export > export",
        "text": "Stackup.export(fpath: str, file_format: str = 'xml', include_material_with_layer: bool = False) -> bool\n\nExport stackup definition to a file.\n\nParameters\n\nfpath\n\npython:str\n\nFile path to export to.\n\nfile_format\n\npython:str, optional\n\nFormat of the file to export. The default is \"xml\". Options are:\n- \"csv\"\n- \"xlsx\"\n- \"json\"\n- \"xml\"\n\ninclude_material_with_layer\n\nbool, optional\n\nWhether to include the material definition inside layer objects. This parameter is only used\nwhen a JSON file is exported. The default is False.\n\nReturns\n\nbool\n\nTrue when successful.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> edb.stackup.export(\"stackup.xml\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_zone_name",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_zone_name.html#get_zone_name",
        "title": "get_zone_name",
        "section": "get_zone_name",
        "text": "Get the name for a given zone.\nZone ID.\nName of the zone.\nget_zone_name\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_zone_name",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_zone_name.html#pyedb.grpc.database.stackup.Stackup.get_zone_name",
        "title": "get_zone_name > get_zone_name > get_zone_name",
        "section": "get_zone_name > get_zone_name",
        "text": "Stackup.get_zone_name(zone)\n\nGet the name for a given zone.\n\nParameters\n\nzone\n\npython:int\n\nZone ID.\n\nReturns\n\npython:str\n\nName of the zone.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the ConnObj object to the correct concrete type.\ncast\nConnObj"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.cast.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "PadstackInstance.cast()\n\nCast the ConnObj object to the correct concrete type.\n\nReturns\n\nConnObj\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.set_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.set_hfss_prop.html#set_hfss_prop",
        "title": "set_hfss_prop",
        "section": "set_hfss_prop",
        "text": "Set HFSS properties.\nMaterial property name to set.\nWhether to solve inside.\nset_hfss_prop\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.set_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.set_hfss_prop.html#pyedb.grpc.database.primitive.path.Path.set_hfss_prop",
        "title": "set_hfss_prop > set_hfss_prop > set_hfss_prop",
        "section": "set_hfss_prop > set_hfss_prop",
        "text": "Path.set_hfss_prop(material: str, solve_inside: bool)\n\nSet HFSS properties.\n\nParameters\n\nmaterial\n\npython:str\n\nMaterial property name to set.\n\nsolve_inside\n\nbool\n\nWhether to solve inside.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_probe",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_probe.html#create_voltage_probe",
        "title": "create_voltage_probe",
        "section": "create_voltage_probe",
        "text": "Create a voltage probe.\nPadstackInstanceTerminal,\nPointTerminal,\nPinGroupTerminal,\nPositive terminal of the port.\npyedb.grpc.database.terminals.PadstackInstanceTerminal,\nPadstackInstanceTerminal,\nPinGroupTerminal,\nNegative terminal of the probe.\ncreate_voltage_probe\nEdgeTerminal\nPadstackInstanceTerminal\nPointTerminal\nPinGroupTerminal\nEdgeTerminal\npyedb.grpc.database.terminals.PadstackInstanceTerminal\nPadstackInstanceTerminal\nPinGroupTerminal\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_probe",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_probe.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_probe",
        "title": "create_voltage_probe > create_voltage_probe > create_voltage_probe",
        "section": "create_voltage_probe > create_voltage_probe",
        "text": "SourceExcitation.create_voltage_probe(terminal: Terminal, ref_terminal: Terminal) -> Terminal\n\nCreate a voltage probe.\n\nParameters\n\nterminal\n\nEdgeTerminal,\n\nPadstackInstanceTerminal,\nPointTerminal,\nPinGroupTerminal,\nPositive terminal of the port.\n\nref_terminal\n\nEdgeTerminal,\n\npyedb.grpc.database.terminals.PadstackInstanceTerminal,\nPadstackInstanceTerminal,\nPinGroupTerminal,\nNegative terminal of the probe.\n\nReturns\n\nTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_clip_info",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_clip_info.html#get_clip_info",
        "title": "get_clip_info",
        "section": "get_clip_info",
        "text": "Get the data used to clip the path.\nReturns a tuple in this format:\n(clipping_poly, keep_inside)\nclipping_poly : PolygonData used to clip the path.\nkeep_inside : Indicates whether the part of the path inside the polygon is preserved.\nget_clip_info\npython:tuple\nof\nPolygonData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_clip_info",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.get_clip_info.html#pyedb.grpc.database.primitive.path.Path.get_clip_info",
        "title": "get_clip_info > get_clip_info > get_clip_info",
        "section": "get_clip_info > get_clip_info",
        "text": "Path.get_clip_info() -> tuple[PolygonData, bool]\n\nGet the data used to clip the path.\n\nReturns\n\npython:tuple of (PolygonData, bool)\n\nReturns a tuple in this format:\n\n(clipping_poly, keep_inside)\n\nclipping_poly : PolygonData used to clip the path.\n\nkeep_inside : Indicates whether the part of the path inside the polygon is preserved.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.shape_to_polygon_data",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.shape_to_polygon_data.html#shape_to_polygon_data",
        "title": "shape_to_polygon_data",
        "section": "shape_to_polygon_data",
        "text": "Convert a shape to polygon data.\nType of the shape to convert. Options are \"rectangle\" and \"polygon\".\nshape_to_polygon_data\npyedb.dotnet.database.modeler.Modeler.Shape\n\"rectangle\"\n\"polygon\""
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.shape_to_polygon_data",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.shape_to_polygon_data.html#pyedb.dotnet.database.modeler.Modeler.shape_to_polygon_data",
        "title": "shape_to_polygon_data > shape_to_polygon_data > shape_to_polygon_data",
        "section": "shape_to_polygon_data > shape_to_polygon_data",
        "text": "Modeler.shape_to_polygon_data(shape)\n\nConvert a shape to polygon data.\n\nParameters\n\nshape\n\npyedb.dotnet.database.modeler.Modeler.Shape\n\nType of the shape to convert. Options are \"rectangle\" and \"polygon\".\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSettings",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSettings.html#raptorxsimulationsettings",
        "title": "RaptorXSimulationSettings",
        "section": "RaptorXSimulationSettings",
        "text": "RaptorXSimulationSettings"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSettings",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSettings.html#pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSettings",
        "title": "RaptorXSimulationSettings > RaptorXSimulationSettings > RaptorXSimulationSettings",
        "section": "RaptorXSimulationSettings > RaptorXSimulationSettings",
        "text": "class pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSettings(edb_setup_info, pedb)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.update_forward_refs",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "update_forward_refs"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.update_forward_refs",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.update_forward_refs.html#pyedb.workflows.drc.drc.CopperBalance.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod CopperBalance.update_forward_refs(**localns: Any) -> None\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.spice_model.SpiceModel.create",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.spice_model.SpiceModel.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a SPICE model.\nName of the SPICE model file.\nPath to the SPICE model file.\nSubcircuit name of the SPICE model.\ncreate\npython:str\npython:str\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.spice_model.SpiceModel.create",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.spice_model.SpiceModel.create.html#pyedb.grpc.database.hierarchy.spice_model.SpiceModel.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod SpiceModel.create(name, path, sub_circuit)\n\nCreate a SPICE model.\n\nParameters\n\nname\n\npython:str\n\nName of the SPICE model file.\n\npath\n\npython:str\n\nPath to the SPICE model file.\n\nsub_circuit\n\npython:str\n\nSubcircuit name of the SPICE model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.assign_s_param_model",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.assign_s_param_model.html#assign_s_param_model",
        "title": "assign_s_param_model",
        "section": "assign_s_param_model",
        "text": "Assign S-parameter to this component.\nFile path of the S-parameter model.\nName of the S-parameter model.\nReference net.\nComponentModel.\nassign_s_param_model\npython:str\npython:str\noptional\npython:str\noptional\nNPortComponentModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.assign_s_param_model",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.assign_s_param_model.html#pyedb.grpc.database.hierarchy.component.Component.assign_s_param_model",
        "title": "assign_s_param_model > assign_s_param_model > assign_s_param_model",
        "section": "assign_s_param_model > assign_s_param_model",
        "text": "Component.assign_s_param_model(file_path, name=None, reference_net=None) -> NPortComponentModel\n\nAssign S-parameter to this component.\n\nParameters\n\nfile_path\n\npython:str\n\nFile path of the S-parameter model.\n\nname\n\npython:str, optional\n\nName of the S-parameter model.\n\nreference_net\n\npython:str, optional\n\nReference net.\n\nReturns\n\nNPortComponentModel\n\nComponentModel.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_point_terminal_reference_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_point_terminal_reference_primitive.html#get_point_terminal_reference_primitive",
        "title": "get_point_terminal_reference_primitive",
        "section": "get_point_terminal_reference_primitive",
        "text": "Find and return the primitive reference for the point terminal or the padstack instance.\nget_point_terminal_reference_primitive\ndotnet.database.edb_data.padstacks_data.EDBPadstackInstance\nor\npyedb.dotnet.database.edb_data.primitives_data.EDBPrimitives"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_point_terminal_reference_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_point_terminal_reference_primitive.html#pyedb.grpc.database.ports.ports.ExcitationSources.get_point_terminal_reference_primitive",
        "title": "get_point_terminal_reference_primitive > get_point_terminal_reference_primitive > get_point_terminal_reference_primitive",
        "section": "get_point_terminal_reference_primitive > get_point_terminal_reference_primitive",
        "text": "ExcitationSources.get_point_terminal_reference_primitive()\n\nFind and return the primitive reference for the point terminal or the padstack instance.\n\nReturns\n\ndotnet.database.edb_data.padstacks_data.EDBPadstackInstance or\n\n\n\npyedb.dotnet.database.edb_data.primitives_data.EDBPrimitives\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_trace",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_trace.html#create_trace",
        "title": "create_trace",
        "section": "create_trace",
        "text": "Create trace path.\nList of points [x,y] or [[x, y], …]\nor [(x, y)…].\nLayer name.\nTrace width.\nAssociated net name.\nStart cap style (“Round”, “Extended”, “Flat”).\nEnd cap style (“Round”, “Extended”, “Flat”).\nCorner style (“Round”, “Sharp”, “Mitered”).\nPath object if created, False otherwise.\ncreate_trace\nIterable\npython:str\npython:float\noptional\npython:str\noptional\npython:str\noptional\npython:str\noptional\npython:str\noptional\npyedb.dotnet.database.edb_data.primitives_data.Path"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_trace",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_trace.html#pyedb.grpc.database.modeler.Modeler.create_trace",
        "title": "create_trace > create_trace > create_trace",
        "section": "create_trace > create_trace",
        "text": "Modeler.create_trace(path_list: Iterable[float] | PolygonData, layer_name: str, width: float = 1, net_name: str = '', start_cap_style: str = 'Round', end_cap_style: str = 'Round', corner_style: str = 'Round') -> Primitive | None\n\nCreate trace path.\n\nParameters\n\npath_list\n\nIterable\n\nList of points [x,y] or [[x, y], …]\nor [(x, y)…].\n\nlayer_name\n\npython:str\n\nLayer name.\n\nwidth\n\npython:float, optional\n\nTrace width.\n\nnet_name\n\npython:str, optional\n\nAssociated net name.\n\nstart_cap_style\n\npython:str, optional\n\nStart cap style (“Round”, “Extended”, “Flat”).\n\nend_cap_style\n\npython:str, optional\n\nEnd cap style (“Round”, “Extended”, “Flat”).\n\ncorner_style\n\npython:str, optional\n\nCorner style (“Round”, “Sharp”, “Mitered”).\n\nReturns\n\npyedb.dotnet.database.edb_data.primitives_data.Path or bool\n\nPath object if created, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFile.parse_xml",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFile.parse_xml.html#parse_xml",
        "title": "parse_xml",
        "section": "parse_xml",
        "text": "Parse an xml and populate the class with materials and Stackup only.\nFull path to xml.\nparse_xml\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFile.parse_xml",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFile.parse_xml.html#pyedb.grpc.database.utility.xml_control_file.ControlFile.parse_xml",
        "title": "parse_xml > parse_xml > parse_xml",
        "section": "parse_xml > parse_xml",
        "text": "ControlFile.parse_xml(xml_input)\n\nParse an xml and populate the class with materials and Stackup only.\n\nParameters\n\nxml_input\n\npython:str\n\nFull path to xml.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.tolerance",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.tolerance.html#tolerance",
        "title": "tolerance",
        "section": "tolerance",
        "text": "tolerance"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.tolerance",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.tolerance.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.tolerance",
        "title": "tolerance > tolerance > tolerance",
        "section": "tolerance > tolerance",
        "text": "DiffPairLengthMatch.tolerance: str\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.copy",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude: Optional set or mapping specifying which fields to include in the copied model.\nexclude: Optional set or mapping specifying which fields to exclude in the copied model.\nupdate: Optional dictionary of field-value pairs to override field values in the copied model.\ndeep: If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.copy",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.copy.html#pyedb.grpc.database.definition.materials.MaterialProperties.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "MaterialProperties.copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -> Self\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nArgs:\n\ninclude: Optional set or mapping specifying which fields to include in the copied model.\nexclude: Optional set or mapping specifying which fields to exclude in the copied model.\nupdate: Optional dictionary of field-value pairs to override field values in the copied model.\ndeep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_fields.html#pyedb.workflows.drc.drc.DiffPair.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "DiffPair.model_fields = {'negative': FieldInfo(annotation=str, required=True), 'positive': FieldInfo(annotation=str, required=True)}\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_layer_below",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_layer_below.html#add_layer_below",
        "title": "add_layer_below",
        "section": "add_layer_below",
        "text": "Add a layer below a layer.\nName of the layer.\nName of the base layer.\nType of the layer. The default to \"signal\". Options are \"signal\", \"dielectric\"\nadd_layer_below\npython:str\n\"signal\"\n\"signal\"\n\"dielectric\""
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_layer_below",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.add_layer_below.html#pyedb.dotnet.database.stackup.Stackup.add_layer_below",
        "title": "add_layer_below > add_layer_below > add_layer_below",
        "section": "add_layer_below > add_layer_below",
        "text": "Stackup.add_layer_below(name, base_layer_name, layer_type='signal', **kwargs)\n\nAdd a layer below a layer.\n\nParameters\n\nname\n\npython:str\n\nName of the layer.\n\nbase_layer_name: str\n\nName of the base layer.\n\nlayer_type: str, optional\n\nType of the layer. The default to \"signal\". Options are \"signal\", \"dielectric\"\n\nkwargs\n\n\n\nReturns\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_thermal_modifier",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_thermal_modifier.html#set_thermal_modifier",
        "title": "set_thermal_modifier",
        "section": "set_thermal_modifier",
        "text": "Set the thermal modifier of the material property.\nMaterial property to set the thermal modifier on.\nThermal modifier to assign to the material property.\nset_thermal_modifier\nMaterialProperty\nMaterialPropertyThermalModifier"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_thermal_modifier",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_thermal_modifier.html#pyedb.grpc.database.definition.materials.Material.set_thermal_modifier",
        "title": "set_thermal_modifier > set_thermal_modifier > set_thermal_modifier",
        "section": "set_thermal_modifier > set_thermal_modifier",
        "text": "Material.set_thermal_modifier(material_property_id: MaterialProperty, thermal_modifier: MaterialPropertyThermalModifier)\n\nSet the thermal modifier of the material property.\n\nParameters\n\nmaterial_property_id\n\nMaterialProperty\n\nMaterial property to set the thermal modifier on.\n\nthermal_modifier\n\nMaterialPropertyThermalModifier\n\nThermal modifier to assign to the material property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.type",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.type.html#type",
        "title": "type",
        "section": "type",
        "text": "type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.type",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.type.html#pyedb.grpc.database.ports.ports.CircuitPort.type",
        "title": "type > type > type",
        "section": "type > type",
        "text": "CircuitPort.type = 0\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCSettings.html#dcsettings",
        "title": "DCSettings",
        "section": "DCSettings",
        "text": "DCSettings.get_configurations()\nGet all attributes.\nDCSettings.restore_default()\n\nDCSettings\nDCSettings.get_configurations\nDCSettings.restore_default"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCSettings.html#pyedb.dotnet.database.sim_setup_data.io.siwave.DCSettings",
        "title": "DCSettings > DCSettings > DCSettings",
        "section": "DCSettings > DCSettings",
        "text": "class pyedb.dotnet.database.sim_setup_data.io.siwave.DCSettings(parent)\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nDCSettings.get_configurations()\n\nGet all attributes.\n\nDCSettings.restore_default()\n\n\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EDBArcs",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EDBArcs.html#edbarcs",
        "title": "EDBArcs",
        "section": "EDBArcs",
        "text": "Manages EDB Arc Data functionalities.\nIt Inherits EDB primitives arcs properties.\nEDBArcs"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EDBArcs",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EDBArcs.html#pyedb.dotnet.database.edb_data.primitives_data.EDBArcs",
        "title": "EDBArcs > EDBArcs > EDBArcs",
        "section": "EDBArcs > EDBArcs",
        "text": "class pyedb.dotnet.database.edb_data.primitives_data.EDBArcs(app, arc)\n\nManages EDB Arc Data functionalities.\nIt Inherits EDB primitives arcs properties.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb(myedb, edbversion=\"2021.2\")\n>>> prim_arcs = edb.modeler.primitives[0].arcs\n>>> prim_arcs.center  # arc center\n>>> prim_arcs.points  # arc point list\n>>> prim_arcs.mid_point  # arc mid point\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/rectangle",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/rectangle.html#rectangle",
        "title": "Rectangle",
        "section": "Rectangle",
        "text": "This class is managing EDB rectangle.\nRectangle\nClass representing a rectangle object.\nRectangle\nRectangle"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.disable_rlc_component",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.disable_rlc_component.html#disable_rlc_component",
        "title": "disable_rlc_component",
        "section": "disable_rlc_component",
        "text": "Disable RLC component.\nComponent name.\nTrue if successful, False otherwise.\ndisable_rlc_component\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.disable_rlc_component",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.disable_rlc_component.html#pyedb.grpc.database.components.Components.disable_rlc_component",
        "title": "disable_rlc_component > disable_rlc_component > disable_rlc_component",
        "section": "disable_rlc_component > disable_rlc_component",
        "text": "Components.disable_rlc_component(component_name: str) -> bool\n\nDisable RLC component.\n\nParameters\n\ncomponent_name\n\npython:str\n\nComponent name.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\nExamples\n\n>>> edbapp.components.disable_rlc_component(\"R1\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.get_product_property.html#pyedb.grpc.database.net.net_class.NetClass.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "NetClass.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.dc_shorts",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.dc_shorts.html#dc_shorts",
        "title": "dc_shorts",
        "section": "dc_shorts",
        "text": "Find DC shorts on layout.\nList of nets.\nIf True, rename all the nets. (default)\nIf False, only report dc shorts.\n[[net name, net name]].\ndc_shorts\npython:str\npython:list\npython:str\noptional\noptional\nList\nList\npython:str\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.dc_shorts",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.dc_shorts.html#pyedb.grpc.database.layout_validation.LayoutValidation.dc_shorts",
        "title": "dc_shorts > dc_shorts > dc_shorts",
        "section": "dc_shorts > dc_shorts",
        "text": "LayoutValidation.dc_shorts(net_list: str | List[str] | None = None, fix: bool = False) -> List[List[str]]\n\nFind DC shorts on layout.\n\nParameters\n\nnet_list\n\npython:str or python:list[python:str], optional\n\nList of nets.\n\nfix\n\nbool, optional\n\nIf True, rename all the nets. (default)\nIf False, only report dc shorts.\n\nReturns\n\nList[List[python:str, python:str]]\n\n[[net name, net name]].\n\nExamples\n\n>>> edb = Edb(\"edb_file\")\n>>> # Find shorts without fixing\n>>> shorts = edb.layout_validation.dc_shorts()\n>>>\n>>> # Find and fix shorts on specific nets\n>>> fixed_shorts = edb.layout_validation.dc_shorts(net_list=[\"GND\", \"VCC\"], fix=True)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_hole_overrides",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_hole_overrides.html#get_hole_overrides",
        "title": "get_hole_overrides",
        "section": "get_hole_overrides",
        "text": "Get the hole overrides of the padstack instance.\nReturns a tuple in this format:\n(is_hole_override, hole_override)\nis_hole_override : If padstack instance is hole override.\nhole_override : Hole override diameter of this padstack instance.\nget_hole_overrides\npython:tuple\nof\nValue"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_hole_overrides",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_hole_overrides.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_hole_overrides",
        "title": "get_hole_overrides > get_hole_overrides > get_hole_overrides",
        "section": "get_hole_overrides > get_hole_overrides",
        "text": "PadstackInstance.get_hole_overrides() -> tuple[bool, Value]\n\nGet the hole overrides of the padstack instance.\n\nReturns\n\npython:tuple of (bool, Value)\n\nReturns a tuple in this format:\n\n(is_hole_override, hole_override)\n\nis_hole_override : If padstack instance is hole override.\n\nhole_override : Hole override diameter of this padstack instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_back_drill_by_depth",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_back_drill_by_depth.html#set_back_drill_by_depth",
        "title": "set_back_drill_by_depth",
        "section": "set_back_drill_by_depth",
        "text": "Set back drill by depth.\ndrill depth value\ndrill diameter\nDefault value is True.\nset_back_drill_by_depth\npython:str\npython:float\npython:str\npython:float\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_back_drill_by_depth",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_back_drill_by_depth.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_back_drill_by_depth",
        "title": "set_back_drill_by_depth > set_back_drill_by_depth > set_back_drill_by_depth",
        "section": "set_back_drill_by_depth > set_back_drill_by_depth",
        "text": "PadstackInstance.set_back_drill_by_depth(drill_depth, diameter, from_bottom=True)\n\nSet back drill by depth.\n\nParameters\n\ndrill_depth\n\npython:str, python:float\n\ndrill depth value\n\ndiameter\n\npython:str, python:float\n\ndrill diameter\n\nfrom_bottom\n\nbool, optional\n\nDefault value is True.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/point_data",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/point_data.html#point-data",
        "title": "Point Data",
        "section": "Point Data",
        "text": "These class manages geometry point data.\nPointData\nClass managing Point Data\nPoint Data\nPointData\nPoint Data"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.html#edbsiwave",
        "title": "EdbSiwave",
        "section": "EdbSiwave",
        "text": "Manages EDB methods related to Siwave Setup accessible from Edb.siwave property.\nInherited parent object.\nEdbSiwave.add_cpa_analysis([name, ...])\n\nEdbSiwave.add_siwave_dc_analysis([name])\nAdd a Siwave DC analysis in EDB.\nEdbSiwave.add_siwave_syz_analysis([name, ...])\nAdd a SIwave AC analysis to EDB.\nEdbSiwave.configure_siw_analysis_setup([...])\nConfigure Siwave analysis setup.\nEdbSiwave.create_circuit_port_on_net(...[, ...])\nCreate a circuit port on a NET.\nEdbSiwave.create_circuit_port_on_pin(...[, ...])\nCreate a circuit port on a pin.\nEdbSiwave.create_circuit_port_on_pin_group(...)\nCreate a port between two pin groups.\nEdbSiwave.create_current_source_on_net(...)\nCreate a current source.\nEdbSiwave.create_current_source_on_pin(...)\nCreate a current source.\nEdbSiwave.create_current_source_on_pin_group(...)\nCreate current source between two pin groups.\nEdbSiwave.create_dc_terminal(component_name, ...)\nCreate a dc terminal.\nEdbSiwave.create_exec_file([add_dc, add_ac, ...])\nCreate an executable file.\nEdbSiwave.create_impedance_crosstalk_scan([...])\nCreate Siwave crosstalk scan object\nEdbSiwave.create_pin_group(...[, group_name])\nCreate pin group on the component.\nEdbSiwave.create_pin_group_on_net(...[, ...])\nCreate pin group on component by net name.\nEdbSiwave.create_pin_group_terminal(source)\nCreate a pin group terminal.\nEdbSiwave.create_port_between_pin_and_layer([...])\nCreate circuit port between pin and a reference layer.\nEdbSiwave.create_resistor_on_pin(pos_pin, ...)\nCreate a Resistor boundary between two given pins..\nEdbSiwave.create_rlc_component(pins[, ...])\nCreate physical Rlc component.\nEdbSiwave.create_voltage_probe_on_pin_group(...)\nCreate voltage probe between two pin groups.\nEdbSiwave.create_voltage_source_on_net(...)\nCreate a voltage source.\nEdbSiwave.create_voltage_source_on_pin(...)\nCreate a voltage source.\nEdbSiwave.create_voltage_source_on_pin_group(...)\nCreate voltage source between two pin groups.\nEdbSiwave.create_vrm_module([name, ...])\nCreate a voltage regulator module.\nEdbSiwave.place_voltage_probe(name, ...)\nPlace a voltage probe between two points.\nEdbSiwave\npyedb.edb.Edb\nEdbSiwave.add_cpa_analysis\nEdbSiwave.add_siwave_dc_analysis\nEdbSiwave.add_siwave_syz_analysis\nEdbSiwave.configure_siw_analysis_setup\nEdbSiwave.create_circuit_port_on_net\nEdbSiwave.create_circuit_port_on_pin\nEdbSiwave.create_circuit_port_on_pin_group\nEdbSiwave.create_current_source_on_net\nEdbSiwave.create_current_source_on_pin\nEdbSiwave.create_current_source_on_pin_group\nEdbSiwave.create_dc_terminal\nEdbSiwave.create_exec_file\nEdbSiwave.create_impedance_crosstalk_scan\nEdbSiwave.create_pin_group\nEdbSiwave.create_pin_group_on_net\nEdbSiwave.create_pin_group_terminal\nEdbSiwave.create_port_between_pin_and_layer\nEdbSiwave.create_resistor_on_pin\nEdbSiwave.create_rlc_component\nEdbSiwave.create_voltage_probe_on_pin_group\nEdbSiwave.create_voltage_source_on_net\nEdbSiwave.create_voltage_source_on_pin\nEdbSiwave.create_voltage_source_on_pin_group\nEdbSiwave.create_vrm_module\nEdbSiwave.place_voltage_probe"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.html#pyedb.dotnet.database.siwave.EdbSiwave",
        "title": "EdbSiwave > EdbSiwave > EdbSiwave",
        "section": "EdbSiwave > EdbSiwave",
        "text": "class pyedb.dotnet.database.siwave.EdbSiwave(p_edb)\n\nManages EDB methods related to Siwave Setup accessible from Edb.siwave property.\n\nParameters\n\nedb_class\n\npyedb.edb.Edb\n\nInherited parent object.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", edbversion=\"2021.2\")\n>>> edb_siwave = edbapp.siwave\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nEdbSiwave.add_cpa_analysis([name, ...])\n\n\n\nEdbSiwave.add_siwave_dc_analysis([name])\n\nAdd a Siwave DC analysis in EDB.\n\nEdbSiwave.add_siwave_syz_analysis([name, ...])\n\nAdd a SIwave AC analysis to EDB.\n\nEdbSiwave.configure_siw_analysis_setup([...])\n\nConfigure Siwave analysis setup.\n\nEdbSiwave.create_circuit_port_on_net(...[, ...])\n\nCreate a circuit port on a NET.\n\nEdbSiwave.create_circuit_port_on_pin(...[, ...])\n\nCreate a circuit port on a pin.\n\nEdbSiwave.create_circuit_port_on_pin_group(...)\n\nCreate a port between two pin groups.\n\nEdbSiwave.create_current_source_on_net(...)\n\nCreate a current source.\n\nEdbSiwave.create_current_source_on_pin(...)\n\nCreate a current source.\n\nEdbSiwave.create_current_source_on_pin_group(...)\n\nCreate current source between two pin groups.\n\nEdbSiwave.create_dc_terminal(component_name, ...)\n\nCreate a dc terminal.\n\nEdbSiwave.create_exec_file([add_dc, add_ac, ...])\n\nCreate an executable file.\n\nEdbSiwave.create_impedance_crosstalk_scan([...])\n\nCreate Siwave crosstalk scan object\n\nEdbSiwave.create_pin_group(...[, group_name])\n\nCreate pin group on the component.\n\nEdbSiwave.create_pin_group_on_net(...[, ...])\n\nCreate pin group on component by net name.\n\nEdbSiwave.create_pin_group_terminal(source)\n\nCreate a pin group terminal.\n\nEdbSiwave.create_port_between_pin_and_layer([...])\n\nCreate circuit port between pin and a reference layer.\n\nEdbSiwave.create_resistor_on_pin(pos_pin, ...)\n\nCreate a Resistor boundary between two given pins..\n\nEdbSiwave.create_rlc_component(pins[, ...])\n\nCreate physical Rlc component.\n\nEdbSiwave.create_voltage_probe_on_pin_group(...)\n\nCreate voltage probe between two pin groups.\n\nEdbSiwave.create_voltage_source_on_net(...)\n\nCreate a voltage source.\n\nEdbSiwave.create_voltage_source_on_pin(...)\n\nCreate a voltage source.\n\nEdbSiwave.create_voltage_source_on_pin_group(...)\n\nCreate voltage source between two pin groups.\n\nEdbSiwave.create_vrm_module([name, ...])\n\nCreate a voltage regulator module.\n\nEdbSiwave.place_voltage_probe(name, ...)\n\nPlace a voltage probe between two points.\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/EdbValue",
        "href": "dotnet_api/dotnet/edb_data/EdbValue.html#edb-value",
        "title": "EDB value",
        "section": "EDB value",
        "text": "Class managing EDB Value.\nEdbValue\nClass defining Edb Value properties.\nEDB value\nEdbValue"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.rotate",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.rotate.html#rotate",
        "title": "rotate",
        "section": "rotate",
        "text": "Rotate polygon around a center point by an angle.\nValue of the rotation angle in degree.\nIf None rotation is done from polygon center.\nTrue when successful, False when failed.\nrotate\npython:float\nList\nof\npython:float\npython:str\noptional\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.rotate",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.rotate.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.rotate",
        "title": "rotate > rotate > rotate",
        "section": "rotate > rotate",
        "text": "EdbPolygon.rotate(angle, center=None)\n\nRotate polygon around a center point by an angle.\n\nParameters\n\nangle\n\npython:float\n\nValue of the rotation angle in degree.\n\ncenter\n\nList of python:float or python:str [x,y], optional\n\nIf None rotation is done from polygon center.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> edbapp = ansys.aedt.core.Edb(\"myproject.aedb\")\n>>> top_layer_polygon = [poly for poly in edbapp.modeler.polygons if poly.layer_name == \"Top Layer\"]\n>>> for polygon in top_layer_polygon:\n>>>     polygon.rotate(angle=45)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_raptorx_setup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_raptorx_setup.html#create_raptorx_setup",
        "title": "create_raptorx_setup",
        "section": "create_raptorx_setup",
        "text": "Create an RaptorX simulation setup from a template.\nSetup name.\ncreate_raptorx_setup\npython:str\noptional\nlegacy.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_raptorx_setup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_raptorx_setup.html#pyedb.dotnet.edb.Edb.create_raptorx_setup",
        "title": "create_raptorx_setup > create_raptorx_setup > create_raptorx_setup",
        "section": "create_raptorx_setup > create_raptorx_setup",
        "text": "Edb.create_raptorx_setup(name=None)\n\nCreate an RaptorX simulation setup from a template.\n\nParameters\n\nname\n\npython:str, optional\n\nSetup name.\n\nReturns\n\nlegacy.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXGeneralSettings",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXGeneralSettings.html#raptorxgeneralsettings",
        "title": "RaptorXGeneralSettings",
        "section": "RaptorXGeneralSettings",
        "text": "RaptorXGeneralSettings"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXGeneralSettings",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXGeneralSettings.html#pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXGeneralSettings",
        "title": "RaptorXGeneralSettings > RaptorXGeneralSettings > RaptorXGeneralSettings",
        "section": "RaptorXGeneralSettings > RaptorXGeneralSettings",
        "text": "class pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXGeneralSettings(edb_setup_info, pedb)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/index",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/index.html#utility-classes",
        "title": "Utility classes",
        "section": "Utility classes",
        "text": "This section describes EDB utility classes.\nUtility classes"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.CircularPatch.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.CircularPatch.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Draw the patch, ground plane and feed geometry in EDB.\nTrue when the geometry has been successfully created.\ncreate"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.CircularPatch.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.CircularPatch.create.html#pyedb.libraries.rf_libraries.planar_antennas.CircularPatch.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "CircularPatch.create() -> bool\n\nDraw the patch, ground plane and feed geometry in EDB.\n\nReturns\n\nbool\n\nTrue when the geometry has been successfully created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.html#bundleterminal",
        "title": "BundleTerminal",
        "section": "BundleTerminal",
        "text": "Manages bundle terminal properties.\nEDB object.\nBundleTerminal instance from EDB.\nBundleTerminal.cast([term_type])\nCast the terminal object to the correct concrete type, fetching the type if necessary.\nBundleTerminal.create(terminals)\nCreate a bundle terminal.\nBundleTerminal.create_3d_comp()\nCreate a 3D composite model from an MCAD file.\nBundleTerminal.create_hfss()\nCreate an HFSS model from an MCAD file.\nBundleTerminal.create_stride()\nCreate a Stride model from an MCAD file.\nBundleTerminal.decouple()\nUngroup a bundle of terminals.\nBundleTerminal.delete()\nDelete the layout object.\nBundleTerminal.find(layout, name)\nFind a terminal by name in a given layout.\nBundleTerminal.find_by_id(layout, uid)\nFind a Connectable object by database ID in a given layout.\nBundleTerminal.get_product_property(prod_id, ...)\nGet the product property of the layout object for a given product ID and attribute ID.\nBundleTerminal.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nBundleTerminal.product_solver_names(product_id)\nGet the list of solver names.\nBundleTerminal.product_solver_option(...)\nGet the name of the product solver option.\nBundleTerminal.set_product_property(prod_id, ...)\nSet the product property of the layout object for a given product ID and attribute ID.\nBundleTerminal.set_product_solver_option(...)\nSet the product solver option.\nBundleTerminal.ungroup()\nDelete the grouping.\nBundleTerminal.layout_obj_type\n\nBundleTerminal.type\n\nBundleTerminal\nEdb\nBundleTerminal\nBundleTerminal.cast\nBundleTerminal.create\nBundleTerminal.create_3d_comp\nBundleTerminal.create_hfss\nBundleTerminal.create_stride\nBundleTerminal.decouple\nBundleTerminal.delete\nBundleTerminal.find\nBundleTerminal.find_by_id\nBundleTerminal.get_product_property\nBundleTerminal.get_product_property_ids\nBundleTerminal.product_solver_names\nBundleTerminal.product_solver_option\nBundleTerminal.set_product_property\nBundleTerminal.set_product_solver_option\nBundleTerminal.ungroup\nBundleTerminal.layout_obj_type\nBundleTerminal.type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.html#pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal",
        "title": "BundleTerminal > BundleTerminal > BundleTerminal",
        "section": "BundleTerminal > BundleTerminal",
        "text": "class pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal(pedb, edb_object)\n\nManages bundle terminal properties.\n\nParameters\n\npedb\n\nEdb\n\nEDB object.\n\nedb_object\n\nBundleTerminal\n\nBundleTerminal instance from EDB.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nBundleTerminal.cast([term_type])\n\nCast the terminal object to the correct concrete type, fetching the type if necessary.\n\nBundleTerminal.create(terminals)\n\nCreate a bundle terminal.\n\nBundleTerminal.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nBundleTerminal.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nBundleTerminal.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nBundleTerminal.decouple()\n\nUngroup a bundle of terminals.\n\nBundleTerminal.delete()\n\nDelete the layout object.\n\nBundleTerminal.find(layout, name)\n\nFind a terminal by name in a given layout.\n\nBundleTerminal.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nBundleTerminal.get_product_property(prod_id, ...)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nBundleTerminal.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nBundleTerminal.product_solver_names(product_id)\n\nGet the list of solver names.\n\nBundleTerminal.product_solver_option(...)\n\nGet the name of the product solver option.\n\nBundleTerminal.set_product_property(prod_id, ...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nBundleTerminal.set_product_solver_option(...)\n\nSet the product solver option.\n\nBundleTerminal.ungroup()\n\nDelete the grouping.\n\n\n\nAttributes\n\n\n\n\n\n\n\nBundleTerminal.layout_obj_type\n\n\n\nBundleTerminal.type\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.open",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.open.html#open",
        "title": "open",
        "section": "open",
        "text": "Open EDB database.\nTrue if successful, False otherwise.\nopen"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.open",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.open.html#pyedb.grpc.edb.Edb.open",
        "title": "open > open > open",
        "section": "open > open",
        "text": "Edb.open(restart_rpc_server=False) -> bool\n\nOpen EDB database.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\nExamples\n\n>>> # Open an existing EDB database:\n>>> edb = Edb(\"myproject.aedb\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.default_dielectric_property_values",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.default_dielectric_property_values.html#default_dielectric_property_values",
        "title": "default_dielectric_property_values",
        "section": "default_dielectric_property_values",
        "text": "default_dielectric_property_values"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.default_dielectric_property_values",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.default_dielectric_property_values.html#pyedb.dotnet.database.materials.Materials.default_dielectric_property_values",
        "title": "default_dielectric_property_values > default_dielectric_property_values > default_dielectric_property_values",
        "section": "default_dielectric_property_values > default_dielectric_property_values",
        "text": "Materials.default_dielectric_property_values = {'conductivity': 0, 'dielectric_loss_tangent': 0.02, 'magnetic_loss_tangent': 0, 'mass_density': 1900, 'permeability': 1, 'permittivity': 4.4, 'poisson_ratio': 0.28, 'specific_heat': 1150, 'thermal_conductivity': 0.294, 'thermal_expansion_coefficient': 1.5e-05, 'youngs_modulus': 11000000000}\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_pins",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_pins.html#get_pins",
        "title": "get_pins",
        "section": "get_pins",
        "text": "Get pins of a component.\nReference designator.\nNet name filter.\nPin name filter.\nDictionary of pins.\nget_pins\npython:str\npython:str\noptional\npython:str\noptional\npython:dict"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_pins",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_pins.html#pyedb.grpc.database.components.Components.get_pins",
        "title": "get_pins > get_pins > get_pins",
        "section": "get_pins > get_pins",
        "text": "Components.get_pins(reference_designator: str, net_name: str | None = None, pin_name: str | None = None) -> Dict[str, Any]\n\nGet pins of a component.\n\nParameters\n\nreference_designator\n\npython:str\n\nReference designator.\n\nnet_name\n\npython:str, optional\n\nNet name filter.\n\npin_name\n\npython:str, optional\n\nPin name filter.\n\nReturns\n\npython:dict\n\nDictionary of pins.\n\nExamples\n\n>>> pins = edbapp.components.get_pins(\"U1\", net_name=\"GND\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.set_product_property.html#pyedb.grpc.database.primitive.path.Path.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "Path.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_post_init",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nmodel_post_init"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_post_init",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_post_init.html#pyedb.workflows.drc.drc.DiffPair.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "DiffPair.model_post_init(context: Any, /) -> None\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/raptor_x_simulation_setup",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/raptor_x_simulation_setup.html#raptor-x-simulation-setup",
        "title": "Raptor X simulation setup",
        "section": "Raptor X simulation setup",
        "text": "This class is managing EDB raptor X simulation setup.\nRaptorXSimulationSetup\nRaptorX simulation setup.\nRaptor X simulation setup\nRaptorXSimulationSetup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the layout object.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.delete.html#pyedb.grpc.database.hierarchy.component.Component.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "Component.delete()\n\nDelete the layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.html#materials",
        "title": "Materials",
        "section": "Materials",
        "text": "Manages EDB methods for material management accessible from Edb.materials property.\nMaterials.add_conductor_material(name, ...)\nAdd a new conductor material.\nMaterials.add_debye_material(name, ...)\nAdd a dielectric with the Debye model.\nMaterials.add_dielectric_material(name, ...)\nAdd a new dielectric material in library.\nMaterials.add_djordjevicsarkar_dielectric(...)\nAdd a dielectric using the Djordjevic-Sarkar model.\nMaterials.add_material(name, **kwargs)\nAdd a new material.\nMaterials.add_multipole_debye_material(name, ...)\nAdd a dielectric with the Multipole Debye model.\nMaterials.delete(material_name)\nRemove a material from the database.\nMaterials.delete_material(material_name)\n.deprecated: pyedb 0.32.0 use delete instead.\nMaterials.duplicate(material_name, ...)\nDuplicate a material from the database.\nMaterials.iterate_materials_in_amat([amat_file])\nIterate over material description in an AMAT file.\nMaterials.load_amat(amat_file)\nLoad materials from an AMAT file.\nMaterials.load_material(material)\nLoad material.\nMaterials.material_property_to_id(property_name)\nConvert a material property name to a material property ID.\nMaterials.read_materials(amat_file)\nRead materials from an AMAT file.\nMaterials.read_syslib_material(material_name)\nRead a specific material from syslib AMAT file.\nMaterials.update_material(material_name, ...)\nUpdate material attributes.\nMaterials.update_materials_from_sys_library([...])\nUpdate material properties from syslib AMAT file.\nMaterials.default_conductor_property_values\n\nMaterials.default_dielectric_property_values\n\nMaterials\nMaterials.add_conductor_material\nMaterials.add_debye_material\nMaterials.add_dielectric_material\nMaterials.add_djordjevicsarkar_dielectric\nMaterials.add_material\nMaterials.add_multipole_debye_material\nMaterials.delete\nMaterials.delete_material\nMaterials.duplicate\nMaterials.iterate_materials_in_amat\nMaterials.load_amat\nMaterials.load_material\nMaterials.material_property_to_id\nMaterials.read_materials\nMaterials.read_syslib_material\nMaterials.update_material\nMaterials.update_materials_from_sys_library\nMaterials.default_conductor_property_values\nMaterials.default_dielectric_property_values"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.html#pyedb.grpc.database.definition.materials.Materials",
        "title": "Materials > Materials > Materials",
        "section": "Materials > Materials",
        "text": "class pyedb.grpc.database.definition.materials.Materials(edb: Edb)\n\nManages EDB methods for material management accessible from Edb.materials property.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nMaterials.add_conductor_material(name, ...)\n\nAdd a new conductor material.\n\nMaterials.add_debye_material(name, ...)\n\nAdd a dielectric with the Debye model.\n\nMaterials.add_dielectric_material(name, ...)\n\nAdd a new dielectric material in library.\n\nMaterials.add_djordjevicsarkar_dielectric(...)\n\nAdd a dielectric using the Djordjevic-Sarkar model.\n\nMaterials.add_material(name, **kwargs)\n\nAdd a new material.\n\nMaterials.add_multipole_debye_material(name, ...)\n\nAdd a dielectric with the Multipole Debye model.\n\nMaterials.delete(material_name)\n\nRemove a material from the database.\n\nMaterials.delete_material(material_name)\n\n.deprecated: pyedb 0.32.0 use delete instead.\n\nMaterials.duplicate(material_name, ...)\n\nDuplicate a material from the database.\n\nMaterials.iterate_materials_in_amat([amat_file])\n\nIterate over material description in an AMAT file.\n\nMaterials.load_amat(amat_file)\n\nLoad materials from an AMAT file.\n\nMaterials.load_material(material)\n\nLoad material.\n\nMaterials.material_property_to_id(property_name)\n\nConvert a material property name to a material property ID.\n\nMaterials.read_materials(amat_file)\n\nRead materials from an AMAT file.\n\nMaterials.read_syslib_material(material_name)\n\nRead a specific material from syslib AMAT file.\n\nMaterials.update_material(material_name, ...)\n\nUpdate material attributes.\n\nMaterials.update_materials_from_sys_library([...])\n\nUpdate material properties from syslib AMAT file.\n\n\n\nAttributes\n\n\n\n\n\n\n\nMaterials.default_conductor_property_values\n\n\n\nMaterials.default_dielectric_property_values\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_settings.HFSSSimulationSettings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_settings.HFSSSimulationSettings.html#hfsssimulationsettings",
        "title": "HFSSSimulationSettings",
        "section": "HFSSSimulationSettings",
        "text": "PyEDB-core HFSS simulation settings class.\nHFSSSimulationSettings"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_settings.HFSSSimulationSettings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_settings.HFSSSimulationSettings.html#pyedb.grpc.database.simulation_setup.hfss_simulation_settings.HFSSSimulationSettings",
        "title": "HFSSSimulationSettings > HFSSSimulationSettings > HFSSSimulationSettings",
        "section": "HFSSSimulationSettings > HFSSSimulationSettings",
        "text": "class pyedb.grpc.database.simulation_setup.hfss_simulation_settings.HFSSSimulationSettings(pedb, edb_object)\n\nPyEDB-core HFSS simulation settings class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.product_solver_names",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.product_solver_names.html#product_solver_names",
        "title": "product_solver_names",
        "section": "product_solver_names",
        "text": "Get the list of solver names.\nID of the product.\nproduct_solver_names\nProductIdType\npython:list\nof\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.product_solver_names",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.product_solver_names.html#pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.product_solver_names",
        "title": "product_solver_names > product_solver_names > product_solver_names",
        "section": "product_solver_names > product_solver_names",
        "text": "PadstackInstanceTerminal.product_solver_names(product_id)\n\nGet the list of solver names.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nReturns\n\npython:list of python:str\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.parse_file",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "parse_file"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.parse_file",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.parse_file.html#pyedb.workflows.drc.drc.Rules.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod Rules.parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.fromhex",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.fromhex.html#fromhex",
        "title": "fromhex",
        "section": "fromhex",
        "text": "Create a floating-point number from a hexadecimal string.\nfromhex"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.fromhex",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.fromhex.html#pyedb.grpc.database.utility.value.Value.fromhex",
        "title": "fromhex > fromhex > fromhex",
        "section": "fromhex > fromhex",
        "text": "Value.fromhex(string, /)\n\nCreate a floating-point number from a hexadecimal string.\n\n>>> float.fromhex('0x1.ffffp10')\n2047.984375\n>>> float.fromhex('-0x1p-1074')\n-5e-324\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.subtract",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.subtract.html#subtract",
        "title": "subtract",
        "section": "subtract",
        "text": "Subtract active primitive with one or more primitives.\nor: List[Primitives]\nor: class:PolygonData <ansys.edb.core.geometry.polygon_data.PolygonData>\nList of Primitive objects.\nsubtract\nPrimitives\nPrimitives\nList\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.subtract",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.subtract.html#pyedb.grpc.database.primitive.polygon.Polygon.subtract",
        "title": "subtract > subtract > subtract",
        "section": "subtract > subtract",
        "text": "Polygon.subtract(primitives) -> list[any]\n\nSubtract active primitive with one or more primitives.\n\nParameters\n\nprimitives\n\nPrimitives\n\nor: List[Primitives]\nor: class:PolygonData <ansys.edb.core.geometry.polygon_data.PolygonData>\n\nReturns\n\nList[Primitive]\n\nList of Primitive objects.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.is_integer",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.is_integer.html#is_integer",
        "title": "is_integer",
        "section": "is_integer",
        "text": "Return True if the float is an integer.\nis_integer"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.is_integer",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.is_integer.html#pyedb.grpc.database.utility.value.Value.is_integer",
        "title": "is_integer > is_integer > is_integer",
        "section": "is_integer > is_integer",
        "text": "Value.is_integer(/)\n\nReturn True if the float is an integer.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.tangent_at",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.tangent_at.html#tangent_at",
        "title": "tangent_at",
        "section": "tangent_at",
        "text": "Get the tangent vector of the arc at a given point.\nPoint.\ntangent_at\nPointData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.tangent_at",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.tangent_at.html#pyedb.grpc.database.geometry.arc_data.ArcData.tangent_at",
        "title": "tangent_at > tangent_at > tangent_at",
        "section": "tangent_at > tangent_at",
        "text": "ArcData.tangent_at(point: PointLike) -> PointData\n\nGet the tangent vector of the arc at a given point.\n\nParameters\n\npoint\n\nPoint2DLike\n\nPoint.\n\nReturns\n\nPointData\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layer for a given product ID and attribute ID.\nProduct ID.\nAttribute ID.\nProduct property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.get_product_property.html#pyedb.grpc.database.layers.layer.Layer.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "Layer.get_product_property(prod_id, attr_it)\n\nGet the product property of the layer for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nProduct ID.\n\nattr_it\n\npython:int\n\nAttribute ID.\n\nReturns\n\npython:str\n\nProduct property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.normalized",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.normalized.html#normalized",
        "title": "normalized",
        "section": "normalized",
        "text": "Get the normalized points of the polygon.\nnormalized\npython:list\nof\nPointData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.normalized",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.normalized.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.normalized",
        "title": "normalized > normalized > normalized",
        "section": "normalized > normalized",
        "text": "PolygonData.normalized() -> list[PointData]\n\nGet the normalized points of the polygon.\n\nReturns\n\npython:list of PointData\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_3d_data.Point3DData.equals",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_3d_data.Point3DData.equals.html#equals",
        "title": "equals",
        "section": "equals",
        "text": "Compare the equality of two 3D points within a given tolerance.\nTolerance.\nTrue if the 3D points are equal, False otherwise.\nequals\nPoint3DData\npython:float\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_3d_data.Point3DData.equals",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_3d_data.Point3DData.equals.html#pyedb.grpc.database.geometry.point_3d_data.Point3DData.equals",
        "title": "equals > equals > equals",
        "section": "equals > equals",
        "text": "Point3DData.equals(other, tolerance: float = 1e-09) -> bool\n\nCompare the equality of two 3D points within a given tolerance.\n\nParameters\n\nother\n\nPoint3DData\n\n\n\ntolerance\n\npython:float, default: 1e-9\n\nTolerance.\n\nReturns\n\nbool\n\nTrue if the 3D points are equal, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.merge_via",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.merge_via.html#merge_via",
        "title": "merge_via",
        "section": "merge_via",
        "text": "Evaluate pad-stack instances included on the provided point list and replace all by single instance.\nNested list of polygon with points [x,y].\nList[str: net_name] apply a net filter, nets included in the filter are excluded from the via merge.\nPad-stack instance start layer, if None the top layer is selected.\nPad-stack instance stop layer, if None the bottom layer is selected.\nmerge_via\nList\nList\nList\npython:float\npython:float\noptional\noptional\npython:str\noptional\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.merge_via",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.merge_via.html#pyedb.grpc.database.padstacks.Padstacks.merge_via",
        "title": "merge_via > merge_via > merge_via",
        "section": "merge_via > merge_via",
        "text": "Padstacks.merge_via(contour_boxes: List[List[float]], net_filter: str | List[str] | None = None, start_layer: str | None = None, stop_layer: str | None = None) -> List[str]\n\nEvaluate pad-stack instances included on the provided point list and replace all by single instance.\n\nParameters\n\ncontour_boxes\n\nList[List[List[python:float, python:float]]]\n\nNested list of polygon with points [x,y].\n\nnet_filter\n\noptional\n\nList[str: net_name] apply a net filter, nets included in the filter are excluded from the via merge.\n\nstart_layer\n\noptional, python:str\n\nPad-stack instance start layer, if None the top layer is selected.\n\nstop_layer\n\noptional, python:str\n\nPad-stack instance stop layer, if None the bottom layer is selected.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.create_hfss.html#create_hfss",
        "title": "create_hfss",
        "section": "create_hfss",
        "text": "Create an HFSS model from an MCAD file.\nHFSS model created.\ncreate_hfss\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.create_hfss.html#pyedb.grpc.database.ports.ports.WavePort.create_hfss",
        "title": "create_hfss > create_hfss > create_hfss",
        "section": "create_hfss > create_hfss",
        "text": "WavePort.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nReturns\n\nMcadModel\n\nHFSS model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFile.parse_xml",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFile.parse_xml.html#parse_xml",
        "title": "parse_xml",
        "section": "parse_xml",
        "text": "Parse an XML control file and populate the object.\nPath to XML control file.\nTrue if successful, False otherwise.\nparse_xml\npython:str\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFile.parse_xml",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFile.parse_xml.html#pyedb.grpc.database.control_file.ControlFile.parse_xml",
        "title": "parse_xml > parse_xml > parse_xml",
        "section": "parse_xml > parse_xml",
        "text": "ControlFile.parse_xml(xml_input: str) -> bool\n\nParse an XML control file and populate the object.\n\nParameters\n\nxml_input\n\npython:str\n\nPath to XML control file.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/sources",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/sources.html#source",
        "title": "Source",
        "section": "Source",
        "text": "This class is managing EDB sources.\nNode\nProvides for handling nodes for Siwave sources.\nSource\nProvides for handling Siwave sources.\nCircuitPort\nManages a circuit port.\nVoltageSource\nManages a voltage source.\nCurrentSource\nManages a current source.\nDCTerminal\nManages a dc terminal source.\nResistorSource\nManages a resistor source.\nSource\nNode\nSource\nCircuitPort\nVoltageSource\nCurrentSource\nDCTerminal\nResistorSource"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.delete",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete current simulation setup.\ndelete"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.delete",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.delete.html#pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "HFSSPISimulationSetup.delete()\n\nDelete current simulation setup.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_pad_edge_terminal_reference_pin",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_pad_edge_terminal_reference_pin.html#get_pad_edge_terminal_reference_pin",
        "title": "get_pad_edge_terminal_reference_pin",
        "section": "get_pad_edge_terminal_reference_pin",
        "text": "Get the closest pin padstack instances and serves any edge terminal connected to a pad.\nPreferred reference net name. Optianal, default is None which will auto compute the gnd name.\nget_pad_edge_terminal_reference_pin\npython:str\noptional\npyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_pad_edge_terminal_reference_pin",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_pad_edge_terminal_reference_pin.html#pyedb.dotnet.database.edb_data.ports.WavePort.get_pad_edge_terminal_reference_pin",
        "title": "get_pad_edge_terminal_reference_pin > get_pad_edge_terminal_reference_pin > get_pad_edge_terminal_reference_pin",
        "section": "get_pad_edge_terminal_reference_pin > get_pad_edge_terminal_reference_pin",
        "text": "WavePort.get_pad_edge_terminal_reference_pin(gnd_net_name_preference=None)\n\nGet the closest pin padstack instances and serves any edge terminal connected to a pad.\n\nParameters\n\ngnd_net_name_preference\n\npython:str, optional\n\nPreferred reference net name. Optianal, default is None which will auto compute the gnd name.\n\nReturns\n\npyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileComponent",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileComponent.html#controlfilecomponent",
        "title": "ControlFileComponent",
        "section": "ControlFileComponent",
        "text": "Components.\nControlFileComponent.add_pin(name, x, y, layer)\n\nControlFileComponent.add_port(name, z0, pospin)\n\nControlFileComponent\nControlFileComponent.add_pin\nControlFileComponent.add_port"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileComponent",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileComponent.html#pyedb.dotnet.database.edb_data.control_file.ControlFileComponent",
        "title": "ControlFileComponent > ControlFileComponent > ControlFileComponent",
        "section": "ControlFileComponent > ControlFileComponent",
        "text": "class pyedb.dotnet.database.edb_data.control_file.ControlFileComponent\n\nComponents.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nControlFileComponent.add_pin(name, x, y, layer)\n\n\n\nControlFileComponent.add_port(name, z0, pospin)\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.html#materialproperties",
        "title": "MaterialProperties",
        "section": "MaterialProperties",
        "text": "Store material properties.\nMaterialProperties.construct([_fields_set])\n\nMaterialProperties.copy(*[, include, ...])\nReturns a copy of the model.\nMaterialProperties.dict(*[, include, ...])\n\nMaterialProperties.from_orm(obj)\n\nMaterialProperties.json(*[, include, ...])\n\nMaterialProperties.model_construct([_fields_set])\nCreates a new instance of the Model class with validated data.\nMaterialProperties.model_copy(*[, update, deep])\n!!! abstract \"Usage Documentation\"\nMaterialProperties.model_dump(*[, mode, ...])\n!!! abstract \"Usage Documentation\"\nMaterialProperties.model_dump_json(*[, ...])\n!!! abstract \"Usage Documentation\"\nMaterialProperties.model_json_schema([...])\nGenerates a JSON schema for a model class.\nMaterialProperties.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nMaterialProperties.model_post_init(context, /)\nOverride this method to perform additional initialization after __init__ and model_construct.\nMaterialProperties.model_rebuild(*[, force, ...])\nTry to rebuild the pydantic-core schema for the model.\nMaterialProperties.model_validate(obj, *[, ...])\nValidate a pydantic model instance.\nMaterialProperties.model_validate_json(...)\n!!! abstract \"Usage Documentation\"\nMaterialProperties.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nMaterialProperties.parse_file(path, *[, ...])\n\nMaterialProperties.parse_obj(obj)\n\nMaterialProperties.parse_raw(b, *[, ...])\n\nMaterialProperties.schema([by_alias, ...])\n\nMaterialProperties.schema_json(*[, ...])\n\nMaterialProperties.update_forward_refs(**localns)\n\nMaterialProperties.validate(value)\n\nMaterialProperties.model_computed_fields\n\nMaterialProperties.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nMaterialProperties.model_fields\n\nMaterialProperties.conductivity\n\nMaterialProperties.dielectric_loss_tangent\n\nMaterialProperties.magnetic_loss_tangent\n\nMaterialProperties.mass_density\n\nMaterialProperties.permittivity\n\nMaterialProperties.permeability\n\nMaterialProperties.poisson_ratio\n\nMaterialProperties.specific_heat\n\nMaterialProperties.thermal_conductivity\n\nMaterialProperties.youngs_modulus\n\nMaterialProperties.thermal_expansion_coefficient\n\nMaterialProperties.dc_conductivity\n\nMaterialProperties.dc_permittivity\n\nMaterialProperties.dielectric_model_frequency\n\nMaterialProperties.loss_tangent_at_frequency\n\nMaterialProperties.permittivity_at_frequency\n\nMaterialProperties\nMaterialProperties.construct\nMaterialProperties.copy\nMaterialProperties.dict\nMaterialProperties.from_orm\nMaterialProperties.json\nMaterialProperties.model_construct\nMaterialProperties.model_copy\nMaterialProperties.model_dump\nMaterialProperties.model_dump_json\nMaterialProperties.model_json_schema\nMaterialProperties.model_parametrized_name\nMaterialProperties.model_post_init\nMaterialProperties.model_rebuild\nMaterialProperties.model_validate\nMaterialProperties.model_validate_json\nMaterialProperties.model_validate_strings\nMaterialProperties.parse_file\nMaterialProperties.parse_obj\nMaterialProperties.parse_raw\nMaterialProperties.schema\nMaterialProperties.schema_json\nMaterialProperties.update_forward_refs\nMaterialProperties.validate\nMaterialProperties.model_computed_fields\nMaterialProperties.model_config\nMaterialProperties.model_fields\nMaterialProperties.conductivity\nMaterialProperties.dielectric_loss_tangent\nMaterialProperties.magnetic_loss_tangent\nMaterialProperties.mass_density\nMaterialProperties.permittivity\nMaterialProperties.permeability\nMaterialProperties.poisson_ratio\nMaterialProperties.specific_heat\nMaterialProperties.thermal_conductivity\nMaterialProperties.youngs_modulus\nMaterialProperties.thermal_expansion_coefficient\nMaterialProperties.dc_conductivity\nMaterialProperties.dc_permittivity\nMaterialProperties.dielectric_model_frequency\nMaterialProperties.loss_tangent_at_frequency\nMaterialProperties.permittivity_at_frequency"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.html#pyedb.grpc.database.definition.materials.MaterialProperties",
        "title": "MaterialProperties > MaterialProperties > MaterialProperties",
        "section": "MaterialProperties > MaterialProperties",
        "text": "class pyedb.grpc.database.definition.materials.MaterialProperties(*, conductivity: Annotated[float, Gt(gt=0)] | None = 0.0, dielectric_loss_tangent: Annotated[float, Gt(gt=0)] | None = 0.0, magnetic_loss_tangent: Annotated[float, Gt(gt=0)] | None = 0.0, mass_density: Annotated[float, Gt(gt=0)] | None = 0.0, permittivity: Annotated[float, Gt(gt=0)] | None = 0.0, permeability: Annotated[float, Gt(gt=0)] | None = 0.0, poisson_ratio: Annotated[float, Gt(gt=0)] | None = 0.0, specific_heat: Annotated[float, Gt(gt=0)] | None = 0.0, thermal_conductivity: Annotated[float, Gt(gt=0)] | None = 0.0, youngs_modulus: Annotated[float, Gt(gt=0)] | None = 0.0, thermal_expansion_coefficient: Annotated[float, Gt(gt=0)] | None = 0.0, dc_conductivity: Annotated[float, Gt(gt=0)] | None = 0.0, dc_permittivity: Annotated[float, Gt(gt=0)] | None = 0.0, dielectric_model_frequency: Annotated[float, Gt(gt=0)] | None = 0.0, loss_tangent_at_frequency: Annotated[float, Gt(gt=0)] | None = 0.0, permittivity_at_frequency: Annotated[float, Gt(gt=0)] | None = 0.0)\n\nStore material properties.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nMaterialProperties.construct([_fields_set])\n\n\n\nMaterialProperties.copy(*[, include, ...])\n\nReturns a copy of the model.\n\nMaterialProperties.dict(*[, include, ...])\n\n\n\nMaterialProperties.from_orm(obj)\n\n\n\nMaterialProperties.json(*[, include, ...])\n\n\n\nMaterialProperties.model_construct([_fields_set])\n\nCreates a new instance of the Model class with validated data.\n\nMaterialProperties.model_copy(*[, update, deep])\n\n!!! abstract \"Usage Documentation\"\n\nMaterialProperties.model_dump(*[, mode, ...])\n\n!!! abstract \"Usage Documentation\"\n\nMaterialProperties.model_dump_json(*[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nMaterialProperties.model_json_schema([...])\n\nGenerates a JSON schema for a model class.\n\nMaterialProperties.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nMaterialProperties.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nMaterialProperties.model_rebuild(*[, force, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nMaterialProperties.model_validate(obj, *[, ...])\n\nValidate a pydantic model instance.\n\nMaterialProperties.model_validate_json(...)\n\n!!! abstract \"Usage Documentation\"\n\nMaterialProperties.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nMaterialProperties.parse_file(path, *[, ...])\n\n\n\nMaterialProperties.parse_obj(obj)\n\n\n\nMaterialProperties.parse_raw(b, *[, ...])\n\n\n\nMaterialProperties.schema([by_alias, ...])\n\n\n\nMaterialProperties.schema_json(*[, ...])\n\n\n\nMaterialProperties.update_forward_refs(**localns)\n\n\n\nMaterialProperties.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nMaterialProperties.model_computed_fields\n\n\n\nMaterialProperties.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nMaterialProperties.model_fields\n\n\n\nMaterialProperties.conductivity\n\n\n\nMaterialProperties.dielectric_loss_tangent\n\n\n\nMaterialProperties.magnetic_loss_tangent\n\n\n\nMaterialProperties.mass_density\n\n\n\nMaterialProperties.permittivity\n\n\n\nMaterialProperties.permeability\n\n\n\nMaterialProperties.poisson_ratio\n\n\n\nMaterialProperties.specific_heat\n\n\n\nMaterialProperties.thermal_conductivity\n\n\n\nMaterialProperties.youngs_modulus\n\n\n\nMaterialProperties.thermal_expansion_coefficient\n\n\n\nMaterialProperties.dc_conductivity\n\n\n\nMaterialProperties.dc_permittivity\n\n\n\nMaterialProperties.dielectric_model_frequency\n\n\n\nMaterialProperties.loss_tangent_at_frequency\n\n\n\nMaterialProperties.permittivity_at_frequency\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the ConnObj object to the correct concrete type.\ncast\nConnObj"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.cast.html#pyedb.grpc.database.hierarchy.pingroup.PinGroup.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "PinGroup.cast()\n\nCast the ConnObj object to the correct concrete type.\n\nReturns\n\nConnObj\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.add_siwave_syz_analysis",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.add_siwave_syz_analysis.html#add_siwave_syz_analysis",
        "title": "add_siwave_syz_analysis",
        "section": "add_siwave_syz_analysis",
        "text": "Add a SIwave AC analysis to EDB.\nSetup name.\nLevel of accuracy of SI slider. The default is 1.\nThe default is 10. The value for this parameter is used for these sweep types:\nlinear count and decade count.\nThis parameter is alternative to step_freq, which is used for a linear scale sweep.\nType of the sweep. The default is 1. Options are:\n0: linear count\n1: linear scale\n2: loc scale\nStarting frequency. The default is 1.\nStopping frequency. The default is 1e9.\nFrequency size of the step. The default is 1e6.\nWhether the sweep is discrete. The default is False.\nSetup object class.\nadd_siwave_syz_analysis\npython:str\noptional\npython:int\noptional\n1\npython:int\n10\nstep_freq\npython:int\noptional\n1\n0\n1\n2\npython:float\noptional\n1\npython:float\noptional\n1e9\npython:float\noptional\n1e6\noptional\nFalse\npyedb.dotnet.database.edb_data.siwave_simulation_setup_data.SiwaveSYZSimulationSetup"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.add_siwave_syz_analysis",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.add_siwave_syz_analysis.html#pyedb.dotnet.database.siwave.EdbSiwave.add_siwave_syz_analysis",
        "title": "add_siwave_syz_analysis > add_siwave_syz_analysis > add_siwave_syz_analysis",
        "section": "add_siwave_syz_analysis > add_siwave_syz_analysis",
        "text": "EdbSiwave.add_siwave_syz_analysis(name=None, accuracy_level=1, decade_count=10, sweeptype=1, start_freq=1, stop_freq=1000000000.0, step_freq=1000000.0, discrete_sweep=False)\n\nAdd a SIwave AC analysis to EDB.\n\nParameters\n\nname\n\npython:str optional\n\nSetup name.\n\naccuracy_level\n\npython:int, optional\n\nLevel of accuracy of SI slider. The default is 1.\n\ndecade_count\n\npython:int\n\nThe default is 10. The value for this parameter is used for these sweep types:\nlinear count and decade count.\nThis parameter is alternative to step_freq, which is used for a linear scale sweep.\n\nsweeptype\n\npython:int, optional\n\nType of the sweep. The default is 1. Options are:\n\n0: linear count\n\n1: linear scale\n\n2: loc scale\n\nstart_freq\n\npython:float, optional\n\nStarting frequency. The default is 1.\n\nstop_freq\n\npython:float, optional\n\nStopping frequency. The default is 1e9.\n\nstep_freq\n\npython:float, optional\n\nFrequency size of the step. The default is 1e6.\n\ndiscrete_sweep\n\nbool, optional\n\nWhether the sweep is discrete. The default is False.\n\nReturns\n\npyedb.dotnet.database.edb_data.siwave_simulation_setup_data.SiwaveSYZSimulationSetup\n\nSetup object class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.run_dc_simulation",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.run_dc_simulation.html#run_dc_simulation",
        "title": "run_dc_simulation",
        "section": "run_dc_simulation",
        "text": "Run DC simulation.\nrun_dc_simulation"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.run_dc_simulation",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.run_dc_simulation.html#pyedb.siwave.Siwave.run_dc_simulation",
        "title": "run_dc_simulation > run_dc_simulation > run_dc_simulation",
        "section": "run_dc_simulation > run_dc_simulation",
        "text": "Siwave.run_dc_simulation(export_dc_power_data_to_icepak=False)\n\nRun DC simulation.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the cell for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nNew string to store in this property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.set_product_property.html#pyedb.grpc.database.layout.cell.Cell.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "Cell.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the cell for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nNew string to store in this property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_dcr_settings.HFSSDCRSettings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_dcr_settings.HFSSDCRSettings.html#hfssdcrsettings",
        "title": "HFSSDCRSettings",
        "section": "HFSSDCRSettings",
        "text": "PyEDB-core HFSS DC settings class.\nHFSSDCRSettings"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_dcr_settings.HFSSDCRSettings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_dcr_settings.HFSSDCRSettings.html#pyedb.grpc.database.simulation_setup.hfss_dcr_settings.HFSSDCRSettings",
        "title": "HFSSDCRSettings > HFSSDCRSettings > HFSSDCRSettings",
        "section": "HFSSDCRSettings > HFSSDCRSettings",
        "text": "class pyedb.grpc.database.simulation_setup.hfss_dcr_settings.HFSSDCRSettings(pedb, edb_object)\n\nPyEDB-core HFSS DC settings class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj: The object to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\nfrom_attributes: Whether to extract data from object attributes.\ncontext: Additional context to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nValidationError: If the object could not be validated.\nThe validated model instance.\nmodel_validate"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_validate.html#pyedb.workflows.drc.drc.Rules.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod Rules.model_validate(obj: Any, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\nValidate a pydantic model instance.\n\nArgs:\n\nobj: The object to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\nfrom_attributes: Whether to extract data from object attributes.\ncontext: Additional context to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nRaises:\n\nValidationError: If the object could not be validated.\n\nReturns:\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.update_materials_from_sys_library",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.update_materials_from_sys_library.html#update_materials_from_sys_library",
        "title": "update_materials_from_sys_library",
        "section": "update_materials_from_sys_library",
        "text": "Update material properties from syslib AMAT file.\nupdate_materials_from_sys_library"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.update_materials_from_sys_library",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.update_materials_from_sys_library.html#pyedb.grpc.database.definition.materials.Materials.update_materials_from_sys_library",
        "title": "update_materials_from_sys_library > update_materials_from_sys_library > update_materials_from_sys_library",
        "section": "update_materials_from_sys_library > update_materials_from_sys_library",
        "text": "Materials.update_materials_from_sys_library(update_all: bool = True, material_name: str | list | None = None)\n\nUpdate material properties from syslib AMAT file.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_is_in_zone",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_is_in_zone.html#set_is_in_zone",
        "title": "set_is_in_zone",
        "section": "set_is_in_zone",
        "text": "Set whether the layer exists in a given zone.\nZone.\nWhether the layer exists in this zone.\nset_is_in_zone\npython:int\npython:True"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_is_in_zone",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_is_in_zone.html#pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_is_in_zone",
        "title": "set_is_in_zone > set_is_in_zone > set_is_in_zone",
        "section": "set_is_in_zone > set_is_in_zone",
        "text": "StackupLayer.set_is_in_zone(zone, in_zone=True)\n\nSet whether the layer exists in a given zone.\n\nParameters\n\nzone\n\npython:int\n\nZone.\n\nin_zone\n\nbool, default: python:True\n\nWhether the layer exists in this zone.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_layer_range",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_layer_range.html#set_layer_range",
        "title": "set_layer_range",
        "section": "set_layer_range",
        "text": "Set the top and bottom layers of the padstack instance.\nTop layer of the padstack instance.\nBottom layer of the padstack instance.\nset_layer_range\nLayer\nLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_layer_range",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_layer_range.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.set_layer_range",
        "title": "set_layer_range > set_layer_range > set_layer_range",
        "section": "set_layer_range > set_layer_range",
        "text": "PadstackInstance.set_layer_range(top_layer: Layer, bottom_layer: Layer)\n\nSet the top and bottom layers of the padstack instance.\n\nParameters\n\ntop_layer\n\nLayer\n\nTop layer of the padstack instance.\n\nbottom_layer\n\nLayer\n\nBottom layer of the padstack instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFile",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFile.html#controlfile",
        "title": "ControlFile",
        "section": "ControlFile",
        "text": "Control File Class. It helps the creation and modification of edb xml control files.\nControlFile.parse_layer_map(layer_map)\nParse layer map and adds info to the stackup info.\nControlFile.parse_technology(tecnhology[, ...])\nParse technology files using Helic and convert it to xml file.\nControlFile.parse_xml(xml_input)\nParse an xml and populate the class with materials and Stackup only.\nControlFile.write_xml(xml_output)\nWrite xml to output file\nControlFile\nControlFile.parse_layer_map\nControlFile.parse_technology\nControlFile.parse_xml\nControlFile.write_xml"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFile",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFile.html#pyedb.grpc.database.utility.xml_control_file.ControlFile",
        "title": "ControlFile > ControlFile > ControlFile",
        "section": "ControlFile > ControlFile",
        "text": "class pyedb.grpc.database.utility.xml_control_file.ControlFile(xml_input=None, tecnhology=None, layer_map=None)\n\nControl File Class. It helps the creation and modification of edb xml control files.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nControlFile.parse_layer_map(layer_map)\n\nParse layer map and adds info to the stackup info.\n\nControlFile.parse_technology(tecnhology[, ...])\n\nParse technology files using Helic and convert it to xml file.\n\nControlFile.parse_xml(xml_input)\n\nParse an xml and populate the class with materials and Stackup only.\n\nControlFile.write_xml(xml_output)\n\nWrite xml to output file\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.get_simulation_settings",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.get_simulation_settings.html#get_simulation_settings",
        "title": "get_simulation_settings",
        "section": "get_simulation_settings",
        "text": "get_simulation_settings"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.get_simulation_settings",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.get_simulation_settings.html#pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.get_simulation_settings",
        "title": "get_simulation_settings > get_simulation_settings > get_simulation_settings",
        "section": "get_simulation_settings > get_simulation_settings",
        "text": "HFSSPISimulationSetup.get_simulation_settings()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.add_siwave_dc_analysis",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.add_siwave_dc_analysis.html#add_siwave_dc_analysis",
        "title": "add_siwave_dc_analysis",
        "section": "add_siwave_dc_analysis",
        "text": "Add a Siwave DC analysis in EDB.\nIf a setup is present, it is deleted and replaced with\nactual settings.\nSource Reference to Ground settings works only from 2021.2\nSetup name.\nSetup object class.\nadd_siwave_dc_analysis\npython:str\noptional\npyedb.dotnet.database.edb_data.siwave_simulation_setup_data.SiwaveDCSimulationSetup"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.add_siwave_dc_analysis",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.add_siwave_dc_analysis.html#pyedb.dotnet.database.siwave.EdbSiwave.add_siwave_dc_analysis",
        "title": "add_siwave_dc_analysis > add_siwave_dc_analysis > add_siwave_dc_analysis",
        "section": "add_siwave_dc_analysis > add_siwave_dc_analysis",
        "text": "EdbSiwave.add_siwave_dc_analysis(name=None)\n\nAdd a Siwave DC analysis in EDB.\n\nIf a setup is present, it is deleted and replaced with\nactual settings.\n\nSource Reference to Ground settings works only from 2021.2\n\nParameters\n\nname\n\npython:str, optional\n\nSetup name.\n\nReturns\n\npyedb.dotnet.database.edb_data.siwave_simulation_setup_data.SiwaveDCSimulationSetup\n\nSetup object class.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb(\"pathtoaedb\", edbversion=\"2021.2\")\n>>> edb.siwave.add_siwave_ac_analysis()\n>>> edb.siwave.add_siwave_dc_analysis2(\"my_setup\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.get_anisotropic_thermal_modifier",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.get_anisotropic_thermal_modifier.html#get_anisotropic_thermal_modifier",
        "title": "get_anisotropic_thermal_modifier",
        "section": "get_anisotropic_thermal_modifier",
        "text": "Get the thermal modifier of an anisotropic material property.\nMaterial property to get the thermal modifier of.\nAnisotropic component ID of the             material property to get the thermal modifier of.\nget_anisotropic_thermal_modifier\nMaterialProperty\npython:int\nMaterialPropertyThermalModifier"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.get_anisotropic_thermal_modifier",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.get_anisotropic_thermal_modifier.html#pyedb.grpc.database.definition.materials.Material.get_anisotropic_thermal_modifier",
        "title": "get_anisotropic_thermal_modifier > get_anisotropic_thermal_modifier > get_anisotropic_thermal_modifier",
        "section": "get_anisotropic_thermal_modifier > get_anisotropic_thermal_modifier",
        "text": "Material.get_anisotropic_thermal_modifier(material_property_id, component_id)\n\nGet the thermal modifier of an anisotropic material property.\n\nParameters\n\nmaterial_property_id\n\nMaterialProperty\n\nMaterial property to get the thermal modifier of.\n\ncomponent_id\n\npython:int\n\nAnisotropic component ID of the             material property to get the thermal modifier of.\n\nReturns\n\nMaterialPropertyThermalModifier\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_component_placement_vector",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_component_placement_vector.html#get_component_placement_vector",
        "title": "get_component_placement_vector",
        "section": "get_component_placement_vector",
        "text": "Get the placement vector between 2 components.\nMounted component name.\nHosting component name.\nMounted component Pin 1 name.\nMounted component Pin 2 name.\nHosted component Pin 1 name.\nHosted component Pin 2 name.\nEither if the mounted component will be flipped or not.\nTuple of Vector offset, rotation and solder height.\nget_component_placement_vector\npython:str\npython:str\npython:str\npython:str\noptional\npython:tuple"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_component_placement_vector",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_component_placement_vector.html#pyedb.dotnet.database.components.Components.get_component_placement_vector",
        "title": "get_component_placement_vector > get_component_placement_vector > get_component_placement_vector",
        "section": "get_component_placement_vector > get_component_placement_vector",
        "text": "Components.get_component_placement_vector(mounted_component, hosting_component, mounted_component_pin1, mounted_component_pin2, hosting_component_pin1, hosting_component_pin2, flipped=False)\n\nGet the placement vector between 2 components.\n\nParameters\n\nmounted_component\n\nedb.cell.hierarchy._hierarchy.Component\n\nMounted component name.\n\nhosting_component\n\nedb.cell.hierarchy._hierarchy.Component\n\nHosting component name.\n\nmounted_component_pin1\n\npython:str\n\nMounted component Pin 1 name.\n\nmounted_component_pin2\n\npython:str\n\nMounted component Pin 2 name.\n\nhosting_component_pin1\n\npython:str\n\nHosted component Pin 1 name.\n\nhosting_component_pin2\n\npython:str\n\nHosted component Pin 2 name.\n\nflipped\n\nbool, optional\n\nEither if the mounted component will be flipped or not.\n\nReturns\n\npython:tuple\n\nTuple of Vector offset, rotation and solder height.\n\nExamples\n\n>>> edb1 = Edb(edbpath=targetfile1, edbversion=\"2021.2\")\n>>> hosting_cmp = edb1.components.get_component_by_name(\"U100\")\n>>> mounted_cmp = edb2.components.get_component_by_name(\"BGA\")\n>>> vector, rotation, solder_ball_height = edb1.components.get_component_placement_vector(\n...     mounted_component=mounted_cmp,\n...     hosting_component=hosting_cmp,\n...     mounted_component_pin1=\"A12\",\n...     mounted_component_pin2=\"A14\",\n...     hosting_component_pin1=\"A12\",\n...     hosting_component_pin2=\"A14\",\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.html#nets",
        "title": "Nets",
        "section": "Nets",
        "text": "Manages EDB methods for nets management accessible from Edb.nets property.\n# Close EDB session\nNets.classify_nets([power_nets, signal_nets])\nReassign net classifications as power/ground or signal.\nNets.delete(netlist)\nDelete one or more nets from the layout.\nNets.eligible_power_nets([threshold])\nIdentify nets eligible for power/ground classification based on area ratio.\nNets.find_or_create_net([net_name, ...])\nFind or create a net based on given criteria.\nNets.get_dcconnected_net_list([ground_nets, ...])\nGet nets connected to DC through inductors and low-value resistors.\nNets.get_net_by_name(net_name)\nFind a net by name.\nNets.get_powertree(power_net_name, ground_nets)\nRetrieve power tree for a given power net.\nNets.is_net_in_component(component_name, ...)\nCheck if a net belongs to a component.\nNets.is_power_gound_net(netname_list)\nCheck if any net in a list is a power/ground net.\nNets.merge_nets_polygons(net_names_list)\nMerge polygons for specified nets on each layer.\nNets.plot([nets, layers, color_by_net, ...])\nPlot a Net to Matplotlib 2D Chart.\nNets\nNets.classify_nets\nNets.delete\nNets.eligible_power_nets\nNets.find_or_create_net\nNets.get_dcconnected_net_list\nNets.get_net_by_name\nNets.get_powertree\nNets.is_net_in_component\nNets.is_power_gound_net\nNets.merge_nets_polygons\nNets.plot"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.html#pyedb.grpc.database.nets.Nets",
        "title": "Nets > Nets > Nets",
        "section": "Nets > Nets",
        "text": "class pyedb.grpc.database.nets.Nets(p_edb: Any)\n\nManages EDB methods for nets management accessible from Edb.nets property.\n\nExamples\n\n>>> from pyedb import Edb\n\n>>> # Initialize EDB session\n>>> edbapp = Edb(edbversion=\"2025.2\")\n\n>>> # Access Nets class\n>>> nets = edbapp.nets\n\n>>> # =================\n>>> # Property examples\n>>> # =================\n\n>>> # Get all nets dictionary\n>>> all_nets = nets.nets\n>>> print(\"All nets:\", list(all_nets.keys()))\n\n>>> # Get net names list\n>>> net_names = nets.netlist\n>>> print(\"Net names:\", net_names)\n\n>>> # Get signal nets\n>>> signal_nets = nets.signal\n>>> print(\"Signal nets:\", list(signal_nets.keys()))\n\n>>> # Get power/ground nets\n>>> power_nets = nets.power\n>>> print(\"Power nets:\", list(power_nets.keys()))\n\n>>> # Get nets by components\n>>> nets_by_comps = nets.nets_by_components\n>>> print(\"Nets by components:\", nets_by_comps)\n\n>>> # Get components by nets\n>>> comps_by_nets = nets.components_by_nets\n>>> print(\"Components by nets:\", comps_by_nets)\n\n>>> # ===============\n>>> # Method examples\n>>> # ===============\n\n>>> # Get net by name\n>>> net_obj = nets[\"GND\"]\n>>> print(f\"Net object: {net_obj.name}\")\n\n>>> # Check net existence\n>>> if \"PCIe_RX\" in nets:\n>>>    print(\"PCIe_RX exists\")\n\n>>> # Identify eligible power nets\n>>> eligible_pwr = nets.eligible_power_nets(threshold=0.25)\n>>> print(\"Eligible power nets:\", [net.name for net in eligible_pwr])\n\n>>> # Generate extended nets (deprecated)\n>>> nets.generate_extended_nets(resistor_below=5, inductor_below=0.5, capacitor_above=0.1)\n\n>>> # Classify nets\n>>> nets.classify_nets(power_nets=[\"VDD_CPU\", \"VDD_MEM\"], signal_nets=[\"PCIe_TX\", \"ETH_RX\"])\n\n>>> # Check power/ground status\n>>> is_power = nets.is_power_gound_net([\"VDD_CPU\", \"PCIe_TX\"])\n>>> print(\"Is power net:\", is_power)\n\n>>> # Get DC-connected nets\n>>> dc_connected = nets.get_dcconnected_net_list(ground_nets=[\"GND\"], res_value=0.002)\n    print(\"DC-connected nets:\", dc_connected)\n\n>>> # Get power tree\n>>> comp_list, columns, net_group = nets.get_powertree(power_net_name=\"VDD_CPU\", ground_nets=[\"GND\"])\n>>> print(\"Power tree components:\", comp_list)\n\n>>> # Find net by name\n>>> found_net = nets.get_net_by_name(\"PCIe_TX\")\n>>> print(f\"Found net: {found_net.name}\")\n\n>>> # Delete nets\n>>> deleted = nets.delete([\"Unused_Net\", \"Test_Net\"])\n>>> print(\"Deleted nets:\", deleted)\n\n>>> # Find or create net\n>>> new_net = nets.find_or_create_net(net_name=\"New_Net\")\n>>> print(f\"Created net: {new_net.name}\")\n\n>>> # Check net-component association\n>>> in_component = nets.is_net_in_component(\"U1\", \"VDD_CPU\")\n>>> print(\"Net in component:\", in_component)\n\n>>> # Find and fix disjoint nets (deprecated)\n>>> fixed_nets = nets.find_and_fix_disjoint_nets(net_list=[\"PCIe_TX\"], clean_disjoints_less_than=1e-6)\n>>> print(\"Fixed nets:\", fixed_nets)\n\n>>> # Merge net polygons\n>>> merged = nets.merge_nets_polygons([\"VDD_CPU\", \"VDD_MEM\"])\n>>> print(\"Polygons merged:\", merged)\n\n# Close EDB session\n\n>>> edbapp.close()\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nNets.classify_nets([power_nets, signal_nets])\n\nReassign net classifications as power/ground or signal.\n\nNets.delete(netlist)\n\nDelete one or more nets from the layout.\n\nNets.eligible_power_nets([threshold])\n\nIdentify nets eligible for power/ground classification based on area ratio.\n\nNets.find_or_create_net([net_name, ...])\n\nFind or create a net based on given criteria.\n\nNets.get_dcconnected_net_list([ground_nets, ...])\n\nGet nets connected to DC through inductors and low-value resistors.\n\nNets.get_net_by_name(net_name)\n\nFind a net by name.\n\nNets.get_powertree(power_net_name, ground_nets)\n\nRetrieve power tree for a given power net.\n\nNets.is_net_in_component(component_name, ...)\n\nCheck if a net belongs to a component.\n\nNets.is_power_gound_net(netname_list)\n\nCheck if any net in a list is a power/ground net.\n\nNets.merge_nets_polygons(net_names_list)\n\nMerge polygons for specified nets on each layer.\n\nNets.plot([nets, layers, color_by_net, ...])\n\nPlot a Net to Matplotlib 2D Chart.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.is_in_pin_group",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.is_in_pin_group.html#is_in_pin_group",
        "title": "is_in_pin_group",
        "section": "is_in_pin_group",
        "text": "Determine if the padstack instance is in a given pin group.\nPin group to check if the padstack instance is in it.\nWhether the padstack instance is in a pin group.\nis_in_pin_group\nPinGroup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.is_in_pin_group",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.is_in_pin_group.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.is_in_pin_group",
        "title": "is_in_pin_group > is_in_pin_group > is_in_pin_group",
        "section": "is_in_pin_group > is_in_pin_group",
        "text": "PadstackInstance.is_in_pin_group(pin_group: PinGroup) -> bool\n\nDetermine if the padstack instance is in a given pin group.\n\nParameters\n\npin_group\n\nPinGroup\n\nPin group to check if the padstack instance is in it.\n\nReturns\n\nbool\n\nWhether the padstack instance is in a pin group.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.product_solver_names",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.product_solver_names.html#product_solver_names",
        "title": "product_solver_names",
        "section": "product_solver_names",
        "text": "Get the list of solver names.\nID of the product.\nproduct_solver_names\nProductIdType\npython:list\nof\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.product_solver_names",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.product_solver_names.html#pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.product_solver_names",
        "title": "product_solver_names > product_solver_names > product_solver_names",
        "section": "product_solver_names > product_solver_names",
        "text": "PinGroupTerminal.product_solver_names(product_id)\n\nGet the list of solver names.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nReturns\n\npython:list of python:str\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.get_product_property.html#pyedb.grpc.database.ports.ports.GapPort.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "GapPort.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_polygons_by_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_polygons_by_layer.html#get_polygons_by_layer",
        "title": "get_polygons_by_layer",
        "section": "get_polygons_by_layer",
        "text": "Retrieve polygons by layer.\nLayer name.\nList of net names to filter by.\nList of polygon objects.\nget_polygons_by_layer\npython:str\npython:list\noptional\npython:list"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_polygons_by_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.get_polygons_by_layer.html#pyedb.grpc.database.modeler.Modeler.get_polygons_by_layer",
        "title": "get_polygons_by_layer > get_polygons_by_layer > get_polygons_by_layer",
        "section": "get_polygons_by_layer > get_polygons_by_layer",
        "text": "Modeler.get_polygons_by_layer(layer_name: str, net_list: List[str] | None = None) -> List[Primitive]\n\nRetrieve polygons by layer.\n\nParameters\n\nlayer_name\n\npython:str\n\nLayer name.\n\nnet_list\n\npython:list, optional\n\nList of net names to filter by.\n\nReturns\n\npython:list\n\nList of polygon objects.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.html#copperbalance",
        "title": "CopperBalance",
        "section": "CopperBalance",
        "text": "Copper-density balance rule.\nCopperBalance.construct([_fields_set])\n\nCopperBalance.copy(*[, include, exclude, ...])\nReturns a copy of the model.\nCopperBalance.dict(*[, include, exclude, ...])\n\nCopperBalance.from_orm(obj)\n\nCopperBalance.json(*[, include, exclude, ...])\n\nCopperBalance.model_construct([_fields_set])\nCreates a new instance of the Model class with validated data.\nCopperBalance.model_copy(*[, update, deep])\n!!! abstract \"Usage Documentation\"\nCopperBalance.model_dump(*[, mode, include, ...])\n!!! abstract \"Usage Documentation\"\nCopperBalance.model_dump_json(*[, indent, ...])\n!!! abstract \"Usage Documentation\"\nCopperBalance.model_json_schema([by_alias, ...])\nGenerates a JSON schema for a model class.\nCopperBalance.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nCopperBalance.model_post_init(context, /)\nOverride this method to perform additional initialization after __init__ and model_construct.\nCopperBalance.model_rebuild(*[, force, ...])\nTry to rebuild the pydantic-core schema for the model.\nCopperBalance.model_validate(obj, *[, ...])\nValidate a pydantic model instance.\nCopperBalance.model_validate_json(json_data, *)\n!!! abstract \"Usage Documentation\"\nCopperBalance.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nCopperBalance.parse_file(path, *[, ...])\n\nCopperBalance.parse_obj(obj)\n\nCopperBalance.parse_raw(b, *[, ...])\n\nCopperBalance.schema([by_alias, ref_template])\n\nCopperBalance.schema_json(*[, by_alias, ...])\n\nCopperBalance.update_forward_refs(**localns)\n\nCopperBalance.validate(value)\n\nCopperBalance.model_computed_fields\n\nCopperBalance.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nCopperBalance.model_fields\n\nCopperBalance.name\n\nCopperBalance.max_percent\n\nCopperBalance.layers\n\nCopperBalance\nCopperBalance.construct\nCopperBalance.copy\nCopperBalance.dict\nCopperBalance.from_orm\nCopperBalance.json\nCopperBalance.model_construct\nCopperBalance.model_copy\nCopperBalance.model_dump\nCopperBalance.model_dump_json\nCopperBalance.model_json_schema\nCopperBalance.model_parametrized_name\nCopperBalance.model_post_init\nCopperBalance.model_rebuild\nCopperBalance.model_validate\nCopperBalance.model_validate_json\nCopperBalance.model_validate_strings\nCopperBalance.parse_file\nCopperBalance.parse_obj\nCopperBalance.parse_raw\nCopperBalance.schema\nCopperBalance.schema_json\nCopperBalance.update_forward_refs\nCopperBalance.validate\nCopperBalance.model_computed_fields\nCopperBalance.model_config\nCopperBalance.model_fields\nCopperBalance.name\nCopperBalance.max_percent\nCopperBalance.layers"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.html#pyedb.workflows.drc.drc.CopperBalance",
        "title": "CopperBalance > CopperBalance > CopperBalance",
        "section": "CopperBalance > CopperBalance",
        "text": "class pyedb.workflows.drc.drc.CopperBalance(*, name: str, max_percent: int, layers: List[str])\n\nCopper-density balance rule.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nCopperBalance.construct([_fields_set])\n\n\n\nCopperBalance.copy(*[, include, exclude, ...])\n\nReturns a copy of the model.\n\nCopperBalance.dict(*[, include, exclude, ...])\n\n\n\nCopperBalance.from_orm(obj)\n\n\n\nCopperBalance.json(*[, include, exclude, ...])\n\n\n\nCopperBalance.model_construct([_fields_set])\n\nCreates a new instance of the Model class with validated data.\n\nCopperBalance.model_copy(*[, update, deep])\n\n!!! abstract \"Usage Documentation\"\n\nCopperBalance.model_dump(*[, mode, include, ...])\n\n!!! abstract \"Usage Documentation\"\n\nCopperBalance.model_dump_json(*[, indent, ...])\n\n!!! abstract \"Usage Documentation\"\n\nCopperBalance.model_json_schema([by_alias, ...])\n\nGenerates a JSON schema for a model class.\n\nCopperBalance.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nCopperBalance.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nCopperBalance.model_rebuild(*[, force, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nCopperBalance.model_validate(obj, *[, ...])\n\nValidate a pydantic model instance.\n\nCopperBalance.model_validate_json(json_data, *)\n\n!!! abstract \"Usage Documentation\"\n\nCopperBalance.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nCopperBalance.parse_file(path, *[, ...])\n\n\n\nCopperBalance.parse_obj(obj)\n\n\n\nCopperBalance.parse_raw(b, *[, ...])\n\n\n\nCopperBalance.schema([by_alias, ref_template])\n\n\n\nCopperBalance.schema_json(*[, by_alias, ...])\n\n\n\nCopperBalance.update_forward_refs(**localns)\n\n\n\nCopperBalance.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nCopperBalance.model_computed_fields\n\n\n\nCopperBalance.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nCopperBalance.model_fields\n\n\n\nCopperBalance.name\n\n\n\nCopperBalance.max_percent\n\n\n\nCopperBalance.layers\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.remove_property",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.remove_property.html#remove_property",
        "title": "remove_property",
        "section": "remove_property",
        "text": "Remove a property from the material definition.\nMaterial property to be removed.\nremove_property\nMaterialProperty"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.remove_property",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.remove_property.html#pyedb.grpc.database.definition.materials.Material.remove_property",
        "title": "remove_property > remove_property > remove_property",
        "section": "remove_property > remove_property",
        "text": "Material.remove_property(material_property: MaterialProperty)\n\nRemove a property from the material definition.\n\nParameters\n\nmaterial_property\n\nMaterialProperty\n\nMaterial property to be removed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_product_property",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layer collection for a given product ID and attribute ID.\nProduct ID.\nAttribute ID.\nProduct property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_product_property",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_product_property.html#pyedb.grpc.database.stackup.Stackup.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "Stackup.get_product_property(prod_id, attr_it)\n\nGet the product property of the layer collection for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nProduct ID.\n\nattr_it\n\npython:int\n\nAttribute ID.\n\nReturns\n\npython:str\n\nProduct property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_q3d",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_q3d.html#export_q3d",
        "title": "export_q3d",
        "section": "export_q3d",
        "text": "Export EDB to Q3D.\nFull path and name for saving the AEDT file.\nList of nets to export only if certain ones are to be exported.\nThe default is None, in which case all nets are eported.\nNumber of cores to use for the export. The default is None.\nName of the AEDT output file without the .aedt extension. The default is None,\nin which case the default name is used.\nOpen Siwave in embedding mode. User will only see Siwave Icon but UI will be hidden.\nFull path to the AEDT file.\nexport_q3d\npython:str\npython:list\noptional\nNone\npython:int\noptional\nNone\npython:str\noptional\n.aedt\nNone\noptional\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_q3d",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_q3d.html#pyedb.dotnet.edb.Edb.export_q3d",
        "title": "export_q3d > export_q3d > export_q3d",
        "section": "export_q3d > export_q3d",
        "text": "Edb.export_q3d(path_to_output, net_list=None, num_cores=None, aedt_file_name=None, hidden=False)\n\nExport EDB to Q3D.\n\nParameters\n\npath_to_output\n\npython:str\n\nFull path and name for saving the AEDT file.\n\nnet_list\n\npython:list, optional\n\nList of nets to export only if certain ones are to be exported.\nThe default is None, in which case all nets are eported.\n\nnum_cores\n\npython:int, optional\n\nNumber of cores to use for the export. The default is None.\n\naedt_file_name\n\npython:str, optional\n\nName of the AEDT output file without the .aedt extension. The default is None,\nin which case the default name is used.\n\nhidden\n\nbool, optional\n\nOpen Siwave in embedding mode. User will only see Siwave Icon but UI will be hidden.\n\nReturns\n\npython:str\n\nFull path to the AEDT file.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb(edbpath=\"C:\\temp\\myproject.aedb\", version=\"2021.2\")\n>>> options_config = {\"UNITE_NETS\": 1, \"LAUNCH_Q3D\": 0}\n>>> edb.write_export3d_option_config_file(\"C:\\temp\", options_config)\n>>> edb.export_q3d(\"C:\\temp\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.html#minclearance",
        "title": "MinClearance",
        "section": "MinClearance",
        "text": "Minimum clearance between two nets.\nMinClearance.construct([_fields_set])\n\nMinClearance.copy(*[, include, exclude, ...])\nReturns a copy of the model.\nMinClearance.dict(*[, include, exclude, ...])\n\nMinClearance.from_orm(obj)\n\nMinClearance.json(*[, include, exclude, ...])\n\nMinClearance.model_construct([_fields_set])\nCreates a new instance of the Model class with validated data.\nMinClearance.model_copy(*[, update, deep])\n!!! abstract \"Usage Documentation\"\nMinClearance.model_dump(*[, mode, include, ...])\n!!! abstract \"Usage Documentation\"\nMinClearance.model_dump_json(*[, indent, ...])\n!!! abstract \"Usage Documentation\"\nMinClearance.model_json_schema([by_alias, ...])\nGenerates a JSON schema for a model class.\nMinClearance.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nMinClearance.model_post_init(context, /)\nOverride this method to perform additional initialization after __init__ and model_construct.\nMinClearance.model_rebuild(*[, force, ...])\nTry to rebuild the pydantic-core schema for the model.\nMinClearance.model_validate(obj, *[, ...])\nValidate a pydantic model instance.\nMinClearance.model_validate_json(json_data, *)\n!!! abstract \"Usage Documentation\"\nMinClearance.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nMinClearance.parse_file(path, *[, ...])\n\nMinClearance.parse_obj(obj)\n\nMinClearance.parse_raw(b, *[, content_type, ...])\n\nMinClearance.schema([by_alias, ref_template])\n\nMinClearance.schema_json(*[, by_alias, ...])\n\nMinClearance.update_forward_refs(**localns)\n\nMinClearance.validate(value)\n\nMinClearance.model_computed_fields\n\nMinClearance.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nMinClearance.model_fields\n\nMinClearance.name\n\nMinClearance.value\n\nMinClearance.net1\n\nMinClearance.net2\n\nMinClearance\nMinClearance.construct\nMinClearance.copy\nMinClearance.dict\nMinClearance.from_orm\nMinClearance.json\nMinClearance.model_construct\nMinClearance.model_copy\nMinClearance.model_dump\nMinClearance.model_dump_json\nMinClearance.model_json_schema\nMinClearance.model_parametrized_name\nMinClearance.model_post_init\nMinClearance.model_rebuild\nMinClearance.model_validate\nMinClearance.model_validate_json\nMinClearance.model_validate_strings\nMinClearance.parse_file\nMinClearance.parse_obj\nMinClearance.parse_raw\nMinClearance.schema\nMinClearance.schema_json\nMinClearance.update_forward_refs\nMinClearance.validate\nMinClearance.model_computed_fields\nMinClearance.model_config\nMinClearance.model_fields\nMinClearance.name\nMinClearance.value\nMinClearance.net1\nMinClearance.net2"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.html#pyedb.workflows.drc.drc.MinClearance",
        "title": "MinClearance > MinClearance > MinClearance",
        "section": "MinClearance > MinClearance",
        "text": "class pyedb.workflows.drc.drc.MinClearance(*, name: str, value: str, net1: str, net2: str)\n\nMinimum clearance between two nets.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nMinClearance.construct([_fields_set])\n\n\n\nMinClearance.copy(*[, include, exclude, ...])\n\nReturns a copy of the model.\n\nMinClearance.dict(*[, include, exclude, ...])\n\n\n\nMinClearance.from_orm(obj)\n\n\n\nMinClearance.json(*[, include, exclude, ...])\n\n\n\nMinClearance.model_construct([_fields_set])\n\nCreates a new instance of the Model class with validated data.\n\nMinClearance.model_copy(*[, update, deep])\n\n!!! abstract \"Usage Documentation\"\n\nMinClearance.model_dump(*[, mode, include, ...])\n\n!!! abstract \"Usage Documentation\"\n\nMinClearance.model_dump_json(*[, indent, ...])\n\n!!! abstract \"Usage Documentation\"\n\nMinClearance.model_json_schema([by_alias, ...])\n\nGenerates a JSON schema for a model class.\n\nMinClearance.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nMinClearance.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nMinClearance.model_rebuild(*[, force, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nMinClearance.model_validate(obj, *[, ...])\n\nValidate a pydantic model instance.\n\nMinClearance.model_validate_json(json_data, *)\n\n!!! abstract \"Usage Documentation\"\n\nMinClearance.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nMinClearance.parse_file(path, *[, ...])\n\n\n\nMinClearance.parse_obj(obj)\n\n\n\nMinClearance.parse_raw(b, *[, content_type, ...])\n\n\n\nMinClearance.schema([by_alias, ref_template])\n\n\n\nMinClearance.schema_json(*[, by_alias, ...])\n\n\n\nMinClearance.update_forward_refs(**localns)\n\n\n\nMinClearance.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nMinClearance.model_computed_fields\n\n\n\nMinClearance.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nMinClearance.model_fields\n\n\n\nMinClearance.name\n\n\n\nMinClearance.value\n\n\n\nMinClearance.net1\n\n\n\nMinClearance.net2\n\n\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.place_voltage_probe",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.place_voltage_probe.html#place_voltage_probe",
        "title": "place_voltage_probe",
        "section": "place_voltage_probe",
        "text": "Place a voltage probe between two points.\nName of the probe.\nName of the positive net.\nLocation of the positive terminal.\nLayer of the positive terminal.\nName of the negative net.\nLocation of the negative terminal.\nLayer of the negative terminal.\nplace_voltage_probe\npython:str\npython:list\npython:list\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.place_voltage_probe",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.place_voltage_probe.html#pyedb.dotnet.database.siwave.EdbSiwave.place_voltage_probe",
        "title": "place_voltage_probe > place_voltage_probe > place_voltage_probe",
        "section": "place_voltage_probe > place_voltage_probe",
        "text": "EdbSiwave.place_voltage_probe(name, positive_net_name, positive_location, positive_layer, negative_net_name, negative_location, negative_layer)\n\nPlace a voltage probe between two points.\n\nParameters\n\nname\n\nstr,\n\nName of the probe.\n\npositive_net_name\n\npython:str\n\nName of the positive net.\n\npositive_location\n\npython:list\n\nLocation of the positive terminal.\n\npositive_layer\n\nstr,\n\nLayer of the positive terminal.\n\nnegative_net_name\n\nstr,\n\nName of the negative net.\n\nnegative_location\n\npython:list\n\nLocation of the negative terminal.\n\nnegative_layer\n\npython:str\n\nLayer of the negative terminal.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues: Trusted or pre-validated data dictionary.\nA new instance of the Model class with validated data.\nmodel_construct"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_construct.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod DiffPairLengthMatch.model_construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nArgs:\n\n_fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues: Trusted or pre-validated data dictionary.\n\nReturns:\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.find_by_id.html#find_by_id",
        "title": "find_by_id",
        "section": "find_by_id",
        "text": "Find a Connectable object by database ID in a given layout.\nLayout to search for the Connectable object.\nDatabase ID.\nConnectable object with the given database ID.\nfind_by_id\nLayout\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.find_by_id.html#pyedb.grpc.database.primitive.rectangle.Rectangle.find_by_id",
        "title": "find_by_id > find_by_id > find_by_id",
        "section": "find_by_id > find_by_id",
        "text": "classmethod Rectangle.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the Connectable object.\n\nuid\n\npython:int\n\nDatabase ID.\n\nReturns\n\nConnectable\n\nConnectable object with the given database ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileLayer",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileLayer.html#controlfilelayer",
        "title": "ControlFileLayer",
        "section": "ControlFileLayer",
        "text": "ControlFileLayer"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileLayer",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileLayer.html#pyedb.dotnet.database.edb_data.control_file.ControlFileLayer",
        "title": "ControlFileLayer > ControlFileLayer > ControlFileLayer",
        "section": "ControlFileLayer > ControlFileLayer",
        "text": "class pyedb.dotnet.database.edb_data.control_file.ControlFileLayer(name, properties)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_hfsspi_setup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_hfsspi_setup.html#create_hfsspi_setup",
        "title": "create_hfsspi_setup",
        "section": "create_hfsspi_setup",
        "text": "Create an HFSS PI simulation setup from a template.\nSetup name.\ncreate_hfsspi_setup\npython:str\noptional\nlegacy.database.edb_data.hfss_pi_simulation_setup_data.HFSSPISimulationSetup when succeeded, ``False`\nwhen"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_hfsspi_setup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_hfsspi_setup.html#pyedb.dotnet.edb.Edb.create_hfsspi_setup",
        "title": "create_hfsspi_setup > create_hfsspi_setup > create_hfsspi_setup",
        "section": "create_hfsspi_setup > create_hfsspi_setup",
        "text": "Edb.create_hfsspi_setup(name=None)\n\nCreate an HFSS PI simulation setup from a template.\n\nParameters\n\nname\n\npython:str, optional\n\nSetup name.\n\nReturns\n\nlegacy.database.edb_data.hfss_pi_simulation_setup_data.HFSSPISimulationSetup when succeeded, ``False`\n\n\n\nwhen failed.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_current_source_on_pin",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_current_source_on_pin.html#create_current_source_on_pin",
        "title": "create_current_source_on_pin",
        "section": "create_current_source_on_pin",
        "text": "Create a current source.\nPositive Pin.\nNegative Pin.\nValue for the current. The default is 0.1.\nValue for the phase. The default is 0.\nName of the source. The default is \"\".\nSource Name.\ncreate_current_source_on_pin\nObject\nObject\npython:float\noptional\n0.1\noptional\n0\npython:str\noptional\n\"\"\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_current_source_on_pin",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_current_source_on_pin.html#pyedb.dotnet.database.hfss.EdbHfss.create_current_source_on_pin",
        "title": "create_current_source_on_pin > create_current_source_on_pin > create_current_source_on_pin",
        "section": "create_current_source_on_pin > create_current_source_on_pin",
        "text": "EdbHfss.create_current_source_on_pin(pos_pin, neg_pin, current_value=0.1, phase_value=0, source_name='')\n\nCreate a current source.\n\nParameters\n\npos_pin\n\nObject\n\nPositive Pin.\n\nneg_pin\n\nObject\n\nNegative Pin.\n\ncurrent_value\n\npython:float, optional\n\nValue for the current. The default is 0.1.\n\nphase_value\n\noptional\n\nValue for the phase. The default is 0.\n\nsource_name\n\npython:str, optional\n\nName of the source. The default is \"\".\n\nReturns\n\npython:str\n\nSource Name.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", \"project name\", \"release version\")\n>>> pins = edbapp.components.get_pin_from_component(\"U2A5\")\n>>> edbapp.hfss.create_current_source_on_pin(pins[0], pins[1], 50, \"source_name\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "archive",
        "href": "archive.html#legacy-dotnet-api-archived",
        "title": "Legacy DotNet API (Archived)",
        "section": "Legacy DotNet API (Archived)",
        "text": "The ``pyedb.dotnet`` module is deprecated and archived.\nSupport for ‘pyedb.dotnet`` is ending soon.\nIt is strongly encouraged that you\nmigrate to the new gRPC-based client.\nLegacy DotNet API (Archived)"
    },
    {
        "objectID": "archive",
        "href": "archive.html#what-was-the-dotnet-api",
        "title": "Legacy DotNet API (Archived) > What Was the DotNet API?",
        "section": "What Was the DotNet API?",
        "text": "The original implementation of the pyedb.dotnet module was\nbuilt on the Microsoft DotNet framework.\nFuture development are going to use the gRPC client.\nThe new gRPC client addresses numerous cross-platform compatibility issues.\nWhat Was the DotNet API?\npyedb.dotnet"
    },
    {
        "objectID": "archive",
        "href": "archive.html#why-it-was-replaced",
        "title": "Legacy DotNet API (Archived) > Why It Was Replaced",
        "section": "Why It Was Replaced",
        "text": "The new architecture, based on a standalone gRPC service (ansys-edb-core), provides significant advantages:\nCross-Platform: The client can run on Linux, and Windows.\nHeadless Operation: Ideal for servers, Docker, and CI/CD pipelines.\nBetter Performance: The gRPC protocol is more efficient.\nModern and Maintainable: The codebase is cleaner and easier to extend.\nWhy It Was Replaced\nansys-edb-core"
    },
    {
        "objectID": "archive",
        "href": "archive.html#accessing-the-archived-code",
        "title": "Legacy DotNet API (Archived) > Accessing the Archived Code",
        "section": "Accessing the Archived Code",
        "text": "The code for the deprecated dotnet module has been moved to a separate, archived branch in the GitHub repository\nto avoid confusion and keep the main branch clean.\nYou can access the final version of the `dotnet` code here:\nThis code is provided as-is for reference and migration purposes only. Do not use it for\nnew projects. If you need to maintain an old script that uses the dotnet API, your goal should be to migrate it to\nthe gRPC client.\nAccessing the Archived Code\ndotnet\ndotnet"
    },
    {
        "objectID": "archive",
        "href": "archive.html#migration-guide",
        "title": "Legacy DotNet API (Archived) > Migration Guide",
        "section": "Migration Guide",
        "text": "If you have existing scripts using pyedb.dotnet, see the migration_guide for help porting your code to the\nmodern gRPC API.\nMigration Guide"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.add_void",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.add_void.html#add_void",
        "title": "add_void",
        "section": "add_void",
        "text": "Add a void to current primitive.\nTrue if successful, either  False.\nadd_void\npython:list\nPrimitive\npoint\npython:list\nin\nthe\nformat\nof\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.add_void",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.add_void.html#pyedb.grpc.database.primitive.rectangle.Rectangle.add_void",
        "title": "add_void > add_void > add_void",
        "section": "add_void > add_void",
        "text": "Rectangle.add_void(point_list) -> bool\n\nAdd a void to current primitive.\n\nParameters\n\npoint_list\n\npython:list or Primitive             or point python:list in the format of [[x1,y1], [x2,y2],..,[xn,yn]].\n\n\n\nReturns\n\nbool\n\nTrue if successful, either  False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.layout_obj_type.html#pyedb.grpc.database.net.net.Net.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "Net.layout_obj_type = 6\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup.html#raptorxsimulationsetup",
        "title": "RaptorXSimulationSetup",
        "section": "RaptorXSimulationSetup",
        "text": "RaptorX simulation setup.\nRaptorXSimulationSetup.add_frequency_sweep([...])\nAdd frequency sweep.\nRaptorXSimulationSetup.add_sweep([name, ...])\nAdd a HFSS frequency sweep.\nRaptorXSimulationSetup.cast()\nCast the base SimulationSetup object to correct subclass, if possible.\nRaptorXSimulationSetup.create(cell, name)\nCreate a RaptorX simulation setup.\nRaptorXSimulationSetup\nRaptorXSimulationSetup.add_frequency_sweep\nRaptorXSimulationSetup.add_sweep\nRaptorXSimulationSetup.cast\nRaptorXSimulationSetup.create"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup.html#pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup",
        "title": "RaptorXSimulationSetup > RaptorXSimulationSetup > RaptorXSimulationSetup",
        "section": "RaptorXSimulationSetup > RaptorXSimulationSetup",
        "text": "class pyedb.grpc.database.simulation_setup.raptor_x_simulation_setup.RaptorXSimulationSetup(pedb, edb_object)\n\nRaptorX simulation setup.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nRaptorXSimulationSetup.add_frequency_sweep([...])\n\nAdd frequency sweep.\n\nRaptorXSimulationSetup.add_sweep([name, ...])\n\nAdd a HFSS frequency sweep.\n\nRaptorXSimulationSetup.cast()\n\nCast the base SimulationSetup object to correct subclass, if possible.\n\nRaptorXSimulationSetup.create(cell, name)\n\nCreate a RaptorX simulation setup.\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_sim_setup_info",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_sim_setup_info.html#set_sim_setup_info",
        "title": "set_sim_setup_info",
        "section": "set_sim_setup_info",
        "text": "set_sim_setup_info"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_sim_setup_info",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_sim_setup_info.html#pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_sim_setup_info",
        "title": "set_sim_setup_info > set_sim_setup_info > set_sim_setup_info",
        "section": "set_sim_setup_info > set_sim_setup_info",
        "text": "HfssSimulationSetup.set_sim_setup_info(sim_setup_info)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.delete_frequency_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.delete_frequency_sweep.html#delete_frequency_sweep",
        "title": "delete_frequency_sweep",
        "section": "delete_frequency_sweep",
        "text": "Delete a frequency sweep.\ndelete_frequency_sweep"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.delete_frequency_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.delete_frequency_sweep.html#pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.delete_frequency_sweep",
        "title": "delete_frequency_sweep > delete_frequency_sweep > delete_frequency_sweep",
        "section": "delete_frequency_sweep > delete_frequency_sweep",
        "text": "HFSSPISimulationSetup.delete_frequency_sweep(sweep_data)\n\nDelete a frequency sweep.\n\nParameters\n\nsweep_data\n\nEdbFrequencySweep.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.get_product_property_ids.html#pyedb.grpc.database.net.extended_net.ExtendedNet.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "ExtendedNet.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.get_product_property_ids.html#pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "VoltageRegulator.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCAdvancedSettings.get_configurations",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCAdvancedSettings.get_configurations.html#get_configurations",
        "title": "get_configurations",
        "section": "get_configurations",
        "text": "Get all attributes.\nget_configurations\npython:dict"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCAdvancedSettings.get_configurations",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCAdvancedSettings.get_configurations.html#pyedb.dotnet.database.sim_setup_data.io.siwave.DCAdvancedSettings.get_configurations",
        "title": "get_configurations > get_configurations > get_configurations",
        "section": "get_configurations > get_configurations",
        "text": "DCAdvancedSettings.get_configurations()\n\nGet all attributes.\n\nReturns\n\npython:dict\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.parse_obj",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "parse_obj"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.parse_obj",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.parse_obj.html#pyedb.grpc.database.definition.materials.MaterialProperties.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod MaterialProperties.parse_obj(obj: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the rectangle primitive from the layout.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.delete.html#pyedb.grpc.database.primitive.rectangle.Rectangle.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "Rectangle.delete()\n\nDelete the rectangle primitive from the layout.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.import_from_control_file",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.import_from_control_file.html#import_from_control_file",
        "title": "import_from_control_file",
        "section": "import_from_control_file",
        "text": "Import layers from a control file and optional XML schema file.\nFull path to the control file.\nFull path to the XML schema file.\nimport_from_control_file\npython:str\npython:str\npython:None"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.import_from_control_file",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.import_from_control_file.html#pyedb.grpc.database.stackup.Stackup.import_from_control_file",
        "title": "import_from_control_file > import_from_control_file > import_from_control_file",
        "section": "import_from_control_file > import_from_control_file",
        "text": "Stackup.import_from_control_file(control_file_path, schema_file_path=None)\n\nImport layers from a control file and optional XML schema file.\n\nParameters\n\ncontrol_file_path\n\npython:str\n\nFull path to the control file.\n\nschema_file_path\n\npython:str, default: python:None\n\nFull path to the XML schema file.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_product_property.html#pyedb.grpc.database.primitive.bondwire.Bondwire.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "Bondwire.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_point_terminal_reference_primitive",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_point_terminal_reference_primitive.html#get_point_terminal_reference_primitive",
        "title": "get_point_terminal_reference_primitive",
        "section": "get_point_terminal_reference_primitive",
        "text": "Find and return the primitive reference for the point terminal or the padstack instance.\nget_point_terminal_reference_primitive\ndotnet.database.edb_data.padstacks_data.EDBPadstackInstance\nor\npyedb.dotnet.database.edb_data.primitives_data.EDBPrimitives"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_point_terminal_reference_primitive",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_point_terminal_reference_primitive.html#pyedb.dotnet.database.edb_data.ports.WavePort.get_point_terminal_reference_primitive",
        "title": "get_point_terminal_reference_primitive > get_point_terminal_reference_primitive > get_point_terminal_reference_primitive",
        "section": "get_point_terminal_reference_primitive > get_point_terminal_reference_primitive",
        "text": "WavePort.get_point_terminal_reference_primitive()\n\nFind and return the primitive reference for the point terminal or the padstack instance.\n\nReturns\n\ndotnet.database.edb_data.padstacks_data.EDBPadstackInstance or\n\n\n\npyedb.dotnet.database.edb_data.primitives_data.EDBPrimitives\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_pin_group_on_net",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_pin_group_on_net.html#create_pin_group_on_net",
        "title": "create_pin_group_on_net",
        "section": "create_pin_group_on_net",
        "text": "Create pin group on component by net name.\nReferences designator of the component.\nName of the net.\nName of the pin group. The default value is None.\ncreate_pin_group_on_net\npython:str\npython:str\npython:str\noptional\nNone\nPinGroup"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_pin_group_on_net",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_pin_group_on_net.html#pyedb.dotnet.database.siwave.EdbSiwave.create_pin_group_on_net",
        "title": "create_pin_group_on_net > create_pin_group_on_net > create_pin_group_on_net",
        "section": "create_pin_group_on_net > create_pin_group_on_net",
        "text": "EdbSiwave.create_pin_group_on_net(reference_designator, net_name, group_name=None)\n\nCreate pin group on component by net name.\n\nParameters\n\nreference_designator\n\npython:str\n\nReferences designator of the component.\n\nnet_name\n\npython:str\n\nName of the net.\n\ngroup_name\n\npython:str, optional\n\nName of the pin group. The default value is None.\n\nReturns\n\nPinGroup\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType.kMeshSetupLength",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType.kMeshSetupLength.html#kmeshsetuplength",
        "title": "kMeshSetupLength",
        "section": "kMeshSetupLength",
        "text": "kMeshSetupLength"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType.kMeshSetupLength",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType.kMeshSetupLength.html#pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType.kMeshSetupLength",
        "title": "kMeshSetupLength > kMeshSetupLength > kMeshSetupLength",
        "section": "kMeshSetupLength > kMeshSetupLength",
        "text": "MeshOpType.kMeshSetupLength = 'length'\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.construct",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "construct"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.construct",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.construct.html#pyedb.grpc.database.definition.materials.MaterialProperties.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod MaterialProperties.construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.add_void",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.add_void.html#add_void",
        "title": "add_void",
        "section": "add_void",
        "text": "Add void to shape.\nMain shape.\nVoid shape(s).\nTrue if successful, False otherwise.\nadd_void\npyedb.dotnet.database.edb_data.primitives_data.Primitive\npython:list\npyedb.dotnet.database.edb_data.primitives_data.Primitive"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.add_void",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.add_void.html#pyedb.grpc.database.modeler.Modeler.add_void",
        "title": "add_void > add_void > add_void",
        "section": "add_void > add_void",
        "text": "static Modeler.add_void(shape: Primitive, void_shape: Primitive | List[Primitive]) -> bool\n\nAdd void to shape.\n\nParameters\n\nshape\n\npyedb.dotnet.database.edb_data.primitives_data.Primitive\n\nMain shape.\n\nvoid_shape\n\npython:list or pyedb.dotnet.database.edb_data.primitives_data.Primitive\n\nVoid shape(s).\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_validate_strings",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj: The object containing string data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nThe validated Pydantic model.\nmodel_validate_strings"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_validate_strings",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_validate_strings.html#pyedb.workflows.drc.drc.CopperBalance.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod CopperBalance.model_validate_strings(obj: Any, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\nValidate the given object with string data against the Pydantic model.\n\nArgs:\n\nobj: The object containing string data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nReturns:\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.DefeatureSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.DefeatureSettings.html#defeaturesettings",
        "title": "DefeatureSettings",
        "section": "DefeatureSettings",
        "text": "Manages EDB methods for defeature settings.\nDefeatureSettings"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.DefeatureSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.DefeatureSettings.html#pyedb.dotnet.database.sim_setup_data.data.settings.DefeatureSettings",
        "title": "DefeatureSettings > DefeatureSettings > DefeatureSettings",
        "section": "DefeatureSettings > DefeatureSettings",
        "text": "class pyedb.dotnet.database.sim_setup_data.data.settings.DefeatureSettings(parent)\n\nManages EDB methods for defeature settings.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlCircuitPt",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlCircuitPt.html#controlcircuitpt",
        "title": "ControlCircuitPt",
        "section": "ControlCircuitPt",
        "text": "Represents a circuit port.\nPort name.\nX-coordinate of first point.\nY-coordinate of first point.\nLayer of first point.\nX-coordinate of second point.\nY-coordinate of second point.\nLayer of second point.\nCharacteristic impedance.\nControlCircuitPt\npython:str\npython:float\npython:float\npython:str\npython:float\npython:float\npython:str\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlCircuitPt",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlCircuitPt.html#pyedb.grpc.database.control_file.ControlCircuitPt",
        "title": "ControlCircuitPt > ControlCircuitPt > ControlCircuitPt",
        "section": "ControlCircuitPt > ControlCircuitPt",
        "text": "class pyedb.grpc.database.control_file.ControlCircuitPt(name, x1, y1, lay1, x2, y2, lay2, z0)\n\nRepresents a circuit port.\n\nParameters\n\nname\n\npython:str\n\nPort name.\n\nx1\n\npython:float\n\nX-coordinate of first point.\n\ny1\n\npython:float\n\nY-coordinate of first point.\n\nlay1\n\npython:str\n\nLayer of first point.\n\nx2\n\npython:float\n\nX-coordinate of second point.\n\ny2\n\npython:float\n\nY-coordinate of second point.\n\nlay2\n\npython:str\n\nLayer of second point.\n\nz0\n\npython:float\n\nCharacteristic impedance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.create",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a voltage regulator.\nLayout to create the voltage regulator in.\nName of the voltage regulator.\nActive state of the voltage regulator.\nVoltage of the voltage regulator.\nLoad regulation current.\nLoad regulation percentage.\nVoltage regulator created.\ncreate\nLayout\npython:str\nVoltageRegulator"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.create",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.create.html#pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod VoltageRegulator.create(layout, name, active, voltage, lrc, lrp)\n\nCreate a voltage regulator.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to create the voltage regulator in.\n\nname\n\npython:str\n\nName of the voltage regulator.\n\nactive\n\nbool\n\nActive state of the voltage regulator.\n\nvoltage\n\nValueLike\n\nVoltage of the voltage regulator.\n\nlrc\n\nValueLike\n\nLoad regulation current.\n\nlrp\n\nValueLike\n\nLoad regulation percentage.\n\nReturns\n\nVoltageRegulator\n\nVoltage regulator created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNets.generate_extended_nets",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNets.generate_extended_nets.html#generate_extended_nets",
        "title": "generate_extended_nets",
        "section": "generate_extended_nets",
        "text": "Get extended net and associated components.\nThreshold of resistor value. Search extended net across resistors which has value lower than the threshold.\nThreshold of inductor value. Search extended net across inductances which has value lower than the\nthreshold.\nThreshold of capacitor value. Search extended net across capacitors which has value higher than the\nthreshold.\nList of components to bypass when performing threshold checks. Components\nin the list are considered as serial components. The default is None.\nWhether to generate extended signal nets. The default is True.\nWhether to generate extended power nets. The default is True.\nList of all extended nets.\ngenerate_extended_nets\npython:int\npython:float\noptional\npython:int\npython:float\noptional\npython:int\npython:float\noptional\npython:list\noptional\nNone\npython:str\noptional\nTrue\npython:str\noptional\nTrue\nList\nExtendedNet"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNets.generate_extended_nets",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNets.generate_extended_nets.html#pyedb.grpc.database.net.extended_net.ExtendedNets.generate_extended_nets",
        "title": "generate_extended_nets > generate_extended_nets > generate_extended_nets",
        "section": "generate_extended_nets > generate_extended_nets",
        "text": "ExtendedNets.generate_extended_nets(resistor_below: int | float = 10, inductor_below: int | float = 1, capacitor_above: int | float = 1, exception_list: list | None = None, include_signal: bool = True, include_power: bool = True) -> list[ExtendedNet]\n\nGet extended net and associated components.\n\nParameters\n\nresistor_below\n\npython:int, python:float, optional\n\nThreshold of resistor value. Search extended net across resistors which has value lower than the threshold.\n\ninductor_below\n\npython:int, python:float, optional\n\nThreshold of inductor value. Search extended net across inductances which has value lower than the\nthreshold.\n\ncapacitor_above\n\npython:int, python:float, optional\n\nThreshold of capacitor value. Search extended net across capacitors which has value higher than the\nthreshold.\n\nexception_list\n\npython:list, optional\n\nList of components to bypass when performing threshold checks. Components\nin the list are considered as serial components. The default is None.\n\ninclude_signal\n\npython:str, optional\n\nWhether to generate extended signal nets. The default is True.\n\ninclude_power\n\npython:str, optional\n\nWhether to generate extended power nets. The default is True.\n\nReturns\n\nList[ExtendedNet]\n\nList of all extended nets.\n\nExamples\n\n>>> from pyedb import Edb\n>>> app = Edb()\n>>> app.nets.get_extended_nets()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_3d_comp.html#create_3d_comp",
        "title": "create_3d_comp",
        "section": "create_3d_comp",
        "text": "Create a 3D composite model from an MCAD file.\n3D composite model created.\ncreate_3d_comp\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_3d_comp.html#pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_3d_comp",
        "title": "create_3d_comp > create_3d_comp > create_3d_comp",
        "section": "create_3d_comp > create_3d_comp",
        "text": "PinGroup.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nReturns\n\nMcadModel\n\n3D composite model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_dump",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#python-mode)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude: A set of fields to include in the output.\nexclude: A set of fields to exclude from the output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\nA dictionary representation of the model.\nmodel_dump"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_dump",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_dump.html#pyedb.workflows.drc.drc.DiffPair.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "DiffPair.model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -> dict[str, Any]\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#python-mode)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n\nmode: The mode in which to_python should run.\n\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude: A set of fields to include in the output.\nexclude: A set of fields to exclude from the output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\n\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\n\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback: A function to call when an unknown value is encountered. If not provided,\n\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_solder_ball_height",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_solder_ball_height.html#get_solder_ball_height",
        "title": "get_solder_ball_height",
        "section": "get_solder_ball_height",
        "text": "Get solder ball height of a component.\nComponent name or instance.\nSolder ball height in meters.\nget_solder_ball_height\npython:str\npyedb.grpc.database.hierarchy.component.Component\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_solder_ball_height",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_solder_ball_height.html#pyedb.grpc.database.components.Components.get_solder_ball_height",
        "title": "get_solder_ball_height > get_solder_ball_height > get_solder_ball_height",
        "section": "get_solder_ball_height > get_solder_ball_height",
        "text": "Components.get_solder_ball_height(cmp: str | Component) -> float\n\nGet solder ball height of a component.\n\nParameters\n\ncmp\n\npython:str or pyedb.grpc.database.hierarchy.component.Component\n\nComponent name or instance.\n\nReturns\n\npython:float\n\nSolder ball height in meters.\n\nExamples\n\n>>> height = edbapp.components.get_solder_ball_height(\"U1\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/differential_pair",
        "href": "grpc_api/grpc/database/pyedb_lib/net/differential_pair.html#differential-pair",
        "title": "Differential Pair",
        "section": "Differential Pair",
        "text": "This class is managing EDB differential pair.\nDifferentialPair\nManages EDB functionalities for a primitive.\nDifferentialPairs\n\nDifferential Pair\nDifferentialPair\nDifferentialPairs"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.find_by_id.html#find_by_id",
        "title": "find_by_id",
        "section": "find_by_id",
        "text": "Find a Connectable object by database ID in a given layout.\nLayout to search for the Connectable object.\nDatabase ID.\nConnectable object with the given database ID.\nfind_by_id\nLayout\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.find_by_id.html#pyedb.grpc.database.terminal.point_terminal.PointTerminal.find_by_id",
        "title": "find_by_id > find_by_id > find_by_id",
        "section": "find_by_id > find_by_id",
        "text": "classmethod PointTerminal.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the Connectable object.\n\nuid\n\npython:int\n\nDatabase ID.\n\nReturns\n\nConnectable\n\nConnectable object with the given database ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_product_property_ids.html#pyedb.grpc.database.primitive.primitive.Primitive.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "Primitive.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.SettingsBase.get_configurations",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.SettingsBase.get_configurations.html#get_configurations",
        "title": "get_configurations",
        "section": "get_configurations",
        "text": "Get all attributes.\nget_configurations\npython:dict"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.SettingsBase.get_configurations",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.SettingsBase.get_configurations.html#pyedb.dotnet.database.sim_setup_data.io.siwave.SettingsBase.get_configurations",
        "title": "get_configurations > get_configurations > get_configurations",
        "section": "get_configurations > get_configurations",
        "text": "SettingsBase.get_configurations()\n\nGet all attributes.\n\nReturns\n\npython:dict\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_connected_object_id_set",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_connected_object_id_set.html#get_connected_object_id_set",
        "title": "get_connected_object_id_set",
        "section": "get_connected_object_id_set",
        "text": "Produce a list of all geometries physically connected to a given layout object.\nFound connected objects IDs with Layout object.\nget_connected_object_id_set\nList\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_connected_object_id_set",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_connected_object_id_set.html#pyedb.grpc.database.primitive.rectangle.Rectangle.get_connected_object_id_set",
        "title": "get_connected_object_id_set > get_connected_object_id_set > get_connected_object_id_set",
        "section": "get_connected_object_id_set > get_connected_object_id_set",
        "text": "Rectangle.get_connected_object_id_set() -> list[int]\n\nProduce a list of all geometries physically connected to a given layout object.\n\nReturns\n\nList[python:int]\n\nFound connected objects IDs with Layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.delete_primitives",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.delete_primitives.html#delete_primitives",
        "title": "delete_primitives",
        "section": "delete_primitives",
        "text": "Delete primitives by net names.\nNames of the nets to delete.\nTrue when successful, False when failed.\ndelete_primitives\npython:str\npython:list\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.delete_primitives",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.delete_primitives.html#pyedb.dotnet.database.modeler.Modeler.delete_primitives",
        "title": "delete_primitives > delete_primitives > delete_primitives",
        "section": "delete_primitives > delete_primitives",
        "text": "Modeler.delete_primitives(net_names)\n\nDelete primitives by net names.\n\nParameters\n\nnet_names\n\npython:str, python:list\n\nNames of the nets to delete.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nReferences\n\n>>> Edb.modeler.delete_primitives(net_names=[\"GND\"])\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.update_materials_from_sys_library",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.update_materials_from_sys_library.html#update_materials_from_sys_library",
        "title": "update_materials_from_sys_library",
        "section": "update_materials_from_sys_library",
        "text": "Update material properties from syslib AMAT file.\nupdate_materials_from_sys_library"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.update_materials_from_sys_library",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.update_materials_from_sys_library.html#pyedb.dotnet.database.materials.Materials.update_materials_from_sys_library",
        "title": "update_materials_from_sys_library > update_materials_from_sys_library > update_materials_from_sys_library",
        "section": "update_materials_from_sys_library > update_materials_from_sys_library",
        "text": "Materials.update_materials_from_sys_library(update_all: bool = True, material_name: str | list | None = None)\n\nUpdate material properties from syslib AMAT file.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_hfss",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_hfss.html#export_hfss",
        "title": "export_hfss",
        "section": "export_hfss",
        "text": "Export to HFSS project.\nOutput directory.\nNets to export.\nProcessing cores to use.\nCustom AEDT filename.\nRun Siwave in background. Default False.\nPath to generated AEDT file.\nexport_hfss\npython:str\npython:list\noptional\npython:int\noptional\npython:str\noptional\noptional\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_hfss",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_hfss.html#pyedb.grpc.edb.Edb.export_hfss",
        "title": "export_hfss > export_hfss > export_hfss",
        "section": "export_hfss > export_hfss",
        "text": "Edb.export_hfss(path_to_output, net_list=None, num_cores=None, aedt_file_name=None, hidden=False)\n\nExport to HFSS project.\n\nParameters\n\npath_to_output\n\npython:str\n\nOutput directory.\n\nnet_list\n\npython:list, optional\n\nNets to export.\n\nnum_cores\n\npython:int, optional\n\nProcessing cores to use.\n\naedt_file_name\n\npython:str, optional\n\nCustom AEDT filename.\n\nhidden\n\nbool, optional\n\nRun Siwave in background. Default False.\n\nReturns\n\npython:str\n\nPath to generated AEDT file.\n\nExamples\n\n>>> # Export to HFSS project:\n>>> edb.export_hfss(r\"C:/output\", net_list=[\"SignalNet\"])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.hfss.Hfss.get_trace_width_for_traces_with_ports",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.hfss.Hfss.get_trace_width_for_traces_with_ports.html#get_trace_width_for_traces_with_ports",
        "title": "get_trace_width_for_traces_with_ports",
        "section": "get_trace_width_for_traces_with_ports",
        "text": "Retrieve trace widths for traces with ports.\nDictionary mapping net names to smallest trace widths.\nget_trace_width_for_traces_with_ports\npython:dict"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.hfss.Hfss.get_trace_width_for_traces_with_ports",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.hfss.Hfss.get_trace_width_for_traces_with_ports.html#pyedb.grpc.database.hfss.Hfss.get_trace_width_for_traces_with_ports",
        "title": "get_trace_width_for_traces_with_ports > get_trace_width_for_traces_with_ports > get_trace_width_for_traces_with_ports",
        "section": "get_trace_width_for_traces_with_ports > get_trace_width_for_traces_with_ports",
        "text": "Hfss.get_trace_width_for_traces_with_ports()\n\nRetrieve trace widths for traces with ports.\n\nReturns\n\npython:dict\n\nDictionary mapping net names to smallest trace widths.\n\nExamples\n\n>>> widths = edb.hfss.get_trace_width_for_traces_with_ports()\n>>> for net_name, width in widths.items():\n...     print(f\"Net '{net_name}': Smallest width = {width}\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.delete",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete current simulation setup.\ndelete"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.delete",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.delete.html#pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "SiwaveSimulationSetup.delete()\n\nDelete current simulation setup.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.parse_file",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "parse_file"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.parse_file",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.parse_file.html#pyedb.grpc.database.definition.materials.MaterialProperties.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod MaterialProperties.parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.html#modeler",
        "title": "Modeler",
        "section": "Modeler",
        "text": "Manages EDB methods for primitives management accessible from Edb.modeler property.\nModeler.add_void(shape, void_shape)\nAdd a void into a shape.\nModeler.create_bondwire(definition_name, ...)\nCreate a bondwire object.\nModeler.create_circle(layer_name, x, y, radius)\nCreate a circle on a specified layer.\nModeler.create_pin_group(name[, pins_by_id, ...])\nCreate a PinGroup.\nModeler.create_polygon([main_shape, ...])\nCreate a polygon based on a list of points and voids.\nModeler.create_rectangle(layer_name[, ...])\nCreate rectangle.\nModeler.create_trace(path_list, layer_name)\nCreate a trace based on a list of points.\nModeler.defeature_polygon(poly[, tolerance])\nDefeature the polygon based on the maximum surface deviation criteria.\nModeler.delete_primitives(net_names)\nDelete primitives by net names.\nModeler.fix_circle_void_for_clipping()\nFix issues when circle void are clipped due to a bug in EDB.\nModeler.get_layout_statistics([...])\nReturn EDBStatistics object from a layout.\nModeler.get_polygon_bounding_box(polygon)\nRetrieve a polygon bounding box.\nModeler.get_polygon_points(polygon)\nRetrieve polygon points.\nModeler.get_polygons_by_layer(layer_name[, ...])\nRetrieve polygons by a layer.\nModeler.get_primitive(primitive_id)\nRetrieve primitive from give id.\nModeler.get_primitive_by_layer_and_point([...])\nReturn primitive given coordinate point [x, y], layer name and nets.\nModeler.get_primitives([net_name, ...])\nGet primitives by conditions.\nModeler.parametrize_polygon(polygon, ...[, ...])\nParametrize pieces of a polygon based on another polygon.\nModeler.parametrize_trace_width(nets_name[, ...])\nParametrize a Trace on specific layer or all stackup.\nModeler.shape_to_polygon_data(shape)\nConvert a shape to polygon data.\nModeler.unite_polygons_on_layer([...])\nTry to unite all Polygons on specified layer.\nModeler\nModeler.add_void\nModeler.create_bondwire\nModeler.create_circle\nModeler.create_pin_group\nModeler.create_polygon\nModeler.create_rectangle\nModeler.create_trace\nModeler.defeature_polygon\nModeler.delete_primitives\nModeler.fix_circle_void_for_clipping\nModeler.get_layout_statistics\nModeler.get_polygon_bounding_box\nModeler.get_polygon_points\nModeler.get_polygons_by_layer\nModeler.get_primitive\nModeler.get_primitive_by_layer_and_point\nModeler.get_primitives\nModeler.parametrize_polygon\nModeler.parametrize_trace_width\nModeler.shape_to_polygon_data\nModeler.unite_polygons_on_layer"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.html#pyedb.dotnet.database.modeler.Modeler",
        "title": "Modeler > Modeler > Modeler",
        "section": "Modeler > Modeler",
        "text": "class pyedb.dotnet.database.modeler.Modeler(p_edb)\n\nManages EDB methods for primitives management accessible from Edb.modeler property.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", edbversion=\"2021.2\")\n>>> edb_layout = edbapp.modeler\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nModeler.add_void(shape, void_shape)\n\nAdd a void into a shape.\n\nModeler.create_bondwire(definition_name, ...)\n\nCreate a bondwire object.\n\nModeler.create_circle(layer_name, x, y, radius)\n\nCreate a circle on a specified layer.\n\nModeler.create_pin_group(name[, pins_by_id, ...])\n\nCreate a PinGroup.\n\nModeler.create_polygon([main_shape, ...])\n\nCreate a polygon based on a list of points and voids.\n\nModeler.create_rectangle(layer_name[, ...])\n\nCreate rectangle.\n\nModeler.create_trace(path_list, layer_name)\n\nCreate a trace based on a list of points.\n\nModeler.defeature_polygon(poly[, tolerance])\n\nDefeature the polygon based on the maximum surface deviation criteria.\n\nModeler.delete_primitives(net_names)\n\nDelete primitives by net names.\n\nModeler.fix_circle_void_for_clipping()\n\nFix issues when circle void are clipped due to a bug in EDB.\n\nModeler.get_layout_statistics([...])\n\nReturn EDBStatistics object from a layout.\n\nModeler.get_polygon_bounding_box(polygon)\n\nRetrieve a polygon bounding box.\n\nModeler.get_polygon_points(polygon)\n\nRetrieve polygon points.\n\nModeler.get_polygons_by_layer(layer_name[, ...])\n\nRetrieve polygons by a layer.\n\nModeler.get_primitive(primitive_id)\n\nRetrieve primitive from give id.\n\nModeler.get_primitive_by_layer_and_point([...])\n\nReturn primitive given coordinate point [x, y], layer name and nets.\n\nModeler.get_primitives([net_name, ...])\n\nGet primitives by conditions.\n\nModeler.parametrize_polygon(polygon, ...[, ...])\n\nParametrize pieces of a polygon based on another polygon.\n\nModeler.parametrize_trace_width(nets_name[, ...])\n\nParametrize a Trace on specific layer or all stackup.\n\nModeler.shape_to_polygon_data(shape)\n\nConvert a shape to polygon data.\n\nModeler.unite_polygons_on_layer([...])\n\nTry to unite all Polygons on specified layer.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the layout object.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.delete.html#pyedb.grpc.database.terminal.terminal.Terminal.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "Terminal.delete()\n\nDelete the layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_fill_material",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_fill_material.html#get_fill_material",
        "title": "get_fill_material",
        "section": "get_fill_material",
        "text": "Get the name of the fill material of the layer.\nWhether to evaluate the material if it is parameterized.\nName of the fill material.\nget_fill_material\npython:True\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_fill_material",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_fill_material.html#pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_fill_material",
        "title": "get_fill_material > get_fill_material > get_fill_material",
        "section": "get_fill_material > get_fill_material",
        "text": "StackupLayer.get_fill_material(evaluated=True)\n\nGet the name of the fill material of the layer.\n\nParameters\n\nevaluated\n\nbool, default: python:True\n\nWhether to evaluate the material if it is parameterized.\n\nReturns\n\npython:str\n\nName of the fill material.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.get_product_property_ids.html#pyedb.grpc.database.terminal.point_terminal.PointTerminal.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "PointTerminal.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/index",
        "href": "examples/index.html#examples",
        "title": "Examples",
        "section": "Examples",
        "text": "Examples"
    },
    {
        "objectID": "examples/index",
        "href": "examples/index.html#high-frequency-layout-examples-pyaedt--pyedb",
        "title": "Examples > High-Frequency Layout Examples (PyAEDT + PyEDB)",
        "section": "High-Frequency Layout Examples (PyAEDT + PyEDB)",
        "text": "These examples show how PyEDB and PyAEDT work together to create solve and post-process high-frequency PCB/IC packages and RF boards.\nThey are maintained in the main PyAEDT example gallery and include:\nImport and modification of EDB layout\nHFSS 3-D and HFSS 3-D Layout set-ups\nFrequency sweeps, field plots, S-parameter export\nParametric studies and optimization loops\nFeel free to open an issue or pull request if you would like to add new PyEDB-focused examples to this collection.\nThis examples are focused on using PyEDB to create, modify, and analyze PCB/IC packages and RF boards. The basic\nsection covers fundamental tasks, while the advanced section demonstrates more complex workflows for Si-PI.\nHigh-Frequency Layout Examples (PyAEDT + PyEDB)"
    },
    {
        "objectID": "examples/index",
        "href": "examples/index.html#pyedb-basic-and-advanced-examples",
        "title": "Examples > PyEDB basic and advanced examples",
        "section": "PyEDB basic and advanced examples",
        "text": "PyEDB basic and advanced examples"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.is_net_in_component",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.is_net_in_component.html#is_net_in_component",
        "title": "is_net_in_component",
        "section": "is_net_in_component",
        "text": "Check if a net belongs to a component.\nName of the component.\nName of the net.\nTrue if the net is found in the component, False otherwise.\nis_net_in_component\npython:str\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.is_net_in_component",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.is_net_in_component.html#pyedb.grpc.database.nets.Nets.is_net_in_component",
        "title": "is_net_in_component > is_net_in_component > is_net_in_component",
        "section": "is_net_in_component > is_net_in_component",
        "text": "Nets.is_net_in_component(component_name: str, net_name: str) -> bool\n\nCheck if a net belongs to a component.\n\nParameters\n\ncomponent_name\n\npython:str\n\nName of the component.\n\nnet_name\n\npython:str\n\nName of the net.\n\nReturns\n\nbool\n\nTrue if the net is found in the component, False otherwise.\n\nExamples\n\n>>> in_component = edb_nets.is_net_in_component(\"U1\", \"VDD_CPU\")\n>>> print(\"Net in component:\", in_component)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.find_by_name",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.find_by_name.html#find_by_name",
        "title": "find_by_name",
        "section": "find_by_name",
        "text": "Find a material definition by name in a given database.\nDatabase to search for the material definition.\nName of the material definition.\nMaterial definition object found.\nIf a material definition isn’t found, the returned material definition is null.\nfind_by_name\nDatabase\npython:str\nMaterialDef\nnull"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.find_by_name",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.find_by_name.html#pyedb.grpc.database.definition.materials.Material.find_by_name",
        "title": "find_by_name > find_by_name > find_by_name",
        "section": "find_by_name > find_by_name",
        "text": "classmethod Material.find_by_name(database: Database, name: str) -> MaterialDef\n\nFind a material definition by name in a given database.\n\nParameters\n\ndatabase\n\nDatabase\n\nDatabase to search for the material definition.\n\nname\n\npython:str\n\nName of the material definition.\n\nReturns\n\nMaterialDef\n\nMaterial definition object found.\nIf a material definition isn’t found, the returned material definition is null.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.dict",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "dict"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.dict",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.dict.html#pyedb.workflows.drc.drc.MinAnnularRing.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "MinAnnularRing.dict(*, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Dict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.html#edbnets",
        "title": "EdbNets",
        "section": "EdbNets",
        "text": "Manages EDB methods for nets management accessible from Edb.nets property.\nEdbNets.classify_nets([power_nets, signal_nets])\nReassign power/ground or signal nets based on list of nets.\nEdbNets.delete(netlist)\nDelete one or more nets from EDB.\nEdbNets.eligible_power_nets([threshold])\nReturn a list of nets calculated by area to be eligible for PWR/Ground net classification.\nEdbNets.find_or_create_net([net_name, ...])\nFind or create the net with the given name in the layout.\nEdbNets.generate_extended_nets([...])\nGet extended net and associated components.\nEdbNets.get_dcconnected_net_list([...])\nGet the nets connected to the direct current through inductors.\nEdbNets.get_net_by_name(net_name)\nFind a net by name.\nEdbNets.get_powertree(power_net_name, ...)\nRetrieve the power tree.\nEdbNets.is_net_in_component(component_name, ...)\nCheck if a net belongs to a component.\nEdbNets.is_power_gound_net(netname_list)\nDetermine if one of the  nets in a list is power or ground.\nEdbNets.merge_nets_polygons(net_names_list)\nConvert paths from net into polygons, evaluate all connected polygons and perform the merge.\nEdbNets.plot([nets, layers, color_by_net, ...])\nPlot a Net to Matplotlib 2D Chart.\nEdbNets\nEdbNets.classify_nets\nEdbNets.delete\nEdbNets.eligible_power_nets\nEdbNets.find_or_create_net\nEdbNets.generate_extended_nets\nEdbNets.get_dcconnected_net_list\nEdbNets.get_net_by_name\nEdbNets.get_powertree\nEdbNets.is_net_in_component\nEdbNets.is_power_gound_net\nEdbNets.merge_nets_polygons\nEdbNets.plot"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.html#pyedb.dotnet.database.nets.EdbNets",
        "title": "EdbNets > EdbNets > EdbNets",
        "section": "EdbNets > EdbNets",
        "text": "class pyedb.dotnet.database.nets.EdbNets(p_edb)\n\nManages EDB methods for nets management accessible from Edb.nets property.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", edbversion=\"2021.2\")\n>>> edb_nets = edbapp.nets\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nEdbNets.classify_nets([power_nets, signal_nets])\n\nReassign power/ground or signal nets based on list of nets.\n\nEdbNets.delete(netlist)\n\nDelete one or more nets from EDB.\n\nEdbNets.eligible_power_nets([threshold])\n\nReturn a list of nets calculated by area to be eligible for PWR/Ground net classification.\n\nEdbNets.find_or_create_net([net_name, ...])\n\nFind or create the net with the given name in the layout.\n\nEdbNets.generate_extended_nets([...])\n\nGet extended net and associated components.\n\nEdbNets.get_dcconnected_net_list([...])\n\nGet the nets connected to the direct current through inductors.\n\nEdbNets.get_net_by_name(net_name)\n\nFind a net by name.\n\nEdbNets.get_powertree(power_net_name, ...)\n\nRetrieve the power tree.\n\nEdbNets.is_net_in_component(component_name, ...)\n\nCheck if a net belongs to a component.\n\nEdbNets.is_power_gound_net(netname_list)\n\nDetermine if one of the  nets in a list is power or ground.\n\nEdbNets.merge_nets_polygons(net_names_list)\n\nConvert paths from net into polygons, evaluate all connected polygons and perform the merge.\n\nEdbNets.plot([nets, layers, color_by_net, ...])\n\nPlot a Net to Matplotlib 2D Chart.\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_rlc_component",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_rlc_component.html#create_rlc_component",
        "title": "create_rlc_component",
        "section": "create_rlc_component",
        "text": "Create physical Rlc component.\nList of EDB pins.\nComponent name.\nResistor value.\nCapacitance value.\nInductor value.\nUsing parallel model when True, series when False.\nCreated EDB component.\ncreate_rlc_component\npython:list\nEdb.Cell.Primitive.PadstackInstance\npython:str\npython:float\npython:float\npython:float\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_rlc_component",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_rlc_component.html#pyedb.dotnet.database.siwave.EdbSiwave.create_rlc_component",
        "title": "create_rlc_component > create_rlc_component > create_rlc_component",
        "section": "create_rlc_component > create_rlc_component",
        "text": "EdbSiwave.create_rlc_component(pins, component_name='', r_value=1.0, c_value=1e-09, l_value=1e-09, is_parallel=False)\n\nCreate physical Rlc component.\n\nParameters\n\npins\n\npython:list[Edb.Cell.Primitive.PadstackInstance]\n\nList of EDB pins.\n\ncomponent_name\n\npython:str\n\nComponent name.\n\nr_value\n\npython:float\n\nResistor value.\n\nc_value\n\npython:float\n\nCapacitance value.\n\nl_value\n\npython:float\n\nInductor value.\n\nis_parallel\n\nbool\n\nUsing parallel model when True, series when False.\n\nReturns\n\nclass:pyedb.dotnet.database.components.Components\n\nCreated EDB component.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.adaptive_frequency_data.AdaptiveFrequencyData",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.adaptive_frequency_data.AdaptiveFrequencyData.html#adaptivefrequencydata",
        "title": "AdaptiveFrequencyData",
        "section": "AdaptiveFrequencyData",
        "text": "Manages EDB methods for adaptive frequency data.\nAdaptiveFrequencyData"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.adaptive_frequency_data.AdaptiveFrequencyData",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.adaptive_frequency_data.AdaptiveFrequencyData.html#pyedb.dotnet.database.sim_setup_data.data.adaptive_frequency_data.AdaptiveFrequencyData",
        "title": "AdaptiveFrequencyData > AdaptiveFrequencyData > AdaptiveFrequencyData",
        "section": "AdaptiveFrequencyData > AdaptiveFrequencyData",
        "text": "class pyedb.dotnet.database.sim_setup_data.data.adaptive_frequency_data.AdaptiveFrequencyData(adaptive_frequency_data)\n\nManages EDB methods for adaptive frequency data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.delete",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete current simulation setup.\ndelete"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.delete",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.delete.html#pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "SiwaveDCSimulationSetup.delete()\n\nDelete current simulation setup.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues: Trusted or pre-validated data dictionary.\nA new instance of the Model class with validated data.\nmodel_construct"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_construct.html#pyedb.workflows.drc.drc.DiffPair.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod DiffPair.model_construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nArgs:\n\n_fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues: Trusted or pre-validated data dictionary.\n\nReturns:\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.positive",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.positive.html#positive",
        "title": "positive",
        "section": "positive",
        "text": "positive"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.positive",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.positive.html#pyedb.workflows.drc.drc.DiffPair.positive",
        "title": "positive > positive > positive",
        "section": "positive > positive",
        "text": "DiffPair.positive: str\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create_port_on_component",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create_port_on_component.html#create_port_on_component",
        "title": "create_port_on_component",
        "section": "create_port_on_component",
        "text": "Create ports on a component.\nEDB component or str component name.\nList of nets where ports must be created on the component.\nIf the net is not part of the component, this parameter is skipped.\nType of port to create. CoaxPort generates solder balls.\nCircuitPort generates circuit ports on pins belonging to the net list.\nTrue activate pingroup during port creation (only used with combination of CircPort),\nFalse will take the closest reference pin and generate one port per signal pin.\nlist of the reference net.\nPort name for overwriting the default port-naming convention,\nwhich is [component][net][pin]. The port name must be unique.\nIf a port with the specified name already exists, the\ndefault naming convention is used so that port creation does\nnot fail.\nSolder balls height used for the component. When provided default value is overwritten and must be\nprovided in meter.\nSolder balls diameter. When provided auto evaluation based on padstack size will be disabled.\nSolder balls mid-diameter. When provided if value is different than solder balls size, spheroid shape will\nbe switched.\nWhen no reference pins are found on the component extend the pins search with taking the closest one. If\ndo_pingroup is True will be set to False. Default value is False.\nSalder ball height vale, False when failed.\ncreate_port_on_component\npython:str\nself._pedb.component\npython:str\npython:list\nof\nSourceType\nenumerator\nCoaxPort\nCircuitPort\nCoaxPort\nCircuitPort\npython:str\npython:list\nof\npython:str\n[component][net][pin]\npython:float\noptional\npython:float\noptional\npython:float\noptional\ndouble\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create_port_on_component",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create_port_on_component.html#pyedb.dotnet.database.components.Components.create_port_on_component",
        "title": "create_port_on_component > create_port_on_component > create_port_on_component",
        "section": "create_port_on_component > create_port_on_component",
        "text": "Components.create_port_on_component(component, net_list, port_type=0, do_pingroup=True, reference_net='gnd', port_name=None, solder_balls_height=None, solder_balls_size=None, solder_balls_mid_size=None, extend_reference_pins_outside_component=False)\n\nCreate ports on a component.\n\nParameters\n\ncomponent\n\npython:str or  self._pedb.component\n\nEDB component or str component name.\n\nnet_list\n\npython:str or python:list of string.\n\nList of nets where ports must be created on the component.\nIf the net is not part of the component, this parameter is skipped.\n\nport_type\n\nSourceType enumerator, CoaxPort or CircuitPort\n\nType of port to create. CoaxPort generates solder balls.\nCircuitPort generates circuit ports on pins belonging to the net list.\n\ndo_pingroup\n\nbool\n\nTrue activate pingroup during port creation (only used with combination of CircPort),\nFalse will take the closest reference pin and generate one port per signal pin.\n\nrefnet\n\npython:str or python:list of string.\n\nlist of the reference net.\n\nport_name\n\npython:str\n\nPort name for overwriting the default port-naming convention,\nwhich is [component][net][pin]. The port name must be unique.\nIf a port with the specified name already exists, the\ndefault naming convention is used so that port creation does\nnot fail.\n\nsolder_balls_height\n\npython:float, optional\n\nSolder balls height used for the component. When provided default value is overwritten and must be\nprovided in meter.\n\nsolder_balls_size\n\npython:float, optional\n\nSolder balls diameter. When provided auto evaluation based on padstack size will be disabled.\n\nsolder_balls_mid_size\n\npython:float, optional\n\nSolder balls mid-diameter. When provided if value is different than solder balls size, spheroid shape will\nbe switched.\n\nextend_reference_pins_outside_component\n\nbool\n\nWhen no reference pins are found on the component extend the pins search with taking the closest one. If\ndo_pingroup is True will be set to False. Default value is False.\n\nReturns\n\ndouble, bool\n\nSalder ball height vale, False when failed.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\")\n>>> net_list = [\"M_DQ<1>\", \"M_DQ<2>\", \"M_DQ<3>\", \"M_DQ<4>\", \"M_DQ<5>\"]\n>>> edbapp.components.create_port_on_component(cmp=\"U2A5\", net_list=net_list,\n>>> port_type=SourceType.CoaxPort, do_pingroup=False, refnet=\"GND\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_port_on_pins",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_port_on_pins.html#create_port_on_pins",
        "title": "create_port_on_pins",
        "section": "create_port_on_pins",
        "text": "Create circuit port between pins and reference ones.\nstr or Component object.\nUnion[int, str, PadstackInstance], List[Union[int, str, PadstackInstance]]\nUnion[int, str, PadstackInstance], List[Union[int, str, PadstackInstance]]\nstr, float\nPort name. The default is None, in which case a name is automatically assigned.\nIf True force using pingroup definition on single pin to have the port created at the pad center. If\nFalse the port is created at the pad edge. Default value is False.\ncreate_port_on_pins\nComponent\nreference\ndesignator\npin\nspecifier\ns\nor\ninstance\ns\nwhere\nthe\nport\nterminal\nis\nto\nbe\nSingle\npin\nname\na\npython:list\nof\nreference\npin\nspecifier\ns\nor\ninstance\ns\nfor\nthe\nport\nreference\nAllowed\nvalues\nare\nPort\nimpedance\npython:str\noptional\nNone\noptional\nTrue\nFalse\nFalse\nEDB\nterminal\ncreated\nor\npython:False\nif\nfailed\nto\nOr\nto\ntake\nall\nreference\npins"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_port_on_pins",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_port_on_pins.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_port_on_pins",
        "title": "create_port_on_pins > create_port_on_pins > create_port_on_pins",
        "section": "create_port_on_pins > create_port_on_pins",
        "text": "SourceExcitation.create_port_on_pins(refdes: str | Component, pins: int | str | PadstackInstance | List[int | str | PadstackInstance], reference_pins: int | str | PadstackInstance | List[int | str | PadstackInstance] | None = None, impedance: str | float = '50ohm', port_name: str | None = None, pec_boundary: bool = False, pingroup_on_single_pin: bool = False) -> PadstackInstanceTerminal\n\nCreate circuit port between pins and reference ones.\n\nParameters\n\nrefdes\n\nComponent reference designator\n\nstr or Component object.\n\npins\n\npin specifier(s) or instance(s) where the port terminal is to be created. Single pin name or a python:list of\n\n\n\nseveral can be provided. If several pins are provided a pin group will be created. Pin specifiers can be the\n\n\n\nglobal EDB object ID or padstack instance name or pin name on component with refdes ``refdes``. Pin instances\n\n\n\ncan be provided as ``EDBPadstackInstance`` objects.\n\n\n\nFor instance for the pin called ``Pin1`` located on component with refdes ``U1``: ``U1-Pin1``, ``Pin1`` with\n\n\n\n``refdes=U1``, the pin’s global EDB object ID, or the ``EDBPadstackInstance`` corresponding to the pin can be\n\n\n\nprovided.\n\nUnion[int, str, PadstackInstance], List[Union[int, str, PadstackInstance]]\n\nreference_pins\n\nreference pin specifier(s) or instance(s) for the port reference terminal. Allowed values are\n\n\n\nthe same as for the ``pins`` parameter.\n\nUnion[int, str, PadstackInstance], List[Union[int, str, PadstackInstance]]\n\nimpedance\n\nPort impedance\n\nstr, float\n\nport_name\n\npython:str, optional\n\nPort name. The default is None, in which case a name is automatically assigned.\n\npec_boundary\n\nbool, optional\n\n\n\nWhether to define the PEC boundary, The default is ``False``. If set to ``True``,\n\n\n\na perfect short is created between the pin and impedance is ignored. This\n\n\n\nparameter is only supported on a port created between two pins, such as\n\n\n\nwhen there is no pin group.\n\n\n\npingroup_on_single_pin\n\nbool\n\nIf True force using pingroup definition on single pin to have the port created at the pad center. If\nFalse the port is created at the pad edge. Default value is False.\n\nReturns\n\nEDB terminal created, or python:False if failed to create.\n\n\n\nExample:\n\n\n\n>>> :obj:`from` :obj:`pyedb` :obj:`import` :obj:`Edb`\n    ..\n\n>>> :obj:`edb` = :obj:`Edb`\\(:obj:`path_to_edb_file`)\n    ..\n\n>>> :obj:`pin` = \"AJ6\"\n    ..\n\n>>> :obj:`ref_pins` = [\"AM7\", \"AM4\"]\n    ..\n\nOr to take all reference pins\n\n\n\n>>> :obj:`ref_pins` = [:obj:`pin` :obj:`for` :obj:`pin` :obj:`in` :class:`python:list`\\(:obj:`edb.components`\\[\"U2A5\"]:obj:`.pins.values`\\()) :obj:`if` :obj:`pin.net_name` == \"GND\"]\n    ..\n\n>>> :obj:`edb.components.create_port_on_pins`\\(refdes=\"U2A5\", pins=pin, reference_pins=ref_pins)\n    ..\n\n>>> :obj:`edb.save_edb`\\()\n    ..\n\n>>> :obj:`edb.close_edb`\\()\n    ..\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.add_variable",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.add_variable.html#add_variable",
        "title": "add_variable",
        "section": "add_variable",
        "text": "Add a variable.\nVariable name.\nValue, which can be any type that can be converted to a Value\ninstance.\nWhether the new variable is a parameter. The default is False, which means it is a local variable.\nVariables can be added to the following EDB objects:\nDatabase (Variable names must begin with a ‘$’.)\nComponentDef\nCell\nLayout (Adds variable to the corresponding\nCell instance.)\nAdd variables to a cell and create a value that references these variables.\nadd_variable\npython:str\npython:str\npython:int\npython:float\ncomplex\nValue\nValue\npython:False\nFalse\nDatabase\nComponentDef\nCell\nLayout\nCell"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.add_variable",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.add_variable.html#pyedb.grpc.database.layout.cell.Cell.add_variable",
        "title": "add_variable > add_variable > add_variable",
        "section": "add_variable > add_variable",
        "text": "Cell.add_variable(name, value, is_param=False)\n\nAdd a variable.\n\nParameters\n\nname\n\npython:str\n\nVariable name.\n\nvalue\n\npython:str, python:int, python:float, complex, Value\n\nValue, which can be any type that can be converted to a Value\ninstance.\n\nis_param\n\nbool, default: python:False\n\nWhether the new variable is a parameter. The default is False, which means it is a local variable.\n\nNotes\n\nVariables can be added to the following EDB objects:\n\nDatabase (Variable names must begin with a ‘$’.)\n\nComponentDef\n\nCell\n\nLayout (Adds variable to the corresponding\nCell instance.)\n\nExamples\n\nAdd variables to a cell and create a value that references these variables.\n\n>>> param = Value(33.1)\n>>> cell.add_variable(\"blue1\", param)\n>>> cell.add_variable(\"blue2\", \"25mm\")\n>>> vv = cell.create_value(\"blue1 + blue2\")\n>>> print(vv.double)\n33.125\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.intersection_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.intersection_type.html#intersection_type",
        "title": "intersection_type",
        "section": "intersection_type",
        "text": "Get intersection type between actual primitive and another primitive or polygon data.\nIntersection type:\n0 - objects do not intersect,\n1 - this object fully inside other (no common contour points),\n2 - other object fully inside this,\n3 - common contour points,\n4 - undefined intersection.\nintersection_type\nPolygon\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.intersection_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.intersection_type.html#pyedb.grpc.database.primitive.primitive.Primitive.intersection_type",
        "title": "intersection_type > intersection_type > intersection_type",
        "section": "intersection_type > intersection_type",
        "text": "Primitive.intersection_type(primitive)\n\nGet intersection type between actual primitive and another primitive or polygon data.\n\nParameters\n\nprimitive\n\nPolygon or PolygonData\n\n\n\nReturns\n\npython:int\n\nIntersection type:\n0 - objects do not intersect,\n1 - this object fully inside other (no common contour points),\n2 - other object fully inside this,\n3 - common contour points,\n4 - undefined intersection.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.parse_file",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "parse_file"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.parse_file",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.parse_file.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod DiffPairLengthMatch.parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.simplify_dielectrics_for_phi",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.simplify_dielectrics_for_phi.html#simplify_dielectrics_for_phi",
        "title": "simplify_dielectrics_for_phi",
        "section": "simplify_dielectrics_for_phi",
        "text": "Split dielectric layers at the boundaries of signal layers and merge them.\nThickness threshold for the layer.\nMethod for merging.\nList of dielectric layers created during the dielectric simplification process.\nsimplify_dielectrics_for_phi\nDatabase\npython:float\nDielectricMergingMethod\nWEIGHTED_CAPACITANCE\npython:list\nStackupLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.simplify_dielectrics_for_phi",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.simplify_dielectrics_for_phi.html#pyedb.grpc.database.stackup.Stackup.simplify_dielectrics_for_phi",
        "title": "simplify_dielectrics_for_phi > simplify_dielectrics_for_phi > simplify_dielectrics_for_phi",
        "section": "simplify_dielectrics_for_phi > simplify_dielectrics_for_phi",
        "text": "Stackup.simplify_dielectrics_for_phi(database, layer_thickness_thresh=-1, merging_method=DielectricMergingMethod.WEIGHTED_CAPACITANCE)\n\nSplit dielectric layers at the boundaries of signal layers and merge them.\n\nParameters\n\ndatabase\n\nDatabase\n\n\n\nlayer_thickness_thresh\n\npython:float, default: -1\n\nThickness threshold for the layer.\n\nmerging_method\n\nDielectricMergingMethod, default: WEIGHTED_CAPACITANCE\n\nMethod for merging.\n\nReturns\n\npython:list[StackupLayer]\n\nList of dielectric layers created during the dielectric simplification process.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create_package_def",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create_package_def.html#create_package_def",
        "title": "create_package_def",
        "section": "create_package_def",
        "text": "Create a package definition and assign it to the component.\nName of the package definition\nPart name of the component.\nTrue if succeeded, False otherwise.\ncreate_package_def\npython:str\noptional\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create_package_def",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.create_package_def.html#pyedb.grpc.database.hierarchy.component.Component.create_package_def",
        "title": "create_package_def > create_package_def > create_package_def",
        "section": "create_package_def > create_package_def",
        "text": "Component.create_package_def(name=None, component_part_name=None) -> bool\n\nCreate a package definition and assign it to the component.\n\nParameters\n\nname: str, optional\n\nName of the package definition\n\ncomponent_part_name\n\npython:str, optional\n\nPart name of the component.\n\nReturns\n\nbool\n\nTrue if succeeded, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.layout_obj_type.html#pyedb.grpc.database.ports.ports.CircuitPort.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "CircuitPort.layout_obj_type = 2\n\n"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude: Optional set or mapping specifying which fields to include in the copied model.\nexclude: Optional set or mapping specifying which fields to exclude in the copied model.\nupdate: Optional dictionary of field-value pairs to override field values in the copied model.\ndeep: If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.copy.html#pyedb.workflows.drc.drc.Rules.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "Rules.copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -> Self\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nArgs:\n\ninclude: Optional set or mapping specifying which fields to include in the copied model.\nexclude: Optional set or mapping specifying which fields to exclude in the copied model.\nupdate: Optional dictionary of field-value pairs to override field values in the copied model.\ndeep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_parametrized_name",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nString representing the new class where params are passed to cls as type variables.\nTypeError: Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_parametrized_name",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_parametrized_name.html#pyedb.grpc.database.definition.materials.MaterialProperties.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod MaterialProperties.model_parametrized_name(params: tuple[type[Any], ...]) -> str\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n\nparams: Tuple of types of the class. Given a generic class\n\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturns:\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises:\n\nTypeError: Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.html#padstackinstanceterminal",
        "title": "PadstackInstanceTerminal",
        "section": "PadstackInstanceTerminal",
        "text": "Manages bundle terminal properties.\nPadstackInstanceTerminal.cast([term_type])\nCast the terminal object to the correct concrete type, fetching the type if necessary.\nPadstackInstanceTerminal.create(layout, ...)\nCreate a padstack instance terminal.\nPadstackInstanceTerminal.create_3d_comp()\nCreate a 3D composite model from an MCAD file.\nPadstackInstanceTerminal.create_hfss()\nCreate an HFSS model from an MCAD file.\nPadstackInstanceTerminal.create_stride()\nCreate a Stride model from an MCAD file.\nPadstackInstanceTerminal.delete()\nDelete the layout object.\nPadstackInstanceTerminal.find(layout, name)\nFind a terminal by name in a given layout.\nPadstackInstanceTerminal.find_by_id(layout, uid)\nFind a Connectable object by database ID in a given layout.\nPadstackInstanceTerminal.get_product_property(...)\nGet the product property of the layout object for a given product ID and attribute ID.\nPadstackInstanceTerminal.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nPadstackInstanceTerminal.product_solver_names(...)\nGet the list of solver names.\nPadstackInstanceTerminal.product_solver_option(...)\nGet the name of the product solver option.\nPadstackInstanceTerminal.set_product_property(...)\nSet the product property of the layout object for a given product ID and attribute ID.\nPadstackInstanceTerminal.set_product_solver_option(...)\nSet the product solver option.\nPadstackInstanceTerminal.layout_obj_type\n\nPadstackInstanceTerminal.type\n\nPadstackInstanceTerminal\nPadstackInstanceTerminal.cast\nPadstackInstanceTerminal.create\nPadstackInstanceTerminal.create_3d_comp\nPadstackInstanceTerminal.create_hfss\nPadstackInstanceTerminal.create_stride\nPadstackInstanceTerminal.delete\nPadstackInstanceTerminal.find\nPadstackInstanceTerminal.find_by_id\nPadstackInstanceTerminal.get_product_property\nPadstackInstanceTerminal.get_product_property_ids\nPadstackInstanceTerminal.product_solver_names\nPadstackInstanceTerminal.product_solver_option\nPadstackInstanceTerminal.set_product_property\nPadstackInstanceTerminal.set_product_solver_option\nPadstackInstanceTerminal.layout_obj_type\nPadstackInstanceTerminal.type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.html#pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal",
        "title": "PadstackInstanceTerminal > PadstackInstanceTerminal > PadstackInstanceTerminal",
        "section": "PadstackInstanceTerminal > PadstackInstanceTerminal",
        "text": "class pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal(pedb, edb_object=None)\n\nManages bundle terminal properties.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nPadstackInstanceTerminal.cast([term_type])\n\nCast the terminal object to the correct concrete type, fetching the type if necessary.\n\nPadstackInstanceTerminal.create(layout, ...)\n\nCreate a padstack instance terminal.\n\nPadstackInstanceTerminal.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nPadstackInstanceTerminal.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nPadstackInstanceTerminal.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nPadstackInstanceTerminal.delete()\n\nDelete the layout object.\n\nPadstackInstanceTerminal.find(layout, name)\n\nFind a terminal by name in a given layout.\n\nPadstackInstanceTerminal.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nPadstackInstanceTerminal.get_product_property(...)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nPadstackInstanceTerminal.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nPadstackInstanceTerminal.product_solver_names(...)\n\nGet the list of solver names.\n\nPadstackInstanceTerminal.product_solver_option(...)\n\nGet the name of the product solver option.\n\nPadstackInstanceTerminal.set_product_property(...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nPadstackInstanceTerminal.set_product_solver_option(...)\n\nSet the product solver option.\n\n\n\nAttributes\n\n\n\n\n\n\n\nPadstackInstanceTerminal.layout_obj_type\n\n\n\nPadstackInstanceTerminal.type\n\n\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_dc_terminal",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_dc_terminal.html#create_dc_terminal",
        "title": "create_dc_terminal",
        "section": "create_dc_terminal",
        "text": "Create a dc terminal.\nName of the positive component.\nName of the positive net.\nName of the source. The default is \"\".\nThe name of the source.\ncreate_dc_terminal\npython:str\npython:str\npython:str\noptional\n\"\"\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_dc_terminal",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_dc_terminal.html#pyedb.dotnet.database.siwave.EdbSiwave.create_dc_terminal",
        "title": "create_dc_terminal > create_dc_terminal > create_dc_terminal",
        "section": "create_dc_terminal > create_dc_terminal",
        "text": "EdbSiwave.create_dc_terminal(component_name, net_name, source_name='')\n\nCreate a dc terminal.\n\nParameters\n\ncomponent_name\n\npython:str\n\nName of the positive component.\n\nnet_name\n\npython:str\n\nName of the positive net.\n\nsource_name\n\npython:str, optional\n\nName of the source. The default is \"\".\n\nReturns\n\npython:str\n\nThe name of the source.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", \"project name\", \"release version\")\n>>> edb.siwave.create_dc_terminal(\"U2A5\", \"V1P5_S3\", \"source_name\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.html#edbnetsdata",
        "title": "EDBNetsData",
        "section": "EDBNetsData",
        "text": "Manages EDB functionalities for a primitives.\nIt Inherits EDB Object properties.\nEDBNetsData.create(layout, name)\nEdb Dotnet Api Database Edb.Net.Create.\nEDBNetsData.delete()\nEdb Dotnet Api Database Edb.Net.Delete.\nEDBNetsData.find_by_name(layout, net)\nEdb Dotnet Api Database Edb.Net.FindByName.\nEDBNetsData.find_dc_short([fix])\nFind DC-shorted nets.\nEDBNetsData.get_smallest_trace_width()\nRetrieve the smallest trace width from paths.\nEDBNetsData.plot([layers, show_legend, ...])\nPlot a net to Matplotlib 2D chart.\nEDBNetsData\nEDBNetsData.create\nEDBNetsData.delete\nEDBNetsData.find_by_name\nEDBNetsData.find_dc_short\nEDBNetsData.get_smallest_trace_width\nEDBNetsData.plot"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.html#pyedb.dotnet.database.edb_data.nets_data.EDBNetsData",
        "title": "EDBNetsData > EDBNetsData > EDBNetsData",
        "section": "EDBNetsData > EDBNetsData",
        "text": "class pyedb.dotnet.database.edb_data.nets_data.EDBNetsData(raw_net, core_app)\n\nManages EDB functionalities for a primitives.\nIt Inherits EDB Object properties.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb(myedb, edbversion=\"2021.2\")\n>>> edb_net = edb.nets.nets[\"GND\"]\n>>> edb_net.name  # Class Property\n>>> edb_net.name  # EDB Object Property\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nEDBNetsData.create(layout, name)\n\nEdb Dotnet Api Database Edb.Net.Create.\n\nEDBNetsData.delete()\n\nEdb Dotnet Api Database Edb.Net.Delete.\n\nEDBNetsData.find_by_name(layout, net)\n\nEdb Dotnet Api Database Edb.Net.FindByName.\n\nEDBNetsData.find_dc_short([fix])\n\nFind DC-shorted nets.\n\nEDBNetsData.get_smallest_trace_width()\n\nRetrieve the smallest trace width from paths.\n\nEDBNetsData.plot([layers, show_legend, ...])\n\nPlot a net to Matplotlib 2D chart.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.make_zone_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.make_zone_primitive.html#make_zone_primitive",
        "title": "make_zone_primitive",
        "section": "make_zone_primitive",
        "text": "Make the primitive a zone primitive with a zone specified by the provided ID.\nID of the zone primitive to use.\nmake_zone_primitive\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.make_zone_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.make_zone_primitive.html#pyedb.grpc.database.primitive.path.Path.make_zone_primitive",
        "title": "make_zone_primitive > make_zone_primitive > make_zone_primitive",
        "section": "make_zone_primitive > make_zone_primitive",
        "text": "Path.make_zone_primitive(zone_id: int)\n\nMake the primitive a zone primitive with a zone specified by the provided ID.\n\nParameters\n\nzone_id\n\npython:int\n\nID of the zone primitive to use.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/layout_validation",
        "href": "grpc_api/grpc/database/layout_validation.html#layout-validation",
        "title": "Layout validation",
        "section": "Layout validation",
        "text": "These classes are the containers of Layout Validation.\nlayout_validation.LayoutValidation\nManages all layout validation capabilities\nLayout validation\nlayout_validation.LayoutValidation"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_element_data",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_element_data.html#export_element_data",
        "title": "export_element_data",
        "section": "export_element_data",
        "text": "Export element data.\nName of the setup.\nPath to the exported report.\nType of the data. The default is \"Vias\".\nTrue when successful, False when failed.\nexport_element_data\npython:str\npython:str\npython:str\noptional\n\"Vias\"\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_element_data",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_element_data.html#pyedb.siwave.Siwave.export_element_data",
        "title": "export_element_data > export_element_data > export_element_data",
        "section": "export_element_data > export_element_data",
        "text": "Siwave.export_element_data(simulation_name, file_path, data_type='Vias')\n\nExport element data.\n\nParameters\n\nsimulation_name\n\npython:str\n\nName of the setup.\n\nfile_path\n\npython:str\n\nPath to the exported report.\n\ndata_type\n\npython:str, optional\n\nType of the data. The default is \"Vias\".\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_product_property.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "PadstackInstance.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.area",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.area.html#area",
        "title": "area",
        "section": "area",
        "text": "Return the total area.\nEither if the voids have to be included in computation.\nThe default value is True.\narea\noptional\nTrue\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.area",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.area.html#pyedb.grpc.database.primitive.primitive.Primitive.area",
        "title": "area > area > area",
        "section": "area > area",
        "text": "Primitive.area(include_voids=True) -> float\n\nReturn the total area.\n\nParameters\n\ninclude_voids\n\nbool, optional\n\nEither if the voids have to be included in computation.\nThe default value is True.\n\nReturns\n\npython:float\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_voltage_source_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_voltage_source_terminal.html#create_voltage_source_terminal",
        "title": "create_voltage_source_terminal",
        "section": "create_voltage_source_terminal",
        "text": "Create voltage source terminal.\nSource magnitude, default value 1.0.\nSource phase, default value 0.0.\nSource impedance, default value 1e-3.\nPin group terminal.\ncreate_voltage_source_terminal\npython:float\npython:int\noptional\n1.0\npython:float\npython:int\noptional\n0.0\npython:float\noptional\n1e-3\nPinGroupTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_voltage_source_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_voltage_source_terminal.html#pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_voltage_source_terminal",
        "title": "create_voltage_source_terminal > create_voltage_source_terminal > create_voltage_source_terminal",
        "section": "create_voltage_source_terminal > create_voltage_source_terminal",
        "text": "PinGroup.create_voltage_source_terminal(magnitude=1, phase=0, impedance=0.001) -> PinGroupTerminal\n\nCreate voltage source terminal.\n\nParameters\n\nmagnitude\n\npython:float or python:int, optional\n\nSource magnitude, default value 1.0.\n\nphase\n\npython:float or python:int, optional\n\nSource phase, default value 0.0.\n\nimpedance\n\npython:float, optional\n\nSource impedance, default value 1e-3.\n\nReturns\n\nPinGroupTerminal.\n\nPin group terminal.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.product_solver_option.html#product_solver_option",
        "title": "product_solver_option",
        "section": "product_solver_option",
        "text": "Get the name of the product solver option.\nID of the product.\nName of the solver.\nName of the product solver option.\nproduct_solver_option\nProductIdType\nstr\nstr"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.product_solver_option.html#pyedb.grpc.database.ports.ports.GapPort.product_solver_option",
        "title": "product_solver_option > product_solver_option > product_solver_option",
        "section": "product_solver_option > product_solver_option",
        "text": "GapPort.product_solver_option(product_id, solver_name)\n\nGet the name of the product solver option.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nsolver_name\n\nstr\n\nName of the solver.\n\nReturns\n\nstr\n\nName of the product solver option.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.remove_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.remove_hfss_prop.html#remove_hfss_prop",
        "title": "remove_hfss_prop",
        "section": "remove_hfss_prop",
        "text": "Remove HFSS properties.\nremove_hfss_prop"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.remove_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.remove_hfss_prop.html#pyedb.grpc.database.primitive.bondwire.Bondwire.remove_hfss_prop",
        "title": "remove_hfss_prop > remove_hfss_prop > remove_hfss_prop",
        "section": "remove_hfss_prop > remove_hfss_prop",
        "text": "Bondwire.remove_hfss_prop()\n\nRemove HFSS properties.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.dict",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "dict"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.dict",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.dict.html#pyedb.workflows.drc.drc.MinLineWidth.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "MinLineWidth.dict(*, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Dict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.layer_data.LayerEdbClass.update",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.layer_data.LayerEdbClass.update.html#update",
        "title": "update",
        "section": "update",
        "text": "update"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.layer_data.LayerEdbClass.update",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.layer_data.LayerEdbClass.update.html#pyedb.dotnet.database.edb_data.layer_data.LayerEdbClass.update",
        "title": "update > update > update",
        "section": "update > update",
        "text": "LayerEdbClass.update(**kwargs)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.set_zone_name",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.set_zone_name.html#set_zone_name",
        "title": "set_zone_name",
        "section": "set_zone_name",
        "text": "Set the name for a given zone.\nZone ID.\nNew name to give the zone.\nset_zone_name\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.set_zone_name",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.set_zone_name.html#pyedb.grpc.database.stackup.Stackup.set_zone_name",
        "title": "set_zone_name > set_zone_name > set_zone_name",
        "section": "set_zone_name > set_zone_name",
        "text": "Stackup.set_zone_name(zone, name)\n\nSet the name for a given zone.\n\nParameters\n\nzone\n\npython:int\n\nZone ID.\n\nname\n\npython:str\n\nNew name to give the zone.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_pin_group_terminal_reference_pin",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_pin_group_terminal_reference_pin.html#get_pin_group_terminal_reference_pin",
        "title": "get_pin_group_terminal_reference_pin",
        "section": "get_pin_group_terminal_reference_pin",
        "text": "Return a list of pins and serves terminals connected to pingroups.\nPreferred reference net name.\nget_pin_group_terminal_reference_pin\npython:str\noptional\ndotnet.database.edb_data.padstack_data.EDBPadstackInstance"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_pin_group_terminal_reference_pin",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_pin_group_terminal_reference_pin.html#pyedb.dotnet.database.edb_data.ports.WavePort.get_pin_group_terminal_reference_pin",
        "title": "get_pin_group_terminal_reference_pin > get_pin_group_terminal_reference_pin > get_pin_group_terminal_reference_pin",
        "section": "get_pin_group_terminal_reference_pin > get_pin_group_terminal_reference_pin",
        "text": "WavePort.get_pin_group_terminal_reference_pin(gnd_net_name_preference=None)\n\nReturn a list of pins and serves terminals connected to pingroups.\n\nParameters\n\ngnd_net_name_preference\n\npython:str, optional\n\nPreferred reference net name.\n\nReturns\n\ndotnet.database.edb_data.padstack_data.EDBPadstackInstance\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.parse_file",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "parse_file"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.parse_file",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.parse_file.html#pyedb.workflows.drc.drc.MinAnnularRing.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod MinAnnularRing.parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.find_by_reference_designator",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.find_by_reference_designator.html#find_by_reference_designator",
        "title": "find_by_reference_designator",
        "section": "find_by_reference_designator",
        "text": "Find a component.\nReference designator of the component.\nfind_by_reference_designator\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.find_by_reference_designator",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.find_by_reference_designator.html#pyedb.dotnet.database.components.Components.find_by_reference_designator",
        "title": "find_by_reference_designator > find_by_reference_designator > find_by_reference_designator",
        "section": "find_by_reference_designator > find_by_reference_designator",
        "text": "Components.find_by_reference_designator(reference_designator)\n\nFind a component.\n\nParameters\n\nreference_designator\n\npython:str\n\nReference designator of the component.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.parse_obj",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "parse_obj"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.parse_obj",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.parse_obj.html#pyedb.workflows.drc.drc.MinClearance.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod MinClearance.parse_obj(obj: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/job_manager/job_manager",
        "href": "workflows/job_manager/job_manager.html#pyedb-job-manager-backendproduction-documentation",
        "title": "PyEDB job manager backend—production documentation",
        "section": "PyEDB job manager backend—production documentation",
        "text": "PyEDB job manager backend—production documentation\nOverview\nModule Reference\njob_manager_handler.py\njob_submission.py\nservice.py\nREST API\nJobs\nResources & Queues\nCluster Introspection\nWebSocket Events\nQuick Examples\nSynchronous (Legacy Code)\nAsynchronous (Native Asyncio)\nCommand Line\nDeployment Notes\nSee Also\nPyEDB job manager backend—production documentation\nTable of Contents"
    },
    {
        "objectID": "workflows/job_manager/job_manager",
        "href": "workflows/job_manager/job_manager.html#overview",
        "title": "PyEDB job manager backend—production documentation > Overview",
        "section": "Overview",
        "text": "The job manager backend is a hybrid async/sync service that schedules and\nmonitors HFSS / 3D-Layout simulations on:\nLocal workstations (sub-process)\nEnterprise clusters (SLURM, LSF, PBS, Windows-HPC)\nIt exposes thread-safe synchronous façades for legacy code bases while\nkeeping a fully asynchronous core for high-throughput scenarios.\nOverview"
    },
    {
        "objectID": "workflows/job_manager/job_manager",
        "href": "workflows/job_manager/job_manager.html#module-reference",
        "title": "PyEDB job manager backend—production documentation > Module Reference",
        "section": "Module Reference",
        "text": "Module Reference"
    },
    {
        "objectID": "workflows/job_manager/job_manager",
        "href": "workflows/job_manager/job_manager.html#job_manager_handlerpy",
        "title": "PyEDB job manager backend—production documentation > job_manager_handler.py",
        "section": "job_manager_handler.py",
        "text": "Thread-safe synchronous façade\nBridges blocking code to the async JobManager without exposing asyncio\nAuto-detects ANSYS installation and cluster scheduler\nStarts / stops a daemon thread hosting the aiohttp server\nProvides convenience helpers such as create_simulation_config()\njob_manager_handler.py\nJobManager\nasyncio\ncreate_simulation_config()"
    },
    {
        "objectID": "workflows/job_manager/job_manager",
        "href": "workflows/job_manager/job_manager.html#job_submissionpy",
        "title": "PyEDB job manager backend—production documentation > job_submission.py",
        "section": "job_submission.py",
        "text": "Cross-platform simulation launcher\nImmutable data models: HFSSSimulationConfig, SchedulerOptions, MachineNode\nGenerates ready-to-run shell commands or batch scripts (SLURM/LSF)\nEntry point: create_hfss_config() → config.run_simulation()\njob_submission.py\nHFSSSimulationConfig\nSchedulerOptions\nMachineNode\ncreate_hfss_config()\nconfig.run_simulation()"
    },
    {
        "objectID": "workflows/job_manager/job_manager",
        "href": "workflows/job_manager/job_manager.html#servicepy",
        "title": "PyEDB job manager backend—production documentation > service.py",
        "section": "service.py",
        "text": "Async job manager & REST layer\nJobManager: priority queues, resource limits, Socket. IO push\nResourceMonitor: async telemetry (CPU, RAM, disk)\nSchedulerManager: live cluster introspection (partitions, queues)\nSelf-hosted aiohttp application with REST + WebSocket endpoints\nservice.py\nJobManager\nResourceMonitor\nSchedulerManager"
    },
    {
        "objectID": "workflows/job_manager/job_manager",
        "href": "workflows/job_manager/job_manager.html#rest-api",
        "title": "PyEDB job manager backend—production documentation > REST API",
        "section": "REST API",
        "text": "Base URL defaults to http://localhost:8080.\nAll JSON payloads use Content-Type: application/json.\nREST API\nhttp://localhost:8080\nContent-Type: application/json"
    },
    {
        "objectID": "workflows/job_manager/job_manager",
        "href": "workflows/job_manager/job_manager.html#jobs",
        "title": "PyEDB job manager backend—production documentation > Jobs",
        "section": "Jobs",
        "text": "Method\nRoute\nDescription\nPayload\nResponse\nPOST\n/jobs/submit\nQueue new simulation\n{\"config\": {...}, \"priority\": 0}\n{\"job_id\": \"uuid\", \"status\": \"queued\"}\nGET\n/jobs\nList all jobs\n—\nJSON array\nPOST\n/jobs/{id}/cancel\nCancel queued / running job\n—\n{\"success\": true}\nPOST\n/jobs/{id}/priority\nChange job priority\n{\"priority\": 5}\n{\"success\": true}\nJobs\nPOST\n/jobs/submit\n{\"config\": {...}, \"priority\": 0}\n{\"job_id\": \"uuid\", \"status\": \"queued\"}\nGET\n/jobs\nPOST\n/jobs/{id}/cancel\n{\"success\": true}\nPOST\n/jobs/{id}/priority\n{\"priority\": 5}\n{\"success\": true}"
    },
    {
        "objectID": "workflows/job_manager/job_manager",
        "href": "workflows/job_manager/job_manager.html#resources--queues",
        "title": "PyEDB job manager backend—production documentation > Resources & Queues",
        "section": "Resources & Queues",
        "text": "Method\nRoute\nDescription\nResponse\nGET\n/resources\nHost telemetry snapshot\n{\"cpu_percent\": 12.3, \"memory_free_gb\": 45.6, ...}\nGET\n/queue\nQueue statistics\n{\"total_queued\": 7, \"running_jobs\": 2, ...}\nPUT\n/pool/limits\nEdit concurrency limits\n{\"max_concurrent_jobs\": 4}\nResources & Queues\nGET\n/resources\n{\"cpu_percent\": 12.3, \"memory_free_gb\": 45.6, ...}\nGET\n/queue\n{\"total_queued\": 7, \"running_jobs\": 2, ...}\nPUT\n/pool/limits\n{\"max_concurrent_jobs\": 4}"
    },
    {
        "objectID": "workflows/job_manager/job_manager",
        "href": "workflows/job_manager/job_manager.html#cluster-introspection",
        "title": "PyEDB job manager backend—production documentation > Cluster Introspection",
        "section": "Cluster Introspection",
        "text": "Method\nRoute\nDescription\nResponse\nGET\n/scheduler/partitions\nAvailable partitions / queues\nJSON array\nGET\n/system/status\nCombined status object\nScheduler, resources, limits\nCluster Introspection\nGET\n/scheduler/partitions\nGET\n/system/status"
    },
    {
        "objectID": "workflows/job_manager/job_manager",
        "href": "workflows/job_manager/job_manager.html#websocket-events",
        "title": "PyEDB job manager backend—production documentation > WebSocket Events",
        "section": "WebSocket Events",
        "text": "Connect to ws://host:port with Socket.IO.\nEmitted server → client:\njob_queued\njob_started\njob_scheduled\njob_completed\nlimits_updated\nWebSocket Events\nws://host:port\njob_queued\njob_started\njob_scheduled\njob_completed\nlimits_updated"
    },
    {
        "objectID": "workflows/job_manager/job_manager",
        "href": "workflows/job_manager/job_manager.html#quick-examples",
        "title": "PyEDB job manager backend—production documentation > Quick Examples",
        "section": "Quick Examples",
        "text": "Quick Examples"
    },
    {
        "objectID": "workflows/job_manager/job_manager",
        "href": "workflows/job_manager/job_manager.html#synchronous-legacy-code",
        "title": "PyEDB job manager backend—production documentation > Synchronous (Legacy Code)",
        "section": "Synchronous (Legacy Code)",
        "text": "Synchronous (Legacy Code)"
    },
    {
        "objectID": "workflows/job_manager/job_manager",
        "href": "workflows/job_manager/job_manager.html#asynchronous-native-asyncio",
        "title": "PyEDB job manager backend—production documentation > Asynchronous (Native Asyncio)",
        "section": "Asynchronous (Native Asyncio)",
        "text": "Asynchronous (Native Asyncio)"
    },
    {
        "objectID": "workflows/job_manager/job_manager",
        "href": "workflows/job_manager/job_manager.html#command-line",
        "title": "PyEDB job manager backend—production documentation > Command Line",
        "section": "Command Line",
        "text": "Command Line"
    },
    {
        "objectID": "workflows/job_manager/job_manager",
        "href": "workflows/job_manager/job_manager.html#deployment-notes",
        "title": "PyEDB job manager backend—production documentation > Deployment Notes",
        "section": "Deployment Notes",
        "text": "The service is self-contained; no external database is required (jobs are\nstored in-memory).  For persistence, plug in a small SQLite layer inside\nJobManager.jobs.\nWhen running inside Docker, expose port 8080 and mount the project\ndirectory into the container so that ansysedt can access .aedt files.\nCPU / RAM limits are soft limits; tune ResourceLimits to your\nworkstation or cluster node size.\nTLS termination should be handled by an upstream reverse proxy (nginx,\nreverse proxy, etc.); the backend only speaks plain HTTP/WebSocket.\nDeployment Notes\nJobManager.jobs\n8080\nansysedt\n.aedt\nResourceLimits"
    },
    {
        "objectID": "workflows/job_manager/job_manager",
        "href": "workflows/job_manager/job_manager.html#see-also",
        "title": "PyEDB job manager backend—production documentation > See Also",
        "section": "See Also",
        "text": "job_manager_handler_discussion—architectural trade-offs\nexamples/job_manager/—full CLI & Jupyter demos\nANSYS HFSS batch options documentation\nSee Also\nexamples/job_manager/"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.set_simulation_settings",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.set_simulation_settings.html#set_simulation_settings",
        "title": "set_simulation_settings",
        "section": "set_simulation_settings",
        "text": "set_simulation_settings"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.set_simulation_settings",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.set_simulation_settings.html#pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.set_simulation_settings",
        "title": "set_simulation_settings > set_simulation_settings > set_simulation_settings",
        "section": "set_simulation_settings > set_simulation_settings",
        "text": "SiwaveSimulationSetup.set_simulation_settings(sim_settings: dict)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.layout_obj_type.html#pyedb.grpc.database.net.extended_net.ExtendedNet.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "ExtendedNet.layout_obj_type = 14\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.couple_ports",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.couple_ports.html#couple_ports",
        "title": "couple_ports",
        "section": "couple_ports",
        "text": "Create a bundle wave port.\nPorts to be added.\ncouple_ports\nWaveport\nBundleWavePort"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.couple_ports",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.couple_ports.html#pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.couple_ports",
        "title": "couple_ports > couple_ports > couple_ports",
        "section": "couple_ports > couple_ports",
        "text": "EdgeTerminal.couple_ports(port)\n\nCreate a bundle wave port.\n\nParameters\n\nport\n\nWaveport,\n\n\n\n:class:`GapPOrt <pyedb.grpc.database.ports.ports.GapPort>`, list, optional\n\nPorts to be added.\n\nReturns\n\nBundleWavePort\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_json_schema",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias: Whether to use attribute aliases or not.\nref_template: The reference template.\nunion_format: The format to use when combining schemas from unions together. Can be one of:\n‘any_of’: Use the [anyOf](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\nkeyword to combine schemas (the default).\n- ‘primitive_type_array’: Use the [type](https://json-schema.org/understanding-json-schema/reference/type)\nkeyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\ntype (string, boolean, null, integer or number) or contains constraints/metadata, falls back to\nany_of.\nGenerateJsonSchema with your desired modifications\nmode: The mode in which to generate the schema.\nThe JSON schema for the given model class.\nmodel_json_schema"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_json_schema",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_json_schema.html#pyedb.grpc.database.definition.materials.MaterialProperties.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod MaterialProperties.model_json_schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}', schema_generator: type[~pydantic.json_schema.GenerateJsonSchema] = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: ~typing.Literal['validation', 'serialization'] = 'validation', *, union_format: ~typing.Literal['any_of', 'primitive_type_array'] = 'any_of') -> dict[str, Any]\n\nGenerates a JSON schema for a model class.\n\nArgs:\n\nby_alias: Whether to use attribute aliases or not.\nref_template: The reference template.\nunion_format: The format to use when combining schemas from unions together. Can be one of:\n\n‘any_of’: Use the [anyOf](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n\nkeyword to combine schemas (the default).\n- ‘primitive_type_array’: Use the [type](https://json-schema.org/understanding-json-schema/reference/type)\nkeyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\ntype (string, boolean, null, integer or number) or contains constraints/metadata, falls back to\nany_of.\n\nschema_generator: To override the logic used to generate the JSON schema, as a subclass of\n\nGenerateJsonSchema with your desired modifications\n\nmode: The mode in which to generate the schema.\n\nReturns:\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.hfss_extent_info.HfssExtentInfo",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.hfss_extent_info.HfssExtentInfo.html#hfssextentinfo",
        "title": "HfssExtentInfo",
        "section": "HfssExtentInfo",
        "text": "Manages EDB functionalities for HFSS extent information.\nInherited EDB object.\nHfssExtentInfo.export_config()\nExport HFSS extent information.\nHfssExtentInfo.load_config(config)\nLoad HFSS extent configuration.\nHfssExtentInfo\npyedb.grpc.edb.Edb\nHfssExtentInfo.export_config\nHfssExtentInfo.load_config"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.hfss_extent_info.HfssExtentInfo",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.hfss_extent_info.HfssExtentInfo.html#pyedb.grpc.database.utility.hfss_extent_info.HfssExtentInfo",
        "title": "HfssExtentInfo > HfssExtentInfo > HfssExtentInfo",
        "section": "HfssExtentInfo > HfssExtentInfo",
        "text": "class pyedb.grpc.database.utility.hfss_extent_info.HfssExtentInfo(pedb)\n\nManages EDB functionalities for HFSS extent information.\n\nParameters\n\npedb\n\npyedb.grpc.edb.Edb\n\nInherited EDB object.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nHfssExtentInfo.export_config()\n\nExport HFSS extent information.\n\nHfssExtentInfo.load_config(config)\n\nLoad HFSS extent configuration.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.solve_siwave",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.solve_siwave.html#solve_siwave",
        "title": "solve_siwave",
        "section": "solve_siwave",
        "text": "Solve with SIwave.\nPath to SIwave project.\nsolve_siwave\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.solve_siwave",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.solve_siwave.html#pyedb.grpc.edb.Edb.solve_siwave",
        "title": "solve_siwave > solve_siwave > solve_siwave",
        "section": "solve_siwave > solve_siwave",
        "text": "Edb.solve_siwave()\n\nSolve with SIwave.\n\nReturns\n\npython:str\n\nPath to SIwave project.\n\nExamples\n\n>>> # Solve with SIwave:\n>>> edb.solve_siwave()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.couple_ports",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.couple_ports.html#couple_ports",
        "title": "couple_ports",
        "section": "couple_ports",
        "text": "Create a bundle wave port.\nPorts to be added.\ncouple_ports\ndotnet.database.ports.WavePort\ndotnet.database.ports.GapPort\npython:list\noptional\ndotnet.database.ports.BundleWavePort"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.couple_ports",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.couple_ports.html#pyedb.dotnet.database.edb_data.ports.WavePort.couple_ports",
        "title": "couple_ports > couple_ports > couple_ports",
        "section": "couple_ports > couple_ports",
        "text": "WavePort.couple_ports(port)\n\nCreate a bundle wave port.\n\nParameters\n\nport\n\ndotnet.database.ports.WavePort, dotnet.database.ports.GapPort, python:list, optional\n\nPorts to be added.\n\nReturns\n\ndotnet.database.ports.BundleWavePort\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_padstack_terminal_reference_pin",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_padstack_terminal_reference_pin.html#get_padstack_terminal_reference_pin",
        "title": "get_padstack_terminal_reference_pin",
        "section": "get_padstack_terminal_reference_pin",
        "text": "Get a list of pad stacks instances and serves Coax wave ports,\npingroup terminals, PadEdge terminals.\nPreferred reference net name.\nget_padstack_terminal_reference_pin\npython:str\noptional\ndotnet.database.edb_data.padstack_data.EDBPadstackInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_padstack_terminal_reference_pin",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_padstack_terminal_reference_pin.html#pyedb.grpc.database.ports.ports.ExcitationSources.get_padstack_terminal_reference_pin",
        "title": "get_padstack_terminal_reference_pin > get_padstack_terminal_reference_pin > get_padstack_terminal_reference_pin",
        "section": "get_padstack_terminal_reference_pin > get_padstack_terminal_reference_pin",
        "text": "ExcitationSources.get_padstack_terminal_reference_pin(gnd_net_name_preference=None)\n\nGet a list of pad stacks instances and serves Coax wave ports,\npingroup terminals, PadEdge terminals.\n\nParameters\n\ngnd_net_name_preference\n\npython:str, optional\n\nPreferred reference net name.\n\nReturns\n\ndotnet.database.edb_data.padstack_data.EDBPadstackInstance\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/heat_sink",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/heat_sink.html#heat-sink",
        "title": "Heat sink",
        "section": "Heat sink",
        "text": "This class is managing EDB heat sink.\nHeatSink\nHeatsink model description.\nHeat sink\nHeatSink"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.adjust_solder_dielectrics",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.adjust_solder_dielectrics.html#adjust_solder_dielectrics",
        "title": "adjust_solder_dielectrics",
        "section": "adjust_solder_dielectrics",
        "text": "Adjust the stack-up by adding or modifying dielectric layers that contains Solder Balls.\nThis method identifies the solder-ball height and adjust the dielectric thickness on top (or bottom) to fit\nthe thickness in order to merge another layout.\nadjust_solder_dielectrics"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.adjust_solder_dielectrics",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.adjust_solder_dielectrics.html#pyedb.dotnet.database.stackup.Stackup.adjust_solder_dielectrics",
        "title": "adjust_solder_dielectrics > adjust_solder_dielectrics > adjust_solder_dielectrics",
        "section": "adjust_solder_dielectrics > adjust_solder_dielectrics",
        "text": "Stackup.adjust_solder_dielectrics()\n\nAdjust the stack-up by adding or modifying dielectric layers that contains Solder Balls.\nThis method identifies the solder-ball height and adjust the dielectric thickness on top (or bottom) to fit\nthe thickness in order to merge another layout.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.hfss_extent_info.HfssExtentInfo.load_config",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.hfss_extent_info.HfssExtentInfo.load_config.html#load_config",
        "title": "load_config",
        "section": "load_config",
        "text": "Load HFSS extent configuration.\nParameters of the HFSS extent information.\nload_config"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.hfss_extent_info.HfssExtentInfo.load_config",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.hfss_extent_info.HfssExtentInfo.load_config.html#pyedb.dotnet.database.edb_data.hfss_extent_info.HfssExtentInfo.load_config",
        "title": "load_config > load_config > load_config",
        "section": "load_config > load_config",
        "text": "HfssExtentInfo.load_config(config)\n\nLoad HFSS extent configuration.\n\nParameters\n\nconfig: dict\n\nParameters of the HFSS extent information.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create_via_fence",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create_via_fence.html#create_via_fence",
        "title": "create_via_fence",
        "section": "create_via_fence",
        "text": "Create via fences on both sides of the trace.\nDistance between via fence and trace center line.\nGap between vias.\nName of the via padstack.\nName of the net.\ncreate_via_fence"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create_via_fence",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create_via_fence.html#pyedb.grpc.database.primitive.path.Path.create_via_fence",
        "title": "create_via_fence > create_via_fence > create_via_fence",
        "section": "create_via_fence > create_via_fence",
        "text": "Path.create_via_fence(distance, gap, padstack_name, net_name='GND')\n\nCreate via fences on both sides of the trace.\n\nParameters\n\ndistance: str, float\n\nDistance between via fence and trace center line.\n\ngap: str, float\n\nGap between vias.\n\npadstack_name: str\n\nName of the via padstack.\n\nnet_name: str, optional\n\nName of the net.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.dielectric_loss_tangent",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.dielectric_loss_tangent.html#dielectric_loss_tangent",
        "title": "dielectric_loss_tangent",
        "section": "dielectric_loss_tangent",
        "text": "dielectric_loss_tangent"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.dielectric_loss_tangent",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.dielectric_loss_tangent.html#pyedb.grpc.database.definition.materials.MaterialProperties.dielectric_loss_tangent",
        "title": "dielectric_loss_tangent > dielectric_loss_tangent > dielectric_loss_tangent",
        "section": "dielectric_loss_tangent > dielectric_loss_tangent",
        "text": "MaterialProperties.dielectric_loss_tangent: Annotated[float, Gt(gt=0)] | None\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.definitions.Definitions",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.definitions.Definitions.html#definitions",
        "title": "Definitions",
        "section": "Definitions",
        "text": "Definitions.add_package_def(name[, ...])\nAdd a package definition.\nDefinitions\nDefinitions.add_package_def"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.definitions.Definitions",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.definitions.Definitions.html#pyedb.grpc.database.definitions.Definitions",
        "title": "Definitions > Definitions > Definitions",
        "section": "Definitions > Definitions",
        "text": "class pyedb.grpc.database.definitions.Definitions(pedb)\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nDefinitions.add_package_def(name[, ...])\n\nAdd a package definition.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_current_source_on_net",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_current_source_on_net.html#create_current_source_on_net",
        "title": "create_current_source_on_net",
        "section": "create_current_source_on_net",
        "text": "Create a voltage source.\nName of the positive component.\nName of the positive net.\nName of the negative component. The default is None, in which case the name of\nthe positive net is assigned.\nName of the negative net name. The default is None which will look for GND Nets.\nValue for the voltage. The default is 3.3.\nValue for the phase. The default is 0.\nName of the source. The default is \"\".\nThe name of the source.\ncreate_current_source_on_net\npython:str\npython:str\npython:str\noptional\nNone\npython:str\noptional\nNone\npython:float\noptional\n3.3\noptional\n0\npython:str\noptional\n\"\"\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_current_source_on_net",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_current_source_on_net.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_current_source_on_net",
        "title": "create_current_source_on_net > create_current_source_on_net > create_current_source_on_net",
        "section": "create_current_source_on_net > create_current_source_on_net",
        "text": "SourceExcitation.create_current_source_on_net(positive_component_name: str, positive_net_name: str, negative_component_name: str | None = None, negative_net_name: str | None = None, current_value: int | float = 0, phase_value: int | float = 0, source_name: str | None = None) -> str | None\n\nCreate a voltage source.\n\nParameters\n\npositive_component_name\n\npython:str\n\nName of the positive component.\n\npositive_net_name\n\npython:str\n\nName of the positive net.\n\nnegative_component_name\n\npython:str, optional\n\nName of the negative component. The default is None, in which case the name of\nthe positive net is assigned.\n\nnegative_net_name\n\npython:str, optional\n\nName of the negative net name. The default is None which will look for GND Nets.\n\nvoltage_value\n\npython:float, optional\n\nValue for the voltage. The default is 3.3.\n\nphase_value\n\noptional\n\nValue for the phase. The default is 0.\n\nsource_name\n\npython:str, optional\n\nName of the source. The default is \"\".\n\nReturns\n\npython:str\n\nThe name of the source.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> edb.source_excitation.create_current_source_on_net(\"U1\", \"INPUT\", \"U1\", \"GND\", 0.1, name=\"InputCurrent\")\n\"InputCurrent\"\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_debye_material",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_debye_material.html#add_debye_material",
        "title": "add_debye_material",
        "section": "add_debye_material",
        "text": "Add a dielectric with the Debye model.\nName of the dielectric.\nRelative permittivity of the dielectric at the frequency specified\nfor lower_frequency.\nRelative permittivity of the dielectric at the frequency specified\nfor higher_frequency.\nLoss tangent for the material at the frequency specified\nfor lower_frequency.\nLoss tangent for the material at the frequency specified\nfor higher_frequency.\nValue for the lower frequency.\nValue for the higher frequency.\nadd_debye_material\npython:str\npython:float\npython:int\nlower_frequency\npython:float\npython:int\nhigher_frequency\npython:float\npython:int\nlower_frequency\npython:float\npython:int\nhigher_frequency\npython:str\npython:float\npython:int\npython:str\npython:float\npython:int\npyedb.dotnet.database.materials.Material"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_debye_material",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_debye_material.html#pyedb.dotnet.database.materials.Materials.add_debye_material",
        "title": "add_debye_material > add_debye_material > add_debye_material",
        "section": "add_debye_material > add_debye_material",
        "text": "Materials.add_debye_material(name, permittivity_low, permittivity_high, loss_tangent_low, loss_tangent_high, lower_freqency, higher_frequency, **kwargs)\n\nAdd a dielectric with the Debye model.\n\nParameters\n\nname\n\npython:str\n\nName of the dielectric.\n\npermittivity_low\n\npython:float, python:int\n\nRelative permittivity of the dielectric at the frequency specified\nfor lower_frequency.\n\npermittivity_high\n\npython:float, python:int\n\nRelative permittivity of the dielectric at the frequency specified\nfor higher_frequency.\n\nloss_tangent_low\n\npython:float, python:int\n\nLoss tangent for the material at the frequency specified\nfor lower_frequency.\n\nloss_tangent_high\n\npython:float, python:int\n\nLoss tangent for the material at the frequency specified\nfor higher_frequency.\n\nlower_freqency\n\npython:str, python:float, python:int\n\nValue for the lower frequency.\n\nhigher_frequency\n\npython:str, python:float, python:int\n\nValue for the higher frequency.\n\nReturns\n\npyedb.dotnet.database.materials.Material\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_hfss_setup",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_hfss_setup.html#create_hfss_setup",
        "title": "create_hfss_setup",
        "section": "create_hfss_setup",
        "text": "Create an HFSS simulation setup from a template.\n. deprecated:: pyedb 0.30.0\nUse pyedb.grpc.core.hfss.add_setup() instead.\ncreate_hfss_setup\npyedb.grpc.core.hfss.add_setup()"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_hfss_setup",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_hfss_setup.html#pyedb.grpc.edb.Edb.create_hfss_setup",
        "title": "create_hfss_setup > create_hfss_setup > create_hfss_setup",
        "section": "create_hfss_setup > create_hfss_setup",
        "text": "Edb.create_hfss_setup(name=None, start_frequency='0GHz', stop_frequency='20GHz', step_frequency='10MHz') -> HfssSimulationSetup\n\nCreate an HFSS simulation setup from a template.\n\n. deprecated:: pyedb 0.30.0\nUse pyedb.grpc.core.hfss.add_setup() instead.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.set_variable_value",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.set_variable_value.html#set_variable_value",
        "title": "set_variable_value",
        "section": "set_variable_value",
        "text": "Set a variable to a new value.\nVariable name.\nNew value.\nset_variable_value\npython:str\npython:str\npython:int\npython:float\ncomplex\nValue"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.set_variable_value",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.set_variable_value.html#pyedb.grpc.database.layout.cell.Cell.set_variable_value",
        "title": "set_variable_value > set_variable_value > set_variable_value",
        "section": "set_variable_value > set_variable_value",
        "text": "Cell.set_variable_value(name, new_value)\n\nSet a variable to a new value.\n\nParameters\n\nname\n\npython:str\n\nVariable name.\n\nnew_value\n\npython:str, python:int, python:float, complex, Value\n\nNew value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.update_forward_refs",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "update_forward_refs"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.update_forward_refs",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.update_forward_refs.html#pyedb.workflows.drc.drc.BackDrillStubLength.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod BackDrillStubLength.update_forward_refs(**localns: Any) -> None\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.delete",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete current simulation setup.\ndelete"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.delete",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.delete.html#pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "RaptorXSimulationSetup.delete()\n\nDelete current simulation setup.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_dump",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#python-mode)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude: A set of fields to include in the output.\nexclude: A set of fields to exclude from the output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\nA dictionary representation of the model.\nmodel_dump"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_dump",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_dump.html#pyedb.workflows.drc.drc.MinAnnularRing.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "MinAnnularRing.model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -> dict[str, Any]\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#python-mode)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n\nmode: The mode in which to_python should run.\n\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude: A set of fields to include in the output.\nexclude: A set of fields to exclude from the output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\n\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\n\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback: A function to call when an unknown value is encountered. If not provided,\n\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileComponents.add_component",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileComponents.add_component.html#add_component",
        "title": "add_component",
        "section": "add_component",
        "text": "Create a new component.\nReference Designator name.\nPart name.\nComponent Type. Can be “IC”, “IO” or “Other”.\nDie Type. Can be “None”, “Flip chip” or “Wire bond”.\nSolderball Type. Can be “None”, “Cylinder” or “Spheroid”.\nadd_component\npython:str\npython:str\npython:str\npython:str\noptional\npython:str\noptional"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileComponents.add_component",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileComponents.add_component.html#pyedb.dotnet.database.edb_data.control_file.ControlFileComponents.add_component",
        "title": "add_component > add_component > add_component",
        "section": "add_component > add_component",
        "text": "ControlFileComponents.add_component(ref_des, partname, component_type, die_type='None', solderball_shape='None')\n\nCreate a new component.\n\nParameters\n\nref_des\n\npython:str\n\nReference Designator name.\n\npartname\n\npython:str\n\nPart name.\n\ncomponent_type\n\npython:str\n\nComponent Type. Can be “IC”, “IO” or “Other”.\n\ndie_type\n\npython:str, optional\n\nDie Type. Can be “None”, “Flip chip” or “Wire bond”.\n\nsolderball_shape\n\npython:str, optional\n\nSolderball Type. Can be “None”, “Cylinder” or “Spheroid”.\n\nReturns\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileVia",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileVia.html#controlfilevia",
        "title": "ControlFileVia",
        "section": "ControlFileVia",
        "text": "ControlFileVia"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileVia",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileVia.html#pyedb.grpc.database.utility.xml_control_file.ControlFileVia",
        "title": "ControlFileVia > ControlFileVia > ControlFileVia",
        "section": "ControlFileVia > ControlFileVia",
        "text": "class pyedb.grpc.database.utility.xml_control_file.ControlFileVia(name, properties)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.closest_points",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.closest_points.html#closest_points",
        "title": "closest_points",
        "section": "closest_points",
        "text": "Compute points on this and another polygon that are closest to the other polygon.\nclosest_points\nPolygonData\npython:tuple\nof\nPointData\nPointData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.closest_points",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.closest_points.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.closest_points",
        "title": "closest_points > closest_points > closest_points",
        "section": "closest_points > closest_points",
        "text": "PolygonData.closest_points(polygon: PolygonData) -> tuple[PointData, PointData]\n\nCompute points on this and another polygon that are closest to the other polygon.\n\nParameters\n\npolygon\n\nPolygonData\n\n\n\nReturns\n\npython:tuple of (PointData, PointData)\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.assign_spice_model",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.assign_spice_model.html#assign_spice_model",
        "title": "assign_spice_model",
        "section": "assign_spice_model",
        "text": "Assign Spice model to all components under this part name.\nFile path of the Spice model.\nName of the Spice model.\nassign_spice_model\npython:str\npython:str\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.assign_spice_model",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.assign_spice_model.html#pyedb.grpc.database.definition.component_def.ComponentDef.assign_spice_model",
        "title": "assign_spice_model > assign_spice_model > assign_spice_model",
        "section": "assign_spice_model > assign_spice_model",
        "text": "ComponentDef.assign_spice_model(file_path, model_name=None) -> bool\n\nAssign Spice model to all components under this part name.\n\nParameters\n\nfile_path\n\npython:str\n\nFile path of the Spice model.\n\nmodel_name\n\npython:str, optional\n\nName of the Spice model.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_hfss_prop.html#get_hfss_prop",
        "title": "get_hfss_prop",
        "section": "get_hfss_prop",
        "text": "Get HFSS properties.\nReturns a tuple in this format:\n(material, solve_inside)\nmaterial :  Name of the material property.\nsolve_inside : Whether to solve inside.\nget_hfss_prop\npython:tuple\nof\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_hfss_prop.html#pyedb.grpc.database.primitive.bondwire.Bondwire.get_hfss_prop",
        "title": "get_hfss_prop > get_hfss_prop > get_hfss_prop",
        "section": "get_hfss_prop > get_hfss_prop",
        "text": "Bondwire.get_hfss_prop() -> tuple[str, bool]\n\nGet HFSS properties.\n\nReturns\n\npython:tuple of (python:str, bool)\n\nReturns a tuple in this format:\n\n(material, solve_inside)\n\nmaterial :  Name of the material property.\n\nsolve_inside : Whether to solve inside.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.create_pin_group",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.create_pin_group.html#create_pin_group",
        "title": "create_pin_group",
        "section": "create_pin_group",
        "text": "Create pin group on a component.\nReference designator.\nList of pin names.\nGroup name.\n(group_name, PinGroup) if successful, False otherwise.\ncreate_pin_group\npython:str\npython:list\npython:str\npython:str\noptional\npython:tuple\npython:str\npyedb.grpc.database.hierarchy.pingroup.PinGroup\nor"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.create_pin_group",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.create_pin_group.html#pyedb.grpc.database.components.Components.create_pin_group",
        "title": "create_pin_group > create_pin_group > create_pin_group",
        "section": "create_pin_group > create_pin_group",
        "text": "Components.create_pin_group(reference_designator: str, pin_numbers: str | List[str], group_name: str | None = None) -> Tuple[str, PinGroup] | bool\n\nCreate pin group on a component.\n\nParameters\n\nreference_designator\n\npython:str\n\nReference designator.\n\npin_numbers\n\npython:list[python:str]\n\nList of pin names.\n\ngroup_name\n\npython:str, optional\n\nGroup name.\n\nReturns\n\npython:tuple[python:str, pyedb.grpc.database.hierarchy.pingroup.PinGroup] or bool\n\n(group_name, PinGroup) if successful, False otherwise.\n\nExamples\n\n>>> name, group = edbapp.components.create_pin_group(\"U1\", [\"1\", \"2\"])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_current_source_on_pin",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_current_source_on_pin.html#create_current_source_on_pin",
        "title": "create_current_source_on_pin",
        "section": "create_current_source_on_pin",
        "text": "Create a current source.\nPositive pin.\nNegative pin.\nValue for the current. The default is 0.1.\nValue for the phase. The default is 0.\nName of the source. The default is \"\".\nSource Name.\ncreate_current_source_on_pin\nObject\nObject\npython:float\noptional\n0.1\noptional\n0\npython:str\noptional\n\"\"\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_current_source_on_pin",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_current_source_on_pin.html#pyedb.dotnet.database.siwave.EdbSiwave.create_current_source_on_pin",
        "title": "create_current_source_on_pin > create_current_source_on_pin > create_current_source_on_pin",
        "section": "create_current_source_on_pin > create_current_source_on_pin",
        "text": "EdbSiwave.create_current_source_on_pin(pos_pin, neg_pin, current_value=0.1, phase_value=0, source_name='')\n\nCreate a current source.\n\nParameters\n\npos_pin\n\nObject\n\nPositive pin.\n\nneg_pin\n\nObject\n\nNegative pin.\n\ncurrent_value\n\npython:float, optional\n\nValue for the current. The default is 0.1.\n\nphase_value\n\noptional\n\nValue for the phase. The default is 0.\n\nsource_name\n\npython:str, optional\n\nName of the source. The default is \"\".\n\nReturns\n\npython:str\n\nSource Name.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", \"project name\", \"release version\")\n>>> pins = edbapp.components.get_pin_from_component(\"U2A5\")\n>>> edbapp.siwave.create_current_source_on_pin(pins[0], pins[1], 50, \"source_name\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.intersect",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.intersect.html#intersect",
        "title": "intersect",
        "section": "intersect",
        "text": "Intersect active primitive with one or more primitives.\nList of Primitive objects.\nintersect\nList\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.intersect",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.intersect.html#pyedb.grpc.database.primitive.primitive.Primitive.intersect",
        "title": "intersect > intersect > intersect",
        "section": "intersect > intersect",
        "text": "Primitive.intersect(primitives) -> list[any]\n\nIntersect active primitive with one or more primitives.\n\nParameters\n\nprimitives :class:`Primitives <pyedb.grpc.database.primitive.primitive.Primitive>`\n\n\n\nor: List[:class:`Primitives <pyedb.grpc.database.primitive.primitive.Primitive>`]\n\n\n\nor: class:`PolygonData <ansys.edb.core.geometry.polygon_data.PolygonData>`\n\n\n\nReturns\n\nList[Primitive]\n\nList of Primitive objects.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.create_terminal",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.create_terminal.html#create_terminal",
        "title": "create_terminal",
        "section": "create_terminal",
        "text": "Create a padstack instance terminal\ncreate_terminal"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.create_terminal",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.create_terminal.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.create_terminal",
        "title": "create_terminal > create_terminal > create_terminal",
        "section": "create_terminal > create_terminal",
        "text": "EDBPadstackInstance.create_terminal(name=None)\n\nCreate a padstack instance terminal\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_debye_material",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_debye_material.html#add_debye_material",
        "title": "add_debye_material",
        "section": "add_debye_material",
        "text": "Add a dielectric with the Debye model.\nName of the dielectric.\nRelative permittivity of the dielectric at the frequency specified\nfor lower_frequency.\nRelative permittivity of the dielectric at the frequency specified\nfor higher_frequency.\nLoss tangent for the material at the frequency specified\nfor lower_frequency.\nLoss tangent for the material at the frequency specified\nfor higher_frequency.\nValue for the lower frequency.\nValue for the higher frequency.\nMaterial object.\nadd_debye_material\npython:str\npython:float\npython:int\nlower_frequency\npython:float\npython:int\nhigher_frequency\npython:float\npython:int\nlower_frequency\npython:float\npython:int\nhigher_frequency\npython:str\npython:float\npython:int\npython:str\npython:float\npython:int\nMaterial"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_debye_material",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_debye_material.html#pyedb.grpc.database.definition.materials.Materials.add_debye_material",
        "title": "add_debye_material > add_debye_material > add_debye_material",
        "section": "add_debye_material > add_debye_material",
        "text": "Materials.add_debye_material(name, permittivity_low, permittivity_high, loss_tangent_low, loss_tangent_high, lower_freqency, higher_frequency, **kwargs) -> Material\n\nAdd a dielectric with the Debye model.\n\nParameters\n\nname\n\npython:str\n\nName of the dielectric.\n\npermittivity_low\n\npython:float, python:int\n\nRelative permittivity of the dielectric at the frequency specified\nfor lower_frequency.\n\npermittivity_high\n\npython:float, python:int\n\nRelative permittivity of the dielectric at the frequency specified\nfor higher_frequency.\n\nloss_tangent_low\n\npython:float, python:int\n\nLoss tangent for the material at the frequency specified\nfor lower_frequency.\n\nloss_tangent_high\n\npython:float, python:int\n\nLoss tangent for the material at the frequency specified\nfor higher_frequency.\n\nlower_freqency\n\npython:str, python:float, python:int\n\nValue for the lower frequency.\n\nhigher_frequency\n\npython:str, python:float, python:int\n\nValue for the higher frequency.\n\nReturns\n\nMaterial\n\nMaterial object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.product_solver_option.html#product_solver_option",
        "title": "product_solver_option",
        "section": "product_solver_option",
        "text": "Get the name of the product solver option.\nID of the product.\nName of the solver.\nName of the product solver option.\nproduct_solver_option\nProductIdType\nstr\nstr"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.product_solver_option.html#pyedb.grpc.database.terminal.point_terminal.PointTerminal.product_solver_option",
        "title": "product_solver_option > product_solver_option > product_solver_option",
        "section": "product_solver_option > product_solver_option",
        "text": "PointTerminal.product_solver_option(product_id, solver_name)\n\nGet the name of the product solver option.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nsolver_name\n\nstr\n\nName of the solver.\n\nReturns\n\nstr\n\nName of the product solver option.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.html#polygondata",
        "title": "PolygonData",
        "section": "PolygonData",
        "text": "Class managing Polygon Data.\nPolygonData.alpha_shape(points, alpha)\nCompute the outline of a 2D point cloud using alpha shapes.\nPolygonData.area()\nCompute the area of the polygon.\nPolygonData.bbox()\nCompute the bounding box.\nPolygonData.bbox_of_polygons(polygons)\nCompute the bounding box of a list of polygons.\nPolygonData.bounding_circle()\nCompute the bounding circle of the polygon.\nPolygonData.circle_intersect(center, radius)\nDetermine whether the circle intersects with a polygon.\nPolygonData.closest_point(point)\nCompute a point on the polygon that is closest to another point.\nPolygonData.closest_points(polygon)\nCompute points on this and another polygon that are closest to the other polygon.\nPolygonData.convex_hull(polygons)\nCompute the convex hull of the union of a list of polygons.\nPolygonData.create_from_bounding_box(points)\nCreate PolygonData from point list.\nPolygonData.create_from_points(points[, closed])\n\nPolygonData.defeature([tol])\nDefeature a polygon.\nPolygonData.expand([offset, tolerance, ...])\nExpand the polygon shape by an absolute value in all direction.\nPolygonData.has_arcs()\nDetermine whether the polygon contains any arcs.\nPolygonData.has_holes()\nDetermine whether the polygon contains any holes.\nPolygonData.has_self_intersections([tol])\nDetermine whether the polygon contains any self-intersections.\nPolygonData.intersect(polygons1, polygons2)\nCompute the intersection of one or more lists of polygons.\nPolygonData.intersection_type(other[, tol])\nGet the intersection type with another polygon.\nPolygonData.is_box()\nDetermine whether the outer contour of the polygon is a box.\nPolygonData.is_circle()\nDetermine whether the outer contour of the polygon is a circle.\nPolygonData.is_convex()\nDetermine whether the polygon is a convex hull.\nPolygonData.is_hole()\nDetermine whether the polygon is a hole.\nPolygonData.is_inside(point)\nDetermine whether the point is inside the polygon.\nPolygonData.is_parametric()\nDetermine whether a polygon contains any parametrized points.\nPolygonData.mirror_x(x)\nMirror a polygon by x line.\nPolygonData.move(vector)\nMove the polygon by a vector.\nPolygonData.normalized()\nGet the normalized points of the polygon.\nPolygonData.remove_self_intersections([tol])\nRemove self-intersections from this polygon.\nPolygonData.rotate(angle, center)\nRotate the polygon at a center by an angle.\nPolygonData.scale(factor, center)\nScale the polygon by a linear factor from a center.\nPolygonData.subtract(polygons1, polygons2)\nSubtract a set of polygons from another set of polygons.\nPolygonData.unite(polygons)\nCompute the union of a list of polygons.\nPolygonData.without_arcs([max_chord_error, ...])\nGet polygon data with all arcs removed.\nPolygonData.xor(polygons1, polygons2)\nCompute an exclusive OR between a set of polygons and another set of polygons.\nPolygonData\nPolygonData.alpha_shape\nPolygonData.area\nPolygonData.bbox\nPolygonData.bbox_of_polygons\nPolygonData.bounding_circle\nPolygonData.circle_intersect\nPolygonData.closest_point\nPolygonData.closest_points\nPolygonData.convex_hull\nPolygonData.create_from_bounding_box\nPolygonData.create_from_points\nPolygonData.defeature\nPolygonData.expand\nPolygonData.has_arcs\nPolygonData.has_holes\nPolygonData.has_self_intersections\nPolygonData.intersect\nPolygonData.intersection_type\nPolygonData.is_box\nPolygonData.is_circle\nPolygonData.is_convex\nPolygonData.is_hole\nPolygonData.is_inside\nPolygonData.is_parametric\nPolygonData.mirror_x\nPolygonData.move\nPolygonData.normalized\nPolygonData.remove_self_intersections\nPolygonData.rotate\nPolygonData.scale\nPolygonData.subtract\nPolygonData.unite\nPolygonData.without_arcs\nPolygonData.xor"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.html#pyedb.grpc.database.geometry.polygon_data.PolygonData",
        "title": "PolygonData > PolygonData > PolygonData",
        "section": "PolygonData > PolygonData",
        "text": "class pyedb.grpc.database.geometry.polygon_data.PolygonData(pedb, edb_object=None, create_from_points=None, create_from_circle=None, create_from_rectangle=None, create_from_bounding_box=None, **kwargs)\n\nClass managing Polygon Data.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nPolygonData.alpha_shape(points, alpha)\n\nCompute the outline of a 2D point cloud using alpha shapes.\n\nPolygonData.area()\n\nCompute the area of the polygon.\n\nPolygonData.bbox()\n\nCompute the bounding box.\n\nPolygonData.bbox_of_polygons(polygons)\n\nCompute the bounding box of a list of polygons.\n\nPolygonData.bounding_circle()\n\nCompute the bounding circle of the polygon.\n\nPolygonData.circle_intersect(center, radius)\n\nDetermine whether the circle intersects with a polygon.\n\nPolygonData.closest_point(point)\n\nCompute a point on the polygon that is closest to another point.\n\nPolygonData.closest_points(polygon)\n\nCompute points on this and another polygon that are closest to the other polygon.\n\nPolygonData.convex_hull(polygons)\n\nCompute the convex hull of the union of a list of polygons.\n\nPolygonData.create_from_bounding_box(points)\n\nCreate PolygonData from point list.\n\nPolygonData.create_from_points(points[, closed])\n\n\n\nPolygonData.defeature([tol])\n\nDefeature a polygon.\n\nPolygonData.expand([offset, tolerance, ...])\n\nExpand the polygon shape by an absolute value in all direction.\n\nPolygonData.has_arcs()\n\nDetermine whether the polygon contains any arcs.\n\nPolygonData.has_holes()\n\nDetermine whether the polygon contains any holes.\n\nPolygonData.has_self_intersections([tol])\n\nDetermine whether the polygon contains any self-intersections.\n\nPolygonData.intersect(polygons1, polygons2)\n\nCompute the intersection of one or more lists of polygons.\n\nPolygonData.intersection_type(other[, tol])\n\nGet the intersection type with another polygon.\n\nPolygonData.is_box()\n\nDetermine whether the outer contour of the polygon is a box.\n\nPolygonData.is_circle()\n\nDetermine whether the outer contour of the polygon is a circle.\n\nPolygonData.is_convex()\n\nDetermine whether the polygon is a convex hull.\n\nPolygonData.is_hole()\n\nDetermine whether the polygon is a hole.\n\nPolygonData.is_inside(point)\n\nDetermine whether the point is inside the polygon.\n\nPolygonData.is_parametric()\n\nDetermine whether a polygon contains any parametrized points.\n\nPolygonData.mirror_x(x)\n\nMirror a polygon by x line.\n\nPolygonData.move(vector)\n\nMove the polygon by a vector.\n\nPolygonData.normalized()\n\nGet the normalized points of the polygon.\n\nPolygonData.remove_self_intersections([tol])\n\nRemove self-intersections from this polygon.\n\nPolygonData.rotate(angle, center)\n\nRotate the polygon at a center by an angle.\n\nPolygonData.scale(factor, center)\n\nScale the polygon by a linear factor from a center.\n\nPolygonData.subtract(polygons1, polygons2)\n\nSubtract a set of polygons from another set of polygons.\n\nPolygonData.unite(polygons)\n\nCompute the union of a list of polygons.\n\nPolygonData.without_arcs([max_chord_error, ...])\n\nGet polygon data with all arcs removed.\n\nPolygonData.xor(polygons1, polygons2)\n\nCompute an exclusive OR between a set of polygons and another set of polygons.\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_vrm_module",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_vrm_module.html#create_vrm_module",
        "title": "create_vrm_module",
        "section": "create_vrm_module",
        "text": "Create a voltage regulator module.\nName of the voltage regulator.\nSet the voltage regulator active or not. Default value is True.\nSet the voltage value.\ndefining the positive sensor pin.\ndefining the negative sensor pin.\ndefinition the load regulation current value.\ndefinition the load regulation percent value.\ncreate_vrm_module\npython:str\noptional\nTrue\npython:int\nclass\npyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance\npython:int\nclass\npyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance\npython:str\npython:float\npython:float"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_vrm_module",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_vrm_module.html#pyedb.dotnet.database.siwave.EdbSiwave.create_vrm_module",
        "title": "create_vrm_module > create_vrm_module > create_vrm_module",
        "section": "create_vrm_module > create_vrm_module",
        "text": "EdbSiwave.create_vrm_module(name=None, is_active=True, voltage='3V', positive_sensor_pin=None, negative_sensor_pin=None, load_regulation_current='1A', load_regulation_percent=0.1)\n\nCreate a voltage regulator module.\n\nParameters\n\nname\n\npython:str\n\nName of the voltage regulator.\n\nis_active\n\nbool optional\n\nSet the voltage regulator active or not. Default value is True.\n\nvoltage ; str, float\n\nSet the voltage value.\n\npositive_sensor_pin\n\npython:int, class pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance\n\ndefining the positive sensor pin.\n\nnegative_sensor_pin\n\npython:int, class pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance\n\ndefining the negative sensor pin.\n\nload_regulation_current\n\npython:str or python:float\n\ndefinition the load regulation current value.\n\nload_regulation_percent\n\npython:float\n\ndefinition the load regulation percent value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.update_forward_refs",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "update_forward_refs"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.update_forward_refs",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.update_forward_refs.html#pyedb.workflows.drc.drc.MinAnnularRing.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod MinAnnularRing.update_forward_refs(**localns: Any) -> None\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.get_simulation_settings",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.get_simulation_settings.html#get_simulation_settings",
        "title": "get_simulation_settings",
        "section": "get_simulation_settings",
        "text": "get_simulation_settings"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.get_simulation_settings",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.get_simulation_settings.html#pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.get_simulation_settings",
        "title": "get_simulation_settings > get_simulation_settings > get_simulation_settings",
        "section": "get_simulation_settings > get_simulation_settings",
        "text": "HfssSimulationSetup.get_simulation_settings()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.netlist_model.NetlistModel.create",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.netlist_model.NetlistModel.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a netlist model.\nName of the netlist model.\nNetlist model created.\ncreate\npython:str\nNetlistModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.netlist_model.NetlistModel.create",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.netlist_model.NetlistModel.create.html#pyedb.grpc.database.hierarchy.netlist_model.NetlistModel.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod NetlistModel.create(name)\n\nCreate a netlist model.\n\nParameters\n\nname\n\npython:str\n\nName of the netlist model.\n\nReturns\n\nNetlistModel\n\nNetlist model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "migration_guide",
        "href": "migration_guide.html#migration-guide-dotnet-to-grpc",
        "title": "Migration Guide: DotNet to gRPC",
        "section": "Migration Guide: DotNet to gRPC",
        "text": "This guide helps you migrate scripts from the legacy pyedb.dotnet API to the modern gRPC-based PyEDB client.\nMigration Guide: DotNet to gRPC\npyedb.dotnet"
    },
    {
        "objectID": "migration_guide",
        "href": "migration_guide.html#key-conceptual-changes",
        "title": "Migration Guide: DotNet to gRPC > Key Conceptual Changes",
        "section": "Key Conceptual Changes",
        "text": "Import Structure: The top-level import is now the gRPC client.\nNo AEDT: Your script does not requires AEDT to be running. It connects to the ansys-edb-core service.\nKey Conceptual Changes\nansys-edb-core"
    },
    {
        "objectID": "migration_guide",
        "href": "migration_guide.html#side-by-side-code-comparison",
        "title": "Migration Guide: DotNet to gRPC > Side-by-Side Code Comparison",
        "section": "Side-by-Side Code Comparison",
        "text": "Initialization and Setup\nHowever if you close one edb instance, the default behavior is to close the server. Therefore the other EDB\ninstances are disconnected. To close an EDB instance without closing the server you can use the following code:\nCommon Method Calls\nThe core API (methods on edb.modeler, edb.nets, edb.components) is intentionally very similar to ease migration.\nMost method names and signatures are unchanged. Check the api documentation for details.\nSide-by-Side Code Comparison"
    },
    {
        "objectID": "migration_guide",
        "href": "migration_guide.html#handling-breaking-changes",
        "title": "Migration Guide: DotNet to gRPC > Handling Breaking Changes",
        "section": "Handling Breaking Changes",
        "text": "If you encounter a method or property that existed in the dotnet API but is not yet implemented in the gRPC client,\nyou have two options:\n1.  Check for Alternatives: The new API might have a differently named method or a new, more efficient way to\naccomplish the same task. Check the api documentation.\n2.  Report the Gap: Open an issue on the PyEDB GitHub repository. This\nhelps the development team prioritize which legacy features to port next.\nHandling Breaking Changes"
    },
    {
        "objectID": "migration_guide",
        "href": "migration_guide.html#getting-help",
        "title": "Migration Guide: DotNet to gRPC > Getting Help",
        "section": "Getting Help",
        "text": "If you get stuck during migration, please search for or open a discussion on the\nGitHub Discussions page. The community and development team can\nprovide guidance.\nGetting Help"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.get_product_property.html#pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "BundleTerminal.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.import_cadence_file",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.import_cadence_file.html#import_cadence_file",
        "title": "import_cadence_file",
        "section": "import_cadence_file",
        "text": "Import a board file and generate an edb.def file in the working directory.\nFull path to the board file.\nDirectory in which to create the aedb folder. The default value is None,\nin which case the AEDB file is given the same name as the board file. Only\nthe extension differs.\nFull path to the Ansys translator.\nWhether to use the PPE License. The default is False.\nTrue when successful, False when failed.\nimport_cadence_file\nedb.def\npython:str\npython:str\noptional\naedb\nNone\npython:str\noptional\noptional\nFalse\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.import_cadence_file",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.import_cadence_file.html#pyedb.dotnet.edb.Edb.import_cadence_file",
        "title": "import_cadence_file > import_cadence_file > import_cadence_file",
        "section": "import_cadence_file > import_cadence_file",
        "text": "Edb.import_cadence_file(inputBrd, WorkDir=None, anstranslator_full_path='', use_ppe=False)\n\nImport a board file and generate an edb.def file in the working directory.\n\nParameters\n\ninputBrd\n\npython:str\n\nFull path to the board file.\n\nWorkDir\n\npython:str, optional\n\nDirectory in which to create the aedb folder. The default value is None,\nin which case the AEDB file is given the same name as the board file. Only\nthe extension differs.\n\nanstranslator_full_path\n\npython:str, optional\n\nFull path to the Ansys translator.\n\nuse_ppe\n\nbool, optional\n\nWhether to use the PPE License. The default is False.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.create",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a cell.\nDatabase to create the cell in.\nType of the cell to create.\nName of the cell.\nCell created.\ncreate\nDatabase\nCellType\npython:str\nCell"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.create",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.create.html#pyedb.grpc.database.layout.cell.Cell.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod Cell.create(db, cell_type, cell_name)\n\nCreate a cell.\n\nParameters\n\ndb\n\nDatabase\n\nDatabase to create the cell in.\n\ncell_type\n\nCellType\n\nType of the cell to create.\n\ncell_name\n\npython:str\n\nName of the cell.\n\nReturns\n\nCell\n\nCell created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/index",
        "href": "workflows/index.html#workflows",
        "title": "Workflows",
        "section": "Workflows",
        "text": "This section describes PyEDB workflows features.\nWorkflows"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_voltage_probe_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_voltage_probe_terminal.html#create_voltage_probe_terminal",
        "title": "create_voltage_probe_terminal",
        "section": "create_voltage_probe_terminal",
        "text": "Create voltage probe terminal.\nProbe impedance, default value 1e6.\nPin group terminal.\ncreate_voltage_probe_terminal\npython:float\noptional\n1e6\nPinGroupTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_voltage_probe_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_voltage_probe_terminal.html#pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_voltage_probe_terminal",
        "title": "create_voltage_probe_terminal > create_voltage_probe_terminal > create_voltage_probe_terminal",
        "section": "create_voltage_probe_terminal > create_voltage_probe_terminal",
        "text": "PinGroup.create_voltage_probe_terminal(impedance=1000000.0) -> PinGroupTerminal\n\nCreate voltage probe terminal.\n\nParameters\n\nimpedance\n\npython:float, optional\n\nProbe impedance, default value 1e6.\n\nReturns\n\nPinGroupTerminal.\n\nPin group terminal.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_to_ipc2581",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_to_ipc2581.html#export_to_ipc2581",
        "title": "export_to_ipc2581",
        "section": "export_to_ipc2581",
        "text": "Export design to IPC2581 format.\nFull path to aedb folder of the design to convert.\nPath to Ansys translator executable.\nOutput XML file path. Default: <edb_path>.xml.\nPath to output IPC2581 file, and corresponding log file.\nexport_to_ipc2581\npython:str\noptional\npython:str\noptional\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_to_ipc2581",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_to_ipc2581.html#pyedb.dotnet.edb.Edb.export_to_ipc2581",
        "title": "export_to_ipc2581 > export_to_ipc2581 > export_to_ipc2581",
        "section": "export_to_ipc2581 > export_to_ipc2581",
        "text": "Edb.export_to_ipc2581(edbpath='', anstranslator_full_path='', ipc_path=None) -> str\n\nExport design to IPC2581 format.\n\nParameters\n\nedbpath: str\n\nFull path to aedb folder of the design to convert.\n\nanstranslator_full_path\n\npython:str, optional\n\nPath to Ansys translator executable.\n\nipc_path\n\npython:str, optional\n\nOutput XML file path. Default: <edb_path>.xml.\n\nReturns\n\npython:str\n\nPath to output IPC2581 file, and corresponding log file.\n\nExamples\n\n>>> # Export to IPC2581 format:\n>>> edb.export_to_ipc2581(\"output.xml\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.html#padstackinstance",
        "title": "PadstackInstance",
        "section": "PadstackInstance",
        "text": "Manages EDB functionalities for a padstack.\nPadstackInstance object.\nPadstackInstance.cast()\nCast the ConnObj object to the correct concrete type.\nPadstackInstance.convert_hole_to_conical_shape([angle])\nConvert actual padstack instance to microvias 3D Objects with a given aspect ratio.\nPadstackInstance.create(layout, net, name, ...)\nCreate a padstack instance.\nPadstackInstance.create_3d_comp()\nCreate a 3D composite model from an MCAD file.\nPadstackInstance.create_coax_port([name, ...])\nCreate a coax port.\nPadstackInstance.create_hfss()\nCreate an HFSS model from an MCAD file.\nPadstackInstance.create_port([name, ...])\nCreate a port on the padstack instance.\nPadstackInstance.create_rectangle_in_pad(...)\nCreate a rectangle inscribed inside a padstack instance pad.\nPadstackInstance.create_stride()\nCreate a Stride model from an MCAD file.\nPadstackInstance.create_terminal([name])\nCreate a padstack instance terminal.\nPadstackInstance.delete()\nDelete the padstack instance.\nPadstackInstance.find_by_id(layout, uid)\nFind a Connectable object by database ID in a given layout.\nPadstackInstance.get_back_drill_by_depth([...])\nGet back drill by depth parameters Parameters ---------- from_bottom : bool, optional     Default value is True.\nPadstackInstance.get_back_drill_by_layer([...])\nGet backdrill by layer.\nPadstackInstance.get_back_drill_type(from_bottom)\nGet the back drill type of the padstack instance.\nPadstackInstance.get_backdrill_type([...])\nReturn backdrill type Parameters ---------- from_bottom : bool, optional     default value is True.\nPadstackInstance.get_connected_objects()\nGet connected objects.\nPadstackInstance.get_hole_overrides()\nGet the hole overrides of the padstack instance.\nPadstackInstance.get_layer_range()\nGet the top and bottom layers of the padstack instance.\nPadstackInstance.get_padstack_instance_terminal()\nPadstackInstanceTerminal:         Terminal of the padstack instance.\nPadstackInstance.get_position_and_rotation()\nGet the position and rotation of the padstack instance.\nPadstackInstance.get_product_property(...)\nGet the product property of the layout object for a given product ID and attribute ID.\nPadstackInstance.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nPadstackInstance.get_reference_pins([...])\nSearch for reference pins using given criteria.\nPadstackInstance.get_terminal([...])\nReturns padstack instance terminal.\nPadstackInstance.in_polygon(polygon_data[, ...])\nCheck if padstack Instance is in given polygon data.\nPadstackInstance.in_voids([net_name, layer_name])\nCheck if this padstack instance is in any void.\nPadstackInstance.is_in_pin_group(pin_group)\nDetermine if the padstack instance is in a given pin group.\nPadstackInstance.parametrize_position([prefix])\nParametrize the instance position.\nPadstackInstance.set_back_drill_by_depth(...)\nSet back drill by depth.\nPadstackInstance.set_back_drill_by_layer(...)\nSet back drill layer.\nPadstackInstance.set_backdrill_bottom(...[, ...])\nSet backdrill from bottom.\nPadstackInstance.set_backdrill_top(...[, offset])\nSet backdrill from top.\nPadstackInstance.set_hole_overrides(...)\nSet the hole overrides of the padstack instance.\nPadstackInstance.set_layer_range(top_layer, ...)\nSet the top and bottom layers of the padstack instance.\nPadstackInstance.set_position_and_rotation(x, ...)\nSet the position and rotation of the padstack instance.\nPadstackInstance.set_product_property(...)\nSet the product property of the layout object for a given product ID and attribute ID.\nPadstackInstance.split()\nSplit padstack instance into multiple instances.\nPadstackInstance.layout_obj_type\nLayoutObjType: Layout object type of the PadstackInstance class.\nPadstackInstance\nPadstackInstance.cast\nPadstackInstance.convert_hole_to_conical_shape\nPadstackInstance.create\nPadstackInstance.create_3d_comp\nPadstackInstance.create_coax_port\nPadstackInstance.create_hfss\nPadstackInstance.create_port\nPadstackInstance.create_rectangle_in_pad\nPadstackInstance.create_stride\nPadstackInstance.create_terminal\nPadstackInstance.delete\nPadstackInstance.find_by_id\nPadstackInstance.get_back_drill_by_depth\nPadstackInstance.get_back_drill_by_layer\nPadstackInstance.get_back_drill_type\nPadstackInstance.get_backdrill_type\nPadstackInstance.get_connected_objects\nPadstackInstance.get_hole_overrides\nPadstackInstance.get_layer_range\nPadstackInstance.get_padstack_instance_terminal\nPadstackInstanceTerminal\nPadstackInstance.get_position_and_rotation\nPadstackInstance.get_product_property\nPadstackInstance.get_product_property_ids\nPadstackInstance.get_reference_pins\nPadstackInstance.get_terminal\nPadstackInstance.in_polygon\nPadstackInstance.in_voids\nPadstackInstance.is_in_pin_group\nPadstackInstance.parametrize_position\nPadstackInstance.set_back_drill_by_depth\nPadstackInstance.set_back_drill_by_layer\nPadstackInstance.set_backdrill_bottom\nPadstackInstance.set_backdrill_top\nPadstackInstance.set_hole_overrides\nPadstackInstance.set_layer_range\nPadstackInstance.set_position_and_rotation\nPadstackInstance.set_product_property\nPadstackInstance.split\nPadstackInstance.layout_obj_type\nLayoutObjType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance",
        "title": "PadstackInstance > PadstackInstance > PadstackInstance",
        "section": "PadstackInstance > PadstackInstance",
        "text": "class pyedb.grpc.database.primitive.padstack_instance.PadstackInstance(pedb, edb_instance)\n\nManages EDB functionalities for a padstack.\n\nParameters\n\n:class:`PadstackInstance <pyedb.grpc.dataybase.primitive.PadstackInstance>`\n\nPadstackInstance object.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb(myedb, edbversion=\"2021.2\")\n>>> edb_padstack_instance = edb.padstacks.instances[0]\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nPadstackInstance.cast()\n\nCast the ConnObj object to the correct concrete type.\n\nPadstackInstance.convert_hole_to_conical_shape([angle])\n\nConvert actual padstack instance to microvias 3D Objects with a given aspect ratio.\n\nPadstackInstance.create(layout, net, name, ...)\n\nCreate a padstack instance.\n\nPadstackInstance.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nPadstackInstance.create_coax_port([name, ...])\n\nCreate a coax port.\n\nPadstackInstance.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nPadstackInstance.create_port([name, ...])\n\nCreate a port on the padstack instance.\n\nPadstackInstance.create_rectangle_in_pad(...)\n\nCreate a rectangle inscribed inside a padstack instance pad.\n\nPadstackInstance.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nPadstackInstance.create_terminal([name])\n\nCreate a padstack instance terminal.\n\nPadstackInstance.delete()\n\nDelete the padstack instance.\n\nPadstackInstance.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nPadstackInstance.get_back_drill_by_depth([...])\n\nGet back drill by depth parameters Parameters ---------- from_bottom : bool, optional     Default value is True.\n\nPadstackInstance.get_back_drill_by_layer([...])\n\nGet backdrill by layer.\n\nPadstackInstance.get_back_drill_type(from_bottom)\n\nGet the back drill type of the padstack instance.\n\nPadstackInstance.get_backdrill_type([...])\n\nReturn backdrill type Parameters ---------- from_bottom : bool, optional     default value is True.\n\nPadstackInstance.get_connected_objects()\n\nGet connected objects.\n\nPadstackInstance.get_hole_overrides()\n\nGet the hole overrides of the padstack instance.\n\nPadstackInstance.get_layer_range()\n\nGet the top and bottom layers of the padstack instance.\n\nPadstackInstance.get_padstack_instance_terminal()\n\nPadstackInstanceTerminal:         Terminal of the padstack instance.\n\nPadstackInstance.get_position_and_rotation()\n\nGet the position and rotation of the padstack instance.\n\nPadstackInstance.get_product_property(...)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nPadstackInstance.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nPadstackInstance.get_reference_pins([...])\n\nSearch for reference pins using given criteria.\n\nPadstackInstance.get_terminal([...])\n\nReturns padstack instance terminal.\n\nPadstackInstance.in_polygon(polygon_data[, ...])\n\nCheck if padstack Instance is in given polygon data.\n\nPadstackInstance.in_voids([net_name, layer_name])\n\nCheck if this padstack instance is in any void.\n\nPadstackInstance.is_in_pin_group(pin_group)\n\nDetermine if the padstack instance is in a given pin group.\n\nPadstackInstance.parametrize_position([prefix])\n\nParametrize the instance position.\n\nPadstackInstance.set_back_drill_by_depth(...)\n\nSet back drill by depth.\n\nPadstackInstance.set_back_drill_by_layer(...)\n\nSet back drill layer.\n\nPadstackInstance.set_backdrill_bottom(...[, ...])\n\nSet backdrill from bottom.\n\nPadstackInstance.set_backdrill_top(...[, offset])\n\nSet backdrill from top.\n\nPadstackInstance.set_hole_overrides(...)\n\nSet the hole overrides of the padstack instance.\n\nPadstackInstance.set_layer_range(top_layer, ...)\n\nSet the top and bottom layers of the padstack instance.\n\nPadstackInstance.set_position_and_rotation(x, ...)\n\nSet the position and rotation of the padstack instance.\n\nPadstackInstance.set_product_property(...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nPadstackInstance.split()\n\nSplit padstack instance into multiple instances.\n\n\n\nAttributes\n\n\n\n\n\n\n\nPadstackInstance.layout_obj_type\n\nLayoutObjType: Layout object type of the PadstackInstance class.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_3d_data.Point3DData.distance",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_3d_data.Point3DData.distance.html#distance",
        "title": "distance",
        "section": "distance",
        "text": "Compute the distance from this point to another point.\nOther point\nDistance to the other point.\ndistance\nPoint3DData\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_3d_data.Point3DData.distance",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_3d_data.Point3DData.distance.html#pyedb.grpc.database.geometry.point_3d_data.Point3DData.distance",
        "title": "distance > distance > distance",
        "section": "distance > distance",
        "text": "Point3DData.distance(other: Point3DData) -> float\n\nCompute the distance from this point to another point.\n\nParameters\n\nother\n\nPoint3DData\n\nOther point\n\nReturns\n\npython:float\n\nDistance to the other point.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.close_project",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.close_project.html#close_project",
        "title": "close_project",
        "section": "close_project",
        "text": "Close the project.\nWhether to save the current project before closing it. The default is False.\nTrue when successful, False when failed.\nclose_project\noptional\nFalse\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.close_project",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.close_project.html#pyedb.siwave.Siwave.close_project",
        "title": "close_project > close_project > close_project",
        "section": "close_project > close_project",
        "text": "Siwave.close_project(save_project=False)\n\nClose the project.\n\nParameters\n\nsave_project\n\nbool, optional\n\nWhether to save the current project before closing it. The default is False.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/point_3d_data",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/point_3d_data.html#point-3d-data",
        "title": "Point 3D data",
        "section": "Point 3D data",
        "text": "These class manages point 3D data.\nPoint3DData\nPoint 3D Data.\nPoint 3D data\nPoint3DData"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.open_project",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.open_project.html#open_project",
        "title": "open_project",
        "section": "open_project",
        "text": "Open a project.\nFull path to the project. The default is None.\nTrue when successful, False when failed.\nopen_project\npython:str\noptional\nNone\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.open_project",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.open_project.html#pyedb.siwave.Siwave.open_project",
        "title": "open_project > open_project > open_project",
        "section": "open_project > open_project",
        "text": "Siwave.open_project(proj_path=None)\n\nOpen a project.\n\nParameters\n\nproj_path\n\npython:str, optional\n\nFull path to the project. The default is None.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_back_drill_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_back_drill_type.html#get_back_drill_type",
        "title": "get_back_drill_type",
        "section": "get_back_drill_type",
        "text": "Get the back drill type of the padstack instance.\nWhether to get the back drill type from the bottom.\nBack drill type of the padastack instance.\nget_back_drill_type\nBackDrillType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_back_drill_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_back_drill_type.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_back_drill_type",
        "title": "get_back_drill_type > get_back_drill_type > get_back_drill_type",
        "section": "get_back_drill_type > get_back_drill_type",
        "text": "PadstackInstance.get_back_drill_type(from_bottom: bool) -> BackDrillType\n\nGet the back drill type of the padstack instance.\n\nParameters\n\nfrom_bottom\n\nbool\n\nWhether to get the back drill type from the bottom.\n\nReturns\n\nBackDrillType\n\nBack drill type of the padastack instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileVia",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileVia.html#controlfilevia",
        "title": "ControlFileVia",
        "section": "ControlFileVia",
        "text": "Represents a via layer in the control file.\nVia name.\nVia properties dictionary.\nControlFileVia\npython:str\npython:dict"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileVia",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileVia.html#pyedb.grpc.database.control_file.ControlFileVia",
        "title": "ControlFileVia > ControlFileVia > ControlFileVia",
        "section": "ControlFileVia > ControlFileVia",
        "text": "class pyedb.grpc.database.control_file.ControlFileVia(name: str, properties: Dict[str, Any])\n\nRepresents a via layer in the control file.\n\nParameters\n\nname\n\npython:str\n\nVia name.\n\nproperties\n\npython:dict\n\nVia properties dictionary.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.in_voids",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.in_voids.html#in_voids",
        "title": "in_voids",
        "section": "in_voids",
        "text": "Check if this padstack instance is in any void.\nNet name of the voids to be checked. Default is None.\nLayer name of the voids to be checked. Default is None.\nList of the voids that include this padstack instance.\nin_voids\npython:str\nNone\npython:str\nNone\nList\nPadstackInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.in_voids",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.in_voids.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.in_voids",
        "title": "in_voids > in_voids > in_voids",
        "section": "in_voids > in_voids",
        "text": "PadstackInstance.in_voids(net_name=None, layer_name=None) -> list[any]\n\nCheck if this padstack instance is in any void.\n\nParameters\n\nnet_name\n\npython:str\n\nNet name of the voids to be checked. Default is None.\n\nlayer_name\n\npython:str\n\nLayer name of the voids to be checked. Default is None.\n\nReturns\n\nList[PadstackInstance]\n\nList of the voids that include this padstack instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude: Optional set or mapping specifying which fields to include in the copied model.\nexclude: Optional set or mapping specifying which fields to exclude in the copied model.\nupdate: Optional dictionary of field-value pairs to override field values in the copied model.\ndeep: If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.copy.html#pyedb.workflows.drc.drc.MinLineWidth.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "MinLineWidth.copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -> Self\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nArgs:\n\ninclude: Optional set or mapping specifying which fields to include in the copied model.\nexclude: Optional set or mapping specifying which fields to exclude in the copied model.\nupdate: Optional dictionary of field-value pairs to override field values in the copied model.\ndeep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlExtent",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlExtent.html#controlextent",
        "title": "ControlExtent",
        "section": "ControlExtent",
        "text": "Represents extent options for boundaries.\nExtent type. Default is “bbox”.\nDielectric extent type. Default is “bbox”.\nDielectric horizontal factor. Default is 0.25.\nAirbox horizontal factor. Default is 0.25.\nAirbox vertical factor (positive). Default is 0.25.\nAirbox vertical factor (negative). Default is 0.25.\nUse radiation boundary. Default is True.\nHonor primitives. Default is True.\nTruncate at ground. Default is True.\nControlExtent\npython:str\noptional\npython:str\noptional\npython:float\noptional\npython:float\noptional\npython:float\noptional\npython:float\noptional\noptional\nTrue\noptional\nTrue\noptional\nTrue"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlExtent",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlExtent.html#pyedb.grpc.database.control_file.ControlExtent",
        "title": "ControlExtent > ControlExtent > ControlExtent",
        "section": "ControlExtent > ControlExtent",
        "text": "class pyedb.grpc.database.control_file.ControlExtent(type: str = 'bbox', dieltype: str = 'bbox', diel_hactor: float = 0.25, airbox_hfactor: float = 0.25, airbox_vr_p: float = 0.25, airbox_vr_n: float = 0.25, useradiation: bool = True, honor_primitives: bool = True, truncate_at_gnd: bool = True)\n\nRepresents extent options for boundaries.\n\nParameters\n\ntype\n\npython:str, optional\n\nExtent type. Default is “bbox”.\n\ndieltype\n\npython:str, optional\n\nDielectric extent type. Default is “bbox”.\n\ndiel_hactor\n\npython:float, optional\n\nDielectric horizontal factor. Default is 0.25.\n\nairbox_hfactor\n\npython:float, optional\n\nAirbox horizontal factor. Default is 0.25.\n\nairbox_vr_p\n\npython:float, optional\n\nAirbox vertical factor (positive). Default is 0.25.\n\nairbox_vr_n\n\npython:float, optional\n\nAirbox vertical factor (negative). Default is 0.25.\n\nuseradiation\n\nbool, optional\n\nUse radiation boundary. Default is True.\n\nhonor_primitives\n\nbool, optional\n\nHonor primitives. Default is True.\n\ntruncate_at_gnd\n\nbool, optional\n\nTruncate at ground. Default is True.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.add_port_on_rlc_component",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.add_port_on_rlc_component.html#add_port_on_rlc_component",
        "title": "add_port_on_rlc_component",
        "section": "add_port_on_rlc_component",
        "text": "Deactivate RLC component and replace it with a circuit port.\nThe circuit port supports only two-pin components.\nReference designator of the RLC component.\nTrue will replace RLC component by circuit ports, False gap ports compatible with HFSS 3D modeler\nexport.\nWhether to define the PEC boundary, The default is False. If set to True,\na perfect short is created between the pin and impedance is ignored. This\nparameter is only supported on a port created between two pins, such as\nwhen there is no pin group.\nTrue when successful, False when failed.\nadd_port_on_rlc_component\npython:str\nTrue\nFalse\noptional\nFalse\nTrue\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.add_port_on_rlc_component",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.add_port_on_rlc_component.html#pyedb.grpc.database.components.Components.add_port_on_rlc_component",
        "title": "add_port_on_rlc_component > add_port_on_rlc_component > add_port_on_rlc_component",
        "section": "add_port_on_rlc_component > add_port_on_rlc_component",
        "text": "Components.add_port_on_rlc_component(component: str | Component | None = None, circuit_ports: bool = True, pec_boundary: bool = False) -> bool\n\nDeactivate RLC component and replace it with a circuit port.\nThe circuit port supports only two-pin components.\n\nParameters\n\ncomponent\n\npython:str\n\nReference designator of the RLC component.\n\ncircuit_ports\n\nbool\n\nTrue will replace RLC component by circuit ports, False gap ports compatible with HFSS 3D modeler\nexport.\n\npec_boundary\n\nbool, optional\n\nWhether to define the PEC boundary, The default is False. If set to True,\na perfect short is created between the pin and impedance is ignored. This\nparameter is only supported on a port created between two pins, such as\nwhen there is no pin group.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> edb.source_excitation.add_port_on_rlc_component(\"R1\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.number_with_units",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.number_with_units.html#number_with_units",
        "title": "number_with_units",
        "section": "number_with_units",
        "text": "Convert a number to a string with units. If value is a string, it’s returned as is.\nInput number or string.\nUnits for formatting. The default is None, which uses \"meter\".\nString concatenating the value and unit.\nnumber_with_units\npython:float\npython:int\npython:str\noptional\nNone\n\"meter\"\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.number_with_units",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.number_with_units.html#pyedb.grpc.edb.Edb.number_with_units",
        "title": "number_with_units > number_with_units > number_with_units",
        "section": "number_with_units > number_with_units",
        "text": "static Edb.number_with_units(value, units=None)\n\nConvert a number to a string with units. If value is a string, it’s returned as is.\n\nParameters\n\nvalue\n\npython:float, python:int, python:str\n\nInput number or string.\n\nunits\n\noptional\n\nUnits for formatting. The default is None, which uses \"meter\".\n\nReturns\n\npython:str\n\nString concatenating the value and unit.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_statistics",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_statistics.html#get_statistics",
        "title": "get_statistics",
        "section": "get_statistics",
        "text": "Get layout statistics.\nCalculate net areas. Default False.\nLayout statistics report.\nget_statistics\noptional\nLayoutStatistics"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_statistics",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_statistics.html#pyedb.grpc.edb.Edb.get_statistics",
        "title": "get_statistics > get_statistics > get_statistics",
        "section": "get_statistics > get_statistics",
        "text": "Edb.get_statistics(compute_area=False)\n\nGet layout statistics.\n\nParameters\n\ncompute_area\n\nbool, optional\n\nCalculate net areas. Default False.\n\nReturns\n\nLayoutStatistics\n\nLayout statistics report.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.decouple",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.decouple.html#decouple",
        "title": "decouple",
        "section": "decouple",
        "text": "Ungroup a bundle of terminals.\ndecouple"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.decouple",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.decouple.html#pyedb.grpc.database.ports.ports.BundleWavePort.decouple",
        "title": "decouple > decouple > decouple",
        "section": "decouple > decouple",
        "text": "BundleWavePort.decouple() -> bool\n\nUngroup a bundle of terminals.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.get_product_property.html#pyedb.grpc.database.ports.ports.WavePort.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "WavePort.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.get_product_property_ids.html#pyedb.grpc.database.ports.ports.BundleWavePort.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "BundleWavePort.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_back_drill_by_layer",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_back_drill_by_layer.html#get_back_drill_by_layer",
        "title": "get_back_drill_by_layer",
        "section": "get_back_drill_by_layer",
        "text": "Get backdrill by layer.\nDefault value is True.\nget_back_drill_by_layer"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_back_drill_by_layer",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_back_drill_by_layer.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_back_drill_by_layer",
        "title": "get_back_drill_by_layer > get_back_drill_by_layer > get_back_drill_by_layer",
        "section": "get_back_drill_by_layer > get_back_drill_by_layer",
        "text": "PadstackInstance.get_back_drill_by_layer(from_bottom=True) -> tuple[str, float, float]\n\nGet backdrill by layer.\n\nParameters\n\nfrom_bottom\n\nbool, optional.\n\nDefault value is True.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.html#diffpairlengthmatch",
        "title": "DiffPairLengthMatch",
        "section": "DiffPairLengthMatch",
        "text": "Length-matching rule for differential pairs.\nDiffPairLengthMatch.construct([_fields_set])\n\nDiffPairLengthMatch.copy(*[, include, ...])\nReturns a copy of the model.\nDiffPairLengthMatch.dict(*[, include, ...])\n\nDiffPairLengthMatch.from_orm(obj)\n\nDiffPairLengthMatch.json(*[, include, ...])\n\nDiffPairLengthMatch.model_construct([...])\nCreates a new instance of the Model class with validated data.\nDiffPairLengthMatch.model_copy(*[, update, deep])\n!!! abstract \"Usage Documentation\"\nDiffPairLengthMatch.model_dump(*[, mode, ...])\n!!! abstract \"Usage Documentation\"\nDiffPairLengthMatch.model_dump_json(*[, ...])\n!!! abstract \"Usage Documentation\"\nDiffPairLengthMatch.model_json_schema([...])\nGenerates a JSON schema for a model class.\nDiffPairLengthMatch.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nDiffPairLengthMatch.model_post_init(context, /)\nOverride this method to perform additional initialization after __init__ and model_construct.\nDiffPairLengthMatch.model_rebuild(*[, ...])\nTry to rebuild the pydantic-core schema for the model.\nDiffPairLengthMatch.model_validate(obj, *[, ...])\nValidate a pydantic model instance.\nDiffPairLengthMatch.model_validate_json(...)\n!!! abstract \"Usage Documentation\"\nDiffPairLengthMatch.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nDiffPairLengthMatch.parse_file(path, *[, ...])\n\nDiffPairLengthMatch.parse_obj(obj)\n\nDiffPairLengthMatch.parse_raw(b, *[, ...])\n\nDiffPairLengthMatch.schema([by_alias, ...])\n\nDiffPairLengthMatch.schema_json(*[, ...])\n\nDiffPairLengthMatch.update_forward_refs(...)\n\nDiffPairLengthMatch.validate(value)\n\nDiffPairLengthMatch.model_computed_fields\n\nDiffPairLengthMatch.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nDiffPairLengthMatch.model_fields\n\nDiffPairLengthMatch.name\n\nDiffPairLengthMatch.tolerance\n\nDiffPairLengthMatch.pairs\n\nDiffPairLengthMatch\nDiffPairLengthMatch.construct\nDiffPairLengthMatch.copy\nDiffPairLengthMatch.dict\nDiffPairLengthMatch.from_orm\nDiffPairLengthMatch.json\nDiffPairLengthMatch.model_construct\nDiffPairLengthMatch.model_copy\nDiffPairLengthMatch.model_dump\nDiffPairLengthMatch.model_dump_json\nDiffPairLengthMatch.model_json_schema\nDiffPairLengthMatch.model_parametrized_name\nDiffPairLengthMatch.model_post_init\nDiffPairLengthMatch.model_rebuild\nDiffPairLengthMatch.model_validate\nDiffPairLengthMatch.model_validate_json\nDiffPairLengthMatch.model_validate_strings\nDiffPairLengthMatch.parse_file\nDiffPairLengthMatch.parse_obj\nDiffPairLengthMatch.parse_raw\nDiffPairLengthMatch.schema\nDiffPairLengthMatch.schema_json\nDiffPairLengthMatch.update_forward_refs\nDiffPairLengthMatch.validate\nDiffPairLengthMatch.model_computed_fields\nDiffPairLengthMatch.model_config\nDiffPairLengthMatch.model_fields\nDiffPairLengthMatch.name\nDiffPairLengthMatch.tolerance\nDiffPairLengthMatch.pairs"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.html#pyedb.workflows.drc.drc.DiffPairLengthMatch",
        "title": "DiffPairLengthMatch > DiffPairLengthMatch > DiffPairLengthMatch",
        "section": "DiffPairLengthMatch > DiffPairLengthMatch",
        "text": "class pyedb.workflows.drc.drc.DiffPairLengthMatch(*, name: str, tolerance: str, pairs: List[DiffPair])\n\nLength-matching rule for differential pairs.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nDiffPairLengthMatch.construct([_fields_set])\n\n\n\nDiffPairLengthMatch.copy(*[, include, ...])\n\nReturns a copy of the model.\n\nDiffPairLengthMatch.dict(*[, include, ...])\n\n\n\nDiffPairLengthMatch.from_orm(obj)\n\n\n\nDiffPairLengthMatch.json(*[, include, ...])\n\n\n\nDiffPairLengthMatch.model_construct([...])\n\nCreates a new instance of the Model class with validated data.\n\nDiffPairLengthMatch.model_copy(*[, update, deep])\n\n!!! abstract \"Usage Documentation\"\n\nDiffPairLengthMatch.model_dump(*[, mode, ...])\n\n!!! abstract \"Usage Documentation\"\n\nDiffPairLengthMatch.model_dump_json(*[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nDiffPairLengthMatch.model_json_schema([...])\n\nGenerates a JSON schema for a model class.\n\nDiffPairLengthMatch.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nDiffPairLengthMatch.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nDiffPairLengthMatch.model_rebuild(*[, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nDiffPairLengthMatch.model_validate(obj, *[, ...])\n\nValidate a pydantic model instance.\n\nDiffPairLengthMatch.model_validate_json(...)\n\n!!! abstract \"Usage Documentation\"\n\nDiffPairLengthMatch.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nDiffPairLengthMatch.parse_file(path, *[, ...])\n\n\n\nDiffPairLengthMatch.parse_obj(obj)\n\n\n\nDiffPairLengthMatch.parse_raw(b, *[, ...])\n\n\n\nDiffPairLengthMatch.schema([by_alias, ...])\n\n\n\nDiffPairLengthMatch.schema_json(*[, ...])\n\n\n\nDiffPairLengthMatch.update_forward_refs(...)\n\n\n\nDiffPairLengthMatch.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nDiffPairLengthMatch.model_computed_fields\n\n\n\nDiffPairLengthMatch.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nDiffPairLengthMatch.model_fields\n\n\n\nDiffPairLengthMatch.name\n\n\n\nDiffPairLengthMatch.tolerance\n\n\n\nDiffPairLengthMatch.pairs\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileComponent",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileComponent.html#controlfilecomponent",
        "title": "ControlFileComponent",
        "section": "ControlFileComponent",
        "text": "Components.\nControlFileComponent.add_pin(name, x, y, layer)\n\nControlFileComponent.add_port(name, z0, pospin)\n\nControlFileComponent\nControlFileComponent.add_pin\nControlFileComponent.add_port"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileComponent",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileComponent.html#pyedb.grpc.database.utility.xml_control_file.ControlFileComponent",
        "title": "ControlFileComponent > ControlFileComponent > ControlFileComponent",
        "section": "ControlFileComponent > ControlFileComponent",
        "text": "class pyedb.grpc.database.utility.xml_control_file.ControlFileComponent\n\nComponents.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nControlFileComponent.add_pin(name, x, y, layer)\n\n\n\nControlFileComponent.add_port(name, z0, pospin)\n\n\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.unite",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.unite.html#unite",
        "title": "unite",
        "section": "unite",
        "text": "Unite active primitive with one or more primitives.\nunite\ndotnet.database.edb_data.EDBPrimitives\nEDB\nPolygonData\nEDB\nPrimitive\npython:list\nList\nof\ndotnet.database.edb_data.EDBPrimitives"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.unite",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.unite.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.unite",
        "title": "unite > unite > unite",
        "section": "unite > unite",
        "text": "EdbPolygon.unite(primitives)\n\nUnite active primitive with one or more primitives.\n\nParameters\n\nprimitives\n\ndotnet.database.edb_data.EDBPrimitives or EDB PolygonData or EDB Primitive or python:list\n\n\n\nReturns\n\nList of dotnet.database.edb_data.EDBPrimitives\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.adjust_solder_dielectrics",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.adjust_solder_dielectrics.html#adjust_solder_dielectrics",
        "title": "adjust_solder_dielectrics",
        "section": "adjust_solder_dielectrics",
        "text": "Adjust the stack-up by adding or modifying dielectric layers that contain solder balls.\nThis method identifies the solder-ball height and adjusts the dielectric thickness on top (or bottom)\nto fit the thickness in order to merge another layout.\nTrue when successful.\nadjust_solder_dielectrics\nTrue"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.adjust_solder_dielectrics",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.adjust_solder_dielectrics.html#pyedb.grpc.database.stackup.Stackup.adjust_solder_dielectrics",
        "title": "adjust_solder_dielectrics > adjust_solder_dielectrics > adjust_solder_dielectrics",
        "section": "adjust_solder_dielectrics > adjust_solder_dielectrics",
        "text": "Stackup.adjust_solder_dielectrics() -> bool\n\nAdjust the stack-up by adding or modifying dielectric layers that contain solder balls.\n\nThis method identifies the solder-ball height and adjusts the dielectric thickness on top (or bottom)\nto fit the thickness in order to merge another layout.\n\nReturns\n\nbool\n\nTrue when successful.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_top_bottom_stackup_layers",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_top_bottom_stackup_layers.html#get_top_bottom_stackup_layers",
        "title": "get_top_bottom_stackup_layers",
        "section": "get_top_bottom_stackup_layers",
        "text": "Get the top and bottom stackup layers of a specific type and their elevations.\nLayer type set indicating the layer types to retrieve.\nReturns a tuple in this format:\n(upper_layer, upper_layer_top_elevation, lower_layer, lower_layer_lower_elevation)\nget_top_bottom_stackup_layers\nLayerTypeSet\npython:tuple\nLayer\npython:float\nLayer\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_top_bottom_stackup_layers",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_top_bottom_stackup_layers.html#pyedb.grpc.database.stackup.Stackup.get_top_bottom_stackup_layers",
        "title": "get_top_bottom_stackup_layers > get_top_bottom_stackup_layers > get_top_bottom_stackup_layers",
        "section": "get_top_bottom_stackup_layers > get_top_bottom_stackup_layers",
        "text": "Stackup.get_top_bottom_stackup_layers(layer_type_set)\n\nGet the top and bottom stackup layers of a specific type and their elevations.\n\nParameters\n\nlayer_type_set\n\nLayerTypeSet\n\nLayer type set indicating the layer types to retrieve.\n\nReturns\n\npython:tuple[Layer, python:float, Layer, python:float]\n\nReturns a tuple in this format:\n(upper_layer, upper_layer_top_elevation, lower_layer, lower_layer_lower_elevation)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_solution_broadband",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_solution_broadband.html#set_solution_broadband",
        "title": "set_solution_broadband",
        "section": "set_solution_broadband",
        "text": "Set broadband solution.\nLow frequency. The default is 5GHz.\nHigh frequency. The default is 10GHz.\nMaximum number of passes. The default is 10.\nMaximum Delta S. Default is 0.02.\nset_solution_broadband\npython:str\npython:float\noptional\n5GHz\npython:str\npython:float\noptional\n10GHz\npython:int\noptional\n10\npython:float\noptional\n0.02"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_solution_broadband",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_solution_broadband.html#pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_solution_broadband",
        "title": "set_solution_broadband > set_solution_broadband > set_solution_broadband",
        "section": "set_solution_broadband > set_solution_broadband",
        "text": "HfssSimulationSetup.set_solution_broadband(low_frequency='5Ghz', high_frequency='10Ghz', max_num_passes=10, max_delta_s='0.02')\n\nSet broadband solution.\n\nParameters\n\nlow_frequency\n\npython:str, python:float, optional\n\nLow frequency. The default is 5GHz.\n\nhigh_frequency\n\npython:str, python:float, optional\n\nHigh frequency. The default is 10GHz.\n\nmax_num_passes\n\npython:int, optional\n\nMaximum number of passes. The default is 10.\n\nmax_delta_s\n\npython:float, optional\n\nMaximum Delta S. Default is 0.02.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/index",
        "href": "dotnet_api/dotnet/utilities/index.html#utilities",
        "title": "Utilities",
        "section": "Utilities",
        "text": "This section describes utilities.\nUtilities"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.create",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a circle.\nLayout to create this circle in.\nLayer to place the circle on.\nNet of the circle.\nX value of the center point.\nY value of the center point.\nRadius value of the circle.\nCircle created.\ncreate\nLayout\npython:None\nCircle"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.create",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.create.html#pyedb.grpc.database.primitive.circle.Circle.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "Circle.create(layout=None, layer: str | Layer | None = None, net: str | Net | None = None, center_x: float | None = None, center_y: float | None = None, radius: float = 0.0)\n\nCreate a circle.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to create this circle in.\n\nlayer\n\nLayerLike\n\nLayer to place the circle on.\n\nnet\n\nNetLike or python:None\n\nNet of the circle.\n\ncenter_x\n\nValueLike\n\nX value of the center point.\n\ncenter_y\n\nValueLike\n\nY value of the center point.\n\nradius\n\nValueLike\n\nRadius value of the circle.\n\nReturns\n\nCircle\n\nCircle created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the layout object.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.delete.html#pyedb.grpc.database.net.differential_pair.DifferentialPair.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "DifferentialPair.delete()\n\nDelete the layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.is_power_gound_net",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.is_power_gound_net.html#is_power_gound_net",
        "title": "is_power_gound_net",
        "section": "is_power_gound_net",
        "text": "Check if any net in a list is a power/ground net.\nNet name or list of net names to check.\nTrue if any net is power/ground, False otherwise.\nis_power_gound_net\npython:str\npython:list\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.is_power_gound_net",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.is_power_gound_net.html#pyedb.grpc.database.nets.Nets.is_power_gound_net",
        "title": "is_power_gound_net > is_power_gound_net > is_power_gound_net",
        "section": "is_power_gound_net > is_power_gound_net",
        "text": "Nets.is_power_gound_net(netname_list: str | List[str]) -> bool\n\nCheck if any net in a list is a power/ground net.\n\nParameters\n\nnetname_list\n\npython:str | python:list[python:str]\n\nNet name or list of net names to check.\n\nReturns\n\nbool\n\nTrue if any net is power/ground, False otherwise.\n\nExamples\n\n>>> is_power = edb_nets.is_power_gound_net([\"VDD_CPU\", \"PCIe_TX\"])\n>>> print(\"Contains power net:\", is_power)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.parametrize_position",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.parametrize_position.html#parametrize_position",
        "title": "parametrize_position",
        "section": "parametrize_position",
        "text": "Parametrize the instance position.\nPrefix for the variable name. Default is None.\nExample “MyVariableName” will create 2 Project variables $MyVariableNamesX and $MyVariableNamesY.\nList of variables created.\nparametrize_position\npython:str\noptional\nNone\nList"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.parametrize_position",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.parametrize_position.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.parametrize_position",
        "title": "parametrize_position > parametrize_position > parametrize_position",
        "section": "parametrize_position > parametrize_position",
        "text": "PadstackInstance.parametrize_position(prefix=None) -> list[str]\n\nParametrize the instance position.\n\nParameters\n\nprefix\n\npython:str, optional\n\nPrefix for the variable name. Default is None.\nExample “MyVariableName” will create 2 Project variables $MyVariableNamesX and $MyVariableNamesY.\n\nReturns\n\nList\n\nList of variables created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.refresh_layer_collection",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.refresh_layer_collection.html#refresh_layer_collection",
        "title": "refresh_layer_collection",
        "section": "refresh_layer_collection",
        "text": "Refresh layer collection from Edb. This method is run on demand after all edit operations on stackup.\nrefresh_layer_collection"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.refresh_layer_collection",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.refresh_layer_collection.html#pyedb.dotnet.database.stackup.Stackup.refresh_layer_collection",
        "title": "refresh_layer_collection > refresh_layer_collection > refresh_layer_collection",
        "section": "refresh_layer_collection > refresh_layer_collection",
        "text": "Stackup.refresh_layer_collection()\n\nRefresh layer collection from Edb. This method is run on demand after all edit operations on stackup.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_layer_range",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_layer_range.html#get_layer_range",
        "title": "get_layer_range",
        "section": "get_layer_range",
        "text": "Get the top and bottom layers of the padstack instance.\nThe tuple is in this format:\n(top_layer, bottom_layer)\ntop_layer: Top layer of the padstack instance\nbottom_layer: Bottom layer of the padstack instance\nget_layer_range\npython:tuple\nof\nLayer\nLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_layer_range",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_layer_range.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_layer_range",
        "title": "get_layer_range > get_layer_range > get_layer_range",
        "section": "get_layer_range > get_layer_range",
        "text": "PadstackInstance.get_layer_range() -> tuple[Layer, Layer]\n\nGet the top and bottom layers of the padstack instance.\n\nReturns\n\npython:tuple of (Layer, Layer)\n\nThe tuple is in this format:\n\n(top_layer, bottom_layer)\n\ntop_layer: Top layer of the padstack instance\nbottom_layer: Bottom layer of the padstack instance\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the terminal object to the correct concrete type, fetching the type if necessary.\ncast\nTerminalType\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.cast.html#pyedb.grpc.database.terminal.terminal.Terminal.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "Terminal.cast(term_type=None)\n\nCast the terminal object to the correct concrete type, fetching the type if necessary.\n\nParameters\n\nterm_type\n\nTerminalType\n\n\n\nReturns\n\nTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.thermal_expansion_coefficient",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.thermal_expansion_coefficient.html#thermal_expansion_coefficient",
        "title": "thermal_expansion_coefficient",
        "section": "thermal_expansion_coefficient",
        "text": "thermal_expansion_coefficient"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.thermal_expansion_coefficient",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.thermal_expansion_coefficient.html#pyedb.grpc.database.definition.materials.MaterialProperties.thermal_expansion_coefficient",
        "title": "thermal_expansion_coefficient > thermal_expansion_coefficient > thermal_expansion_coefficient",
        "section": "thermal_expansion_coefficient > thermal_expansion_coefficient",
        "text": "MaterialProperties.thermal_expansion_coefficient: Annotated[float, Gt(gt=0)] | None\n\n"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.auto_parametrize_design",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.auto_parametrize_design.html#auto_parametrize_design",
        "title": "auto_parametrize_design",
        "section": "auto_parametrize_design",
        "text": "Automatically parametrize design elements.\nParametrize layer thicknesses. Default True.\nParametrize material properties. Default True.\nParametrize via holes. Default True.\nParametrize pads. Default True.\nParametrize antipads. Default True.\nParametrize trace widths. Default True.\nLayers to include. All if None.\nMaterials to include. All if None.\nPadstacks to include. All if None.\nNets to parametrize. All if None.\nSingle variable per padstack. Default True.\nUse delta variables. Default True.\nOutput AEDB path.\nOpen AEDB when finished. Default True.\nPolygon expansion size. Default 0.\nVoid expansion size. Default 0.\nParametrize via positions. Default True.\nCreated parameter names.\nParametrize design elements:\n>>> params = edb.auto_parametrize_design(\n>>>     layers=True,\n>>>     materials=True,\n>>>     trace_net_filter=[“Clock”])\nauto_parametrize_design\noptional\noptional\noptional\noptional\noptional\noptional\npython:list\noptional\npython:list\noptional\npython:list\noptional\npython:list\noptional\noptional\noptional\npython:str\noptional\noptional\npython:float\noptional\npython:float\noptional\noptional\npython:list\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.auto_parametrize_design",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.auto_parametrize_design.html#pyedb.grpc.edb.Edb.auto_parametrize_design",
        "title": "auto_parametrize_design > auto_parametrize_design > auto_parametrize_design",
        "section": "auto_parametrize_design > auto_parametrize_design",
        "text": "Edb.auto_parametrize_design(layers=True, materials=True, via_holes=True, pads=True, antipads=True, traces=True, layer_filter=None, material_filter=None, padstack_definition_filter=None, trace_net_filter=None, use_single_variable_for_padstack_definitions=True, use_relative_variables=True, output_aedb_path=None, open_aedb_at_end=True, expand_polygons_size=0, expand_voids_size=0, via_offset=True)\n\nAutomatically parametrize design elements.\n\nParameters\n\nlayers\n\nbool, optional\n\nParametrize layer thicknesses. Default True.\n\nmaterials\n\nbool, optional\n\nParametrize material properties. Default True.\n\nvia_holes\n\nbool, optional\n\nParametrize via holes. Default True.\n\npads\n\nbool, optional\n\nParametrize pads. Default True.\n\nantipads\n\nbool, optional\n\nParametrize antipads. Default True.\n\ntraces\n\nbool, optional\n\nParametrize trace widths. Default True.\n\nlayer_filter\n\npython:list, optional\n\nLayers to include. All if None.\n\nmaterial_filter\n\npython:list, optional\n\nMaterials to include. All if None.\n\npadstack_definition_filter\n\npython:list, optional\n\nPadstacks to include. All if None.\n\ntrace_net_filter\n\npython:list, optional\n\nNets to parametrize. All if None.\n\nuse_single_variable_for_padstack_definitions\n\nbool, optional\n\nSingle variable per padstack. Default True.\n\nuse_relative_variables\n\nbool, optional\n\nUse delta variables. Default True.\n\noutput_aedb_path\n\npython:str, optional\n\nOutput AEDB path.\n\nopen_aedb_at_end\n\nbool, optional\n\nOpen AEDB when finished. Default True.\n\nexpand_polygons_size\n\npython:float, optional\n\nPolygon expansion size. Default 0.\n\nexpand_voids_size\n\npython:float, optional\n\nVoid expansion size. Default 0.\n\nvia_offset\n\nbool, optional\n\nParametrize via positions. Default True.\n\nReturns\n\npython:list[python:str]\n\nCreated parameter names.\n\nExamples\n\nParametrize design elements:\n>>> params = edb.auto_parametrize_design(\n>>>     layers=True,\n>>>     materials=True,\n>>>     trace_net_filter=[“Clock”])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/netlist_model",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/netlist_model.html#netlist-model",
        "title": "Netlist Model",
        "section": "Netlist Model",
        "text": "This class is managing EDB netlist model.\nNetlistModel\nManage NetlistModel.\nNetlist Model\nNetlistModel\nNetlistModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.get_product_property.html#pyedb.grpc.database.hierarchy.component.Component.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "Component.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileVia",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileVia.html#controlfilevia",
        "title": "ControlFileVia",
        "section": "ControlFileVia",
        "text": "ControlFileVia"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileVia",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileVia.html#pyedb.dotnet.database.edb_data.control_file.ControlFileVia",
        "title": "ControlFileVia > ControlFileVia > ControlFileVia",
        "section": "ControlFileVia > ControlFileVia",
        "text": "class pyedb.dotnet.database.edb_data.control_file.ControlFileVia(name, properties)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.add_n_port_model",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.add_n_port_model.html#add_n_port_model",
        "title": "add_n_port_model",
        "section": "add_n_port_model",
        "text": "Add N-port model.\nadd_n_port_model\nNPortComponentModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.add_n_port_model",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.add_n_port_model.html#pyedb.grpc.database.definition.component_def.ComponentDef.add_n_port_model",
        "title": "add_n_port_model > add_n_port_model > add_n_port_model",
        "section": "add_n_port_model > add_n_port_model",
        "text": "ComponentDef.add_n_port_model(fpath, name=None)\n\nAdd N-port model.\n\nReturns\n\nNport model\n\nNPortComponentModel\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_general_settings.HFSSGeneralSettings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_general_settings.HFSSGeneralSettings.html#hfssgeneralsettings",
        "title": "HFSSGeneralSettings",
        "section": "HFSSGeneralSettings",
        "text": "PyEDB-core HFSS general settings class.\nHFSSGeneralSettings"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_general_settings.HFSSGeneralSettings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_general_settings.HFSSGeneralSettings.html#pyedb.grpc.database.simulation_setup.hfss_general_settings.HFSSGeneralSettings",
        "title": "HFSSGeneralSettings > HFSSGeneralSettings > HFSSGeneralSettings",
        "section": "HFSSGeneralSettings > HFSSGeneralSettings",
        "text": "class pyedb.grpc.database.simulation_setup.hfss_general_settings.HFSSGeneralSettings(pedb, edb_object)\n\nPyEDB-core HFSS general settings class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.write_export3d_option_config_file",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.write_export3d_option_config_file.html#write_export3d_option_config_file",
        "title": "write_export3d_option_config_file",
        "section": "write_export3d_option_config_file",
        "text": "Write the options for a 3D export to a configuration file.\nFull path to the configuration file to save 3D export options to.\nConfiguration dictionaries. The default is None.\nwrite_export3d_option_config_file\npython:str\npython:dict\noptional\nNone"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.write_export3d_option_config_file",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.write_export3d_option_config_file.html#pyedb.grpc.edb.Edb.write_export3d_option_config_file",
        "title": "write_export3d_option_config_file > write_export3d_option_config_file > write_export3d_option_config_file",
        "section": "write_export3d_option_config_file > write_export3d_option_config_file",
        "text": "static Edb.write_export3d_option_config_file(path_to_output, config_dictionaries=None)\n\nWrite the options for a 3D export to a configuration file.\n\nParameters\n\npath_to_output\n\npython:str\n\nFull path to the configuration file to save 3D export options to.\n\nconfig_dictionaries\n\npython:dict, optional\n\nConfiguration dictionaries. The default is None.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_source_on_net",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_source_on_net.html#create_voltage_source_on_net",
        "title": "create_voltage_source_on_net",
        "section": "create_voltage_source_on_net",
        "text": "Create a voltage source.\nName of the positive component.\nName of the positive net.\nName of the negative component. The default is None, in which case the name of\nthe positive net is assigned.\nName of the negative net name. The default is None which will look for GND Nets.\nValue for the voltage. The default is 3.3.\nValue for the phase. The default is 0.\nName of the source. The default is \"\".\nThe name of the source.\ncreate_voltage_source_on_net\npython:str\npython:str\npython:str\noptional\nNone\npython:str\noptional\nNone\npython:float\noptional\n3.3\noptional\n0\npython:str\noptional\n\"\"\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_source_on_net",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_source_on_net.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_source_on_net",
        "title": "create_voltage_source_on_net > create_voltage_source_on_net > create_voltage_source_on_net",
        "section": "create_voltage_source_on_net > create_voltage_source_on_net",
        "text": "SourceExcitation.create_voltage_source_on_net(positive_component_name: str, positive_net_name: str, negative_component_name: str | None = None, negative_net_name: str | None = None, voltage_value: int | float = 0, phase_value: int | float = 0, source_name: str | None = None) -> str | None\n\nCreate a voltage source.\n\nParameters\n\npositive_component_name\n\npython:str\n\nName of the positive component.\n\npositive_net_name\n\npython:str\n\nName of the positive net.\n\nnegative_component_name\n\npython:str, optional\n\nName of the negative component. The default is None, in which case the name of\nthe positive net is assigned.\n\nnegative_net_name\n\npython:str, optional\n\nName of the negative net name. The default is None which will look for GND Nets.\n\nvoltage_value\n\npython:float, optional\n\nValue for the voltage. The default is 3.3.\n\nphase_value\n\noptional\n\nValue for the phase. The default is 0.\n\nsource_name\n\npython:str, optional\n\nName of the source. The default is \"\".\n\nReturns\n\npython:str\n\nThe name of the source.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> edb.source_excitation.create_voltage_source_on_net(\"U1\", \"VCC\", \"U1\", \"GND\", 3.3, name=\"VCC_Source\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.bounding_circle",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.bounding_circle.html#bounding_circle",
        "title": "bounding_circle",
        "section": "bounding_circle",
        "text": "Compute the bounding circle of the polygon.\nbounding_circle\npython:tuple\nof\nPointData\nValue"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.bounding_circle",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.bounding_circle.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.bounding_circle",
        "title": "bounding_circle > bounding_circle > bounding_circle",
        "section": "bounding_circle > bounding_circle",
        "text": "PolygonData.bounding_circle() -> tuple[PointData, Value]\n\nCompute the bounding circle of the polygon.\n\nReturns\n\npython:tuple of (PointData, Value)\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_via_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_via_layer.html#add_via_layer",
        "title": "add_via_layer",
        "section": "add_via_layer",
        "text": "Add a via layer to the layer collection.\nadd_via_layer\nViaLayer\nViaLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_via_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_via_layer.html#pyedb.grpc.database.stackup.Stackup.add_via_layer",
        "title": "add_via_layer > add_via_layer > add_via_layer",
        "section": "add_via_layer > add_via_layer",
        "text": "Stackup.add_via_layer(via_layer_to_add)\n\nAdd a via layer to the layer collection.\n\nParameters\n\nvia_layer_to_add\n\nViaLayer\n\n\n\nReturns\n\nViaLayer\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.update",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.update.html#update",
        "title": "update",
        "section": "update",
        "text": "update"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.update",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.update.html#pyedb.grpc.database.layers.layer.Layer.update",
        "title": "update > update > update",
        "section": "update > update",
        "text": "Layer.update(**kwargs)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.html#rectangle",
        "title": "Rectangle",
        "section": "Rectangle",
        "text": "Class representing a rectangle object.\nRectangle.add_void(point_list)\nAdd a void to current primitive.\nRectangle.area([include_voids])\nReturn the total area.\nRectangle.cast()\nCast the primitive object to the correct concrete type.\nRectangle.convert_to_polygon()\nConvert path to polygon.\nRectangle.create([layout, layer, net, ...])\nCreate a rectangle primitive in the specified layout, layer, and net with the given parameters.\nRectangle.create_3d_comp()\nCreate a 3D composite model from an MCAD file.\nRectangle.create_hfss()\nCreate an HFSS model from an MCAD file.\nRectangle.create_stride()\nCreate a Stride model from an MCAD file.\nRectangle.delete()\nDelete the rectangle primitive from the layout.\nRectangle.expand([offset, tolerance, ...])\nExpand the polygon shape by an absolute value in all direction.\nRectangle.find_by_id(layout, uid)\nFind a Connectable object by database ID in a given layout.\nRectangle.get_closest_arc_midpoint(point)\nGet the closest arc midpoint of the primitive to the input data.\nRectangle.get_closest_point(point)\nGet the closest point of the primitive to the input data.\nRectangle.get_connected_object_id_set()\nProduce a list of all geometries physically connected to a given layout object.\nRectangle.get_connected_objects()\nGet connected objects.\nRectangle.get_hfss_prop()\nGet HFSS properties.\nRectangle.get_parameters()\nGet coordinates parameters.\nRectangle.get_product_property(prod_id, attr_id)\nGet the product property of the layout object for a given product ID and attribute ID.\nRectangle.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nRectangle.intersect(primitives)\nIntersect active primitive with one or more primitives.\nRectangle.intersection_type(primitive)\nGet intersection type between actual primitive and another primitive or polygon data.\nRectangle.is_intersecting(primitive)\nCheck if actual primitive and another primitive or polygon data intesects.\nRectangle.make_zone_primitive(zone_id)\nMake the primitive a zone primitive with a zone specified by the provided ID.\nRectangle.plot([plot_net, show, save_plot])\nPlot the current polygon on matplotlib.\nRectangle.points([arc_segments])\nReturn the list of points with arcs converted to segments.\nRectangle.remove_hfss_prop()\nRemove HFSS properties.\nRectangle.render(rep_type, ...[, is_hole])\nGet the polygon data of a rectangle.\nRectangle.scale(factor[, center])\nScales the polygon relative to a center point by a factor.\nRectangle.set_hfss_prop(material, solve_inside)\nSet HFSS properties.\nRectangle.set_parameters(rep_type, param1, ...)\nSet coordinates parameters.\nRectangle.set_product_property(prod_id, ...)\nSet the product property of the layout object for a given product ID and attribute ID.\nRectangle.subtract(primitives)\nSubtract active primitive with one or more primitives.\nRectangle.unite(primitives)\nUnite active primitive with one or more primitives.\nRectangle.layout_obj_type\nLayoutObjType: Layout object type of the Primitive class.\nRectangle\nRectangle.add_void\nRectangle.area\nRectangle.cast\nRectangle.convert_to_polygon\nRectangle.create\nRectangle.create_3d_comp\nRectangle.create_hfss\nRectangle.create_stride\nRectangle.delete\nRectangle.expand\nRectangle.find_by_id\nRectangle.get_closest_arc_midpoint\nRectangle.get_closest_point\nRectangle.get_connected_object_id_set\nRectangle.get_connected_objects\nRectangle.get_hfss_prop\nRectangle.get_parameters\nRectangle.get_product_property\nRectangle.get_product_property_ids\nRectangle.intersect\nRectangle.intersection_type\nRectangle.is_intersecting\nRectangle.make_zone_primitive\nRectangle.plot\nRectangle.points\nRectangle.remove_hfss_prop\nRectangle.render\nRectangle.scale\nRectangle.set_hfss_prop\nRectangle.set_parameters\nRectangle.set_product_property\nRectangle.subtract\nRectangle.unite\nRectangle.layout_obj_type\nLayoutObjType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.html#pyedb.grpc.database.primitive.rectangle.Rectangle",
        "title": "Rectangle > Rectangle > Rectangle",
        "section": "Rectangle > Rectangle",
        "text": "class pyedb.grpc.database.primitive.rectangle.Rectangle(pedb, edb_object=None)\n\nClass representing a rectangle object.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nRectangle.add_void(point_list)\n\nAdd a void to current primitive.\n\nRectangle.area([include_voids])\n\nReturn the total area.\n\nRectangle.cast()\n\nCast the primitive object to the correct concrete type.\n\nRectangle.convert_to_polygon()\n\nConvert path to polygon.\n\nRectangle.create([layout, layer, net, ...])\n\nCreate a rectangle primitive in the specified layout, layer, and net with the given parameters.\n\nRectangle.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nRectangle.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nRectangle.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nRectangle.delete()\n\nDelete the rectangle primitive from the layout.\n\nRectangle.expand([offset, tolerance, ...])\n\nExpand the polygon shape by an absolute value in all direction.\n\nRectangle.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nRectangle.get_closest_arc_midpoint(point)\n\nGet the closest arc midpoint of the primitive to the input data.\n\nRectangle.get_closest_point(point)\n\nGet the closest point of the primitive to the input data.\n\nRectangle.get_connected_object_id_set()\n\nProduce a list of all geometries physically connected to a given layout object.\n\nRectangle.get_connected_objects()\n\nGet connected objects.\n\nRectangle.get_hfss_prop()\n\nGet HFSS properties.\n\nRectangle.get_parameters()\n\nGet coordinates parameters.\n\nRectangle.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nRectangle.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nRectangle.intersect(primitives)\n\nIntersect active primitive with one or more primitives.\n\nRectangle.intersection_type(primitive)\n\nGet intersection type between actual primitive and another primitive or polygon data.\n\nRectangle.is_intersecting(primitive)\n\nCheck if actual primitive and another primitive or polygon data intesects.\n\nRectangle.make_zone_primitive(zone_id)\n\nMake the primitive a zone primitive with a zone specified by the provided ID.\n\nRectangle.plot([plot_net, show, save_plot])\n\nPlot the current polygon on matplotlib.\n\nRectangle.points([arc_segments])\n\nReturn the list of points with arcs converted to segments.\n\nRectangle.remove_hfss_prop()\n\nRemove HFSS properties.\n\nRectangle.render(rep_type, ...[, is_hole])\n\nGet the polygon data of a rectangle.\n\nRectangle.scale(factor[, center])\n\nScales the polygon relative to a center point by a factor.\n\nRectangle.set_hfss_prop(material, solve_inside)\n\nSet HFSS properties.\n\nRectangle.set_parameters(rep_type, param1, ...)\n\nSet coordinates parameters.\n\nRectangle.set_product_property(prod_id, ...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nRectangle.subtract(primitives)\n\nSubtract active primitive with one or more primitives.\n\nRectangle.unite(primitives)\n\nUnite active primitive with one or more primitives.\n\n\n\nAttributes\n\n\n\n\n\n\n\nRectangle.layout_obj_type\n\nLayoutObjType: Layout object type of the Primitive class.\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.new_simulation_configuration",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.new_simulation_configuration.html#new_simulation_configuration",
        "title": "new_simulation_configuration",
        "section": "new_simulation_configuration",
        "text": "New SimulationConfiguration Object.\nInput config file.\nnew_simulation_configuration\npython:str\noptional\nlegacy.database.edb_data.simulation_configuration.SimulationConfiguration"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.new_simulation_configuration",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.new_simulation_configuration.html#pyedb.dotnet.edb.Edb.new_simulation_configuration",
        "title": "new_simulation_configuration > new_simulation_configuration > new_simulation_configuration",
        "section": "new_simulation_configuration > new_simulation_configuration",
        "text": "Edb.new_simulation_configuration(filename: str | None = None) -> SimulationConfiguration\n\nNew SimulationConfiguration Object.\n\nParameters\n\nfilename\n\npython:str, optional\n\nInput config file.\n\nReturns\n\nlegacy.database.edb_data.simulation_configuration.SimulationConfiguration\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.create",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a SIwave SYZ setup.\ncreate\nSiwaveDCSimulationSetup"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.create",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.create.html#pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveSimulationSetup.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "SiwaveSimulationSetup.create(name=None)\n\nCreate a SIwave SYZ setup.\n\nReturns\n\nSiwaveDCSimulationSetup\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.get_variable_desc",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.get_variable_desc.html#get_variable_desc",
        "title": "get_variable_desc",
        "section": "get_variable_desc",
        "text": "Get the description of a variable.\nVariable name.\nDescription of the variable.\nget_variable_desc\npython:str\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.get_variable_desc",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.get_variable_desc.html#pyedb.grpc.database.layout.cell.Cell.get_variable_desc",
        "title": "get_variable_desc > get_variable_desc > get_variable_desc",
        "section": "get_variable_desc > get_variable_desc",
        "text": "Cell.get_variable_desc(name)\n\nGet the description of a variable.\n\nParameters\n\nname\n\npython:str\n\nVariable name.\n\nReturns\n\npython:str\n\nDescription of the variable.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_json_schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias: Whether to use attribute aliases or not.\nref_template: The reference template.\nunion_format: The format to use when combining schemas from unions together. Can be one of:\n‘any_of’: Use the [anyOf](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\nkeyword to combine schemas (the default).\n- ‘primitive_type_array’: Use the [type](https://json-schema.org/understanding-json-schema/reference/type)\nkeyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\ntype (string, boolean, null, integer or number) or contains constraints/metadata, falls back to\nany_of.\nGenerateJsonSchema with your desired modifications\nmode: The mode in which to generate the schema.\nThe JSON schema for the given model class.\nmodel_json_schema"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_json_schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_json_schema.html#pyedb.workflows.drc.drc.MinAnnularRing.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod MinAnnularRing.model_json_schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}', schema_generator: type[~pydantic.json_schema.GenerateJsonSchema] = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: ~typing.Literal['validation', 'serialization'] = 'validation', *, union_format: ~typing.Literal['any_of', 'primitive_type_array'] = 'any_of') -> dict[str, Any]\n\nGenerates a JSON schema for a model class.\n\nArgs:\n\nby_alias: Whether to use attribute aliases or not.\nref_template: The reference template.\nunion_format: The format to use when combining schemas from unions together. Can be one of:\n\n‘any_of’: Use the [anyOf](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n\nkeyword to combine schemas (the default).\n- ‘primitive_type_array’: Use the [type](https://json-schema.org/understanding-json-schema/reference/type)\nkeyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\ntype (string, boolean, null, integer or number) or contains constraints/metadata, falls back to\nany_of.\n\nschema_generator: To override the logic used to generate the JSON schema, as a subclass of\n\nGenerateJsonSchema with your desired modifications\n\nmode: The mode in which to generate the schema.\n\nReturns:\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_start_elevation",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_start_elevation.html#get_start_elevation",
        "title": "get_start_elevation",
        "section": "get_start_elevation",
        "text": "Get the start elevation layer of the bondwire.\nStart cell context of the bondwire.\nStart elevation level of the bondwire.\nget_start_elevation\nCellInstance\nLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_start_elevation",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_start_elevation.html#pyedb.grpc.database.primitive.bondwire.Bondwire.get_start_elevation",
        "title": "get_start_elevation > get_start_elevation > get_start_elevation",
        "section": "get_start_elevation > get_start_elevation",
        "text": "Bondwire.get_start_elevation(start_context: CellInstance) -> Layer\n\nGet the start elevation layer of the bondwire.\n\nParameters\n\nstart_context\n\nCellInstance\n\nStart cell context of the bondwire.\n\nReturns\n\nLayer\n\nStart elevation level of the bondwire.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.set_sim_setup_info",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.set_sim_setup_info.html#set_sim_setup_info",
        "title": "set_sim_setup_info",
        "section": "set_sim_setup_info",
        "text": "set_sim_setup_info"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.set_sim_setup_info",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.set_sim_setup_info.html#pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.set_sim_setup_info",
        "title": "set_sim_setup_info > set_sim_setup_info > set_sim_setup_info",
        "section": "set_sim_setup_info > set_sim_setup_info",
        "text": "HFSSPISimulationSetup.set_sim_setup_info(sim_setup_info)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_material",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_material.html#get_material",
        "title": "get_material",
        "section": "get_material",
        "text": "Get the material of the bondwire.\nWhether an evaluated (in variable namespace) material name is wanted.\nMaterial name.\nget_material\npython:True\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_material",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.get_material.html#pyedb.grpc.database.primitive.bondwire.Bondwire.get_material",
        "title": "get_material > get_material > get_material",
        "section": "get_material > get_material",
        "text": "Bondwire.get_material(evaluated: bool = True) -> str\n\nGet the material of the bondwire.\n\nParameters\n\nevaluated\n\nbool, default: python:True\n\nWhether an evaluated (in variable namespace) material name is wanted.\n\nReturns\n\npython:str\n\nMaterial name.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.product_solver_names",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.product_solver_names.html#product_solver_names",
        "title": "product_solver_names",
        "section": "product_solver_names",
        "text": "Get the list of solver names.\nID of the product.\nproduct_solver_names\nProductIdType\npython:list\nof\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.product_solver_names",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.product_solver_names.html#pyedb.grpc.database.terminal.terminal.Terminal.product_solver_names",
        "title": "product_solver_names > product_solver_names > product_solver_names",
        "section": "product_solver_names > product_solver_names",
        "text": "Terminal.product_solver_names(product_id)\n\nGet the list of solver names.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nReturns\n\npython:list of python:str\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.add_net",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.add_net.html#add_net",
        "title": "add_net",
        "section": "add_net",
        "text": "Add a net to the extended net.\nNet to add.\nadd_net\nNet"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.add_net",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.add_net.html#pyedb.grpc.database.net.extended_net.ExtendedNet.add_net",
        "title": "add_net > add_net > add_net",
        "section": "add_net > add_net",
        "text": "ExtendedNet.add_net(net)\n\nAdd a net to the extended net.\n\nParameters\n\nnet\n\nNet\n\nNet to add.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.acos",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.acos.html#acos",
        "title": "acos",
        "section": "acos",
        "text": "Arccosine of the value.\nacos"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.acos",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.acos.html#pyedb.grpc.database.utility.value.Value.acos",
        "title": "acos > acos > acos",
        "section": "acos > acos",
        "text": "Value.acos()\n\nArccosine of the value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.auto_parametrize_design",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.auto_parametrize_design.html#auto_parametrize_design",
        "title": "auto_parametrize_design",
        "section": "auto_parametrize_design",
        "text": "Assign automatically design and project variables with current values.\nEnable layer thickness parametrization. Default value is True.\nEnable material parametrization. Default value is True.\nEnable via diameter parametrization. Default value is True.\nEnable pads size parametrization. Default value is True.\nEnable anti pads size parametrization. Default value is True.\nEnable trace width parametrization. Default value is True.\nEnable layer filter. Default value is None, all layers are parametrized.\nEnable material filter. Default value is None, all material are parametrized.\nEnable padstack definition filter. Default value is None, all padsatcks are parametrized.\nEnable nets filter for trace width parametrization. Default value is None, all layers are parametrized.\nWhether to use a single design variable for each padstack definition or a variable per pad layer.\nDefault value is True.\nWhether if use an absolute variable for each trace, padstacks and layers or a delta variable instead.\nDefault value is True.\nFull path and name for the new AEDB file. If None, then current aedb will be cutout.\nWhether to open the cutout at the end. The default is True.\nExpansion size on polygons. Polygons will be expanded in all directions. The default is 0.\nExpansion size on polygon voids. Polygons voids will be expanded in all directions. The default is 0.\nWhether if offset the via position or not. The default is True.\nList of all parameters name created.\nauto_parametrize_design\noptional\nTrue\noptional\nTrue\noptional\nTrue\noptional\nTrue\noptional\nTrue\noptional\nTrue\npython:str\nList\npython:str\noptional\nNone\npython:str\nList\npython:str\noptional\nNone\npython:str\nList\npython:str\noptional\nNone\npython:str\nList\npython:str\noptional\nNone\noptional\nTrue\noptional\nTrue\npython:str\noptional\noptional\nTrue\npython:float\noptional\n0\npython:float\noptional\n0\noptional\nTrue\nList\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.auto_parametrize_design",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.auto_parametrize_design.html#pyedb.dotnet.edb.Edb.auto_parametrize_design",
        "title": "auto_parametrize_design > auto_parametrize_design > auto_parametrize_design",
        "section": "auto_parametrize_design > auto_parametrize_design",
        "text": "Edb.auto_parametrize_design(layers=True, materials=True, via_holes=True, pads=True, antipads=True, traces=True, layer_filter=None, material_filter=None, padstack_definition_filter=None, trace_net_filter=None, use_single_variable_for_padstack_definitions=True, use_relative_variables=True, output_aedb_path=None, open_aedb_at_end=True, expand_polygons_size=0, expand_voids_size=0, via_offset=True)\n\nAssign automatically design and project variables with current values.\n\nParameters\n\nlayers\n\nbool, optional\n\nEnable layer thickness parametrization. Default value is True.\n\nmaterials\n\nbool, optional\n\nEnable material parametrization. Default value is True.\n\nvia_holes\n\nbool, optional\n\nEnable via diameter parametrization. Default value is True.\n\npads\n\nbool, optional\n\nEnable pads size parametrization. Default value is True.\n\nantipads\n\nbool, optional\n\nEnable anti pads size parametrization. Default value is True.\n\ntraces\n\nbool, optional\n\nEnable trace width parametrization. Default value is True.\n\nlayer_filter\n\npython:str, List(python:str), optional\n\nEnable layer filter. Default value is None, all layers are parametrized.\n\nmaterial_filter\n\npython:str, List(python:str), optional\n\nEnable material filter. Default value is None, all material are parametrized.\n\npadstack_definition_filter\n\npython:str, List(python:str), optional\n\nEnable padstack definition filter. Default value is None, all padsatcks are parametrized.\n\ntrace_net_filter\n\npython:str, List(python:str), optional\n\nEnable nets filter for trace width parametrization. Default value is None, all layers are parametrized.\n\nuse_single_variable_for_padstack_definitions\n\nbool, optional\n\nWhether to use a single design variable for each padstack definition or a variable per pad layer.\nDefault value is True.\n\nuse_relative_variables\n\nbool, optional\n\nWhether if use an absolute variable for each trace, padstacks and layers or a delta variable instead.\nDefault value is True.\n\noutput_aedb_path\n\npython:str, optional\n\nFull path and name for the new AEDB file. If None, then current aedb will be cutout.\n\nopen_aedb_at_end\n\nbool, optional\n\nWhether to open the cutout at the end. The default is True.\n\nexpand_polygons_size\n\npython:float, optional\n\nExpansion size on polygons. Polygons will be expanded in all directions. The default is 0.\n\nexpand_voids_size\n\npython:float, optional\n\nExpansion size on polygon voids. Polygons voids will be expanded in all directions. The default is 0.\n\nvia_offset\n\nbool, optional\n\nWhether if offset the via position or not. The default is True.\n\nReturns\n\nList(python:str)\n\nList of all parameters name created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_current_source",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_current_source.html#create_current_source",
        "title": "create_current_source",
        "section": "create_current_source",
        "text": "Create a current source.\nUse create_current_source() has been moved to edb.source_excitation.create_current_source.\ncreate_current_source\ncreate_current_source()"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_current_source",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_current_source.html#pyedb.grpc.edb.Edb.create_current_source",
        "title": "create_current_source > create_current_source > create_current_source",
        "section": "create_current_source > create_current_source",
        "text": "Edb.create_current_source(terminal, ref_terminal)\n\nCreate a current source.\n\n..deprecated:: 0.50.0\n\nUse create_current_source() has been moved to edb.source_excitation.create_current_source.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.set_frequencies",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.set_frequencies.html#set_frequencies",
        "title": "set_frequencies",
        "section": "set_frequencies",
        "text": "Set frequency list to the sweep frequencies.\n1 - frequency type (\"linear count\", \"log scale\", or \"linear scale\")\n2 - start frequency\n3 - stop frequency\n4 - step frequency or count\nTrue if correctly executed, False otherwise.\nset_frequencies\npython:list\noptional\nNone\n\"linear count\"\n\"log scale\"\n\"linear scale\"\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.set_frequencies",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.set_frequencies.html#pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.set_frequencies",
        "title": "set_frequencies > set_frequencies > set_frequencies",
        "section": "set_frequencies > set_frequencies",
        "text": "SweepData.set_frequencies(frequency_list=None, update=True)\n\nSet frequency list to the sweep frequencies.\n\nParameters\n\nfrequency_list\n\npython:list, optional\n\nList of lists with four elements. The default is None. If provided, each list must contain:\n\n1 - frequency type (\"linear count\", \"log scale\", or \"linear scale\")\n2 - start frequency\n3 - stop frequency\n4 - step frequency or count\n\nReturns\n\n\n\n——-\n\n\n\nbool\n\nTrue if correctly executed, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileComponent.add_port",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileComponent.add_port.html#add_port",
        "title": "add_port",
        "section": "add_port",
        "text": "add_port"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileComponent.add_port",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileComponent.add_port.html#pyedb.grpc.database.utility.xml_control_file.ControlFileComponent.add_port",
        "title": "add_port > add_port > add_port",
        "section": "add_port > add_port",
        "text": "ControlFileComponent.add_port(name, z0, pospin, refpin=None, pos_type='pin', ref_type='pin')\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_hfss",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_hfss.html#export_hfss",
        "title": "export_hfss",
        "section": "export_hfss",
        "text": "Export EDB to HFSS.\nFull path and name for saving the AEDT file.\nList of nets to export if only certain ones are to be exported.\nThe default is None, in which case all nets are eported.\nNumber of cores to use for the export. The default is None.\nName of the AEDT output file without the .aedt extension. The default is None,\nin which case the default name is used.\nOpen Siwave in embedding mode. User will only see Siwave Icon but UI will be hidden.\nFull path to the AEDT file.\nexport_hfss\npython:str\npython:list\noptional\nNone\npython:int\noptional\nNone\npython:str\noptional\n.aedt\nNone\noptional\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_hfss",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_hfss.html#pyedb.dotnet.edb.Edb.export_hfss",
        "title": "export_hfss > export_hfss > export_hfss",
        "section": "export_hfss > export_hfss",
        "text": "Edb.export_hfss(path_to_output, net_list=None, num_cores=None, aedt_file_name=None, hidden=False)\n\nExport EDB to HFSS.\n\nParameters\n\npath_to_output\n\npython:str\n\nFull path and name for saving the AEDT file.\n\nnet_list\n\npython:list, optional\n\nList of nets to export if only certain ones are to be exported.\nThe default is None, in which case all nets are eported.\n\nnum_cores\n\npython:int, optional\n\nNumber of cores to use for the export. The default is None.\n\naedt_file_name\n\npython:str, optional\n\nName of the AEDT output file without the .aedt extension. The default is None,\nin which case the default name is used.\n\nhidden\n\nbool, optional\n\nOpen Siwave in embedding mode. User will only see Siwave Icon but UI will be hidden.\n\nReturns\n\npython:str\n\nFull path to the AEDT file.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb(edbpath=\"C:\\temp\\myproject.aedb\", version=\"2023.2\")\n\n>>> options_config = {\"UNITE_NETS\": 1, \"LAUNCH_Q3D\": 0}\n>>> edb.write_export3d_option_config_file(r\"C:\\temp\", options_config)\n>>> edb.export_hfss(r\"C:\\temp\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_siwave_dc_results",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_siwave_dc_results.html#export_siwave_dc_results",
        "title": "export_siwave_dc_results",
        "section": "export_siwave_dc_results",
        "text": "Close EDB and solve it with Siwave.\nSiwave full project name.\nSiwave DC Analysis name.\nOuptu folder where files will be downloaded.\nEither if generate or not html report. Default is True.\nEither if generate or not vias report. Default is True.\nEither if generate or not voltage probe report. Default is True.\nEither if generate or not current source report. Default is True.\nEither if generate or not voltage source report. Default is True.\nEither if generate or not power tree image. Default is True.\nEither if generate or not loop resistance report. Default is True.\nList of files generated.\nexport_siwave_dc_results\npython:str\npython:str\npython:str\noptional\noptional\noptional\noptional\noptional\noptional\noptional\noptional\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_siwave_dc_results",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_siwave_dc_results.html#pyedb.dotnet.edb.Edb.export_siwave_dc_results",
        "title": "export_siwave_dc_results > export_siwave_dc_results > export_siwave_dc_results",
        "section": "export_siwave_dc_results > export_siwave_dc_results",
        "text": "Edb.export_siwave_dc_results(siwave_project, solution_name, output_folder=None, html_report=True, vias=True, voltage_probes=True, current_sources=True, voltage_sources=True, power_tree=True, loop_res=True)\n\nClose EDB and solve it with Siwave.\n\nParameters\n\nsiwave_project\n\npython:str\n\nSiwave full project name.\n\nsolution_name\n\npython:str\n\nSiwave DC Analysis name.\n\noutput_folder\n\npython:str, optional\n\nOuptu folder where files will be downloaded.\n\nhtml_report\n\nbool, optional\n\nEither if generate or not html report. Default is True.\n\nvias\n\nbool, optional\n\nEither if generate or not vias report. Default is True.\n\nvoltage_probes\n\nbool, optional\n\nEither if generate or not voltage probe report. Default is True.\n\ncurrent_sources\n\nbool, optional\n\nEither if generate or not current source report. Default is True.\n\nvoltage_sources\n\nbool, optional\n\nEither if generate or not voltage source report. Default is True.\n\npower_tree\n\nbool, optional\n\nEither if generate or not power tree image. Default is True.\n\nloop_res\n\nbool, optional\n\nEither if generate or not loop resistance report. Default is True.\n\nReturns\n\npython:list\n\nList of files generated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.remove_power_module",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.remove_power_module.html#remove_power_module",
        "title": "remove_power_module",
        "section": "remove_power_module",
        "text": "Remove a power module from the voltage regulator.\nComponent group name of the power module.\nremove_power_module\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.remove_power_module",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.remove_power_module.html#pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.remove_power_module",
        "title": "remove_power_module > remove_power_module > remove_power_module",
        "section": "remove_power_module > remove_power_module",
        "text": "VoltageRegulator.remove_power_module(name)\n\nRemove a power module from the voltage regulator.\n\nParameters\n\nname\n\npython:str\n\nComponent group name of the power module.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/edge_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/edge_terminal.html#edge-terminal",
        "title": "Edge terminal",
        "section": "Edge terminal",
        "text": "This class is managing EDB edge terminal.\nEdgeTerminal\n\nEdge terminal\nEdgeTerminal"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.cutout_multizone_layout",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.cutout_multizone_layout.html#cutout_multizone_layout",
        "title": "cutout_multizone_layout",
        "section": "cutout_multizone_layout",
        "text": "Create a multizone project cutout.\nDictionary with EDB path as key and EDB PolygonData as value defining the zone region.\nThis dictionary is returned from the command copy_zones():\n>>> edb = Edb(edb_file)\n>>> zone_dict = edb.copy_zones(“C:/Temp/test”)\nthe common reference net name. This net name must be provided to provide a valid project.\ncutout_multizone_layout\npython:dict\npython:str\nEDB\nPolygonData\npython:str\npython:dict\npython:str\npython:str\npython:list\nof\npython:str\nfirst\ndictionary\ndefined_ports\nwith\nedb\nname\nas\nkey\nand\nexisting\nport\nname\npython:list\nas\nThose\nports\nare\nthe\nones\ndefined\nbefore\nprocessing\nthe\nmultizone\nsecond\nis\nthe\npython:list\nof\nconnected"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.cutout_multizone_layout",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.cutout_multizone_layout.html#pyedb.dotnet.edb.Edb.cutout_multizone_layout",
        "title": "cutout_multizone_layout > cutout_multizone_layout > cutout_multizone_layout",
        "section": "cutout_multizone_layout > cutout_multizone_layout",
        "text": "Edb.cutout_multizone_layout(zone_dict, common_reference_net=None)\n\nCreate a multizone project cutout.\n\nParameters\n\nzone_dict\n\npython:dict[python:str](EDB PolygonData)\n\nDictionary with EDB path as key and EDB PolygonData as value defining the zone region.\nThis dictionary is returned from the command copy_zones():\n>>> edb = Edb(edb_file)\n>>> zone_dict = edb.copy_zones(“C:/Temp/test”)\n\ncommon_reference_net\n\npython:str\n\nthe common reference net name. This net name must be provided to provide a valid project.\n\nReturns\n\npython:dict[python:str][python:str] , python:list of python:str\n\n\n\nfirst dictionary defined_ports with edb name as key and existing port name python:list as value. Those ports are the\n\n\n\nones defined before processing the multizone clipping.\n\n\n\nsecond is the python:list of connected port.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.ungroup",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.ungroup.html#ungroup",
        "title": "ungroup",
        "section": "ungroup",
        "text": "Dissolve the group.\nWhether all containing groups should also be resolved.\nungroup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.ungroup",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.ungroup.html#pyedb.grpc.database.hierarchy.component.Component.ungroup",
        "title": "ungroup > ungroup > ungroup",
        "section": "ungroup > ungroup",
        "text": "Component.ungroup(recursive)\n\nDissolve the group.\n\nParameters\n\nrecursive\n\nbool\n\nWhether all containing groups should also be resolved.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.add_setup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.add_setup.html#add_setup",
        "title": "add_setup",
        "section": "add_setup",
        "text": "Adding method for grpc compatibility\nadd_setup"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.add_setup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.add_setup.html#pyedb.dotnet.database.hfss.EdbHfss.add_setup",
        "title": "add_setup > add_setup > add_setup",
        "section": "add_setup > add_setup",
        "text": "EdbHfss.add_setup(name=None)\n\nAdding method for grpc compatibility\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.int_to_geometry_type",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.int_to_geometry_type.html#int_to_geometry_type",
        "title": "int_to_geometry_type",
        "section": "int_to_geometry_type",
        "text": "Convert an integer to an EDB.PadGeometryType.\nEDB.PadGeometryType enumerator value.\nint_to_geometry_type\npython:int\nobject"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.int_to_geometry_type",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.int_to_geometry_type.html#pyedb.grpc.database.padstacks.Padstacks.int_to_geometry_type",
        "title": "int_to_geometry_type > int_to_geometry_type > int_to_geometry_type",
        "section": "int_to_geometry_type > int_to_geometry_type",
        "text": "static Padstacks.int_to_geometry_type(val: int = 0) -> PadGeometryType\n\nConvert an integer to an EDB.PadGeometryType.\n\nParameters\n\nval\n\npython:int\n\n\n\nReturns\n\nobject\n\nEDB.PadGeometryType enumerator value.\n\nExamples\n\n>>> geom_type = edb_padstacks.int_to_geometry_type(1)  # Returns CIRCLE\n>>> geom_type = edb_padstacks.int_to_geometry_type(2)  # Returns SQUARE\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a path in the specified layout, layer, and net with the given parameters.\nThe layout in which the path will be created. If not provided, the active layout of the pedb instance\nwill be used.\nThe layer in which the path will be created. This parameter is required and must be specified.\nThe net to which the path will belong. If not provided, the path will not be associated with a net.\nThe width of the path in meters. The default value is 100e-6.\nThe style of the first end cap. Options are “flat”, “round”, “extended”, and “clipped”.\nThe default value is “flat”.\nThe style of the second end cap. Options are “flat”, “round”, “extended”, and “clipped”.\nThe default value is “flat”.\nThe style of the path corners. Options are “sharp”, “round”, and “mitter”.\nThe default value is “sharp”.\nThe points defining the path. This can be a list of points or an instance of GrpcPolygonData.\nThis parameter is required and must be specified.\nThe created path object.\nIf the points parameter is not provided.\nIf points is provided as a list, it will be converted to a GrpcPolygonData object.\nThe created path is added to the modeler primitives of the pedb instance.\ncreate\nLayout\noptional\nUnion\npython:str\nLayer\noptional\nUnion\npython:str\nNet\noptional\npython:float\noptional\npython:str\noptional\npython:str\noptional\npython:str\noptional\nUnion\npython:list\nGrpcPolygonData\noptional\nPath\nValueError"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.create.html#pyedb.grpc.database.primitive.path.Path.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "Path.create(layout=None, layer: str | Layer = None, net: str | Net = None, width: float = 0.0001, end_cap1: str | PathEndCapType = 'flat', end_cap2: str | PathEndCapType = 'flat', corner_style: str | PathCornerType = 'sharp', points: list | PolygonData = None)\n\nCreate a path in the specified layout, layer, and net with the given parameters.\n\nParameters\n\nlayout\n\nLayout, optional\n\nThe layout in which the path will be created. If not provided, the active layout of the pedb instance\nwill be used.\n\nlayer\n\nUnion[python:str, Layer], optional\n\nThe layer in which the path will be created. This parameter is required and must be specified.\n\nnet\n\nUnion[python:str, Net], optional\n\nThe net to which the path will belong. If not provided, the path will not be associated with a net.\n\nwidth\n\npython:float, optional\n\nThe width of the path in meters. The default value is 100e-6.\n\nend_cap1\n\npython:str, optional\n\nThe style of the first end cap. Options are “flat”, “round”, “extended”, and “clipped”.\nThe default value is “flat”.\n\nend_cap2\n\npython:str, optional\n\nThe style of the second end cap. Options are “flat”, “round”, “extended”, and “clipped”.\nThe default value is “flat”.\n\ncorner_style\n\npython:str, optional\n\nThe style of the path corners. Options are “sharp”, “round”, and “mitter”.\nThe default value is “sharp”.\n\npoints\n\nUnion[python:list, GrpcPolygonData], optional\n\nThe points defining the path. This can be a list of points or an instance of GrpcPolygonData.\nThis parameter is required and must be specified.\n\nReturns\n\nPath\n\nThe created path object.\n\nRaises\n\nValueError\n\nIf the points parameter is not provided.\n\nNotes\n\nIf points is provided as a list, it will be converted to a GrpcPolygonData object.\n\nThe created path is added to the modeler primitives of the pedb instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_validate_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data: The JSON data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nThe validated Pydantic model.\nValidationError: If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_validate_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_validate_json.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod DiffPairLengthMatch.model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n\njson_data: The JSON data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nReturns:\n\nThe validated Pydantic model.\n\nRaises:\n\nValidationError: If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.find_by_name",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.find_by_name.html#find_by_name",
        "title": "find_by_name",
        "section": "find_by_name",
        "text": "Find a package definition object by name in a given database.\nDatabase to search for the package definition.\nName of the package definition.\nPackage definition found, None otherwise.\nfind_by_name\npython:str\nPackageDef\nNone"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.find_by_name",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.find_by_name.html#pyedb.grpc.database.definition.package_def.PackageDef.find_by_name",
        "title": "find_by_name > find_by_name > find_by_name",
        "section": "find_by_name > find_by_name",
        "text": "classmethod PackageDef.find_by_name(db, name)\n\nFind a package definition object by name in a given database.\n\nParameters\n\ndb :class:`.Database`\n\nDatabase to search for the package definition.\n\nname\n\npython:str\n\nName of the package definition.\n\nReturns\n\nPackageDef\n\nPackage definition found, None otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.default_conductor_property_values",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.default_conductor_property_values.html#default_conductor_property_values",
        "title": "default_conductor_property_values",
        "section": "default_conductor_property_values",
        "text": "default_conductor_property_values"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.default_conductor_property_values",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.default_conductor_property_values.html#pyedb.dotnet.database.materials.Materials.default_conductor_property_values",
        "title": "default_conductor_property_values > default_conductor_property_values > default_conductor_property_values",
        "section": "default_conductor_property_values > default_conductor_property_values",
        "text": "Materials.default_conductor_property_values = {'conductivity': 58000000, 'dielectric_loss_tangent': 0, 'magnetic_loss_tangent': 0, 'mass_density': 8933, 'permeability': 0.999991, 'permittivity': 1, 'poisson_ratio': 0.38, 'specific_heat': 385, 'thermal_conductivity': 400, 'thermal_expansion_coefficient': 1.77e-05, 'youngs_modulus': 120000000000}\n\n"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.name.html#name",
        "title": "name",
        "section": "name",
        "text": "name"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.name.html#pyedb.workflows.drc.drc.BackDrillStubLength.name",
        "title": "name > name > name",
        "section": "name > name",
        "text": "BackDrillStubLength.name: str\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.get_point_terminal",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.get_point_terminal.html#get_point_terminal",
        "title": "get_point_terminal",
        "section": "get_point_terminal",
        "text": "Place terminal between two points.\nName of the terminal.\nName of the net.\nLocation of the terminal.\nLayer of the terminal.\nget_point_terminal\npython:str\npython:list\nPointTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.get_point_terminal",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.get_point_terminal.html#pyedb.grpc.database.source_excitations.SourceExcitation.get_point_terminal",
        "title": "get_point_terminal > get_point_terminal > get_point_terminal",
        "section": "get_point_terminal > get_point_terminal",
        "text": "SourceExcitation.get_point_terminal(name: str, net_name: str, location: List[float], layer: str) -> PointTerminal\n\nPlace terminal between two points.\n\nParameters\n\nname\n\nstr,\n\nName of the terminal.\n\nnet_name\n\npython:str\n\nName of the net.\n\nlocation\n\npython:list\n\nLocation of the terminal.\n\nlayer\n\nstr,\n\nLayer of the terminal.\n\nReturns\n\nPointTerminal\n\n\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> term = edb.source_excitation.get_point_terminal(\"Term1\", \"Net1\", [0, 0], \"TopLayer\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSetup",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSetup.html#controlfilesetup",
        "title": "ControlFileSetup",
        "section": "ControlFileSetup",
        "text": "Represents a simulation setup.\nSetup name.\nControlFileSetup.add_mesh_operation(name, ...)\nAdd a mesh operation.\nControlFileSetup.add_sweep(name, start, ...)\nAdd a frequency sweep.\nControlFileSetup\npython:str\nControlFileSetup.add_mesh_operation\nControlFileSetup.add_sweep"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSetup",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSetup.html#pyedb.grpc.database.control_file.ControlFileSetup",
        "title": "ControlFileSetup > ControlFileSetup > ControlFileSetup",
        "section": "ControlFileSetup > ControlFileSetup",
        "text": "class pyedb.grpc.database.control_file.ControlFileSetup(name: str)\n\nRepresents a simulation setup.\n\nParameters\n\nname\n\npython:str\n\nSetup name.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nControlFileSetup.add_mesh_operation(name, ...)\n\nAdd a mesh operation.\n\nControlFileSetup.add_sweep(name, start, ...)\n\nAdd a frequency sweep.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_connected_objects",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_connected_objects.html#get_connected_objects",
        "title": "get_connected_objects",
        "section": "get_connected_objects",
        "text": "Get connected objects.\nget_connected_objects\nList\nLayoutObjInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_connected_objects",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_connected_objects.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_connected_objects",
        "title": "get_connected_objects > get_connected_objects > get_connected_objects",
        "section": "get_connected_objects > get_connected_objects",
        "text": "PadstackInstance.get_connected_objects()\n\nGet connected objects.\n\nReturns\n\nList[LayoutObjInstance]\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.add_project_variable",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.add_project_variable.html#add_project_variable",
        "title": "add_project_variable",
        "section": "add_project_variable",
        "text": "Add project variable.\nVariable name (auto-prefixed with ‘$’).\nVariable value with units.\nVariable description.\nTrue if successful, False if variable exists.\nadd_project_variable\npython:str\npython:str\npython:float\npython:str\noptional"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.add_project_variable",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.add_project_variable.html#pyedb.grpc.edb.Edb.add_project_variable",
        "title": "add_project_variable > add_project_variable > add_project_variable",
        "section": "add_project_variable > add_project_variable",
        "text": "Edb.add_project_variable(variable_name, variable_value, description=None) -> bool\n\nAdd project variable.\n\nParameters\n\nvariable_name\n\npython:str\n\nVariable name (auto-prefixed with ‘$’).\n\nvariable_value\n\npython:str, python:float\n\nVariable value with units.\n\ndescription\n\npython:str, optional\n\nVariable description.\n\nReturns\n\nbool\n\nTrue if successful, False if variable exists.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.get_product_property_ids.html#pyedb.grpc.database.ports.ports.GapPort.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "GapPort.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.set_properties",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.set_properties.html#set_properties",
        "title": "set_properties",
        "section": "set_properties",
        "text": "set_properties"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.set_properties",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.set_properties.html#pyedb.grpc.database.definition.component_def.ComponentDef.set_properties",
        "title": "set_properties > set_properties > set_properties",
        "section": "set_properties > set_properties",
        "text": "ComponentDef.set_properties(**kwargs)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileStackup.add_dielectric",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileStackup.add_dielectric.html#add_dielectric",
        "title": "add_dielectric",
        "section": "add_dielectric",
        "text": "Add a new dielectric.\nLayer name.\nDielectric layer index as they must be stacked. If not provided the layer index will be incremented.\nMaterial name.\nLayer thickness.\nDictionary with key and  property value.\nLayer name used for layer placement. Default value is None. This option is used for inserting\ndielectric layer between two existing ones. When no argument is provided the dielectric layer will be placed\non top of the stacked ones.\nProvides the method to use when the argument base_layer is provided. When True the layer is added\non top on the base layer, when False it will be added below.\nadd_dielectric\npython:str\npython:int\noptional\npython:str\npython:float\npython:dict\npython:str\noptional\nNone\nbase_layer\nTrue\nFalse\npyedb.dotnet.database.edb_data.control_file.ControlFileDielectric"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileStackup.add_dielectric",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileStackup.add_dielectric.html#pyedb.grpc.database.utility.xml_control_file.ControlFileStackup.add_dielectric",
        "title": "add_dielectric > add_dielectric > add_dielectric",
        "section": "add_dielectric > add_dielectric",
        "text": "ControlFileStackup.add_dielectric(layer_name, layer_index=None, material='', thickness=0.0, properties=None, base_layer=None, add_on_top=True)\n\nAdd a new dielectric.\n\nParameters\n\nlayer_name\n\npython:str\n\nLayer name.\n\nlayer_index\n\npython:int, optional\n\nDielectric layer index as they must be stacked. If not provided the layer index will be incremented.\n\nmaterial\n\npython:str\n\nMaterial name.\n\nthickness\n\npython:float\n\nLayer thickness.\n\nproperties\n\npython:dict\n\nDictionary with key and  property value.\n\nbase_layer\n\npython:str,  optional\n\nLayer name used for layer placement. Default value is None. This option is used for inserting\ndielectric layer between two existing ones. When no argument is provided the dielectric layer will be placed\non top of the stacked ones.\n\nmethod\n\nbool, Optional.\n\nProvides the method to use when the argument base_layer is provided. When True the layer is added\non top on the base layer, when False it will be added below.\n\nReturns\n\npyedb.dotnet.database.edb_data.control_file.ControlFileDielectric\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.make_zone_primitive",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.make_zone_primitive.html#make_zone_primitive",
        "title": "make_zone_primitive",
        "section": "make_zone_primitive",
        "text": "Make primitive a zone primitive with a zone specified by the provided id.\nId of zone primitive will use.\nmake_zone_primitive\npython:int"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.make_zone_primitive",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.make_zone_primitive.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.make_zone_primitive",
        "title": "make_zone_primitive > make_zone_primitive > make_zone_primitive",
        "section": "make_zone_primitive > make_zone_primitive",
        "text": "EdbPolygon.make_zone_primitive(zone_id)\n\nMake primitive a zone primitive with a zone specified by the provided id.\n\nParameters\n\nzone_id\n\npython:int\n\nId of zone primitive will use.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.find",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.find.html#find",
        "title": "find",
        "section": "find",
        "text": "Find a terminal by name in a given layout.\nLayout to search for the terminal.\nName of the terminal.\nfind\nLayout\nstr\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.find",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.find.html#pyedb.grpc.database.ports.ports.CoaxPort.find",
        "title": "find > find > find",
        "section": "find > find",
        "text": "classmethod CoaxPort.find(layout, name)\n\nFind a terminal by name in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the terminal.\n\nname\n\nstr\n\nName of the terminal.\n\nReturns\n\nTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.RatRace.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.RatRace.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Draw the discretised ring and four 50 Ω port stubs.\nTrue on success.\ncreate"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.RatRace.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.RatRace.create.html#pyedb.libraries.rf_libraries.base_functions.RatRace.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "RatRace.create() -> bool\n\nDraw the discretised ring and four 50 Ω port stubs.\n\nReturns\n\nbool\n\nTrue on success.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.update_forward_refs",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "update_forward_refs"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.update_forward_refs",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.update_forward_refs.html#pyedb.grpc.database.definition.materials.MaterialProperties.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod MaterialProperties.update_forward_refs(**localns: Any) -> None\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.from_orm",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "from_orm"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.from_orm",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.from_orm.html#pyedb.workflows.drc.drc.DiffPair.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod DiffPair.from_orm(obj: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_product_property_ids.html#pyedb.grpc.database.terminal.terminal.Terminal.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "Terminal.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.delete_variable",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.delete_variable.html#delete_variable",
        "title": "delete_variable",
        "section": "delete_variable",
        "text": "Delete a variable.\nVariable name.\ndelete_variable\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.delete_variable",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.delete_variable.html#pyedb.grpc.database.layout.layout.Layout.delete_variable",
        "title": "delete_variable > delete_variable > delete_variable",
        "section": "delete_variable > delete_variable",
        "text": "Layout.delete_variable(name)\n\nDelete a variable.\n\nParameters\n\nname\n\npython:str\n\nVariable name.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.update_rlc_from_bom",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.update_rlc_from_bom.html#update_rlc_from_bom",
        "title": "update_rlc_from_bom",
        "section": "update_rlc_from_bom",
        "text": "Update RLC values from BOM file.\nBOM file path.\nDelimiter character.\nValue field name.\nComponent type field name.\nReference designator field name.\nTrue if successful, False otherwise.\nupdate_rlc_from_bom\npython:str\npython:str\noptional\npython:str\noptional\npython:str\noptional\npython:str\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.update_rlc_from_bom",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.update_rlc_from_bom.html#pyedb.grpc.database.components.Components.update_rlc_from_bom",
        "title": "update_rlc_from_bom > update_rlc_from_bom > update_rlc_from_bom",
        "section": "update_rlc_from_bom > update_rlc_from_bom",
        "text": "Components.update_rlc_from_bom(bom_file: str, delimiter: str = ';', valuefield: str = 'Func des', comptype: str = 'Prod name', refdes: str = 'Pos / Place') -> bool\n\nUpdate RLC values from BOM file.\n\nParameters\n\nbom_file\n\npython:str\n\nBOM file path.\n\ndelimiter\n\npython:str, optional\n\nDelimiter character.\n\nvaluefield\n\npython:str, optional\n\nValue field name.\n\ncomptype\n\npython:str, optional\n\nComponent type field name.\n\nrefdes\n\npython:str, optional\n\nReference designator field name.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\nExamples\n\n>>> edbapp.components.update_rlc_from_bom(\"bom.csv\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.Source",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.Source.html#source",
        "title": "Source",
        "section": "Source",
        "text": "Provides for handling Siwave sources.\nSource"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.Source",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.Source.html#pyedb.grpc.database.utility.sources.Source",
        "title": "Source > Source > Source",
        "section": "Source > Source",
        "text": "class pyedb.grpc.database.utility.sources.Source(pedb)\n\nProvides for handling Siwave sources.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.create",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a rectangle primitive in the specified layout, layer, and net with the given parameters.\nThe layout in which the rectangle will be created. If not provided, the active layout of the pedb instance\nwill be used.\nThe layer in which the rectangle will be created. This parameter is required and must be specified.\nThe net to which the rectangle will belong. This parameter is required and must be specified.\nThe representation type of the rectangle. Options are “center_width_height” or “lower_left_upper_right”.\nThe default value is “center_width_height”.\nThe first parameter defining the rectangle. Its meaning depends on the rep_type.\nThe second parameter defining the rectangle. Its meaning depends on the rep_type.\nThe third parameter defining the rectangle. Its meaning depends on the rep_type.\nThe fourth parameter defining the rectangle. Its meaning depends on the rep_type.\nThe corner radius of the rectangle. The default value is 0.0.\nThe rotation angle of the rectangle in degrees. The default value is 0.0.\nThe created rectangle primitive.\nIf the layer parameter is not provided.\nIf the net parameter is not provided.\nThe created rectangle is added to the modeler primitives of the pedb instance.\n“center_width_height”: param1 and param2 represent the center coordinates, while param3 and\nparam4 represent the width and height.\n- “lower_left_upper_right”: param1 and param2 represent the lower-left corner coordinates, while\nparam3 and param4 represent the upper-right corner coordinates.\ncreate\nLayout\noptional\nUnion\npython:str\nLayer\noptional\nUnion\npython:str\nNet\noptional\npython:str\noptional\npython:float\noptional\npython:float\noptional\npython:float\noptional\npython:float\noptional\npython:float\noptional\npython:float\noptional\nRectangle\nValueError\nValueError"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.create",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.create.html#pyedb.grpc.database.primitive.rectangle.Rectangle.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "Rectangle.create(layout=None, layer: str | Layer = None, net: str | Net = None, rep_type: str = 'center_width_height', param1: float = None, param2: float = None, param3: float = None, param4: float = None, corner_rad: float = 0.0, rotation: float = 0.0)\n\nCreate a rectangle primitive in the specified layout, layer, and net with the given parameters.\n\nParameters\n\nlayout\n\nLayout, optional\n\nThe layout in which the rectangle will be created. If not provided, the active layout of the pedb instance\nwill be used.\n\nlayer\n\nUnion[python:str, Layer], optional\n\nThe layer in which the rectangle will be created. This parameter is required and must be specified.\n\nnet\n\nUnion[python:str, Net], optional\n\nThe net to which the rectangle will belong. This parameter is required and must be specified.\n\nrep_type\n\npython:str, optional\n\nThe representation type of the rectangle. Options are “center_width_height” or “lower_left_upper_right”.\nThe default value is “center_width_height”.\n\nparam1\n\npython:float, optional\n\nThe first parameter defining the rectangle. Its meaning depends on the rep_type.\n\nparam2\n\npython:float, optional\n\nThe second parameter defining the rectangle. Its meaning depends on the rep_type.\n\nparam3\n\npython:float, optional\n\nThe third parameter defining the rectangle. Its meaning depends on the rep_type.\n\nparam4\n\npython:float, optional\n\nThe fourth parameter defining the rectangle. Its meaning depends on the rep_type.\n\ncorner_rad\n\npython:float, optional\n\nThe corner radius of the rectangle. The default value is 0.0.\n\nrotation\n\npython:float, optional\n\nThe rotation angle of the rectangle in degrees. The default value is 0.0.\n\nReturns\n\nRectangle\n\nThe created rectangle primitive.\n\nRaises\n\nValueError\n\nIf the layer parameter is not provided.\n\nValueError\n\nIf the net parameter is not provided.\n\nNotes\n\nThe created rectangle is added to the modeler primitives of the pedb instance.\n\nThe rep_type determines how the parameters are interpreted:\n\n“center_width_height”: param1 and param2 represent the center coordinates, while param3 and\n\nparam4 represent the width and height.\n- “lower_left_upper_right”: param1 and param2 represent the lower-left corner coordinates, while\nparam3 and param4 represent the upper-right corner coordinates.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.export",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.export.html#export",
        "title": "export",
        "section": "export",
        "text": "Export stackup definition to a CSV or JSON file.\nFile path to csv or json file.\nFormat of the file to export. The default is \"csv\". Options are \"csv\", \"xlsx\",\n\"json\".\nWhether to include the material definition inside layer ones. This parameter is only used\nwhen a JSON file is exported. The default is False, which keeps the material definition\nsection in the JSON file. If True, the material definition is included inside the layer ones.\nexport\npython:str\npython:str\noptional\n\"csv\"\n\"csv\"\n\"xlsx\"\n\"json\"\nFalse\nTrue"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.export",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.export.html#pyedb.dotnet.database.stackup.Stackup.export",
        "title": "export > export > export",
        "section": "export > export",
        "text": "Stackup.export(fpath, file_format='xml', include_material_with_layer=False)\n\nExport stackup definition to a CSV or JSON file.\n\nParameters\n\nfpath\n\npython:str\n\nFile path to csv or json file.\n\nfile_format\n\npython:str, optional\n\nFormat of the file to export. The default is \"csv\". Options are \"csv\", \"xlsx\",\n\"json\".\n\ninclude_material_with_layer\n\nbool, optional.\n\nWhether to include the material definition inside layer ones. This parameter is only used\nwhen a JSON file is exported. The default is False, which keeps the material definition\nsection in the JSON file. If True, the material definition is included inside the layer ones.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> edb.stackup.export(\"stackup.xml\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.execute",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.execute.html#execute",
        "title": "execute",
        "section": "execute",
        "text": "Execute EDB utility command (Not implemented in gRPC).\nCommand to execute.\nexecute\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.execute",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.execute.html#pyedb.grpc.edb.Edb.execute",
        "title": "execute > execute > execute",
        "section": "execute > execute",
        "text": "Edb.execute(func)\n\nExecute EDB utility command (Not implemented in gRPC).\n\nParameters\n\nfunc\n\npython:str\n\nCommand to execute.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.make_zone_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.make_zone_primitive.html#make_zone_primitive",
        "title": "make_zone_primitive",
        "section": "make_zone_primitive",
        "text": "Make the primitive a zone primitive with a zone specified by the provided ID.\nID of the zone primitive to use.\nmake_zone_primitive\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.make_zone_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.make_zone_primitive.html#pyedb.grpc.database.primitive.rectangle.Rectangle.make_zone_primitive",
        "title": "make_zone_primitive > make_zone_primitive > make_zone_primitive",
        "section": "make_zone_primitive > make_zone_primitive",
        "text": "Rectangle.make_zone_primitive(zone_id: int)\n\nMake the primitive a zone primitive with a zone specified by the provided ID.\n\nParameters\n\nzone_id\n\npython:int\n\nID of the zone primitive to use.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.from_dict",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.from_dict.html#from_dict",
        "title": "from_dict",
        "section": "from_dict",
        "text": "Alias for model_validate.\nDictionary produced by json.load, yaml.safe_load, etc.\nValidated instance ready for Drc.check().\nfrom_dict\nmodel_validate\njson.load\nyaml.safe_load\nRules\nDrc.check()"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.from_dict",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.from_dict.html#pyedb.workflows.drc.drc.Rules.from_dict",
        "title": "from_dict > from_dict > from_dict",
        "section": "from_dict > from_dict",
        "text": "classmethod Rules.from_dict(data: dict[str, Any]) -> Rules\n\nAlias for model_validate.\n\nParameters\n\ndata\n\nDictionary produced by json.load, yaml.safe_load, etc.\n\nReturns\n\nRules\n\nValidated instance ready for Drc.check().\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.create_stride.html#create_stride",
        "title": "create_stride",
        "section": "create_stride",
        "text": "Create a Stride model from an MCAD file.\nStride model created.\ncreate_stride\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.create_stride.html#pyedb.grpc.database.ports.ports.GapPort.create_stride",
        "title": "create_stride > create_stride > create_stride",
        "section": "create_stride > create_stride",
        "text": "GapPort.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nReturns\n\nMcadModel\n\nStride model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.is_arc",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.is_arc.html#is_arc",
        "title": "is_arc",
        "section": "is_arc",
        "text": "Either if a point is an arc or not.\nis_arc"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.is_arc",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.is_arc.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.is_arc",
        "title": "is_arc > is_arc > is_arc",
        "section": "is_arc > is_arc",
        "text": "EdbPolygon.is_arc(point)\n\nEither if a point is an arc or not.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layer_below",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layer_below.html#add_layer_below",
        "title": "add_layer_below",
        "section": "add_layer_below",
        "text": "Add a layer below a specified layer.\nName of the layer.\nName of the base layer.\nType of the layer. The default is \"signal\". Options are \"signal\" and \"dielectric\".\nAdditional keyword arguments. Possible keys are:\n- thickness : float, layer thickness.\n- material : str, layer material.\nLayer object created.\nadd_layer_below\npython:str\npython:str\npython:str\noptional\n\"signal\"\n\"signal\"\n\"dielectric\"\npython:dict\noptional\nthickness\nmaterial\npyedb.grpc.database.layers.stackup_layer.StackupLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layer_below",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.add_layer_below.html#pyedb.grpc.database.stackup.Stackup.add_layer_below",
        "title": "add_layer_below > add_layer_below > add_layer_below",
        "section": "add_layer_below > add_layer_below",
        "text": "Stackup.add_layer_below(name: str, base_layer_name: str, layer_type: str = 'signal', **kwargs) -> Layer | None\n\nAdd a layer below a specified layer.\n\nParameters\n\nname\n\npython:str\n\nName of the layer.\n\nbase_layer_name\n\npython:str\n\nName of the base layer.\n\nlayer_type\n\npython:str, optional\n\nType of the layer. The default is \"signal\". Options are \"signal\" and \"dielectric\".\n\n**kwargs\n\npython:dict, optional\n\nAdditional keyword arguments. Possible keys are:\n- thickness : float, layer thickness.\n- material : str, layer material.\n\nReturns\n\npyedb.grpc.database.layers.stackup_layer.StackupLayer\n\nLayer object created.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> new_layer = edb.stackup.add_layer_below(\"NewLayer\", \"TopLayer\", layer_type=\"dielectric\", thickness=\"0.05mm\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.set_component_rlc",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.set_component_rlc.html#set_component_rlc",
        "title": "set_component_rlc",
        "section": "set_component_rlc",
        "text": "Set RLC values for a component.\nComponent name.\nResistance value.\nInductance value.\nCapacitance value.\nWhether RLC is parallel.\nTrue if successful, False otherwise.\nset_component_rlc\npython:str\npython:float\noptional\npython:float\noptional\npython:float\noptional\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.set_component_rlc",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.set_component_rlc.html#pyedb.grpc.database.components.Components.set_component_rlc",
        "title": "set_component_rlc > set_component_rlc > set_component_rlc",
        "section": "set_component_rlc > set_component_rlc",
        "text": "Components.set_component_rlc(componentname: str, res_value: float | None = None, ind_value: float | None = None, cap_value: float | None = None, isparallel: bool = False) -> bool\n\nSet RLC values for a component.\n\nParameters\n\ncomponentname\n\npython:str\n\nComponent name.\n\nres_value\n\npython:float, optional\n\nResistance value.\n\nind_value\n\npython:float, optional\n\nInductance value.\n\ncap_value\n\npython:float, optional\n\nCapacitance value.\n\nisparallel\n\nbool, optional\n\nWhether RLC is parallel.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\nExamples\n\n>>> edbapp.components.set_component_rlc(\"R1\", res_value=50)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.find",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.find.html#find",
        "title": "find",
        "section": "find",
        "text": "Find a terminal by name in a given layout.\nLayout to search for the terminal.\nName of the terminal.\nfind\nLayout\nstr\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.find",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.find.html#pyedb.grpc.database.terminal.point_terminal.PointTerminal.find",
        "title": "find > find > find",
        "section": "find > find",
        "text": "classmethod PointTerminal.find(layout, name)\n\nFind a terminal by name in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the terminal.\n\nname\n\nstr\n\nName of the terminal.\n\nReturns\n\nTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/SourceData",
        "href": "dotnet_api/dotnet/edb_data/SourceData.html#sources-and-excitations",
        "title": "Sources and excitations",
        "section": "Sources and excitations",
        "text": "These classes are the containers of sources methods of the EDB for both HFSS and SIwave.\nSources and excitations"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create_port_on_pins",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create_port_on_pins.html#create_port_on_pins",
        "title": "create_port_on_pins",
        "section": "create_port_on_pins",
        "text": "Create circuit port between pins and reference ones.\nstr or EDBComponent object.\nUnion[int, str, EDBPadstackInstance], List[Union[int, str, EDBPadstackInstance]]\nUnion[int, str, EDBPadstackInstance], List[Union[int, str, EDBPadstackInstance]]\nstr, float\nPort name. The default is None, in which case a name is automatically assigned.\nIf True force using pingroup definition on single pin to have the port created at the pad center. If\nFalse the port is created at the pad edge. Default value is False.\ncreate_port_on_pins\nComponent\nreference\ndesignator\npin\nspecifier\ns\nor\ninstance\ns\nwhere\nthe\nport\nterminal\nis\nto\nbe\nSingle\npin\nname\na\npython:list\nof\nreference\npin\nspecifier\ns\nor\ninstance\ns\nfor\nthe\nport\nreference\nAllowed\nvalues\nare\nPort\nimpedance\npython:str\noptional\nNone\noptional\nTrue\nFalse\nFalse\nEDB\nterminal\ncreated\nor\npython:False\nif\nfailed\nto\nOr\nto\ntake\nall\nreference\npins"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create_port_on_pins",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create_port_on_pins.html#pyedb.dotnet.database.components.Components.create_port_on_pins",
        "title": "create_port_on_pins > create_port_on_pins > create_port_on_pins",
        "section": "create_port_on_pins > create_port_on_pins",
        "text": "Components.create_port_on_pins(refdes, pins, reference_pins, impedance=50.0, port_name=None, pec_boundary=False, pingroup_on_single_pin=False)\n\nCreate circuit port between pins and reference ones.\n\nParameters\n\nrefdes\n\nComponent reference designator\n\nstr or EDBComponent object.\n\npins\n\npin specifier(s) or instance(s) where the port terminal is to be created. Single pin name or a python:list of\n\n\n\nseveral can be provided. If several pins are provided a pin group will be created. Pin specifiers can be the\n\n\n\nglobal EDB object ID or padstack instance name or pin name on component with refdes ``refdes``. Pin instances\n\n\n\ncan be provided as ``EDBPadstackInstance`` objects.\n\n\n\nFor instance for the pin called ``Pin1`` located on component with refdes ``U1``: ``U1-Pin1``, ``Pin1`` with\n\n\n\n``refdes=U1``, the pin’s global EDB object ID, or the ``EDBPadstackInstance`` corresponding to the pin can be\n\n\n\nprovided.\n\nUnion[int, str, EDBPadstackInstance], List[Union[int, str, EDBPadstackInstance]]\n\nreference_pins\n\nreference pin specifier(s) or instance(s) for the port reference terminal. Allowed values are\n\n\n\nthe same as for the ``pins`` parameter.\n\nUnion[int, str, EDBPadstackInstance], List[Union[int, str, EDBPadstackInstance]]\n\nimpedance\n\nPort impedance\n\nstr, float\n\nport_name\n\npython:str, optional\n\nPort name. The default is None, in which case a name is automatically assigned.\n\npec_boundary\n\nbool, optional\n\n\n\nWhether to define the PEC boundary, The default is ``False``. If set to ``True``,\n\n\n\na perfect short is created between the pin and impedance is ignored. This\n\n\n\nparameter is only supported on a port created between two pins, such as\n\n\n\nwhen there is no pin group.\n\n\n\npingroup_on_single_pin\n\nbool\n\nIf True force using pingroup definition on single pin to have the port created at the pad center. If\nFalse the port is created at the pad edge. Default value is False.\n\nReturns\n\nEDB terminal created, or python:False if failed to create.\n\n\n\nExample:\n\n\n\n>>> :obj:`from` :obj:`pyedb` :obj:`import` :obj:`Edb`\n    ..\n\n>>> :obj:`edb` = :obj:`Edb`\\(:obj:`path_to_edb_file`)\n    ..\n\n>>> :obj:`pin` = \"AJ6\"\n    ..\n\n>>> :obj:`ref_pins` = [\"AM7\", \"AM4\"]\n    ..\n\nOr to take all reference pins\n\n\n\n>>> :obj:`ref_pins` = [:obj:`pin` :obj:`for` :obj:`pin` :obj:`in` :class:`python:list`\\(:obj:`edb.components`\\[\"U2A5\"]:obj:`.pins.values`\\()) :obj:`if` :obj:`pin.net_name` == \"GND\"]\n    ..\n\n>>> :obj:`edb.components.create_port_on_pins`\\(refdes=\"U2A5\", pins=pin, reference_pins=ref_pins)\n    ..\n\n>>> :obj:`edb.save_edb`\\()\n    ..\n\n>>> :obj:`edb.close_edb`\\()\n    ..\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/siwave",
        "href": "dotnet_api/dotnet/sim_setup_data/io/siwave.html#siwave-io",
        "title": "SIwave IO",
        "section": "SIwave IO",
        "text": "This class is the container of SIwave IO.\nSettingsBase\nProvide base settings.\nAdvancedSettings\n\nDCSettings\n\nDCAdvancedSettings\n\nSIwave IO\nSettingsBase\nAdvancedSettings\nDCSettings\nDCAdvancedSettings"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.close",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.close.html#close",
        "title": "close",
        "section": "close",
        "text": "Close the database.\nTerminate RPC session when closing the database. The default value is True.\nUnsaved changes will be lost. If multiple databases are open and RPC session is terminated, the connection\nwith all databases will be lost. You might be careful and set to False until the last open database\nremains.\nclose\noptional"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.close",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.close.html#pyedb.grpc.edb.Edb.close",
        "title": "close > close > close",
        "section": "close > close",
        "text": "Edb.close(terminate_rpc_session=True)\n\nClose the database.\n\nParameters\n\nterminate_rpc_session\n\nbool, optional\n\nTerminate RPC session when closing the database. The default value is True.\n\n. note::\n\nUnsaved changes will be lost. If multiple databases are open and RPC session is terminated, the connection\nwith all databases will be lost. You might be careful and set to False until the last open database\nremains.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_closest_point",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_closest_point.html#get_closest_point",
        "title": "get_closest_point",
        "section": "get_closest_point",
        "text": "Get the closest point of the primitive to the input data.\nget_closest_point\npython:list\nof\npython:float\nPointData\npython:list\nof\npython:float"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_closest_point",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_closest_point.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.get_closest_point",
        "title": "get_closest_point > get_closest_point > get_closest_point",
        "section": "get_closest_point > get_closest_point",
        "text": "EdbPolygon.get_closest_point(point)\n\nGet the closest point of the primitive to the input data.\n\nParameters\n\npoint\n\npython:list of python:float or PointData\n\n\n\nReturns\n\npython:list of python:float\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.create",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create an extended net.\nLayout to create the extended net in.\nName of the extended net.\nExtended net created.\ncreate\nLayout\npython:str\nExtendedNet"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.create",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.create.html#pyedb.grpc.database.net.extended_net.ExtendedNet.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod ExtendedNet.create(layout, name)\n\nCreate an extended net.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to create the extended net in.\n\nname\n\npython:str\n\nName of the extended net.\n\nReturns\n\nExtendedNet\n\nExtended net created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_layer_below",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_layer_below.html#add_layer_below",
        "title": "add_layer_below",
        "section": "add_layer_below",
        "text": "Add a layer below a specified layer.\nName of the layer.\nName of the base layer.\nType of the layer. The default is \"signal\". Options are \"signal\" and \"dielectric\".\nAdditional keyword arguments. Possible keys are:\n- thickness : float, layer thickness.\n- material : str, layer material.\nLayer object created.\nadd_layer_below\npython:str\npython:str\npython:str\noptional\n\"signal\"\n\"signal\"\n\"dielectric\"\npython:dict\noptional\nthickness\nmaterial\npyedb.grpc.database.layers.stackup_layer.StackupLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_layer_below",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.add_layer_below.html#pyedb.grpc.database.stackup.LayerCollection.add_layer_below",
        "title": "add_layer_below > add_layer_below > add_layer_below",
        "section": "add_layer_below > add_layer_below",
        "text": "LayerCollection.add_layer_below(name: str, base_layer_name: str, layer_type: str = 'signal', **kwargs) -> Layer | None\n\nAdd a layer below a specified layer.\n\nParameters\n\nname\n\npython:str\n\nName of the layer.\n\nbase_layer_name\n\npython:str\n\nName of the base layer.\n\nlayer_type\n\npython:str, optional\n\nType of the layer. The default is \"signal\". Options are \"signal\" and \"dielectric\".\n\n**kwargs\n\npython:dict, optional\n\nAdditional keyword arguments. Possible keys are:\n- thickness : float, layer thickness.\n- material : str, layer material.\n\nReturns\n\npyedb.grpc.database.layers.stackup_layer.StackupLayer\n\nLayer object created.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> new_layer = edb.stackup.add_layer_below(\"NewLayer\", \"TopLayer\", layer_type=\"dielectric\", thickness=\"0.05mm\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.html#layout",
        "title": "Layout",
        "section": "Layout",
        "text": "Manage Layout class.\nLayout.add_menu_variable(name, values[, ...])\nAdd a menu variable.\nLayout.add_variable(name, value[, is_param])\nAdd a variable.\nLayout.compress_primitives()\nCompress primitives into         primitive instance collections.\nLayout.convert_primitives_to_vias(primitives)\nConvert a list of primitives into vias or pins.\nLayout.create_3d_comp(filename)\nCreate a 3D composite model from an MCAD file.\nLayout.create_hfss(filename, design)\nCreate an HFSS model from an MCAD file.\nLayout.create_mesh_region(xy_exp, pos_z_exp, ...)\nDesignate a mesh region in a design and create partitions for meshing.\nLayout.create_stride(filename)\nCreate a Stride model from an MCAD file.\nLayout.create_value(val)\nCreate a value instance.\nLayout.delete_variable(name)\nDelete a variable.\nLayout.expanded_extent(nets, extent, ...)\nGet the expanded extent of the geometry on the specified nets.\nLayout.find_padstack_instances([aedt_name, ...])\nFinds padstack instances matching the specified criteria.\nLayout.find_primitive([layer_name, name, ...])\nFind a primitive objects by layer name. Parameters ---------- layer_name : str, list layer_name : str, list, optional     Name of the layer. name : str, list, optional     Name of the primitive net_name : str, list, optional     Name of the primitive Returns ------- List[Primitive <pyedb.grpc.database.primitive.primitive.Primitive]. List of Primitive.\nLayout.get_all_variable_names()\nGet all variable names.\nLayout.get_variable_desc(name)\nGet the description of a variable.\nLayout.get_variable_value(name)\nGet the value for a given variable.\nLayout.group_vias(layer[, ...])\nCreate via groups from the primitives on the specified layers.\nLayout.is_parameter(name)\nDetermine if the variable is a parameter.\nLayout.reconstruct_arcs(layer, tolerance)\nReconstruct arcs of polygons on a layer.\nLayout.set_variable_desc(name, desc)\nSet a variable to have a new description.\nLayout.set_variable_value(name, new_value)\nSet a variable to a new value.\nLayout.snap_primitives(layer[, tol, ...])\nSnap primitives on the specified layer to touching geometry.\nLayout.snap_vias(layer[, via_snapping_tol, ...])\nSnap vias on the specified layers to touching geometry.\nLayout.synchronize_bend_manager()\nSynchronize the bend manager.\nLayout.unite_primitives(layer)\nUnite primitives on a layer.\nLayout\nLayout.add_menu_variable\nLayout.add_variable\nLayout.compress_primitives\nprimitives\nprimitive instance collections\nLayout.convert_primitives_to_vias\nLayout.create_3d_comp\nLayout.create_hfss\nLayout.create_mesh_region\nLayout.create_stride\nLayout.create_value\nLayout.delete_variable\nLayout.expanded_extent\nLayout.find_padstack_instances\nLayout.find_primitive\nPrimitive <pyedb.grpc.database.primitive.primitive.Primitive\nLayout.get_all_variable_names\nLayout.get_variable_desc\nLayout.get_variable_value\nLayout.group_vias\nLayout.is_parameter\nLayout.reconstruct_arcs\nLayout.set_variable_desc\nLayout.set_variable_value\nLayout.snap_primitives\nLayout.snap_vias\nLayout.synchronize_bend_manager\nLayout.unite_primitives"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.html#pyedb.grpc.database.layout.layout.Layout",
        "title": "Layout > Layout > Layout",
        "section": "Layout > Layout",
        "text": "class pyedb.grpc.database.layout.layout.Layout(pedb)\n\nManage Layout class.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nLayout.add_menu_variable(name, values[, ...])\n\nAdd a menu variable.\n\nLayout.add_variable(name, value[, is_param])\n\nAdd a variable.\n\nLayout.compress_primitives()\n\nCompress primitives into         primitive instance collections.\n\nLayout.convert_primitives_to_vias(primitives)\n\nConvert a list of primitives into vias or pins.\n\nLayout.create_3d_comp(filename)\n\nCreate a 3D composite model from an MCAD file.\n\nLayout.create_hfss(filename, design)\n\nCreate an HFSS model from an MCAD file.\n\nLayout.create_mesh_region(xy_exp, pos_z_exp, ...)\n\nDesignate a mesh region in a design and create partitions for meshing.\n\nLayout.create_stride(filename)\n\nCreate a Stride model from an MCAD file.\n\nLayout.create_value(val)\n\nCreate a value instance.\n\nLayout.delete_variable(name)\n\nDelete a variable.\n\nLayout.expanded_extent(nets, extent, ...)\n\nGet the expanded extent of the geometry on the specified nets.\n\nLayout.find_padstack_instances([aedt_name, ...])\n\nFinds padstack instances matching the specified criteria.\n\nLayout.find_primitive([layer_name, name, ...])\n\nFind a primitive objects by layer name. Parameters ---------- layer_name : str, list layer_name : str, list, optional     Name of the layer. name : str, list, optional     Name of the primitive net_name : str, list, optional     Name of the primitive Returns ------- List[Primitive <pyedb.grpc.database.primitive.primitive.Primitive]. List of Primitive.\n\nLayout.get_all_variable_names()\n\nGet all variable names.\n\nLayout.get_variable_desc(name)\n\nGet the description of a variable.\n\nLayout.get_variable_value(name)\n\nGet the value for a given variable.\n\nLayout.group_vias(layer[, ...])\n\nCreate via groups from the primitives on the specified layers.\n\nLayout.is_parameter(name)\n\nDetermine if the variable is a parameter.\n\nLayout.reconstruct_arcs(layer, tolerance)\n\nReconstruct arcs of polygons on a layer.\n\nLayout.set_variable_desc(name, desc)\n\nSet a variable to have a new description.\n\nLayout.set_variable_value(name, new_value)\n\nSet a variable to a new value.\n\nLayout.snap_primitives(layer[, tol, ...])\n\nSnap primitives on the specified layer to touching geometry.\n\nLayout.snap_vias(layer[, via_snapping_tol, ...])\n\nSnap vias on the specified layers to touching geometry.\n\nLayout.synchronize_bend_manager()\n\nSynchronize the bend manager.\n\nLayout.unite_primitives(layer)\n\nUnite primitives on a layer.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/raptor_x_general_settings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/raptor_x_general_settings.html#raptor-x-general-settings",
        "title": "Raptor X general settings",
        "section": "Raptor X general settings",
        "text": "This class is managing EDB raptor x general settings.\nRaptorXGeneralSettings\nRaptor X general settings class.\nRaptor X general settings\nRaptorXGeneralSettings"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_config",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_config",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_config.html#pyedb.workflows.drc.drc.DiffPair.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "DiffPair.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.set_parameters",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.set_parameters.html#set_parameters",
        "title": "set_parameters",
        "section": "set_parameters",
        "text": "Set parameters.\nCenter x value.\nCenter y value\nCircle radius.\nset_parameters\npython:float\npython:float\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.set_parameters",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.set_parameters.html#pyedb.grpc.database.primitive.circle.Circle.set_parameters",
        "title": "set_parameters > set_parameters > set_parameters",
        "section": "set_parameters > set_parameters",
        "text": "Circle.set_parameters(center_x, center_y, radius)\n\nSet parameters.\n\nParameters\n\ncenter_x\n\npython:float\n\nCenter x value.\n\ncenter_y\n\npython:float\n\nCenter y value\n\nradius\n\npython:float\n\nCircle radius.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_bounding_box",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_bounding_box.html#get_bounding_box",
        "title": "get_bounding_box",
        "section": "get_bounding_box",
        "text": "Get layout bounding box.\nlist[list[min_x, min_y], list[max_x, max_y]] in meters.\nget_bounding_box\npython:list"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_bounding_box",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_bounding_box.html#pyedb.grpc.edb.Edb.get_bounding_box",
        "title": "get_bounding_box > get_bounding_box > get_bounding_box",
        "section": "get_bounding_box > get_bounding_box",
        "text": "Edb.get_bounding_box() -> tuple[tuple[float, float], tuple[float, float]]\n\nGet layout bounding box.\n\nReturns\n\npython:list\n\nlist[list[min_x, min_y], list[max_x, max_y]] in meters.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_components_from_nets",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_components_from_nets.html#get_components_from_nets",
        "title": "get_components_from_nets",
        "section": "get_components_from_nets",
        "text": "Retrieve components from a net list.\nName of the net list. The default is None.\nList of components that belong to the signal nets.\nget_components_from_nets\npython:str\noptional\nNone\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_components_from_nets",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_components_from_nets.html#pyedb.dotnet.database.components.Components.get_components_from_nets",
        "title": "get_components_from_nets > get_components_from_nets > get_components_from_nets",
        "section": "get_components_from_nets > get_components_from_nets",
        "text": "Components.get_components_from_nets(netlist=None)\n\nRetrieve components from a net list.\n\nParameters\n\nnetlist\n\npython:str, optional\n\nName of the net list. The default is None.\n\nReturns\n\npython:list\n\nList of components that belong to the signal nets.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property for a given product ID and attribute ID.\nProduct ID.\nAttribute ID.\nProduct property for the given product ID and attribute ID.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.package_def.PackageDef.get_product_property.html#pyedb.grpc.database.definition.package_def.PackageDef.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "PackageDef.get_product_property(prod_id, attr_it)\n\nGet the product property for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nProduct ID.\n\nattr_it\n\npython:int\n\nAttribute ID.\n\nReturns\n\npython:str\n\nProduct property for the given product ID and attribute ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_exec_file",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_exec_file.html#create_exec_file",
        "title": "create_exec_file",
        "section": "create_exec_file",
        "text": "Create an executable file.\nWhether to add the DC option in the EXE file. The default is False.\nWhether to add the AC option in the EXE file. The default is\nFalse.\nWhether to add the SYZ option in the EXE file\nAdd the Touchstone file export option in the EXE file.\nThe default is False.\nFile path for the Touchstone file. The default is \"\".  When no path is\nspecified and export_touchstone=True, the path for the project is\nused.\ncreate_exec_file\noptional\nFalse\noptional\nFalse\noptional\noptional\nFalse\npython:str\noptional\n\"\"\nexport_touchstone=True"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_exec_file",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_exec_file.html#pyedb.dotnet.database.siwave.EdbSiwave.create_exec_file",
        "title": "create_exec_file > create_exec_file > create_exec_file",
        "section": "create_exec_file > create_exec_file",
        "text": "EdbSiwave.create_exec_file(add_dc=False, add_ac=False, add_syz=False, export_touchstone=False, touchstone_file_path='')\n\nCreate an executable file.\n\nParameters\n\nadd_dc\n\nbool, optional\n\nWhether to add the DC option in the EXE file. The default is False.\n\nadd_ac\n\nbool, optional\n\nWhether to add the AC option in the EXE file. The default is\nFalse.\n\nadd_syz\n\nbool, optional\n\nWhether to add the SYZ option in the EXE file\n\nexport_touchstone\n\nbool, optional\n\nAdd the Touchstone file export option in the EXE file.\nThe default is False.\n\ntouchstone_file_path\n\npython:str, optional\n\nFile path for the Touchstone file. The default is \"\".  When no path is\nspecified and export_touchstone=True, the path for the project is\nused.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.html#padstacks",
        "title": "Padstacks",
        "section": "Padstacks",
        "text": "Manages EDB methods for padstacks accessible from Edb.padstacks property.\nPadstacks.check_and_fix_via_plating([...])\nCheck and fix via plating ratios below a minimum value.\nPadstacks.clear_instances_cache()\nClear the cached padstack instances.\nPadstacks.create([padstackname, holediam, ...])\nCreate a padstack definition.\nPadstacks.create_circular_padstack([...])\nCreate a circular padstack.\nPadstacks.create_coax_port(padstackinstance)\nCreate HFSS 3Dlayout coaxial lumped port on a pastack Requires to have solder ball defined before calling this method.\nPadstacks.create_dielectric_filled_backdrills(...)\nCreate dielectric-filled back-drills for through-hole vias.\nPadstacks.dbscan(padstack[, max_distance, ...])\ndensity based spatial clustering for padstack instances\nPadstacks.delete_batch_instances(...)\n\nPadstacks.delete_padstack_instances(net_names)\nDelete padstack instances by net names.\nPadstacks.duplicate(target_padstack_name[, ...])\nDuplicate a padstack definition.\nPadstacks.find_instance_by_id(value)\nFind a padstack instance by database ID.\nPadstacks.get_instances([name, pid, ...])\nGet padstack instances by search criteria.\nPadstacks.get_pad_parameters(pin, layername)\nGet pad parameters for a pin on a specific layer.\nPadstacks.get_padstack_instances_id_intersecting_polygon(points)\nReturns the list of padstack instances ID intersecting a given bounding box and nets.\nPadstacks.get_padstack_instances_intersecting_bounding_box(...)\nReturns the list of padstack instances ID intersecting a given bounding box and nets. Parameters ---------- bounding_box : tuple or list. bounding box, [x1, y1, x2, y2] nets : str or list, optional     net name of list of nets name applying filtering on padstack instances selection. If None is provided     all instances are included in the index. Default value is None. padstack_instances_index : optional, Rtree object. Can be provided optionally to prevent computing padstack instances Rtree index again. Returns ------- List of padstack instances ID intersecting the bounding box.\nPadstacks.get_padstack_instances_rtree_index([nets])\nReturns padstack instances Rtree index.\nPadstacks.get_pin_from_component_and_net([...])\nRetrieve pins by component reference designator and net name.\nPadstacks.get_pinlist_from_component_and_net([...])\nRetrieve pins given a component's reference designator and net name.\nPadstacks.get_reference_pins(positive_pin[, ...])\nFind reference pins near a specified pin.\nPadstacks.get_via_instance_from_net([net_list])\nGet via instances by net names.\nPadstacks.int_to_geometry_type([val])\nConvert an integer to an EDB.PadGeometryType.\nPadstacks.int_to_pad_type([val])\nConvert an integer to an EDB.PadGeometryType.\nPadstacks.layers_between(layers[, ...])\nReturn the sub-list of layers that lies between start_layer (inclusive) and stop_layer (inclusive).\nPadstacks.merge_via(contour_boxes[, ...])\nEvaluate pad-stack instances included on the provided point list and replace all by single instance.\nPadstacks.merge_via_along_lines([net_name, ...])\nReplace padstack instances along lines into a single polygon.\nPadstacks.place(position, definition_name[, ...])\nPlace a padstack instance.\nPadstacks.reduce_via_by_density(padstacks[, ...])\nReduce the number of vias by density.\nPadstacks.reduce_via_in_bounding_box(...[, nets])\nreduce the number of vias intersecting bounding box and nets by x and y samples.\nPadstacks.remove_pads_from_padstack(...[, ...])\nRemove pads from a padstack definition on specified layers.\nPadstacks.set_all_antipad_value(value)\nSet anti-pad value for all padstack definitions.\nPadstacks.set_pad_property(padstack_name[, ...])\nSet pad and anti-pad properties for a padstack definition.\nPadstacks.set_solderball(padstackInst, ...)\nSet solderball for the given PadstackInstance.\nPadstacks\nPadstacks.check_and_fix_via_plating\nPadstacks.clear_instances_cache\nPadstacks.create\nPadstacks.create_circular_padstack\nPadstacks.create_coax_port\nPadstacks.create_dielectric_filled_backdrills\nPadstacks.dbscan\nPadstacks.delete_batch_instances\nPadstacks.delete_padstack_instances\nPadstacks.duplicate\nPadstacks.find_instance_by_id\nPadstacks.get_instances\nPadstacks.get_pad_parameters\nPadstacks.get_padstack_instances_id_intersecting_polygon\nPadstacks.get_padstack_instances_intersecting_bounding_box\nNone\nNone\nPadstacks.get_padstack_instances_rtree_index\nPadstacks.get_pin_from_component_and_net\nPadstacks.get_pinlist_from_component_and_net\nPadstacks.get_reference_pins\nPadstacks.get_via_instance_from_net\nPadstacks.int_to_geometry_type\nPadstacks.int_to_pad_type\nPadstacks.layers_between\nPadstacks.merge_via\nPadstacks.merge_via_along_lines\nPadstacks.place\nPadstacks.reduce_via_by_density\nPadstacks.reduce_via_in_bounding_box\nPadstacks.remove_pads_from_padstack\nPadstacks.set_all_antipad_value\nPadstacks.set_pad_property\nPadstacks.set_solderball"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.html#pyedb.grpc.database.padstacks.Padstacks",
        "title": "Padstacks > Padstacks > Padstacks",
        "section": "Padstacks > Padstacks",
        "text": "class pyedb.grpc.database.padstacks.Padstacks(p_edb: Any)\n\nManages EDB methods for padstacks accessible from Edb.padstacks property.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", edbversion=\"2024.2\")\n>>> edb_padstacks = edbapp.padstacks\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nPadstacks.check_and_fix_via_plating([...])\n\nCheck and fix via plating ratios below a minimum value.\n\nPadstacks.clear_instances_cache()\n\nClear the cached padstack instances.\n\nPadstacks.create([padstackname, holediam, ...])\n\nCreate a padstack definition.\n\nPadstacks.create_circular_padstack([...])\n\nCreate a circular padstack.\n\nPadstacks.create_coax_port(padstackinstance)\n\nCreate HFSS 3Dlayout coaxial lumped port on a pastack Requires to have solder ball defined before calling this method.\n\nPadstacks.create_dielectric_filled_backdrills(...)\n\nCreate dielectric-filled back-drills for through-hole vias.\n\nPadstacks.dbscan(padstack[, max_distance, ...])\n\ndensity based spatial clustering for padstack instances\n\nPadstacks.delete_batch_instances(...)\n\n\n\nPadstacks.delete_padstack_instances(net_names)\n\nDelete padstack instances by net names.\n\nPadstacks.duplicate(target_padstack_name[, ...])\n\nDuplicate a padstack definition.\n\nPadstacks.find_instance_by_id(value)\n\nFind a padstack instance by database ID.\n\nPadstacks.get_instances([name, pid, ...])\n\nGet padstack instances by search criteria.\n\nPadstacks.get_pad_parameters(pin, layername)\n\nGet pad parameters for a pin on a specific layer.\n\nPadstacks.get_padstack_instances_id_intersecting_polygon(points)\n\nReturns the list of padstack instances ID intersecting a given bounding box and nets.\n\nPadstacks.get_padstack_instances_intersecting_bounding_box(...)\n\nReturns the list of padstack instances ID intersecting a given bounding box and nets. Parameters ---------- bounding_box : tuple or list. bounding box, [x1, y1, x2, y2] nets : str or list, optional     net name of list of nets name applying filtering on padstack instances selection. If None is provided     all instances are included in the index. Default value is None. padstack_instances_index : optional, Rtree object. Can be provided optionally to prevent computing padstack instances Rtree index again. Returns ------- List of padstack instances ID intersecting the bounding box.\n\nPadstacks.get_padstack_instances_rtree_index([nets])\n\nReturns padstack instances Rtree index.\n\nPadstacks.get_pin_from_component_and_net([...])\n\nRetrieve pins by component reference designator and net name.\n\nPadstacks.get_pinlist_from_component_and_net([...])\n\nRetrieve pins given a component's reference designator and net name.\n\nPadstacks.get_reference_pins(positive_pin[, ...])\n\nFind reference pins near a specified pin.\n\nPadstacks.get_via_instance_from_net([net_list])\n\nGet via instances by net names.\n\nPadstacks.int_to_geometry_type([val])\n\nConvert an integer to an EDB.PadGeometryType.\n\nPadstacks.int_to_pad_type([val])\n\nConvert an integer to an EDB.PadGeometryType.\n\nPadstacks.layers_between(layers[, ...])\n\nReturn the sub-list of layers that lies between start_layer (inclusive) and stop_layer (inclusive).\n\nPadstacks.merge_via(contour_boxes[, ...])\n\nEvaluate pad-stack instances included on the provided point list and replace all by single instance.\n\nPadstacks.merge_via_along_lines([net_name, ...])\n\nReplace padstack instances along lines into a single polygon.\n\nPadstacks.place(position, definition_name[, ...])\n\nPlace a padstack instance.\n\nPadstacks.reduce_via_by_density(padstacks[, ...])\n\nReduce the number of vias by density.\n\nPadstacks.reduce_via_in_bounding_box(...[, nets])\n\nreduce the number of vias intersecting bounding box and nets by x and y samples.\n\nPadstacks.remove_pads_from_padstack(...[, ...])\n\nRemove pads from a padstack definition on specified layers.\n\nPadstacks.set_all_antipad_value(value)\n\nSet anti-pad value for all padstack definitions.\n\nPadstacks.set_pad_property(padstack_name[, ...])\n\nSet pad and anti-pad properties for a padstack definition.\n\nPadstacks.set_solderball(padstackInst, ...)\n\nSet solderball for the given PadstackInstance.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.replace_rlc_by_gap_boundaries",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.replace_rlc_by_gap_boundaries.html#replace_rlc_by_gap_boundaries",
        "title": "replace_rlc_by_gap_boundaries",
        "section": "replace_rlc_by_gap_boundaries",
        "text": "Replace RLC component by RLC gap boundaries. These boundary types are compatible with 3D modeler export.\nOnly 2 pins RLC components are supported in this command.\nReference designator of the RLC component.\nreplace_rlc_by_gap_boundaries\npython:str\nTrue\nwhen\nsucceed\nFalse\nif\nit"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.replace_rlc_by_gap_boundaries",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.replace_rlc_by_gap_boundaries.html#pyedb.grpc.database.components.Components.replace_rlc_by_gap_boundaries",
        "title": "replace_rlc_by_gap_boundaries > replace_rlc_by_gap_boundaries > replace_rlc_by_gap_boundaries",
        "section": "replace_rlc_by_gap_boundaries > replace_rlc_by_gap_boundaries",
        "text": "Components.replace_rlc_by_gap_boundaries(component: str | Component | None = None) -> bool\n\nReplace RLC component by RLC gap boundaries. These boundary types are compatible with 3D modeler export.\nOnly 2 pins RLC components are supported in this command.\n\nParameters\n\ncomponent\n\npython:str\n\nReference designator of the RLC component.\n\nReturns\n\nbool\n\n\n\nTrue when succeed, False if it failed.\n\n\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb(edb_file)\n>>>  for refdes, cmp in edb.components.capacitors.items():\n>>>     edb.components.replace_rlc_by_gap_boundaries(refdes)\n>>> edb.save_edb()\n>>> edb.close_edb()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_advanced_meshing_settings.HFSSAdvancedMeshingSettings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_advanced_meshing_settings.HFSSAdvancedMeshingSettings.html#hfssadvancedmeshingsettings",
        "title": "HFSSAdvancedMeshingSettings",
        "section": "HFSSAdvancedMeshingSettings",
        "text": "HFSSAdvancedMeshingSettings"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_advanced_meshing_settings.HFSSAdvancedMeshingSettings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_advanced_meshing_settings.HFSSAdvancedMeshingSettings.html#pyedb.grpc.database.simulation_setup.hfss_advanced_meshing_settings.HFSSAdvancedMeshingSettings",
        "title": "HFSSAdvancedMeshingSettings > HFSSAdvancedMeshingSettings > HFSSAdvancedMeshingSettings",
        "section": "HFSSAdvancedMeshingSettings > HFSSAdvancedMeshingSettings",
        "text": "class pyedb.grpc.database.simulation_setup.hfss_advanced_meshing_settings.HFSSAdvancedMeshingSettings(pedb, edb_object)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_connected_objects",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_connected_objects.html#get_connected_objects",
        "title": "get_connected_objects",
        "section": "get_connected_objects",
        "text": "Get connected objects.\nget_connected_objects\nList\nLayoutObjInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_connected_objects",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_connected_objects.html#pyedb.grpc.database.primitive.primitive.Primitive.get_connected_objects",
        "title": "get_connected_objects > get_connected_objects > get_connected_objects",
        "section": "get_connected_objects > get_connected_objects",
        "text": "Primitive.get_connected_objects()\n\nGet connected objects.\n\nReturns\n\nList[LayoutObjInstance]\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.intersect",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.intersect.html#intersect",
        "title": "intersect",
        "section": "intersect",
        "text": "Intersect active primitive with one or more primitives.\nintersect\ndotnet.database.edb_data.EDBPrimitives\nEDB\nPolygonData\nEDB\nPrimitive\npython:list\nList\nof\ndotnet.database.edb_data.EDBPrimitives"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.intersect",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.intersect.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.intersect",
        "title": "intersect > intersect > intersect",
        "section": "intersect > intersect",
        "text": "EdbPolygon.intersect(primitives)\n\nIntersect active primitive with one or more primitives.\n\nParameters\n\nprimitives\n\ndotnet.database.edb_data.EDBPrimitives or EDB PolygonData or EDB Primitive or python:list\n\n\n\nReturns\n\nList of dotnet.database.edb_data.EDBPrimitives\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.spice_model.SpiceModel.clone",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.spice_model.SpiceModel.clone.html#clone",
        "title": "clone",
        "section": "clone",
        "text": "Clone a model.\nclone\nModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.spice_model.SpiceModel.clone",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.spice_model.SpiceModel.clone.html#pyedb.grpc.database.hierarchy.spice_model.SpiceModel.clone",
        "title": "clone > clone > clone",
        "section": "clone > clone",
        "text": "SpiceModel.clone()\n\nClone a model.\n\nReturns\n\nModel cloned.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.place_a3dcomp_3d_placement",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.place_a3dcomp_3d_placement.html#place_a3dcomp_3d_placement",
        "title": "place_a3dcomp_3d_placement",
        "section": "place_a3dcomp_3d_placement",
        "text": "3D Component ports are not visible via EDB. They will be visible after the EDB has been opened in Ansys\nElectronics Desktop as a project.\nPath to the 3D Component file (*.a3dcomp) to place.\nClockwise rotation angle applied to the a3dcomp.\nThe x offset value.\nThe default value is 0.0.\nThe y offset value.\nThe default value is 0.0.\nThe z offset value. (i.e. elevation)\nThe default value is 0.0.\nWhether to place the 3D Component on the top or the bottom of this layout.\nIf False then the 3D Component will also be flipped over around its X axis.\nTrue if successful and False if not.\nplace_a3dcomp_3d_placement\npython:str\ndouble\noptional\ndouble\noptional\n0.0\ndouble\noptional\n0.0\ndouble\noptional\n0.0\noptional\nFalse\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.place_a3dcomp_3d_placement",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.place_a3dcomp_3d_placement.html#pyedb.dotnet.database.stackup.Stackup.place_a3dcomp_3d_placement",
        "title": "place_a3dcomp_3d_placement > place_a3dcomp_3d_placement > place_a3dcomp_3d_placement",
        "section": "place_a3dcomp_3d_placement > place_a3dcomp_3d_placement",
        "text": "Stackup.place_a3dcomp_3d_placement(a3dcomp_path, angle=0.0, offset_x=0.0, offset_y=0.0, offset_z=0.0, place_on_top=True)\n\nPlace a 3D Component into current layout.\n\n3D Component ports are not visible via EDB. They will be visible after the EDB has been opened in Ansys\nElectronics Desktop as a project.\n\nParameters\n\na3dcomp_path\n\npython:str\n\nPath to the 3D Component file (*.a3dcomp) to place.\n\nangle\n\ndouble, optional\n\nClockwise rotation angle applied to the a3dcomp.\n\noffset_x\n\ndouble, optional\n\nThe x offset value.\nThe default value is 0.0.\n\noffset_y\n\ndouble, optional\n\nThe y offset value.\nThe default value is 0.0.\n\noffset_z\n\ndouble, optional\n\nThe z offset value. (i.e. elevation)\nThe default value is 0.0.\n\nplace_on_top\n\nbool, optional\n\nWhether to place the 3D Component on the top or the bottom of this layout.\nIf False then the 3D Component will also be flipped over around its X axis.\n\nReturns\n\nbool\n\nTrue if successful and False if not.\n\nExamples\n\n>>> edb1 = Edb(edbpath=targetfile1, edbversion=\"2021.2\")\n>>> a3dcomp_path = \"connector.a3dcomp\"\n>>> edb1.stackup.place_a3dcomp_3d_placement(\n...     a3dcomp_path,\n...     angle=0.0,\n...     offset_x=\"1mm\",\n...     offset_y=\"2mm\",\n...     flipped_stackup=False,\n...     place_on_top=True,\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.html#stackup",
        "title": "Stackup",
        "section": "Stackup",
        "text": "Manages EDB methods for stackup operations.\nEDB object.\nEDB layer collection object. The default is None.\nStackup.add_document_layer(name[, layer_type])\nAdd a document layer.\nStackup.add_layer(layer_name[, base_layer, ...])\nInsert a layer into stackup.\nStackup.add_layer_above(name, base_layer_name)\nAdd a layer above a specified layer.\nStackup.add_layer_below(name, base_layer_name)\nAdd a layer below a specified layer.\nStackup.add_layer_bottom(name[, layer_type])\nAdd a layer at the bottom of the stackup.\nStackup.add_layer_top(name[, layer_type])\nAdd a layer on top of the stackup.\nStackup.add_layers(layers)\nAdd a list of layers to the layer collection.\nStackup.add_outline_layer([name])\nAdd an outline layer named \"Outline\" if it is not present.\nStackup.add_stackup_layer_at_elevation(...)\nAdd a stackup layer at a user-specified elevation.\nStackup.add_via_layer(via_layer_to_add)\nAdd a via layer to the layer collection.\nStackup.add_zone_to_layer(layer, zone, in_zone)\nSet the zone to the layer and update the layer in the collection.\nStackup.adjust_solder_dielectrics()\nAdjust the stack-up by adding or modifying dielectric layers that contain solder balls.\nStackup.clone()\nCreate a clone of the layer collection.\nStackup.create([mode])\nCreate a layer collection.\nStackup.create_symmetric_stackup(layer_count)\nCreate a symmetric stackup.\nStackup.export(fpath[, file_format, ...])\nExport stackup definition to a file.\nStackup.find_by_name(layer_name)\nFind a layer in the layer collection.\nStackup.flip_design()\nFlip the current design of a layout.\nStackup.get_layers([layer_filter])\nGet a list of layers in the layer collection using a layer filter.\nStackup.get_layout_thickness()\nReturn the layout thickness.\nStackup.get_product_property(prod_id, attr_it)\nGet the product property of the layer collection for a given product ID and attribute ID.\nStackup.get_product_property_ids(prod_id)\nGet a list of attribute IDs for a given product ID for the layer collection.\nStackup.get_top_bottom_stackup_layers(...)\nGet the top and bottom stackup layers of a specific type and their elevations.\nStackup.get_zone_name(zone)\nGet the name for a given zone.\nStackup.import_from_control_file(...[, ...])\nImport layers from a control file and optional XML schema file.\nStackup.insert_zone([copy_zone])\nInsert a zone.\nStackup.is_valid()\nDetermine if the layer collection is in a valid state.\nStackup.limits([only_metals])\nRetrieve stackup limits.\nStackup.load(file_path[, rename])\nImport stackup from a file.\nStackup.merge_dielectrics(layout, ...)\nMerge the dielectric layers in a range of layers into one large dielectric layer.\nStackup.place_a3dcomp_3d_placement(a3dcomp_path)\nPlace a 3D component into the current layout.\nStackup.place_in_layout(edb[, angle, ...])\nPlace current cell into another cell using layer placement method.\nStackup.place_in_layout_3d_placement(edb[, ...])\nPlace current cell into another cell using 3D placement method.\nStackup.place_instance(component_edb[, ...])\nPlace a component instance in the layout using 3D placement.\nStackup.plot([save_plot, size, ...])\nPlot the current stackup and optionally overlap padstack definitions.\nStackup.remove_layer(name)\nRemove a layer from stackup.\nStackup.remove_zone(zone)\nRemove a zone.\nStackup.residual_copper_area_per_layer()\nReport residual copper area per layer in percentage.\nStackup.set_product_property(prod_id, ...)\nSet the product property of the layer collection for a given product ID and attribute ID.\nStackup.set_zone_name(zone, name)\nSet the name for a given zone.\nStackup.simplify_dielectrics_for_phi(database)\nSplit dielectric layers at the boundaries of signal layers and merge them.\nStackup.update_layout()\nUpdate the layout with the current layer collection.\nStackup\npyedb.Edb\nansys.edb.core.layer.LayerCollection\noptional\nNone\nStackup.add_document_layer\nStackup.add_layer\nStackup.add_layer_above\nStackup.add_layer_below\nStackup.add_layer_bottom\nStackup.add_layer_top\nStackup.add_layers\nStackup.add_outline_layer\nStackup.add_stackup_layer_at_elevation\nStackup.add_via_layer\nStackup.add_zone_to_layer\nStackup.adjust_solder_dielectrics\nStackup.clone\nStackup.create\nStackup.create_symmetric_stackup\nStackup.export\nStackup.find_by_name\nStackup.flip_design\nStackup.get_layers\nStackup.get_layout_thickness\nStackup.get_product_property\nStackup.get_product_property_ids\nStackup.get_top_bottom_stackup_layers\nStackup.get_zone_name\nStackup.import_from_control_file\nStackup.insert_zone\nStackup.is_valid\nStackup.limits\nStackup.load\nStackup.merge_dielectrics\nStackup.place_a3dcomp_3d_placement\nStackup.place_in_layout\nStackup.place_in_layout_3d_placement\nStackup.place_instance\nStackup.plot\nStackup.remove_layer\nStackup.remove_zone\nStackup.residual_copper_area_per_layer\nStackup.set_product_property\nStackup.set_zone_name\nStackup.simplify_dielectrics_for_phi\nStackup.update_layout"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.html#pyedb.grpc.database.stackup.Stackup",
        "title": "Stackup > Stackup > Stackup",
        "section": "Stackup > Stackup",
        "text": "class pyedb.grpc.database.stackup.Stackup(pedb, edb_object=None)\n\nManages EDB methods for stackup operations.\n\nParameters\n\npedb\n\npyedb.Edb\n\nEDB object.\n\nedb_object\n\nansys.edb.core.layer.LayerCollection, optional\n\nEDB layer collection object. The default is None.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nStackup.add_document_layer(name[, layer_type])\n\nAdd a document layer.\n\nStackup.add_layer(layer_name[, base_layer, ...])\n\nInsert a layer into stackup.\n\nStackup.add_layer_above(name, base_layer_name)\n\nAdd a layer above a specified layer.\n\nStackup.add_layer_below(name, base_layer_name)\n\nAdd a layer below a specified layer.\n\nStackup.add_layer_bottom(name[, layer_type])\n\nAdd a layer at the bottom of the stackup.\n\nStackup.add_layer_top(name[, layer_type])\n\nAdd a layer on top of the stackup.\n\nStackup.add_layers(layers)\n\nAdd a list of layers to the layer collection.\n\nStackup.add_outline_layer([name])\n\nAdd an outline layer named \"Outline\" if it is not present.\n\nStackup.add_stackup_layer_at_elevation(...)\n\nAdd a stackup layer at a user-specified elevation.\n\nStackup.add_via_layer(via_layer_to_add)\n\nAdd a via layer to the layer collection.\n\nStackup.add_zone_to_layer(layer, zone, in_zone)\n\nSet the zone to the layer and update the layer in the collection.\n\nStackup.adjust_solder_dielectrics()\n\nAdjust the stack-up by adding or modifying dielectric layers that contain solder balls.\n\nStackup.clone()\n\nCreate a clone of the layer collection.\n\nStackup.create([mode])\n\nCreate a layer collection.\n\nStackup.create_symmetric_stackup(layer_count)\n\nCreate a symmetric stackup.\n\nStackup.export(fpath[, file_format, ...])\n\nExport stackup definition to a file.\n\nStackup.find_by_name(layer_name)\n\nFind a layer in the layer collection.\n\nStackup.flip_design()\n\nFlip the current design of a layout.\n\nStackup.get_layers([layer_filter])\n\nGet a list of layers in the layer collection using a layer filter.\n\nStackup.get_layout_thickness()\n\nReturn the layout thickness.\n\nStackup.get_product_property(prod_id, attr_it)\n\nGet the product property of the layer collection for a given product ID and attribute ID.\n\nStackup.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs for a given product ID for the layer collection.\n\nStackup.get_top_bottom_stackup_layers(...)\n\nGet the top and bottom stackup layers of a specific type and their elevations.\n\nStackup.get_zone_name(zone)\n\nGet the name for a given zone.\n\nStackup.import_from_control_file(...[, ...])\n\nImport layers from a control file and optional XML schema file.\n\nStackup.insert_zone([copy_zone])\n\nInsert a zone.\n\nStackup.is_valid()\n\nDetermine if the layer collection is in a valid state.\n\nStackup.limits([only_metals])\n\nRetrieve stackup limits.\n\nStackup.load(file_path[, rename])\n\nImport stackup from a file.\n\nStackup.merge_dielectrics(layout, ...)\n\nMerge the dielectric layers in a range of layers into one large dielectric layer.\n\nStackup.place_a3dcomp_3d_placement(a3dcomp_path)\n\nPlace a 3D component into the current layout.\n\nStackup.place_in_layout(edb[, angle, ...])\n\nPlace current cell into another cell using layer placement method.\n\nStackup.place_in_layout_3d_placement(edb[, ...])\n\nPlace current cell into another cell using 3D placement method.\n\nStackup.place_instance(component_edb[, ...])\n\nPlace a component instance in the layout using 3D placement.\n\nStackup.plot([save_plot, size, ...])\n\nPlot the current stackup and optionally overlap padstack definitions.\n\nStackup.remove_layer(name)\n\nRemove a layer from stackup.\n\nStackup.remove_zone(zone)\n\nRemove a zone.\n\nStackup.residual_copper_area_per_layer()\n\nReport residual copper area per layer in percentage.\n\nStackup.set_product_property(prod_id, ...)\n\nSet the product property of the layer collection for a given product ID and attribute ID.\n\nStackup.set_zone_name(zone, name)\n\nSet the name for a given zone.\n\nStackup.simplify_dielectrics_for_phi(database)\n\nSplit dielectric layers at the boundaries of signal layers and merge them.\n\nStackup.update_layout()\n\nUpdate the layout with the current layer collection.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.create_stride.html#create_stride",
        "title": "create_stride",
        "section": "create_stride",
        "text": "Create a Stride model from an MCAD file.\nStride model created.\ncreate_stride\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.create_stride.html#pyedb.grpc.database.primitive.primitive.Primitive.create_stride",
        "title": "create_stride > create_stride > create_stride",
        "section": "create_stride > create_stride",
        "text": "Primitive.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nReturns\n\nMcadModel\n\nStride model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.save_edb_as",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.save_edb_as.html#save_edb_as",
        "title": "save_edb_as",
        "section": "save_edb_as",
        "text": "Save EDB database to new location.\nUse save_as() instead.\nsave_edb_as\nsave_as()"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.save_edb_as",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.save_edb_as.html#pyedb.grpc.edb.Edb.save_edb_as",
        "title": "save_edb_as > save_edb_as > save_edb_as",
        "section": "save_edb_as > save_edb_as",
        "text": "Edb.save_edb_as(fname) -> bool\n\nSave EDB database to new location.\n\n..deprecated:: 0.51.0\n\nUse save_as() instead.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.delete_material",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.delete_material.html#delete_material",
        "title": "delete_material",
        "section": "delete_material",
        "text": "Remove a material from the database.\ndelete_material"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.delete_material",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.delete_material.html#pyedb.dotnet.database.materials.Materials.delete_material",
        "title": "delete_material > delete_material > delete_material",
        "section": "delete_material > delete_material",
        "text": "Materials.delete_material(material_name)\n\nRemove a material from the database.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.HatchGround",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.HatchGround.html#hatchground",
        "title": "HatchGround",
        "section": "HatchGround",
        "text": "Create a square demo board whose ground layer is made of an\northogonal hatched copper pattern.  Any requested copper fill\nratio between 10 % and 90 % can be realised.\nCentre-to-centre distance of the hatch bars [m].\nWidth of each copper bar [m].\nDesired copper area in percent (10 … 90).\nEdge length of the square board [m].\nName of the layer that receives the hatch pattern.\nHatchGround.create()\nGenerate the stack-up, board outline and hatch pattern.\nHatchGround\npython:float\ndefault\nmm\npython:float\ndefault\nmm\npython:float\ndefault\npython:float\ndefault\nmm\npython:str\ndefault\nHatchGround.create"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.HatchGround",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.HatchGround.html#pyedb.libraries.rf_libraries.base_functions.HatchGround",
        "title": "HatchGround > HatchGround > HatchGround",
        "section": "HatchGround > HatchGround",
        "text": "class pyedb.libraries.rf_libraries.base_functions.HatchGround(edb_cell: Edb | None = None, pitch: str | float = 0.01707, width: str | float = 0.005, fill_target: str | float = 50.0, board_size: str | float = 0.1, layer_gnd: str = 'GND')\n\nCreate a square demo board whose ground layer is made of an\northogonal hatched copper pattern.  Any requested copper fill\nratio between 10 % and 90 % can be realised.\n\nParameters\n\npitch\n\npython:float, default 17.07 mm\n\nCentre-to-centre distance of the hatch bars [m].\n\nwidth\n\npython:float, default 5 mm\n\nWidth of each copper bar [m].\n\nfill_target\n\npython:float, default 50 %\n\nDesired copper area in percent (10 … 90).\n\nboard_size\n\npython:float, default 100 mm\n\nEdge length of the square board [m].\n\nlayer_gnd\n\npython:str, default “GND”\n\nName of the layer that receives the hatch pattern.\n\nExamples\n\n>>> hatch = HatchGround(pitch=0.5e-3, width=0.2e-3, fill_target=70, board_size=5e-3)\n>>> edb = Edb(\"demo.aedb\")\n>>> hatch._edb = edb\n>>> hatch.create()\n>>> round(hatch.copper_fill_ratio, 1)\n70.0\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nHatchGround.create()\n\nGenerate the stack-up, board outline and hatch pattern.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.find_by_id.html#find_by_id",
        "title": "find_by_id",
        "section": "find_by_id",
        "text": "Find a Connectable object by database ID in a given layout.\nLayout to search for the Connectable object.\nDatabase ID.\nConnectable object with the given database ID.\nfind_by_id\nLayout\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.find_by_id.html#pyedb.grpc.database.primitive.circle.Circle.find_by_id",
        "title": "find_by_id > find_by_id > find_by_id",
        "section": "find_by_id > find_by_id",
        "text": "classmethod Circle.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the Connectable object.\n\nuid\n\npython:int\n\nDatabase ID.\n\nReturns\n\nConnectable\n\nConnectable object with the given database ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_pin_group",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_pin_group.html#create_pin_group",
        "title": "create_pin_group",
        "section": "create_pin_group",
        "text": "Create pin group on the component.\nReferences designator of the component.\nList of pin names.\nName of the pin group.\ncreate_pin_group\npython:str\npython:int\npython:str\npython:list\npython:str\noptional\nPinGroup"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_pin_group",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_pin_group.html#pyedb.dotnet.database.siwave.EdbSiwave.create_pin_group",
        "title": "create_pin_group > create_pin_group > create_pin_group",
        "section": "create_pin_group > create_pin_group",
        "text": "EdbSiwave.create_pin_group(reference_designator, pin_numbers, group_name=None)\n\nCreate pin group on the component.\n\nParameters\n\nreference_designator\n\npython:str\n\nReferences designator of the component.\n\npin_numbers\n\npython:int, python:str, python:list\n\nList of pin names.\n\ngroup_name\n\npython:str, optional\n\nName of the pin group.\n\nReturns\n\nPinGroup\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "validate"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.validate.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod DiffPairLengthMatch.validate(value: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.VoltageSource",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.VoltageSource.html#voltagesource",
        "title": "VoltageSource",
        "section": "VoltageSource",
        "text": "Manages a voltage source.\nVoltageSource"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.VoltageSource",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.VoltageSource.html#pyedb.grpc.database.utility.sources.VoltageSource",
        "title": "VoltageSource > VoltageSource > VoltageSource",
        "section": "VoltageSource > VoltageSource",
        "text": "class pyedb.grpc.database.utility.sources.VoltageSource\n\nManages a voltage source.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_pin_position",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_pin_position.html#get_pin_position",
        "title": "get_pin_position",
        "section": "get_pin_position",
        "text": "Retrieve the pin position in meters.\nName of the pin.\nPin position as a list of float values in the form [x, y].\nget_pin_position\npython:str\npython:list\n[x, y]"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_pin_position",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_pin_position.html#pyedb.dotnet.database.components.Components.get_pin_position",
        "title": "get_pin_position > get_pin_position > get_pin_position",
        "section": "get_pin_position > get_pin_position",
        "text": "Components.get_pin_position(pin)\n\nRetrieve the pin position in meters.\n\nParameters\n\npin\n\npython:str\n\nName of the pin.\n\nReturns\n\npython:list\n\nPin position as a list of float values in the form [x, y].\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", \"project name\", \"release version\")\n>>> edbapp.components.get_pin_position(pin)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.RadialStub",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.RadialStub.html#radialstub",
        "title": "RadialStub",
        "section": "RadialStub",
        "text": "Radial (fan) open stub for RF matching.\nRadius of the fan [m].\nOpening angle of the sector.\nWidth of the feeding micro-strip line [m].\nMetal layer.\nNet name.\nRadialStub.create()\nDraw the fan-shaped polygon and the feeding line.\nRadialStub\npython:float\ndefault\npython:float\ndefault\npython:float\ndefault\nmm\npython:str\ndefault\npython:str\ndefault\nRadialStub.create"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.RadialStub",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.RadialStub.html#pyedb.libraries.rf_libraries.base_functions.RadialStub",
        "title": "RadialStub > RadialStub > RadialStub",
        "section": "RadialStub > RadialStub",
        "text": "class pyedb.libraries.rf_libraries.base_functions.RadialStub(edb_cell, radius: str | float = 0.0005, angle_deg: str | float = 60, width: str | float = 0.0002, layer: str = 'TOP', net: str = 'RF')\n\nRadial (fan) open stub for RF matching.\n\nParameters\n\nradius\n\npython:float, default 500 µm\n\nRadius of the fan [m].\n\nangle_deg\n\npython:float, default 60°\n\nOpening angle of the sector.\n\nwidth\n\npython:float, default 0.2 mm\n\nWidth of the feeding micro-strip line [m].\n\nlayer\n\npython:str, default “TOP”\n\nMetal layer.\n\nnet\n\npython:str, default “RF”\n\nNet name.\n\nExamples\n\n>>> stub = RadialStub(radius=1e-3, angle_deg=90)\n>>> edb = Edb(\"radial.aedb\")\n>>> stub._pedb = edb\n>>> stub.create()\n>>> f\"{stub.electrical_length_deg(2e9):.1f}°\"\n'108.0°'\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nRadialStub.create()\n\nDraw the fan-shaped polygon and the feeding line.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.delete_batch_primitives",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.delete_batch_primitives.html#delete_batch_primitives",
        "title": "delete_batch_primitives",
        "section": "delete_batch_primitives",
        "text": "Delete a batch of primitives and update caches.\nList of primitive objects to delete.\ndelete_batch_primitives\npython:list"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.delete_batch_primitives",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.delete_batch_primitives.html#pyedb.grpc.database.modeler.Modeler.delete_batch_primitives",
        "title": "delete_batch_primitives > delete_batch_primitives > delete_batch_primitives",
        "section": "delete_batch_primitives > delete_batch_primitives",
        "text": "Modeler.delete_batch_primitives(prim_list: List[Primitive]) -> None\n\nDelete a batch of primitives and update caches.\n\nParameters\n\nprim_list\n\npython:list\n\nList of primitive objects to delete.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCAdvancedSettings.set_dc_slider",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCAdvancedSettings.set_dc_slider.html#set_dc_slider",
        "title": "set_dc_slider",
        "section": "set_dc_slider",
        "text": "set_dc_slider"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCAdvancedSettings.set_dc_slider",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.DCAdvancedSettings.set_dc_slider.html#pyedb.dotnet.database.sim_setup_data.io.siwave.DCAdvancedSettings.set_dc_slider",
        "title": "set_dc_slider > set_dc_slider > set_dc_slider",
        "section": "set_dc_slider > set_dc_slider",
        "text": "DCAdvancedSettings.set_dc_slider(value)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj: The object to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\nfrom_attributes: Whether to extract data from object attributes.\ncontext: Additional context to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nValidationError: If the object could not be validated.\nThe validated model instance.\nmodel_validate"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_validate.html#pyedb.workflows.drc.drc.CopperBalance.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod CopperBalance.model_validate(obj: Any, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\nValidate a pydantic model instance.\n\nArgs:\n\nobj: The object to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\nfrom_attributes: Whether to extract data from object attributes.\ncontext: Additional context to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nRaises:\n\nValidationError: If the object could not be validated.\n\nReturns:\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.LengthMeshOperation",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.LengthMeshOperation.html#lengthmeshoperation",
        "title": "LengthMeshOperation",
        "section": "LengthMeshOperation",
        "text": "Mesh operation Length class.\nThis class is accessible from Hfss Setup in EDB and add_length_mesh_operation method.\nLengthMeshOperation"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.LengthMeshOperation",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.LengthMeshOperation.html#pyedb.dotnet.database.sim_setup_data.data.mesh_operation.LengthMeshOperation",
        "title": "LengthMeshOperation > LengthMeshOperation > LengthMeshOperation",
        "section": "LengthMeshOperation > LengthMeshOperation",
        "text": "class pyedb.dotnet.database.sim_setup_data.data.mesh_operation.LengthMeshOperation(parent, edb_object)\n\nMesh operation Length class.\nThis class is accessible from Hfss Setup in EDB and add_length_mesh_operation method.\n\nExamples\n\n>>> mop = edbapp.setups[\"setup1a\"].add_length_mesh_operation({\"GND\": [\"TOP\", \"BOTTOM\"]})\n>>> mop.max_elements = 3000\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.quit_application",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.quit_application.html#quit_application",
        "title": "quit_application",
        "section": "quit_application",
        "text": "Quit the application.\nTrue when successful, False when failed.\nquit_application\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.quit_application",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.quit_application.html#pyedb.siwave.Siwave.quit_application",
        "title": "quit_application > quit_application > quit_application",
        "section": "quit_application > quit_application",
        "text": "Siwave.quit_application()\n\nQuit the application.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a pin group.\nLayout to create the pin group in.\nName of the pin group.\nList of padstack instances.\nPin group created.\ncreate\nLayout\npython:str\npython:list\nPadstackInstance\nPinGroup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create.html#pyedb.grpc.database.hierarchy.pingroup.PinGroup.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod PinGroup.create(layout, name, padstack_instances)\n\nCreate a pin group.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to create the pin group in.\n\nname\n\npython:str\n\nName of the pin group.\n\npadstack_instances\n\npython:list[PadstackInstance]\n\nList of padstack instances.\n\nReturns\n\nPinGroup\n\nPin group created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/HfssExtentInfo",
        "href": "dotnet_api/dotnet/edb_data/HfssExtentInfo.html#hfss-extent-info",
        "title": "HFSS extent info",
        "section": "HFSS extent info",
        "text": "These class is the containers of HFSS Extent.\nHfssExtentInfo\nManages EDB functionalities for HFSS extent information.\nHFSS extent info\nHfssExtentInfo"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.find_by_id.html#find_by_id",
        "title": "find_by_id",
        "section": "find_by_id",
        "text": "Find a Connectable object by database ID in a given layout.\nLayout to search for the Connectable object.\nDatabase ID.\nConnectable object with the given database ID.\nfind_by_id\nLayout\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.find_by_id.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.find_by_id",
        "title": "find_by_id > find_by_id > find_by_id",
        "section": "find_by_id > find_by_id",
        "text": "classmethod PadstackInstance.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the Connectable object.\n\nuid\n\npython:int\n\nDatabase ID.\n\nReturns\n\nConnectable\n\nConnectable object with the given database ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.couple_ports",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.couple_ports.html#couple_ports",
        "title": "couple_ports",
        "section": "couple_ports",
        "text": "Create a bundle wave port.\nPorts to be added.\ncouple_ports\nWaveport\nBundleWavePort"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.couple_ports",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.couple_ports.html#pyedb.grpc.database.ports.ports.GapPort.couple_ports",
        "title": "couple_ports > couple_ports > couple_ports",
        "section": "couple_ports > couple_ports",
        "text": "GapPort.couple_ports(port)\n\nCreate a bundle wave port.\n\nParameters\n\nport\n\nWaveport,\n\n\n\n:class:`GapPOrt <pyedb.grpc.database.ports.ports.GapPort>`, list, optional\n\nPorts to be added.\n\nReturns\n\nBundleWavePort\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.set_product_property.html#pyedb.grpc.database.ports.ports.BundleWavePort.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "BundleWavePort.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/hfss_settings_options",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/hfss_settings_options.html#hfss-settings-options",
        "title": "HFSS settings options",
        "section": "HFSS settings options",
        "text": "This class is managing EDB HFSS settings options.\nHFSSSettingsOptions\nPyEDB-core HFSS settings options class.\nHFSS settings options\nHFSSSettingsOptions"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.mirror_x",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.mirror_x.html#mirror_x",
        "title": "mirror_x",
        "section": "mirror_x",
        "text": "Mirror a polygon by x line.\nX line.\nmirror_x\npython:float\nPolygonData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.mirror_x",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.mirror_x.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.mirror_x",
        "title": "mirror_x > mirror_x > mirror_x",
        "section": "mirror_x > mirror_x",
        "text": "PolygonData.mirror_x(x: float) -> PolygonData\n\nMirror a polygon by x line.\n\nParameters\n\nx\n\npython:float\n\nX line.\n\nReturns\n\nPolygonData\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.variable_exists",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.variable_exists.html#variable_exists",
        "title": "variable_exists",
        "section": "variable_exists",
        "text": "Check if a variable exists or not.\nIt returns a booleand to check if the variable exists and the variable\nserver that should contain the variable.\nvariable_exists\npython:tuple\nof\nand\nVariableServer"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.variable_exists",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.variable_exists.html#pyedb.dotnet.edb.Edb.variable_exists",
        "title": "variable_exists > variable_exists > variable_exists",
        "section": "variable_exists > variable_exists",
        "text": "Edb.variable_exists(variable_name)\n\nCheck if a variable exists or not.\n\nReturns\n\npython:tuple of bool and VariableServer\n\nIt returns a booleand to check if the variable exists and the variable\nserver that should contain the variable.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileComponents.add_component",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileComponents.add_component.html#add_component",
        "title": "add_component",
        "section": "add_component",
        "text": "Create a new component.\nReference Designator name.\nPart name.\nComponent Type. Can be “IC”, “IO” or “Other”.\nDie Type. Can be “None”, “Flip chip” or “Wire bond”.\nSolderball Type. Can be “None”, “Cylinder” or “Spheroid”.\nadd_component\npython:str\npython:str\npython:str\npython:str\noptional\npython:str\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileComponents.add_component",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileComponents.add_component.html#pyedb.grpc.database.utility.xml_control_file.ControlFileComponents.add_component",
        "title": "add_component > add_component > add_component",
        "section": "add_component > add_component",
        "text": "ControlFileComponents.add_component(ref_des, partname, component_type, die_type='None', solderball_shape='None')\n\nCreate a new component.\n\nParameters\n\nref_des\n\npython:str\n\nReference Designator name.\n\npartname\n\npython:str\n\nPart name.\n\ncomponent_type\n\npython:str\n\nComponent Type. Can be “IC”, “IO” or “Other”.\n\ndie_type\n\npython:str, optional\n\nDie Type. Can be “None”, “Flip chip” or “Wire bond”.\n\nsolderball_shape\n\npython:str, optional\n\nSolderball Type. Can be “None”, “Cylinder” or “Spheroid”.\n\nReturns\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_advanced_settings.HFSSAdvancedSettings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_advanced_settings.HFSSAdvancedSettings.html#hfssadvancedsettings",
        "title": "HFSSAdvancedSettings",
        "section": "HFSSAdvancedSettings",
        "text": "HFSSAdvancedSettings"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_advanced_settings.HFSSAdvancedSettings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_advanced_settings.HFSSAdvancedSettings.html#pyedb.grpc.database.simulation_setup.hfss_advanced_settings.HFSSAdvancedSettings",
        "title": "HFSSAdvancedSettings > HFSSAdvancedSettings > HFSSAdvancedSettings",
        "section": "HFSSAdvancedSettings > HFSSAdvancedSettings",
        "text": "class pyedb.grpc.database.simulation_setup.hfss_advanced_settings.HFSSAdvancedSettings(pedb, edb_object)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_product_property_ids.html#pyedb.grpc.database.primitive.rectangle.Rectangle.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "Rectangle.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.html#gapport",
        "title": "GapPort",
        "section": "GapPort",
        "text": "Manages gap port properties.\nEDB object from the Edblib library.\nEdge terminal instance from EDB.\nThis example shows how to access the GapPort class.\n>>> from pyedb import Edb\n>>> edb = Edb(“myaedb.aedb”)\n>>> gap_port = edb.ports[“gap_port”]\nGapPort.couple_ports(port)\nCreate a bundle wave port.\nGapPort.delete()\nDelete this primitive.\nGapPort.get_connected_object_id_set()\nProduce a list of all geometries physically connected to a given layout object.\nGapPort.get_connected_objects()\nGet connected objects.\nGapPort.get_edge_terminal_reference_primitive()\nCheck and  return a primitive instance that serves Edge ports, wave ports and coupled edge ports that are directly connedted to primitives.\nGapPort.get_pad_edge_terminal_reference_pin([...])\nGet the closest pin padstack instances and serves any edge terminal connected to a pad.\nGapPort.get_padstack_terminal_reference_pin([...])\nGet a list of pad stacks instances and serves Coax wave ports, pingroup terminals, PadEdge terminals.\nGapPort.get_pin_group_terminal_reference_pin([...])\nReturn a list of pins and serves terminals connected to pingroups.\nGapPort.get_point_terminal_reference_primitive()\nFind and return the primitive reference for the point terminal or the padstack instance.\nGapPort\npyedb.edb.Edb\nEdblib\nAnsys.Ansoft.Edb.Cell.Terminal.EdgeTerminal\nGapPort\nGapPort.couple_ports\nGapPort.delete\nGapPort.get_connected_object_id_set\nGapPort.get_connected_objects\nGapPort.get_edge_terminal_reference_primitive\nGapPort.get_pad_edge_terminal_reference_pin\nGapPort.get_padstack_terminal_reference_pin\nGapPort.get_pin_group_terminal_reference_pin\nGapPort.get_point_terminal_reference_primitive"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.html#pyedb.dotnet.database.edb_data.ports.GapPort",
        "title": "GapPort > GapPort > GapPort",
        "section": "GapPort > GapPort",
        "text": "class pyedb.dotnet.database.edb_data.ports.GapPort(pedb, edb_object)\n\nManages gap port properties.\n\nParameters\n\npedb\n\npyedb.edb.Edb\n\nEDB object from the Edblib library.\n\nedb_object\n\nAnsys.Ansoft.Edb.Cell.Terminal.EdgeTerminal\n\nEdge terminal instance from EDB.\n\nExamples\n\nThis example shows how to access the GapPort class.\n>>> from pyedb import Edb\n>>> edb = Edb(“myaedb.aedb”)\n>>> gap_port = edb.ports[“gap_port”]\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nGapPort.couple_ports(port)\n\nCreate a bundle wave port.\n\nGapPort.delete()\n\nDelete this primitive.\n\nGapPort.get_connected_object_id_set()\n\nProduce a list of all geometries physically connected to a given layout object.\n\nGapPort.get_connected_objects()\n\nGet connected objects.\n\nGapPort.get_edge_terminal_reference_primitive()\n\nCheck and  return a primitive instance that serves Edge ports, wave ports and coupled edge ports that are directly connedted to primitives.\n\nGapPort.get_pad_edge_terminal_reference_pin([...])\n\nGet the closest pin padstack instances and serves any edge terminal connected to a pad.\n\nGapPort.get_padstack_terminal_reference_pin([...])\n\nGet a list of pad stacks instances and serves Coax wave ports, pingroup terminals, PadEdge terminals.\n\nGapPort.get_pin_group_terminal_reference_pin([...])\n\nReturn a list of pins and serves terminals connected to pingroups.\n\nGapPort.get_point_terminal_reference_primitive()\n\nFind and return the primitive reference for the point terminal or the padstack instance.\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.get_layout_bounding_box",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.get_layout_bounding_box.html#get_layout_bounding_box",
        "title": "get_layout_bounding_box",
        "section": "get_layout_bounding_box",
        "text": "Evaluate the layout bounding box.\nEdb layout.\nDigit Resolution. The default value is 6.\n[lower left corner X, lower left corner, upper right corner X, upper right corner Y].\nget_layout_bounding_box\npython:int\noptional\n6\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.get_layout_bounding_box",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.get_layout_bounding_box.html#pyedb.dotnet.database.hfss.EdbHfss.get_layout_bounding_box",
        "title": "get_layout_bounding_box > get_layout_bounding_box > get_layout_bounding_box",
        "section": "get_layout_bounding_box > get_layout_bounding_box",
        "text": "EdbHfss.get_layout_bounding_box(layout=None, digit_resolution=6)\n\nEvaluate the layout bounding box.\n\nParameters\n\nlayout\n\nEdb layout.\n\ndigit_resolution\n\npython:int, optional\n\nDigit Resolution. The default value is 6.\n\nReturns\n\npython:list\n\n[lower left corner X, lower left corner, upper right corner X, upper right corner Y].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/padstack_def",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/padstack_def.html#padstack-definition",
        "title": "Padstack Definition",
        "section": "Padstack Definition",
        "text": "These class is the containers of padstack definition.\nPadProperties\nManages EDB functionalities for pad properties.\nPadstackDef\nManages EDB functionalities for a padstack.\nPadstack Definition\nPadProperties\nPadstackDef"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.create_stride.html#create_stride",
        "title": "create_stride",
        "section": "create_stride",
        "text": "Create a Stride model from an MCAD file.\nStride model created.\ncreate_stride\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.create_stride.html#pyedb.grpc.database.ports.ports.WavePort.create_stride",
        "title": "create_stride > create_stride > create_stride",
        "section": "create_stride > create_stride",
        "text": "WavePort.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nReturns\n\nMcadModel\n\nStride model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_port",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_port.html#create_port",
        "title": "create_port",
        "section": "create_port",
        "text": "Create a port.\nclass:pyedb.dotnet.database.edb_data.terminals.PadstackInstanceTerminal,\nclass:pyedb.dotnet.database.edb_data.terminals.PointTerminal,\nclass:pyedb.dotnet.database.edb_data.terminals.PinGroupTerminal,\nPositive terminal of the port.\nclass:pyedb.dotnet.database.edb_data.terminals.PadstackInstanceTerminal,\nclass:pyedb.dotnet.database.edb_data.terminals.PointTerminal,\nclass:pyedb.dotnet.database.edb_data.terminals.PinGroupTerminal,\noptional\nNegative terminal of the port.\nWhether it is a circuit port. The default is False.\nName of the created port. The default is None, a random name is generated.\npyedb.dotnet.database.edb_data.ports.WavePort,].\ncreate_port\noptional\nFalse\npyedb.dotnet.database.edb_data.ports.WavePort"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_port",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_port.html#pyedb.dotnet.edb.Edb.create_port",
        "title": "create_port > create_port > create_port",
        "section": "create_port > create_port",
        "text": "Edb.create_port(terminal, ref_terminal=None, is_circuit_port=False, name=None)\n\nCreate a port.\n\nParameters\n\nterminal\n\nclass:pyedb.dotnet.database.edb_data.terminals.EdgeTerminal,\n\nclass:pyedb.dotnet.database.edb_data.terminals.PadstackInstanceTerminal,\nclass:pyedb.dotnet.database.edb_data.terminals.PointTerminal,\nclass:pyedb.dotnet.database.edb_data.terminals.PinGroupTerminal,\nPositive terminal of the port.\n\nref_terminal\n\nclass:pyedb.dotnet.database.edb_data.terminals.EdgeTerminal,\n\nclass:pyedb.dotnet.database.edb_data.terminals.PadstackInstanceTerminal,\nclass:pyedb.dotnet.database.edb_data.terminals.PointTerminal,\nclass:pyedb.dotnet.database.edb_data.terminals.PinGroupTerminal,\noptional\nNegative terminal of the port.\n\nis_circuit_port\n\nbool, optional\n\nWhether it is a circuit port. The default is False.\n\nname: str, optional\n\nName of the created port. The default is None, a random name is generated.\n\nReturns\n\n\n\n——-\n\n\n\nlist: [:class:`pyedb.dotnet.database.edb_data.ports.GapPort`,\n\npyedb.dotnet.database.edb_data.ports.WavePort,].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.check_and_fix_via_plating",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.check_and_fix_via_plating.html#check_and_fix_via_plating",
        "title": "check_and_fix_via_plating",
        "section": "check_and_fix_via_plating",
        "text": "Check and fix via plating ratios below a minimum value.\nMinimum plating ratio threshold. Default is 0.0.\nDefault plating ratio to apply. Default is 0.2.\nTrue when successful, False when failed.\ncheck_and_fix_via_plating\npython:float\noptional\n0.0\npython:float\noptional\n0.2\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.check_and_fix_via_plating",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.check_and_fix_via_plating.html#pyedb.grpc.database.padstacks.Padstacks.check_and_fix_via_plating",
        "title": "check_and_fix_via_plating > check_and_fix_via_plating > check_and_fix_via_plating",
        "section": "check_and_fix_via_plating > check_and_fix_via_plating",
        "text": "Padstacks.check_and_fix_via_plating(minimum_value_to_replace: float = 0.0, default_plating_ratio: float = 0.2) -> bool\n\nCheck and fix via plating ratios below a minimum value.\n\nParameters\n\nminimum_value_to_replace\n\npython:float, optional\n\nMinimum plating ratio threshold. Default is 0.0.\n\ndefault_plating_ratio\n\npython:float, optional\n\nDefault plating ratio to apply. Default is 0.2.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> success = edb_padstacks.check_and_fix_via_plating(minimum_value_to_replace=0.1)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.get_layers",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.get_layers.html#get_layers",
        "title": "get_layers",
        "section": "get_layers",
        "text": "Get a list of layers in the layer collection using a layer filter.\nLayer filter.\nList of layers based on the filter used.\nget_layers\nLayerTypeSet\nLayerType\npython:list\nLayerType\nALL_LAYER_SET\npython:list\nLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.get_layers",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.get_layers.html#pyedb.grpc.database.stackup.LayerCollection.get_layers",
        "title": "get_layers > get_layers > get_layers",
        "section": "get_layers > get_layers",
        "text": "LayerCollection.get_layers(layer_filter=LayerTypeSet.ALL_LAYER_SET)\n\nGet a list of layers in the layer collection using a layer filter.\n\nParameters\n\nlayer_filter\n\nLayerTypeSet or LayerType or python:list[LayerType], default: ALL_LAYER_SET\n\nLayer filter.\n\nReturns\n\npython:list[Layer]\n\nList of layers based on the filter used.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.change_design_variable_value",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.change_design_variable_value.html#change_design_variable_value",
        "title": "change_design_variable_value",
        "section": "change_design_variable_value",
        "text": "Change a variable value.\nUser can use also the getitem to read the variable value. See example below.\nName of the variable.\nValue of the variable with units.\nTuple containing the SetVariableValue result and variable server.\nchange_design_variable_value\npython:str\npython:str\npython:float\npython:tuple\nSetVariableValue"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.change_design_variable_value",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.change_design_variable_value.html#pyedb.dotnet.edb.Edb.change_design_variable_value",
        "title": "change_design_variable_value > change_design_variable_value > change_design_variable_value",
        "section": "change_design_variable_value > change_design_variable_value",
        "text": "Edb.change_design_variable_value(variable_name, variable_value)\n\nChange a variable value.\n\n..note::\n\nUser can use also the getitem to read the variable value. See example below.\n\nParameters\n\nvariable_name\n\npython:str\n\nName of the variable.\n\nvariable_value\n\npython:str, python:float\n\nValue of the variable with units.\n\nReturns\n\npython:tuple\n\nTuple containing the SetVariableValue result and variable server.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb_app = Edb()\n>>> boolean, ant_length = edb_app.add_design_variable(\"ant_length\", \"1cm\")\n>>> boolean, ant_length = edb_app.change_design_variable_value(\"ant_length\", \"1m\")\n>>> print(edb_app[\"ant_length\"])  # using getitem\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.save",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.save.html#save",
        "title": "save",
        "section": "save",
        "text": "Save the project.\nFull path to the project. The default is None.\nsave\npython:str\noptional\nNone"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.save",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.save.html#pyedb.siwave.Siwave.save",
        "title": "save > save > save",
        "section": "save > save",
        "text": "Siwave.save(file_path: str | Path | None)\n\nSave the project.\n\nParameters\n\nfile_path\n\npython:str, optional\n\nFull path to the project. The default is None.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileStackup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileStackup.html#controlfilestackup",
        "title": "ControlFileStackup",
        "section": "ControlFileStackup",
        "text": "Class that manages the Stackup info.\nControlFileStackup.add_dielectric(layer_name)\nAdd a new dielectric.\nControlFileStackup.add_layer(layer_name[, ...])\nAdd a new layer.\nControlFileStackup.add_material(material_name)\nAdd a new material with specific properties.\nControlFileStackup.add_via(layer_name[, ...])\nAdd a new via layer.\nControlFileStackup\nControlFileStackup.add_dielectric\nControlFileStackup.add_layer\nControlFileStackup.add_material\nControlFileStackup.add_via"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileStackup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileStackup.html#pyedb.dotnet.database.edb_data.control_file.ControlFileStackup",
        "title": "ControlFileStackup > ControlFileStackup > ControlFileStackup",
        "section": "ControlFileStackup > ControlFileStackup",
        "text": "class pyedb.dotnet.database.edb_data.control_file.ControlFileStackup(units='mm')\n\nClass that manages the Stackup info.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nControlFileStackup.add_dielectric(layer_name)\n\nAdd a new dielectric.\n\nControlFileStackup.add_layer(layer_name[, ...])\n\nAdd a new layer.\n\nControlFileStackup.add_material(material_name)\n\nAdd a new material with specific properties.\n\nControlFileStackup.add_via(layer_name[, ...])\n\nAdd a new via layer.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_product_property_ids",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute ids corresponding to a product property id.\nProduct ID.\nThe attribute ids associated with this product property.\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_product_property_ids",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_product_property_ids.html#pyedb.grpc.edb.Edb.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "Edb.get_product_property_ids(prod_id)\n\nGet a list of attribute ids corresponding to a product property id.\n\nParameters\n\nprod_id\n\nProductIdType\n\nProduct ID.\n\nReturns\n\npython:list[python:int]\n\nThe attribute ids associated with this product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.add_menu_variable",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.add_menu_variable.html#add_menu_variable",
        "title": "add_menu_variable",
        "section": "add_menu_variable",
        "text": "Add a menu variable.\nVariable name.\nEach element can be any type that can be converted to a Value\ninstance.\nWhether the new variable is a parameter. The default is False, which means it is a local variable.\nIndex of the value that is initially selected.\nadd_menu_variable\npython:str\npython:list\npython:str\npython:int\npython:float\ncomplex\nValue\nValue\npython:False\nFalse\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.add_menu_variable",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.add_menu_variable.html#pyedb.grpc.database.layout.layout.Layout.add_menu_variable",
        "title": "add_menu_variable > add_menu_variable > add_menu_variable",
        "section": "add_menu_variable > add_menu_variable",
        "text": "Layout.add_menu_variable(name, values, is_param=False, index=0)\n\nAdd a menu variable.\n\nParameters\n\nname\n\npython:str\n\nVariable name.\n\nvalues\n\npython:list[python:str, python:int, python:float, complex, Value]\n\nEach element can be any type that can be converted to a Value\ninstance.\n\nis_param\n\nbool, default: python:False\n\nWhether the new variable is a parameter. The default is False, which means it is a local variable.\n\nindex\n\npython:int, default: 0\n\nIndex of the value that is initially selected.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.set_simulation_settings",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.set_simulation_settings.html#set_simulation_settings",
        "title": "set_simulation_settings",
        "section": "set_simulation_settings",
        "text": "set_simulation_settings"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.set_simulation_settings",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.set_simulation_settings.html#pyedb.dotnet.database.utilities.siwave_simulation_setup.SiwaveDCSimulationSetup.set_simulation_settings",
        "title": "set_simulation_settings > set_simulation_settings > set_simulation_settings",
        "section": "set_simulation_settings > set_simulation_settings",
        "text": "SiwaveDCSimulationSetup.set_simulation_settings(sim_settings: dict)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.parse_file",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "parse_file"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.parse_file",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.parse_file.html#pyedb.workflows.drc.drc.BackDrillStubLength.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod BackDrillStubLength.parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_product_property",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product-specific property value.\nProduct ID.\nAttribute ID.\nProperty value returned.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_product_property",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_product_property.html#pyedb.grpc.edb.Edb.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "Edb.get_product_property(prod_id, attr_it)\n\nGet the product-specific property value.\n\nParameters\n\nprod_id\n\nProductIdType\n\nProduct ID.\n\nattr_it\n\npython:int\n\nAttribute ID.\n\nReturns\n\npython:str\n\nProperty value returned.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.add_void",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.add_void.html#add_void",
        "title": "add_void",
        "section": "add_void",
        "text": "Add a void into a shape.\nShape of the main object.\nShape of the voids.\nadd_void\nPolygon\npython:list\nPath"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.add_void",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.add_void.html#pyedb.dotnet.database.modeler.Modeler.add_void",
        "title": "add_void > add_void > add_void",
        "section": "add_void > add_void",
        "text": "Modeler.add_void(shape, void_shape)\n\nAdd a void into a shape.\n\nParameters\n\nshape\n\nPolygon\n\nShape of the main object.\n\nvoid_shape\n\npython:list, Path\n\nShape of the voids.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.create",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Edb Dotnet Api Database Edb.Net.Create.\ncreate"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.create",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.create.html#pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "EDBNetsData.create(layout, name)\n\nEdb Dotnet Api Database Edb.Net.Create.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_product_property.html#pyedb.grpc.database.primitive.primitive.Primitive.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "Primitive.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.json.html#json",
        "title": "json",
        "section": "json",
        "text": "json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.json.html#pyedb.workflows.drc.drc.DiffPair.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "DiffPair.json(*, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -> str\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_source_on_pin_group",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_source_on_pin_group.html#create_voltage_source_on_pin_group",
        "title": "create_voltage_source_on_pin_group",
        "section": "create_voltage_source_on_pin_group",
        "text": "Create voltage source between two pin groups.\nName of the positive pin group.\nName of the negative pin group.\nMagnitude of the source.\nPhase of the source\ncreate_voltage_source_on_pin_group\npython:str\npython:str\npython:int\npython:float\noptional\npython:int\npython:float\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_source_on_pin_group",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_source_on_pin_group.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_source_on_pin_group",
        "title": "create_voltage_source_on_pin_group > create_voltage_source_on_pin_group > create_voltage_source_on_pin_group",
        "section": "create_voltage_source_on_pin_group > create_voltage_source_on_pin_group",
        "text": "SourceExcitation.create_voltage_source_on_pin_group(pos_pin_group_name: str, neg_pin_group_name: str, magnitude: int | float = 1, phase: int | float = 0, name: str | None = None, impedance: int | float = 0.001) -> bool\n\nCreate voltage source between two pin groups.\n\nParameters\n\npos_pin_group_name\n\npython:str\n\nName of the positive pin group.\n\nneg_pin_group_name\n\npython:str\n\nName of the negative pin group.\n\nmagnitude\n\npython:int, python:float, optional\n\nMagnitude of the source.\n\nphase\n\npython:int, python:float, optional\n\nPhase of the source\n\nReturns\n\nbool\n\n\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> edb.source_excitation.create_voltage_probe_on_pin_group(\"Probe1\", \"PG1\", \"PG2\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "user_guide/common_tasks",
        "href": "user_guide/common_tasks.html#common-tasks",
        "title": "Common Tasks",
        "section": "Common Tasks",
        "text": "This section provides quick recipes for everyday operations with PyEDB.\nCommon Tasks"
    },
    {
        "objectID": "user_guide/common_tasks",
        "href": "user_guide/common_tasks.html#accessing-and-modifying-nets",
        "title": "Common Tasks > Accessing and Modifying Nets",
        "section": "Accessing and Modifying Nets",
        "text": "Accessing and Modifying Nets"
    },
    {
        "objectID": "user_guide/common_tasks",
        "href": "user_guide/common_tasks.html#working-with-components",
        "title": "Common Tasks > Working with Components",
        "section": "Working with Components",
        "text": "Working with Components"
    },
    {
        "objectID": "user_guide/common_tasks",
        "href": "user_guide/common_tasks.html#creating-a-simple-simulation-setup",
        "title": "Common Tasks > Creating a Simple Simulation Setup",
        "section": "Creating a Simple Simulation Setup",
        "text": "Creating a Simple Simulation Setup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.is_in_zone",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.is_in_zone.html#is_in_zone",
        "title": "is_in_zone",
        "section": "is_in_zone",
        "text": "Determine if the layer exists in the given zone.\nTrue when the layer exists in the given zone, False otherwise.\nis_in_zone\npython:int\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.is_in_zone",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.is_in_zone.html#pyedb.grpc.database.layers.layer.Layer.is_in_zone",
        "title": "is_in_zone > is_in_zone > is_in_zone",
        "section": "is_in_zone > is_in_zone",
        "text": "Layer.is_in_zone(zone)\n\nDetermine if the layer exists in the given zone.\n\nParameters\n\nzone\n\npython:int\n\n\n\nReturns\n\nbool\n\nTrue when the layer exists in the given zone, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.create",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a net.\nLayout to create the net class in.\nName of the net.\nNet class created.\ncreate\nLayout\npython:str\nNetClass"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.create",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.create.html#pyedb.grpc.database.net.net_class.NetClass.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod NetClass.create(layout, name)\n\nCreate a net.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to create the net class in.\n\nname\n\npython:str\n\nName of the net.\n\nReturns\n\nNetClass\n\nNet class created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.layout_obj_type.html#pyedb.grpc.database.net.net_class.NetClass.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "NetClass.layout_obj_type = 9\n\n"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.schema_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "schema_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.schema_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.schema_json.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod DiffPairLengthMatch.schema_json(*, by_alias: bool = True, ref_template: str = '#/$defs/{model}', **dumps_kwargs: Any) -> str\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/models.md#model-copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nbefore creating the new model. You should trust this data.\ndeep: Set to True to make a deep copy of the model.\nNew model instance.\nmodel_copy"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_copy.html#pyedb.workflows.drc.drc.CopperBalance.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "CopperBalance.model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -> Self\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/models.md#model-copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nArgs:\n\nupdate: Values to change/add in the new model. Note: the data is not validated\n\nbefore creating the new model. You should trust this data.\n\ndeep: Set to True to make a deep copy of the model.\n\nReturns:\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.has_arcs",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.has_arcs.html#has_arcs",
        "title": "has_arcs",
        "section": "has_arcs",
        "text": "Determine whether the polygon contains any arcs.\nTrue when the polygon contains arcs, False otherwise.\nhas_arcs\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.has_arcs",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.has_arcs.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.has_arcs",
        "title": "has_arcs > has_arcs > has_arcs",
        "section": "has_arcs > has_arcs",
        "text": "PolygonData.has_arcs() -> bool\n\nDetermine whether the polygon contains any arcs.\n\nReturns\n\nbool\n\nTrue when the polygon contains arcs, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.delete_frequency_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.delete_frequency_sweep.html#delete_frequency_sweep",
        "title": "delete_frequency_sweep",
        "section": "delete_frequency_sweep",
        "text": "Delete a frequency sweep.\ndelete_frequency_sweep"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.delete_frequency_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.delete_frequency_sweep.html#pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.delete_frequency_sweep",
        "title": "delete_frequency_sweep > delete_frequency_sweep > delete_frequency_sweep",
        "section": "delete_frequency_sweep > delete_frequency_sweep",
        "text": "HfssSimulationSetup.delete_frequency_sweep(sweep_data)\n\nDelete a frequency sweep.\n\nParameters\n\nsweep_data\n\nEdbFrequencySweep.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_product_property.html#pyedb.grpc.database.primitive.rectangle.Rectangle.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "Rectangle.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/index",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/index.html#layout-classes",
        "title": "Layout classes",
        "section": "Layout classes",
        "text": "This section describes EDB layout classes.\nLayout classes"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.remove_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.remove_hfss_prop.html#remove_hfss_prop",
        "title": "remove_hfss_prop",
        "section": "remove_hfss_prop",
        "text": "Remove HFSS properties.\nremove_hfss_prop"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.remove_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.remove_hfss_prop.html#pyedb.grpc.database.primitive.circle.Circle.remove_hfss_prop",
        "title": "remove_hfss_prop > remove_hfss_prop > remove_hfss_prop",
        "section": "remove_hfss_prop > remove_hfss_prop",
        "text": "Circle.remove_hfss_prop()\n\nRemove HFSS properties.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.remove_net",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.remove_net.html#remove_net",
        "title": "remove_net",
        "section": "remove_net",
        "text": "Remove net.\nremove_net"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.remove_net",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.remove_net.html#pyedb.grpc.database.net.net_class.NetClass.remove_net",
        "title": "remove_net > remove_net > remove_net",
        "section": "remove_net > remove_net",
        "text": "NetClass.remove_net(net)\n\nRemove net.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.create_stride.html#create_stride",
        "title": "create_stride",
        "section": "create_stride",
        "text": "Create a Stride model from an MCAD file.\nStride model created.\ncreate_stride\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.create_stride.html#pyedb.grpc.database.primitive.circle.Circle.create_stride",
        "title": "create_stride > create_stride > create_stride",
        "section": "create_stride > create_stride",
        "text": "Circle.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nReturns\n\nMcadModel\n\nStride model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.dielectric_model_frequency",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.dielectric_model_frequency.html#dielectric_model_frequency",
        "title": "dielectric_model_frequency",
        "section": "dielectric_model_frequency",
        "text": "dielectric_model_frequency"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.dielectric_model_frequency",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.dielectric_model_frequency.html#pyedb.grpc.database.definition.materials.MaterialProperties.dielectric_model_frequency",
        "title": "dielectric_model_frequency > dielectric_model_frequency > dielectric_model_frequency",
        "section": "dielectric_model_frequency > dielectric_model_frequency",
        "text": "MaterialProperties.dielectric_model_frequency: Annotated[float, Gt(gt=0)] | None\n\n"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.html#diffpair",
        "title": "DiffPair",
        "section": "DiffPair",
        "text": "Differential-pair definition.\nDiffPair.construct([_fields_set])\n\nDiffPair.copy(*[, include, exclude, update, ...])\nReturns a copy of the model.\nDiffPair.dict(*[, include, exclude, ...])\n\nDiffPair.from_orm(obj)\n\nDiffPair.json(*[, include, exclude, ...])\n\nDiffPair.model_construct([_fields_set])\nCreates a new instance of the Model class with validated data.\nDiffPair.model_copy(*[, update, deep])\n!!! abstract \"Usage Documentation\"\nDiffPair.model_dump(*[, mode, include, ...])\n!!! abstract \"Usage Documentation\"\nDiffPair.model_dump_json(*[, indent, ...])\n!!! abstract \"Usage Documentation\"\nDiffPair.model_json_schema([by_alias, ...])\nGenerates a JSON schema for a model class.\nDiffPair.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nDiffPair.model_post_init(context, /)\nOverride this method to perform additional initialization after __init__ and model_construct.\nDiffPair.model_rebuild(*[, force, ...])\nTry to rebuild the pydantic-core schema for the model.\nDiffPair.model_validate(obj, *[, strict, ...])\nValidate a pydantic model instance.\nDiffPair.model_validate_json(json_data, *[, ...])\n!!! abstract \"Usage Documentation\"\nDiffPair.model_validate_strings(obj, *[, ...])\nValidate the given object with string data against the Pydantic model.\nDiffPair.parse_file(path, *[, content_type, ...])\n\nDiffPair.parse_obj(obj)\n\nDiffPair.parse_raw(b, *[, content_type, ...])\n\nDiffPair.schema([by_alias, ref_template])\n\nDiffPair.schema_json(*[, by_alias, ref_template])\n\nDiffPair.update_forward_refs(**localns)\n\nDiffPair.validate(value)\n\nDiffPair.model_computed_fields\n\nDiffPair.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nDiffPair.model_fields\n\nDiffPair.positive\n\nDiffPair.negative\n\nDiffPair\nDiffPair.construct\nDiffPair.copy\nDiffPair.dict\nDiffPair.from_orm\nDiffPair.json\nDiffPair.model_construct\nDiffPair.model_copy\nDiffPair.model_dump\nDiffPair.model_dump_json\nDiffPair.model_json_schema\nDiffPair.model_parametrized_name\nDiffPair.model_post_init\nDiffPair.model_rebuild\nDiffPair.model_validate\nDiffPair.model_validate_json\nDiffPair.model_validate_strings\nDiffPair.parse_file\nDiffPair.parse_obj\nDiffPair.parse_raw\nDiffPair.schema\nDiffPair.schema_json\nDiffPair.update_forward_refs\nDiffPair.validate\nDiffPair.model_computed_fields\nDiffPair.model_config\nDiffPair.model_fields\nDiffPair.positive\nDiffPair.negative"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.html#pyedb.workflows.drc.drc.DiffPair",
        "title": "DiffPair > DiffPair > DiffPair",
        "section": "DiffPair > DiffPair",
        "text": "class pyedb.workflows.drc.drc.DiffPair(*, positive: str, negative: str)\n\nDifferential-pair definition.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nDiffPair.construct([_fields_set])\n\n\n\nDiffPair.copy(*[, include, exclude, update, ...])\n\nReturns a copy of the model.\n\nDiffPair.dict(*[, include, exclude, ...])\n\n\n\nDiffPair.from_orm(obj)\n\n\n\nDiffPair.json(*[, include, exclude, ...])\n\n\n\nDiffPair.model_construct([_fields_set])\n\nCreates a new instance of the Model class with validated data.\n\nDiffPair.model_copy(*[, update, deep])\n\n!!! abstract \"Usage Documentation\"\n\nDiffPair.model_dump(*[, mode, include, ...])\n\n!!! abstract \"Usage Documentation\"\n\nDiffPair.model_dump_json(*[, indent, ...])\n\n!!! abstract \"Usage Documentation\"\n\nDiffPair.model_json_schema([by_alias, ...])\n\nGenerates a JSON schema for a model class.\n\nDiffPair.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nDiffPair.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nDiffPair.model_rebuild(*[, force, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nDiffPair.model_validate(obj, *[, strict, ...])\n\nValidate a pydantic model instance.\n\nDiffPair.model_validate_json(json_data, *[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nDiffPair.model_validate_strings(obj, *[, ...])\n\nValidate the given object with string data against the Pydantic model.\n\nDiffPair.parse_file(path, *[, content_type, ...])\n\n\n\nDiffPair.parse_obj(obj)\n\n\n\nDiffPair.parse_raw(b, *[, content_type, ...])\n\n\n\nDiffPair.schema([by_alias, ref_template])\n\n\n\nDiffPair.schema_json(*[, by_alias, ref_template])\n\n\n\nDiffPair.update_forward_refs(**localns)\n\n\n\nDiffPair.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nDiffPair.model_computed_fields\n\n\n\nDiffPair.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nDiffPair.model_fields\n\n\n\nDiffPair.positive\n\n\n\nDiffPair.negative\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a padstack instance.\nLayout to create the padstack instance in.\nNet of the padstack instance.\nName of the padstack instance.\nPadstack definition of the padstack instance.\nPosition x of the padstack instance.\nPosition y of the padstack instance.\nRotation of the padstack instance.\nTop layer of the padstack instance.\nBottom layer of the padstack instance.\nSolder ball layer of the padstack instance or None for none.\nLayer map of the padstack instance. None or empty results in\nauto-mapping.\nPadstack instance created.\ncreate\nLayout\nNet\npython:str\nPadstackDef\nLayer\nLayer\nLayer\nNone\nLayerMap\nNone\nPadstackInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod PadstackInstance.create(layout: Layout, net: Net, name: str, padstack_def: PadstackDef, position_x: ValueLike, position_y: ValueLike, rotation: ValueLike, top_layer: Layer, bottom_layer: Layer, solder_ball_layer: Layer | None = None, layer_map: LayerMap | None = None) -> PadstackInstance\n\nCreate a padstack instance.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to create the padstack instance in.\n\nnet\n\nNet\n\nNet of the padstack instance.\n\nname\n\npython:str\n\nName of the padstack instance.\n\npadstack_def\n\nPadstackDef\n\nPadstack definition of the padstack instance.\n\nposition_x\n\nValueLike\n\nPosition x of the padstack instance.\n\nposition_y\n\nValueLike\n\nPosition y of the padstack instance.\n\nrotation\n\nValueLike\n\nRotation of the padstack instance.\n\ntop_layer\n\nLayer\n\nTop layer of the padstack instance.\n\nbottom_layer\n\nLayer\n\nBottom layer of the padstack instance.\n\nsolder_ball_layer\n\nLayer\n\nSolder ball layer of the padstack instance or None for none.\n\nlayer_map\n\nLayerMap\n\nLayer map of the padstack instance. None or empty results in\nauto-mapping.\n\nReturns\n\nPadstackInstance\n\nPadstack instance created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.find_by_name",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.find_by_name.html#find_by_name",
        "title": "find_by_name",
        "section": "find_by_name",
        "text": "Find a layer in the layer collection.\nLayer name.\nfind_by_name\npython:str\nLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.find_by_name",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.find_by_name.html#pyedb.grpc.database.stackup.LayerCollection.find_by_name",
        "title": "find_by_name > find_by_name > find_by_name",
        "section": "find_by_name > find_by_name",
        "text": "LayerCollection.find_by_name(layer_name)\n\nFind a layer in the layer collection.\n\nParameters\n\nlayer_name\n\npython:str\n\nLayer name.\n\nReturns\n\nLayer\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create_pingroup_from_pins",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create_pingroup_from_pins.html#create_pingroup_from_pins",
        "title": "create_pingroup_from_pins",
        "section": "create_pingroup_from_pins",
        "text": "Create a pin group on a component.\nList of EDB pins.\nName for the group. The default is None, in which case\na default name is assigned as follows: [component Name] [NetName].\nThe tuple is structured as: (bool, pingroup).\ncreate_pingroup_from_pins\npython:list\npython:str\noptional\nNone\n[component Name] [NetName]\npython:tuple"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create_pingroup_from_pins",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create_pingroup_from_pins.html#pyedb.dotnet.database.components.Components.create_pingroup_from_pins",
        "title": "create_pingroup_from_pins > create_pingroup_from_pins > create_pingroup_from_pins",
        "section": "create_pingroup_from_pins > create_pingroup_from_pins",
        "text": "Components.create_pingroup_from_pins(pins, group_name=None)\n\nCreate a pin group on a component.\n\nParameters\n\npins\n\npython:list\n\nList of EDB pins.\n\ngroup_name\n\npython:str, optional\n\nName for the group. The default is None, in which case\na default name is assigned as follows: [component Name] [NetName].\n\nReturns\n\npython:tuple\n\nThe tuple is structured as: (bool, pingroup).\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\")\n>>> edbapp.components.create_pingroup_from_pins(gndpinlist, \"MyGNDPingroup\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.set_simulation_settings",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.set_simulation_settings.html#set_simulation_settings",
        "title": "set_simulation_settings",
        "section": "set_simulation_settings",
        "text": "set_simulation_settings"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.set_simulation_settings",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.set_simulation_settings.html#pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.set_simulation_settings",
        "title": "set_simulation_settings > set_simulation_settings > set_simulation_settings",
        "section": "set_simulation_settings > set_simulation_settings",
        "text": "RaptorXSimulationSetup.set_simulation_settings(sim_settings: dict)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_siwave_syz_setup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_siwave_syz_setup.html#create_siwave_syz_setup",
        "title": "create_siwave_syz_setup",
        "section": "create_siwave_syz_setup",
        "text": "Create a setup from a template.\nSetup name.\ncreate_siwave_syz_setup\npython:str\noptional\npyedb.dotnet.database.edb_data.siwave_simulation_setup_data.SiwaveSYZSimulationSetup"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_siwave_syz_setup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_siwave_syz_setup.html#pyedb.dotnet.edb.Edb.create_siwave_syz_setup",
        "title": "create_siwave_syz_setup > create_siwave_syz_setup > create_siwave_syz_setup",
        "section": "create_siwave_syz_setup > create_siwave_syz_setup",
        "text": "Edb.create_siwave_syz_setup(name=None, **kwargs)\n\nCreate a setup from a template.\n\nParameters\n\nname\n\npython:str, optional\n\nSetup name.\n\nReturns\n\npyedb.dotnet.database.edb_data.siwave_simulation_setup_data.SiwaveSYZSimulationSetup\n\n\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb()\n>>> setup1 = edbapp.create_siwave_syz_setup(\"setup1\")\n>>> setup1.add_frequency_sweep(\n...     frequency_sweep=[\n...         [\"linear count\", \"0\", \"1kHz\", 1],\n...         [\"log scale\", \"1kHz\", \"0.1GHz\", 10],\n...         [\"linear scale\", \"0.1GHz\", \"10GHz\", \"0.1GHz\"],\n...     ]\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "schema"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.schema.html#pyedb.workflows.drc.drc.MinClearance.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod MinClearance.schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}') -> Dict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.add_variable",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.add_variable.html#add_variable",
        "title": "add_variable",
        "section": "add_variable",
        "text": "Add a variable.\nVariable name.\nValue, which can be any type that can be converted to a Value\ninstance.\nWhether the new variable is a parameter. The default is False, which means it is a local variable.\nVariables can be added to the following EDB objects:\nDatabase (Variable names must begin with a ‘$’.)\nComponentDef\nCell\nLayout (Adds variable to the corresponding\nCell instance.)\nAdd variables to a cell and create a value that references these variables.\nadd_variable\npython:str\npython:str\npython:int\npython:float\ncomplex\nValue\nValue\npython:False\nFalse\nDatabase\nComponentDef\nCell\nLayout\nCell"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.add_variable",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.add_variable.html#pyedb.grpc.database.layout.layout.Layout.add_variable",
        "title": "add_variable > add_variable > add_variable",
        "section": "add_variable > add_variable",
        "text": "Layout.add_variable(name, value, is_param=False)\n\nAdd a variable.\n\nParameters\n\nname\n\npython:str\n\nVariable name.\n\nvalue\n\npython:str, python:int, python:float, complex, Value\n\nValue, which can be any type that can be converted to a Value\ninstance.\n\nis_param\n\nbool, default: python:False\n\nWhether the new variable is a parameter. The default is False, which means it is a local variable.\n\nNotes\n\nVariables can be added to the following EDB objects:\n\nDatabase (Variable names must begin with a ‘$’.)\n\nComponentDef\n\nCell\n\nLayout (Adds variable to the corresponding\nCell instance.)\n\nExamples\n\nAdd variables to a cell and create a value that references these variables.\n\n>>> param = Value(33.1)\n>>> cell.add_variable(\"blue1\", param)\n>>> cell.add_variable(\"blue2\", \"25mm\")\n>>> vv = cell.create_value(\"blue1 + blue2\")\n>>> print(vv.double)\n33.125\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileLayer",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileLayer.html#controlfilelayer",
        "title": "ControlFileLayer",
        "section": "ControlFileLayer",
        "text": "ControlFileLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileLayer",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileLayer.html#pyedb.grpc.database.utility.xml_control_file.ControlFileLayer",
        "title": "ControlFileLayer > ControlFileLayer > ControlFileLayer",
        "section": "ControlFileLayer > ControlFileLayer",
        "text": "class pyedb.grpc.database.utility.xml_control_file.ControlFileLayer(name, properties)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType.html#meshoptype",
        "title": "MeshOpType",
        "section": "MeshOpType",
        "text": "An enumeration.\nMeshOpType.kMeshSetupBase\n\nMeshOpType.kMeshSetupLength\n\nMeshOpType.kMeshSetupSkinDepth\n\nMeshOpType.kNumMeshOpTypes\n\nMeshOpType\nMeshOpType.kMeshSetupBase\nMeshOpType.kMeshSetupLength\nMeshOpType.kMeshSetupSkinDepth\nMeshOpType.kNumMeshOpTypes"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType.html#pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType",
        "title": "MeshOpType > MeshOpType > MeshOpType",
        "section": "MeshOpType > MeshOpType",
        "text": "class pyedb.dotnet.database.sim_setup_data.data.mesh_operation.MeshOpType(value)\n\nAn enumeration.\n\n!! processed by numpydoc !!\n\nAttributes\n\n\n\n\n\n\n\nMeshOpType.kMeshSetupBase\n\n\n\nMeshOpType.kMeshSetupLength\n\n\n\nMeshOpType.kMeshSetupSkinDepth\n\n\n\nMeshOpType.kNumMeshOpTypes\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.find_by_id",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.find_by_id.html#find_by_id",
        "title": "find_by_id",
        "section": "find_by_id",
        "text": "Find a database by ID.\nThe Database’s unique EDB id.\nThe Database or Null on failure.\nfind_by_id\npython:int\nDatabase"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.find_by_id",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.find_by_id.html#pyedb.grpc.edb.Edb.find_by_id",
        "title": "find_by_id > find_by_id > find_by_id",
        "section": "find_by_id > find_by_id",
        "text": "Edb.find_by_id(db_id)\n\nFind a database by ID.\n\nParameters\n\ndb_id\n\npython:int\n\nThe Database’s unique EDB id.\n\nReturns\n\nDatabase\n\nThe Database or Null on failure.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.simulation_settings.SimulationSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.simulation_settings.SimulationSettings.html#simulationsettings",
        "title": "SimulationSettings",
        "section": "SimulationSettings",
        "text": "SimulationSettings"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.simulation_settings.SimulationSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.simulation_settings.SimulationSettings.html#pyedb.dotnet.database.sim_setup_data.data.simulation_settings.SimulationSettings",
        "title": "SimulationSettings > SimulationSettings > SimulationSettings",
        "section": "SimulationSettings > SimulationSettings",
        "text": "class pyedb.dotnet.database.sim_setup_data.data.simulation_settings.SimulationSettings(pedb, sim_setup, edb_object)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/cell",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/cell.html#cell",
        "title": "Cell",
        "section": "Cell",
        "text": "This class is managing EDB cell.\nCell\nManage Cell\nCell\nCell\nCell"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.split_to_microvias",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.split_to_microvias.html#split_to_microvias",
        "title": "split_to_microvias",
        "section": "split_to_microvias",
        "text": "Convert actual padstack definition to multiple microvias definitions.\nsplit_to_microvias\nList\nof\npyedb.dotnet.database.padstackEDBPadstack"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.split_to_microvias",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.split_to_microvias.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.split_to_microvias",
        "title": "split_to_microvias > split_to_microvias > split_to_microvias",
        "section": "split_to_microvias > split_to_microvias",
        "text": "EDBPadstack.split_to_microvias()\n\nConvert actual padstack definition to multiple microvias definitions.\n\nReturns\n\nList of pyedb.dotnet.database.padstackEDBPadstack\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.open_edb",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.open_edb.html#open_edb",
        "title": "open_edb",
        "section": "open_edb",
        "text": "Open EDB.\nopen_edb"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.open_edb",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.open_edb.html#pyedb.dotnet.edb.Edb.open_edb",
        "title": "open_edb > open_edb > open_edb",
        "section": "open_edb > open_edb",
        "text": "Edb.open_edb()\n\nOpen EDB.\n\nReturns\n\n``True`` when succeed ``False`` if failed\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.delete_batch_instances",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.delete_batch_instances.html#delete_batch_instances",
        "title": "delete_batch_instances",
        "section": "delete_batch_instances",
        "text": "delete_batch_instances"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.delete_batch_instances",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.delete_batch_instances.html#pyedb.grpc.database.padstacks.Padstacks.delete_batch_instances",
        "title": "delete_batch_instances > delete_batch_instances > delete_batch_instances",
        "section": "delete_batch_instances > delete_batch_instances",
        "text": "Padstacks.delete_batch_instances(instances_to_delete)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_big",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_big.html#is_big",
        "title": "is_big",
        "section": "is_big",
        "text": "Determine if the arc is big.\nTrue when the arc is big, False otherwise.\nis_big\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_big",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.arc_data.ArcData.is_big.html#pyedb.grpc.database.geometry.arc_data.ArcData.is_big",
        "title": "is_big > is_big > is_big",
        "section": "is_big > is_big",
        "text": "ArcData.is_big() -> bool\n\nDetermine if the arc is big.\n\nReturns\n\nbool\n\nTrue when the arc is big, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_closest_point",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_closest_point.html#get_closest_point",
        "title": "get_closest_point",
        "section": "get_closest_point",
        "text": "Get the closest point of the primitive to the input data.\n[x, y].\nget_closest_point\npython:list\nof\npython:float\nPointData\nList\npython:float\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_closest_point",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_closest_point.html#pyedb.grpc.database.primitive.circle.Circle.get_closest_point",
        "title": "get_closest_point > get_closest_point > get_closest_point",
        "section": "get_closest_point > get_closest_point",
        "text": "Circle.get_closest_point(point) -> list[float]\n\nGet the closest point of the primitive to the input data.\n\nParameters\n\npoint\n\npython:list of python:float or PointData\n\n\n\nReturns\n\nList[python:float, python:float]\n\n[x, y].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_stride.html#create_stride",
        "title": "create_stride",
        "section": "create_stride",
        "text": "Create a Stride model from an MCAD file.\nStride model created.\ncreate_stride\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_stride",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_stride.html#pyedb.grpc.database.hierarchy.pingroup.PinGroup.create_stride",
        "title": "create_stride > create_stride > create_stride",
        "section": "create_stride > create_stride",
        "text": "PinGroup.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nReturns\n\nMcadModel\n\nStride model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.area",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.area.html#area",
        "title": "area",
        "section": "area",
        "text": "Compute the area of the polygon.\nArea of the polygon.\narea\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.area",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.area.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.area",
        "title": "area > area > area",
        "section": "area > area",
        "text": "PolygonData.area() -> float\n\nCompute the area of the polygon.\n\nReturns\n\npython:float\n\nArea of the polygon.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.model.Model",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.model.Model.html#model",
        "title": "Model",
        "section": "Model",
        "text": "Manages model Model.\nModel.clone()\nClone a model.\nModel\nModel\nModel.clone"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.model.Model",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.model.Model.html#pyedb.grpc.database.hierarchy.model.Model",
        "title": "Model > Model > Model",
        "section": "Model > Model",
        "text": "class pyedb.grpc.database.hierarchy.model.Model(pedb)\n\nManages model Model.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nModel.clone()\n\nClone a model.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.get_product_property_ids.html#pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "BundleTerminal.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.update_layout",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.update_layout.html#update_layout",
        "title": "update_layout",
        "section": "update_layout",
        "text": "Update the layout with the current layer collection.\nupdate_layout"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.update_layout",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.update_layout.html#pyedb.grpc.database.stackup.LayerCollection.update_layout",
        "title": "update_layout > update_layout > update_layout",
        "section": "update_layout > update_layout",
        "text": "LayerCollection.update_layout()\n\nUpdate the layout with the current layer collection.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> edb.stackup.update_layout()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.create",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create an edge terminal.\nLayout to create the edge terminal in.\nName of the edge terminal.\nNet reference. The default is None.\nWhether the edge terminal is a reference terminal.\ncreate\nLayout\nstr\npython:list\nof\nEdge\nNet\nstr\npython:None\nNone\nbool\npython:False\nEdgeTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.create",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.create.html#pyedb.grpc.database.ports.ports.CircuitPort.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod CircuitPort.create(layout, name, edges, net=None, is_ref=False)\n\nCreate an edge terminal.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to create the edge terminal in.\n\nname\n\nstr\n\nName of the edge terminal.\n\nedges\n\npython:list of Edge\n\n\n\nnet\n\nNet or str or python:None\n\nNet reference. The default is None.\n\nis_ref\n\nbool, default: python:False\n\nWhether the edge terminal is a reference terminal.\n\nReturns\n\nEdgeTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.rotate",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.rotate.html#rotate",
        "title": "rotate",
        "section": "rotate",
        "text": "Rotate the polygon at a center by an angle.\nAngle in radians.\nCenter.\nrotate\npython:float\nPolygonData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.rotate",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.rotate.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.rotate",
        "title": "rotate > rotate > rotate",
        "section": "rotate > rotate",
        "text": "PolygonData.rotate(angle: float, center: PointLike) -> PolygonData\n\nRotate the polygon at a center by an angle.\n\nParameters\n\nangle\n\npython:float\n\nAngle in radians.\n\ncenter\n\nPoint2DLike\n\nCenter.\n\nReturns\n\nPolygonData\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.is_intersecting",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.is_intersecting.html#is_intersecting",
        "title": "is_intersecting",
        "section": "is_intersecting",
        "text": "Check if actual primitive and another primitive or polygon data intesects.\nis_intersecting\npyaeedt.database.edb_data.primitives_data.EDBPrimitives"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.is_intersecting",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.is_intersecting.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.is_intersecting",
        "title": "is_intersecting > is_intersecting > is_intersecting",
        "section": "is_intersecting > is_intersecting",
        "text": "EdbPolygon.is_intersecting(primitive)\n\nCheck if actual primitive and another primitive or polygon data intesects.\n\nParameters\n\nprimitive\n\npyaeedt.database.edb_data.primitives_data.EDBPrimitives or PolygonData\n\n\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.group_vias",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.group_vias.html#group_vias",
        "title": "group_vias",
        "section": "group_vias",
        "text": "Create via groups from the primitives on the specified layers.\nLayers containing the primitives to be grouped.\nMaximum distance between via primitives in a via group .\nWhether to preserve primitives during via group creation. If False\nprimitives are deleted during via group creation.\nIf True, via primitives are grouped by proximity (relative position to each other).\nIf False, via primitives are grouped by range (any via primitives within the specified maximum\ngrouping distance of each other are grouped)\nIf True, the connectivity of via groups is checked and enforced to prevent\nshort circuits in geometry connecting to the via group. If false, via primitives are\ngrouped regardless of the connectivity of touching geometry.\ngroup_vias\npython:list\nof\nFalse\nTrue\nFalse\nTrue"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.group_vias",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.group_vias.html#pyedb.grpc.database.layout.layout.Layout.group_vias",
        "title": "group_vias > group_vias > group_vias",
        "section": "group_vias > group_vias",
        "text": "Layout.group_vias(layer: LayerListLike, max_grouping_distance: ValueLike = '100um', persistent_vias: bool = False, group_by_proximity: bool = True, check_containment: bool = True)\n\nCreate via groups from the primitives on the specified layers.\n\nParameters\n\nlayer\n\nLayerLike or python:list of LayerLike\n\nLayers containing the primitives to be grouped.\n\nmax_grouping_distance\n\nValueLike\n\nMaximum distance between via primitives in a via group .\n\npersistent_vias\n\nbool\n\nWhether to preserve primitives during via group creation. If False\nprimitives are deleted during via group creation.\n\ngroup_by_proximity\n\nbool\n\nIf True, via primitives are grouped by proximity (relative position to each other).\nIf False, via primitives are grouped by range (any via primitives within the specified maximum\ngrouping distance of each other are grouped)\n\ncheck_containment\n\nbool\n\nIf True, the connectivity of via groups is checked and enforced to prevent\nshort circuits in geometry connecting to the via group. If false, via primitives are\ngrouped regardless of the connectivity of touching geometry.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/hfss_simulation_setup",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/hfss_simulation_setup.html#hfss-simulation-setup",
        "title": "HFSS simulation setup",
        "section": "HFSS simulation setup",
        "text": "This class is managing EDB HFSS simulation setup.\nHfssSimulationSetup\nHFSS simulation setup class.\nHFSS simulation setup\nHfssSimulationSetup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.read_materials",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.read_materials.html#read_materials",
        "title": "read_materials",
        "section": "read_materials",
        "text": "Read materials from an AMAT file.\nFull path to the AMAT file to read.\n{material name: dict of material properties}.\nread_materials\npython:str\npython:dict"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.read_materials",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.read_materials.html#pyedb.grpc.database.definition.materials.Materials.read_materials",
        "title": "read_materials > read_materials > read_materials",
        "section": "read_materials > read_materials",
        "text": "Materials.read_materials(amat_file) -> dict[str, Material]\n\nRead materials from an AMAT file.\n\nParameters\n\namat_file\n\npython:str\n\nFull path to the AMAT file to read.\n\nReturns\n\npython:dict\n\n{material name: dict of material properties}.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData.api_create",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData.api_create.html#api_create",
        "title": "api_create",
        "section": "api_create",
        "text": "Edb Dotnet Api Database Edb.ExtendedNet.Create.\napi_create"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData.api_create",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData.api_create.html#pyedb.dotnet.database.edb_data.nets_data.EDBExtendedNetData.api_create",
        "title": "api_create > api_create > api_create",
        "section": "api_create > api_create",
        "text": "EDBExtendedNetData.api_create(name)\n\nEdb Dotnet Api Database Edb.ExtendedNet.Create.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_edge_port_horizontal",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_edge_port_horizontal.html#create_edge_port_horizontal",
        "title": "create_edge_port_horizontal",
        "section": "create_edge_port_horizontal",
        "text": "Create a horizontal edge port.\nPrimitive ID.\nCoordinate of the point to define the edge terminal.\nThe point must be on the target edge but not on the two\nends of the edge.\nReference primitive ID. The default is None.\nCoordinate of the point to define the reference edge\nterminal. The point must be on the target edge but not\non the two ends of the edge. The default is None.\nName of the port. The default is None.\nImpedance of the port. The default value is 50.\nLayer alignment. The default value is Upper. Options are \"Upper\", \"Lower\".\nName of the port.\ncreate_edge_port_horizontal\npython:int\npython:list\npython:int\noptional\nNone\npython:list\noptional\nNone\npython:str\noptional\nNone\npython:int\npython:float\noptional\n50\npython:str\noptional\nUpper\n\"Upper\"\n\"Lower\"\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_edge_port_horizontal",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_edge_port_horizontal.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_edge_port_horizontal",
        "title": "create_edge_port_horizontal > create_edge_port_horizontal > create_edge_port_horizontal",
        "section": "create_edge_port_horizontal > create_edge_port_horizontal",
        "text": "SourceExcitation.create_edge_port_horizontal(prim_id: int | Primitive, point_on_edge: List[float], ref_prim_id: int | Primitive | None = None, point_on_ref_edge: List[float] | None = None, port_name: str | None = None, impedance: int | float = 50, layer_alignment: str = 'Upper') -> EdgeTerminal | None\n\nCreate a horizontal edge port.\n\nParameters\n\nprim_id\n\npython:int\n\nPrimitive ID.\n\npoint_on_edge\n\npython:list\n\nCoordinate of the point to define the edge terminal.\nThe point must be on the target edge but not on the two\nends of the edge.\n\nref_prim_id\n\npython:int, optional\n\nReference primitive ID. The default is None.\n\npoint_on_ref_edge\n\npython:list, optional\n\nCoordinate of the point to define the reference edge\nterminal. The point must be on the target edge but not\non the two ends of the edge. The default is None.\n\nport_name\n\npython:str, optional\n\nName of the port. The default is None.\n\nimpedance\n\npython:int, python:float, optional\n\nImpedance of the port. The default value is 50.\n\nlayer_alignment\n\npython:str, optional\n\nLayer alignment. The default value is Upper. Options are \"Upper\", \"Lower\".\n\nReturns\n\npython:str\n\nName of the port.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> edb.source_excitation.create_edge_port_horizontal(0, [0, 0], 1, [0, 0.1], \"EdgePort\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.remove_pin",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.remove_pin.html#remove_pin",
        "title": "remove_pin",
        "section": "remove_pin",
        "text": "Remove the provided component pin from the component definition.         the pin will be deleted and set to null.\nThe pin to be removed.\nremove_pin\nnull\nComponentPin"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.remove_pin",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.remove_pin.html#pyedb.grpc.database.definition.component_def.ComponentDef.remove_pin",
        "title": "remove_pin > remove_pin > remove_pin",
        "section": "remove_pin > remove_pin",
        "text": "ComponentDef.remove_pin(pin_to_remove: ComponentPin)\n\nRemove the provided component pin from the component definition.         the pin will be deleted and set to null.\n\nParameters\n\npin_to_remove\n\nComponentPin\n\nThe pin to be removed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_bundle_wave_port",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_bundle_wave_port.html#create_bundle_wave_port",
        "title": "create_bundle_wave_port",
        "section": "create_bundle_wave_port",
        "text": "Create a bundle wave port.\nPrimitive ID of the positive terminal.\nCoordinate of the point to define the edge terminal.\nThe point must be close to the target edge but not on the two\nends of the edge.\nName of the port. The default is None.\nHorizontal extent factor. The default value is 5.\nVertical extent factor. The default value is 3.\nLaunch Width of PEC. The default value is \"0.01mm\".\nThe tuple contains: (port_name, pyedb.egacy.database.edb_data.sources.ExcitationDifferential).\ncreate_bundle_wave_port\npython:list\npython:list\npython:str\noptional\nNone\npython:int\npython:float\noptional\n5\npython:int\npython:float\noptional\n3\npython:str\noptional\n\"0.01mm\"\npython:tuple"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_bundle_wave_port",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_bundle_wave_port.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_bundle_wave_port",
        "title": "create_bundle_wave_port > create_bundle_wave_port > create_bundle_wave_port",
        "section": "create_bundle_wave_port > create_bundle_wave_port",
        "text": "SourceExcitation.create_bundle_wave_port(primitives_id: List[int | Primitive], points_on_edge: List[List[float]], port_name: str | None = None, horizontal_extent_factor: int | float = 5, vertical_extent_factor: int | float = 3, pec_launch_width: str = '0.01mm') -> Tuple[str, BundleWavePort]\n\nCreate a bundle wave port.\n\nParameters\n\nprimitives_id\n\npython:list\n\nPrimitive ID of the positive terminal.\n\npoints_on_edge\n\npython:list\n\nCoordinate of the point to define the edge terminal.\nThe point must be close to the target edge but not on the two\nends of the edge.\n\nport_name\n\npython:str, optional\n\nName of the port. The default is None.\n\nhorizontal_extent_factor\n\npython:int, python:float, optional\n\nHorizontal extent factor. The default value is 5.\n\nvertical_extent_factor\n\npython:int, python:float, optional\n\nVertical extent factor. The default value is 3.\n\npec_launch_width\n\npython:str, optional\n\nLaunch Width of PEC. The default value is \"0.01mm\".\n\nReturns\n\npython:tuple\n\nThe tuple contains: (port_name, pyedb.egacy.database.edb_data.sources.ExcitationDifferential).\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> port_name, port = edb.source_excitation.create_bundle_wave_port([0, 1], [[0, 0], [0, 0.2]])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.pairs",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.pairs.html#pairs",
        "title": "pairs",
        "section": "pairs",
        "text": "pairs"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.pairs",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.pairs.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.pairs",
        "title": "pairs > pairs > pairs",
        "section": "pairs > pairs",
        "text": "DiffPairLengthMatch.pairs: List[DiffPair]\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_primitive_by_layer_and_point",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_primitive_by_layer_and_point.html#get_primitive_by_layer_and_point",
        "title": "get_primitive_by_layer_and_point",
        "section": "get_primitive_by_layer_and_point",
        "text": "Return primitive given coordinate point [x, y], layer name and nets.\nCoordinate [x, y]\nlist of layer name or layer name applied on filter.\nlist of net name or single net name applied on filter\nList of primitives, polygons, paths and rectangles.\nget_primitive_by_layer_and_point\npython:list\npython:list\npython:str\noptional\npython:list\npython:str\noptional\npython:list\nof\npyedb.dotnet.database.edb_data.primitives_data.Primitive"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_primitive_by_layer_and_point",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_primitive_by_layer_and_point.html#pyedb.dotnet.database.modeler.Modeler.get_primitive_by_layer_and_point",
        "title": "get_primitive_by_layer_and_point > get_primitive_by_layer_and_point > get_primitive_by_layer_and_point",
        "section": "get_primitive_by_layer_and_point > get_primitive_by_layer_and_point",
        "text": "Modeler.get_primitive_by_layer_and_point(point=None, layer=None, nets=None)\n\nReturn primitive given coordinate point [x, y], layer name and nets.\n\nParameters\n\npoint\n\npython:list\n\nCoordinate [x, y]\n\nlayer\n\npython:list or python:str, optional\n\nlist of layer name or layer name applied on filter.\n\nnets\n\npython:list or python:str, optional\n\nlist of net name or single net name applied on filter\n\nReturns\n\npython:list of pyedb.dotnet.database.edb_data.primitives_data.Primitive\n\nList of primitives, polygons, paths and rectangles.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.parse_raw",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "parse_raw"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.parse_raw",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.parse_raw.html#pyedb.workflows.drc.drc.Rules.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod Rules.parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_position_and_rotation",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_position_and_rotation.html#get_position_and_rotation",
        "title": "get_position_and_rotation",
        "section": "get_position_and_rotation",
        "text": "Get the position and rotation of the padstack instance.\nReturns a tuple in this format:\n(x, y, rotation)\nx : X coordinate.\ny : Y coordinate.\nrotation : Rotation in radians.\nget_position_and_rotation\npython:tuple\nof\nValue\nValue\nValue"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_position_and_rotation",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_position_and_rotation.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_position_and_rotation",
        "title": "get_position_and_rotation > get_position_and_rotation > get_position_and_rotation",
        "section": "get_position_and_rotation > get_position_and_rotation",
        "text": "PadstackInstance.get_position_and_rotation() -> tuple[Value, Value, Value]\n\nGet the position and rotation of the padstack instance.\n\nReturns\n\npython:tuple of (Value, Value, Value)\n\nReturns a tuple in this format:\n\n(x, y, rotation)\n\nx : X coordinate.\n\ny : Y coordinate.\n\nrotation : Rotation in radians.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.convert_primitives_to_vias",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.convert_primitives_to_vias.html#convert_primitives_to_vias",
        "title": "convert_primitives_to_vias",
        "section": "convert_primitives_to_vias",
        "text": "Convert a list of primitives into vias or pins.\nList of primitives to convert.\nFlag indicating whether to convert the provided primitives\nto pins or vias. The default is False, in which\ncase the primitives will be converted to vias.\nconvert_primitives_to_vias\npython:list\nof\nPrimitive\npython:False\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.convert_primitives_to_vias",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.convert_primitives_to_vias.html#pyedb.grpc.database.layout.layout.Layout.convert_primitives_to_vias",
        "title": "convert_primitives_to_vias > convert_primitives_to_vias > convert_primitives_to_vias",
        "section": "convert_primitives_to_vias > convert_primitives_to_vias",
        "text": "Layout.convert_primitives_to_vias(primitives: List[Primitive], is_pins: bool = False)\n\nConvert a list of primitives into vias or pins.\n\nParameters\n\nprimitives\n\npython:list of Primitive\n\nList of primitives to convert.\n\nis_pins\n\nbool, default: python:False\n\nFlag indicating whether to convert the provided primitives\nto pins or vias. The default is False, in which\ncase the primitives will be converted to vias.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.convert_hole_to_conical_shape",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.convert_hole_to_conical_shape.html#convert_hole_to_conical_shape",
        "title": "convert_hole_to_conical_shape",
        "section": "convert_hole_to_conical_shape",
        "text": "Convert actual padstack instance to microvias 3D Objects with a given aspect ratio.\nAngle of laser penetration in degrees. The angle defines the lowest hole diameter with this formula:\nHoleDiameter -2*tan(laser_angle* Hole depth). Hole depth is the height of the via (dielectric thickness).\nThe default is 75.\nThe lowest hole is 0.75*HoleDepth/HoleDiam.\nconvert_hole_to_conical_shape\npython:float\noptional\n75\n0.75*HoleDepth/HoleDiam"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.convert_hole_to_conical_shape",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.convert_hole_to_conical_shape.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.convert_hole_to_conical_shape",
        "title": "convert_hole_to_conical_shape > convert_hole_to_conical_shape > convert_hole_to_conical_shape",
        "section": "convert_hole_to_conical_shape > convert_hole_to_conical_shape",
        "text": "PadstackInstance.convert_hole_to_conical_shape(angle=75)\n\nConvert actual padstack instance to microvias 3D Objects with a given aspect ratio.\n\nParameters\n\nangle\n\npython:float, optional\n\nAngle of laser penetration in degrees. The angle defines the lowest hole diameter with this formula:\nHoleDiameter -2*tan(laser_angle* Hole depth). Hole depth is the height of the via (dielectric thickness).\nThe default is 75.\nThe lowest hole is 0.75*HoleDepth/HoleDiam.\n\nReturns\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.couple_ports",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.couple_ports.html#couple_ports",
        "title": "couple_ports",
        "section": "couple_ports",
        "text": "Create a bundle wave port.\nPorts to be added.\ncouple_ports\nWaveport\nBundleWavePort"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.couple_ports",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.couple_ports.html#pyedb.grpc.database.ports.ports.WavePort.couple_ports",
        "title": "couple_ports > couple_ports > couple_ports",
        "section": "couple_ports > couple_ports",
        "text": "WavePort.couple_ports(port)\n\nCreate a bundle wave port.\n\nParameters\n\nport\n\nWaveport,\n\n\n\n:class:`GapPOrt <pyedb.grpc.database.ports.ports.GapPort>`, list, optional\n\nPorts to be added.\n\nReturns\n\nBundleWavePort\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.validate",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "validate"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.validate",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.validate.html#pyedb.grpc.database.definition.materials.MaterialProperties.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod MaterialProperties.validate(value: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.intersection_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.intersection_type.html#intersection_type",
        "title": "intersection_type",
        "section": "intersection_type",
        "text": "Get intersection type between actual primitive and another primitive or polygon data.\nIntersection type:\n0 - objects do not intersect,\n1 - this object fully inside other (no common contour points),\n2 - other object fully inside this,\n3 - common contour points,\n4 - undefined intersection.\nintersection_type\nPolygon\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.intersection_type",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.intersection_type.html#pyedb.grpc.database.primitive.circle.Circle.intersection_type",
        "title": "intersection_type > intersection_type > intersection_type",
        "section": "intersection_type > intersection_type",
        "text": "Circle.intersection_type(primitive)\n\nGet intersection type between actual primitive and another primitive or polygon data.\n\nParameters\n\nprimitive\n\nPolygon or PolygonData\n\n\n\nReturns\n\npython:int\n\nIntersection type:\n0 - objects do not intersect,\n1 - this object fully inside other (no common contour points),\n2 - other object fully inside this,\n3 - common contour points,\n4 - undefined intersection.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.fix_self_intersections",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.fix_self_intersections.html#fix_self_intersections",
        "title": "fix_self_intersections",
        "section": "fix_self_intersections",
        "text": "Find and fix self intersections from a given netlist.\nList of nets on which check disjoints. If None is provided then the algorithm will loop on all nets.\nfix_self_intersections\npython:str\npython:list\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.fix_self_intersections",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.fix_self_intersections.html#pyedb.grpc.database.layout_validation.LayoutValidation.fix_self_intersections",
        "title": "fix_self_intersections > fix_self_intersections > fix_self_intersections",
        "section": "fix_self_intersections > fix_self_intersections",
        "text": "LayoutValidation.fix_self_intersections(net_list: str | List[str] | None = None) -> bool\n\nFind and fix self intersections from a given netlist.\n\nParameters\n\nnet_list\n\npython:str, python:list, optional\n\nList of nets on which check disjoints. If None is provided then the algorithm will loop on all nets.\n\nReturns\n\nbool\n\n\n\nExamples\n\n>>> edb = Edb(\"edb_file\")\n>>> # Fix self-intersections on all nets\n>>> edb.layout_validation.fix_self_intersections()\n>>>\n>>> # Fix self-intersections on specific nets\n>>> edb.layout_validation.fix_self_intersections(net_list=[\"RF_line\"])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_multipole_debye_model",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_multipole_debye_model.html#set_multipole_debye_model",
        "title": "set_multipole_debye_model",
        "section": "set_multipole_debye_model",
        "text": "Set multi-pole debeye model on current material.\nset_multipole_debye_model"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_multipole_debye_model",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_multipole_debye_model.html#pyedb.grpc.database.definition.materials.Material.set_multipole_debye_model",
        "title": "set_multipole_debye_model > set_multipole_debye_model > set_multipole_debye_model",
        "section": "set_multipole_debye_model > set_multipole_debye_model",
        "text": "Material.set_multipole_debye_model()\n\nSet multi-pole debeye model on current material.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kQEye",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kQEye.html#kqeye",
        "title": "kQEye",
        "section": "kQEye",
        "text": "kQEye"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kQEye",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kQEye.html#pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kQEye",
        "title": "kQEye > kQEye > kQEye",
        "section": "kQEye > kQEye",
        "text": "SimulationSetupType.kQEye = 'quick_eye'\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.create_hfss.html#create_hfss",
        "title": "create_hfss",
        "section": "create_hfss",
        "text": "Create an HFSS model from an MCAD file.\nHFSS model created.\ncreate_hfss\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.create_hfss.html#pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.create_hfss",
        "title": "create_hfss > create_hfss > create_hfss",
        "section": "create_hfss > create_hfss",
        "text": "PadstackInstanceTerminal.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nReturns\n\nMcadModel\n\nHFSS model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/job_manager/submit_job",
        "href": "workflows/job_manager/submit_job.html#job-submissionproduction-notes--quick-start",
        "title": "Job submission—production notes & quick-start",
        "section": "Job submission—production notes & quick-start",
        "text": "Pre-requisites\nOverview—how it works\nSynchronous usage (scripts & notebooks)\nProduction notes\nAsynchronous usage (CLI & programmatic)\nCLI—submit_local_job\nInstallation\nSynopsis\nEnvironment variables\nExit codes\nExample—CLI (cluster)\nProgrammatic—native asyncio\nChoosing between sync & async\nStand-alone server launcher script\nSee also\nJob submission—production notes & quick-start\nTable of contents\nsubmit_local_job"
    },
    {
        "objectID": "workflows/job_manager/submit_job",
        "href": "workflows/job_manager/submit_job.html#pre-requisites",
        "title": "Job submission—production notes & quick-start > Pre-requisites",
        "section": "Pre-requisites",
        "text": "ANSYS Electronics Desktop must be installed.\nThe environment variable ANSYSEM_ROOT<rrr> must point to the\ninstallation directory, e.g.\nThe backend automatically discovers the newest release if several\nANSYSEM_ROOT<rrr> variables are present.\n(Cluster only) A scheduler template for your workload manager\nmust exist in pyedb/workflows/job_manager/scheduler_templates/.\nOut-of-the-box templates are provided for SLURM and LSF;\nPBS, Torque, Windows-HPC, or cloud batch systems can be added\nby dropping a new YAML file—no code change required.\nPre-requisites\nANSYSEM_ROOT<rrr>\nANSYSEM_ROOT<rrr>\npyedb/workflows/job_manager/scheduler_templates/"
    },
    {
        "objectID": "workflows/job_manager/submit_job",
        "href": "workflows/job_manager/submit_job.html#overviewhow-it-works",
        "title": "Job submission—production notes & quick-start > Overview—how it works",
        "section": "Overview—how it works",
        "text": "The job manager is an asynchronous micro-service that is automatically\nstarted in a background thread when you instantiate JobManagerHandler.\nIt exposes:\nREST & Web-Socket endpoints (http://localhost:8080 by default)\nThread-safe synchronous façade for scripts / Jupyter\nNative async API for advanced integrations\nCLI utilities submit_local_job and submit_job_on_scheduler for shell / CI pipelines\nThe same backend code path is used regardless of front-end style; the difference is\nwho owns the event loop and how control is returned to the caller.\nQuick-start server (any OS)\nSave the launcher script as start_service.py (see start_service_script) and run:\nThe service is ready when the line\n“✅ Job-manager backend listening on http://0.0.0.0:9090.”\nappears; leave the terminal open or daemonize it with your favourite supervisor.\nThe backend auto-detects the scheduler:\nWindows workstation → SchedulerType.NONE (local subprocess)\nLinux workstation → SchedulerType.NONE (local subprocess)\nLinux cluster with SLURM → SchedulerType.SLURM\nLinux cluster with LSF → SchedulerType.LSF\nYou can still override the choice explicitly if needed.\nOverview—how it works\nJobManagerHandler\nhttp://localhost:8080\nsubmit_local_job\nsubmit_job_on_scheduler\nstart_service.py\nSchedulerType.NONE\nSchedulerType.NONE\nSchedulerType.SLURM\nSchedulerType.LSF"
    },
    {
        "objectID": "workflows/job_manager/submit_job",
        "href": "workflows/job_manager/submit_job.html#synchronous-usage-scripts--notebooks",
        "title": "Job submission—production notes & quick-start > Synchronous usage (scripts & notebooks)",
        "section": "Synchronous usage (scripts & notebooks)",
        "text": "Perfect when you simply want to “submit and wait” without learning asyncio.\nSynchronous usage (scripts & notebooks)\nasyncio"
    },
    {
        "objectID": "workflows/job_manager/submit_job",
        "href": "workflows/job_manager/submit_job.html#production-notes",
        "title": "Job submission—production notes & quick-start > Production notes",
        "section": "Production notes",
        "text": "Thread-safe: multiple threads may submit or cancel concurrently.\nResource limits (CPU, memory, disk, concurrency) are enforced; jobs stay queued\nuntil resources are free.\natexit ensures clean shutdown even if the user forgets close().\nCluster runs: change SchedulerType.NONE → SLURM/LSF and supply\nscheduler_options; the code path remains identical.\nProduction notes\natexit\nclose()\nSchedulerType.NONE\nSLURM\nLSF\nscheduler_options"
    },
    {
        "objectID": "workflows/job_manager/submit_job",
        "href": "workflows/job_manager/submit_job.html#asynchronous-usage-cli--programmatic",
        "title": "Job submission—production notes & quick-start > Asynchronous usage (CLI & programmatic)",
        "section": "Asynchronous usage (CLI & programmatic)",
        "text": "Use when you need non-blocking behaviour inside an async function or from\nthe shell / CI pipelines.\nAsynchronous usage (CLI & programmatic)\nasync"
    },
    {
        "objectID": "workflows/job_manager/submit_job",
        "href": "workflows/job_manager/submit_job.html#clisubmit_local_job",
        "title": "Job submission—production notes & quick-start > CLI—submit_local_job",
        "section": "CLI—submit_local_job",
        "text": "The package installs a console entry-point that talks to the same REST API.\nCLI—submit_local_job\nsubmit_local_job"
    },
    {
        "objectID": "workflows/job_manager/submit_job",
        "href": "workflows/job_manager/submit_job.html#installation",
        "title": "Job submission—production notes & quick-start > Installation",
        "section": "Installation",
        "text": "Installation"
    },
    {
        "objectID": "workflows/job_manager/submit_job",
        "href": "workflows/job_manager/submit_job.html#synopsis",
        "title": "Job submission—production notes & quick-start > Synopsis",
        "section": "Synopsis",
        "text": "Synopsis"
    },
    {
        "objectID": "workflows/job_manager/submit_job",
        "href": "workflows/job_manager/submit_job.html#environment-variables",
        "title": "Job submission—production notes & quick-start > Environment variables",
        "section": "Environment variables",
        "text": "Fallback for --host.\nFallback for --port.\nEnvironment variables\n--host\n--port"
    },
    {
        "objectID": "workflows/job_manager/submit_job",
        "href": "workflows/job_manager/submit_job.html#envvar-PYEDB_JOB_MANAGER_HOST",
        "title": "Job submission—production notes & quick-start > Environment variables > envvar-PYEDB_JOB_MANAGER_HOST",
        "section": "Environment variables > envvar-PYEDB_JOB_MANAGER_HOST",
        "text": "PYEDB_JOB_MANAGER_HOST\n\nFallback for --host."
    },
    {
        "objectID": "workflows/job_manager/submit_job",
        "href": "workflows/job_manager/submit_job.html#envvar-PYEDB_JOB_MANAGER_PORT",
        "title": "Job submission—production notes & quick-start > Environment variables > envvar-PYEDB_JOB_MANAGER_PORT",
        "section": "Environment variables > envvar-PYEDB_JOB_MANAGER_PORT",
        "text": "PYEDB_JOB_MANAGER_PORT\n\nFallback for --port."
    },
    {
        "objectID": "workflows/job_manager/submit_job",
        "href": "workflows/job_manager/submit_job.html#exit-codes",
        "title": "Job submission—production notes & quick-start > Exit codes",
        "section": "Exit codes",
        "text": "Code\nMeaning\n0\nJob accepted by manager.\n1\nCLI validation or connection error.\n2\nUnexpected runtime exception.\nExit codes\n0\n1\n2"
    },
    {
        "objectID": "workflows/job_manager/submit_job",
        "href": "workflows/job_manager/submit_job.html#examplecli-cluster",
        "title": "Job submission—production notes & quick-start > Example—CLI (cluster)",
        "section": "Example—CLI (cluster)",
        "text": "The command returns immediately after the job is queued; use the printed ID\nwith wait_until_done or monitor via the web UI.\nExample—CLI (cluster)\nwait_until_done"
    },
    {
        "objectID": "workflows/job_manager/submit_job",
        "href": "workflows/job_manager/submit_job.html#programmaticnative-asyncio",
        "title": "Job submission—production notes & quick-start > Programmatic—native asyncio",
        "section": "Programmatic—native asyncio",
        "text": "Programmatic—native asyncio"
    },
    {
        "objectID": "workflows/job_manager/submit_job",
        "href": "workflows/job_manager/submit_job.html#choosing-between-sync--async",
        "title": "Job submission—production notes & quick-start > Choosing between sync & async",
        "section": "Choosing between sync & async",
        "text": "Synchronous (scripts / notebooks)\nAsynchronous (services / CLI)\nNo asyncio knowledge required.\nCaller runs inside async def; operations are await-ed.\nBlocking calls—caller waits for result.\nNon-blocking—event loop stays responsive.\nIdeal for interactive work, CI pipelines, quick scripts.\nIdeal for web servers, micro-services, GUI applications.\nChoosing between sync & async\nasyncio\nasync def\nawait"
    },
    {
        "objectID": "workflows/job_manager/submit_job",
        "href": "workflows/job_manager/submit_job.html#stand-alone-server-launcher-script",
        "title": "Job submission—production notes & quick-start > Stand-alone server launcher script",
        "section": "Stand-alone server launcher script",
        "text": "The file start_service.py is a minimal wrapper around\nJobManagerHandler that exposes only --host and --port.\nIt is not installed by pip; copy it from the doc folder or the\nprevious code block and place it anywhere in your PATH.\nStand-alone server launcher script\nstart_service.py\nJobManagerHandler\n--host\n--port\nPATH"
    },
    {
        "objectID": "workflows/job_manager/submit_job",
        "href": "workflows/job_manager/submit_job.html#see-also",
        "title": "Job submission—production notes & quick-start > See also",
        "section": "See also",
        "text": "job_manager_rest_api–Complete endpoint reference\nJobManagerHandler–API reference (sync façade)\nJobManager–API reference (async core)\nconfiguration_syntax–All scheduler & solver options\n../tutorials/submit_batch–Bulk submissions on SLURM/LSF\nSee also\nJobManagerHandler\nJobManager"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.html#layoutvalidation",
        "title": "LayoutValidation",
        "section": "LayoutValidation",
        "text": "Manages all layout validation capabilities\nLayoutValidation.dc_shorts([net_list, fix])\nFind DC shorts on layout.\nLayoutValidation.disjoint_nets([net_list, ...])\nFind and fix disjoint nets from a given netlist.\nLayoutValidation.fix_self_intersections([...])\nFind and fix self intersections from a given netlist.\nLayoutValidation.illegal_net_names([fix])\nFind and fix illegal net names.\nLayoutValidation.illegal_rlc_values([fix])\nFind and fix RLC illegal values.\nLayoutValidation.padstacks_no_name([fix])\nIdentify and fix padstacks without names.\nLayoutValidation\nLayoutValidation.dc_shorts\nLayoutValidation.disjoint_nets\nLayoutValidation.fix_self_intersections\nLayoutValidation.illegal_net_names\nLayoutValidation.illegal_rlc_values\nLayoutValidation.padstacks_no_name"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.layout_validation.LayoutValidation.html#pyedb.grpc.database.layout_validation.LayoutValidation",
        "title": "LayoutValidation > LayoutValidation > LayoutValidation",
        "section": "LayoutValidation > LayoutValidation",
        "text": "class pyedb.grpc.database.layout_validation.LayoutValidation(pedb: Any)\n\nManages all layout validation capabilities\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nLayoutValidation.dc_shorts([net_list, fix])\n\nFind DC shorts on layout.\n\nLayoutValidation.disjoint_nets([net_list, ...])\n\nFind and fix disjoint nets from a given netlist.\n\nLayoutValidation.fix_self_intersections([...])\n\nFind and fix self intersections from a given netlist.\n\nLayoutValidation.illegal_net_names([fix])\n\nFind and fix illegal net names.\n\nLayoutValidation.illegal_rlc_values([fix])\n\nFind and fix RLC illegal values.\n\nLayoutValidation.padstacks_no_name([fix])\n\nIdentify and fix padstacks without names.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.create_3d_comp.html#create_3d_comp",
        "title": "create_3d_comp",
        "section": "create_3d_comp",
        "text": "Create a 3D composite model from an MCAD file.\n3D composite model created.\ncreate_3d_comp\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.create_3d_comp.html#pyedb.grpc.database.terminal.point_terminal.PointTerminal.create_3d_comp",
        "title": "create_3d_comp > create_3d_comp > create_3d_comp",
        "section": "create_3d_comp > create_3d_comp",
        "text": "PointTerminal.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nReturns\n\nMcadModel\n\n3D composite model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.create",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a material definition in a given database.\nDatabase to create the material definition in.\nName of the material definition.\nDictionary of material property values.\nThe dictionary key is the material property name. The dictionary value is the             material property value. The expected keys for the kwargs are:\n\"permittivity\"\n\"permeability\"\n\"conductivity\"\n\"dielectric_loss_tangent\"\n\"magnetic_loss_tangent\"\n\"thermal_conductivity\"\n\"mass_density\"\n\"specific_heat\"\n\"youngs_modulus\"\n\"poissons_ratio\"\n\"thermal_expansion_coefficient\"\ncreate\nDatabase\npython:str\npython:dict\nof\npython:str\n\"permittivity\"\n\"permeability\"\n\"conductivity\"\n\"dielectric_loss_tangent\"\n\"magnetic_loss_tangent\"\n\"thermal_conductivity\"\n\"mass_density\"\n\"specific_heat\"\n\"youngs_modulus\"\n\"poissons_ratio\"\n\"thermal_expansion_coefficient\"\nMaterialDef"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.create",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.create.html#pyedb.grpc.database.definition.materials.Material.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod Material.create(database: Database, name: str, **kwargs: Dict[str, ValueLike]) -> MaterialDef\n\nCreate a material definition in a given database.\n\nParameters\n\ndatabase\n\nDatabase\n\nDatabase to create the material definition in.\n\nname\n\npython:str\n\nName of the material definition.\n\nkwargs\n\npython:dict of { python:str\n\nValueLike }\n\nDictionary of material property values.\nThe dictionary key is the material property name. The dictionary value is the             material property value. The expected keys for the kwargs are:\n\n\"permittivity\"\n\n\"permeability\"\n\n\"conductivity\"\n\n\"dielectric_loss_tangent\"\n\n\"magnetic_loss_tangent\"\n\n\"thermal_conductivity\"\n\n\"mass_density\"\n\n\"specific_heat\"\n\n\"youngs_modulus\"\n\n\"poissons_ratio\"\n\n\"thermal_expansion_coefficient\"\n\nReturns\n\nMaterialDef\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_construct",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues: Trusted or pre-validated data dictionary.\nA new instance of the Model class with validated data.\nmodel_construct"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_construct",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_construct.html#pyedb.grpc.database.definition.materials.MaterialProperties.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod MaterialProperties.model_construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nArgs:\n\n_fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues: Trusted or pre-validated data dictionary.\n\nReturns:\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.Substrate.tan_d",
        "href": "libraries/_autosummary/pyedb.libraries.common.Substrate.tan_d.html#tan_d",
        "title": "tan_d",
        "section": "tan_d",
        "text": "tan_d"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.Substrate.tan_d",
        "href": "libraries/_autosummary/pyedb.libraries.common.Substrate.tan_d.html#pyedb.libraries.common.Substrate.tan_d",
        "title": "tan_d > tan_d > tan_d",
        "section": "tan_d > tan_d",
        "text": "Substrate.tan_d: float = 0\n\n"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.value",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.value.html#value",
        "title": "value",
        "section": "value",
        "text": "value"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.value",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.value.html#pyedb.workflows.drc.drc.MinClearance.value",
        "title": "value > value > value",
        "section": "value > value",
        "text": "MinClearance.value: str\n\n"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.value",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.value.html#value",
        "title": "value",
        "section": "value",
        "text": "Minimum width with unit, e.g. \"3.5mil\".\nvalue\n\"3.5mil\""
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.value",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.value.html#pyedb.workflows.drc.drc.MinLineWidth.value",
        "title": "value > value > value",
        "section": "value > value",
        "text": "MinLineWidth.value: str\n\nMinimum width with unit, e.g. \"3.5mil\".\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.set_variable_value",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.set_variable_value.html#set_variable_value",
        "title": "set_variable_value",
        "section": "set_variable_value",
        "text": "Set a variable to a new value.\nVariable name.\nNew value.\nset_variable_value\npython:str\npython:str\npython:int\npython:float\ncomplex\nValue"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.set_variable_value",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.set_variable_value.html#pyedb.grpc.database.layout.layout.Layout.set_variable_value",
        "title": "set_variable_value > set_variable_value > set_variable_value",
        "section": "set_variable_value > set_variable_value",
        "text": "Layout.set_variable_value(name, new_value)\n\nSet a variable to a new value.\n\nParameters\n\nname\n\npython:str\n\nVariable name.\n\nnew_value\n\npython:str, python:int, python:float, complex, Value\n\nNew value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.points",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.points.html#points",
        "title": "points",
        "section": "points",
        "text": "Return the list of points with arcs converted to segments.\nNumber of facets to convert an arc. Default is 6.\n(X, Y).\npoints\npython:int\npython:tuple\npython:float\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.points",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.points.html#pyedb.grpc.database.primitive.circle.Circle.points",
        "title": "points > points > points",
        "section": "points > points",
        "text": "Circle.points(arc_segments=6) -> tuple[float, float]\n\nReturn the list of points with arcs converted to segments.\n\nParameters\n\narc_segments\n\npython:int\n\nNumber of facets to convert an arc. Default is 6.\n\nReturns\n\npython:tuple(python:float, python:float)\n\n(X, Y).\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "troubleshooting",
        "href": "troubleshooting.html#troubleshooting",
        "title": "Troubleshooting",
        "section": "Troubleshooting",
        "text": "Troubleshooting"
    },
    {
        "objectID": "troubleshooting",
        "href": "troubleshooting.html#common-issues-and-solutions",
        "title": "Troubleshooting > Common Issues and Solutions",
        "section": "Common Issues and Solutions",
        "text": "### “Cannot connect to ansys-edb-core service”\n*   Cause: The ansys-edb-core service is not installed or running.\n*   Solution:\nOn Windows with AEDT: Ensure AEDT is properly installed.\nOn Linux/Windows standalone: Ensure the standalone ansys-edb-core service is installed and running. Contact Ansys support for the installer.\n### “The grpc channel is in state TRANSIENT_FAILURE”\n*   Cause: The connection to the gRPC server failed or was interrupted.\n*   Solution:\nCheck if the server process is running.\nRestart the service or your machine.\nCheck firewall settings that might be blocking gRPC communication.\n### “EDBError: Operation not permitted” or permission errors\n*   Cause: The client doesn’t have permission to access the specified EDB directory.\n*   Solution: Check filesystem permissions on the EDB path, especially when running in Docker or on Linux servers.\n### Script runs slowly when creating many geometries\n*   Cause: Using many individual create_rectangle or create_path calls is inefficient.\n*   Solution: Use batch operations where possible, or create complex polygons instead of many simple shapes.\nCommon Issues and Solutions\nansys-edb-core\nansys-edb-core\ncreate_rectangle\ncreate_path"
    },
    {
        "objectID": "troubleshooting",
        "href": "troubleshooting.html#getting-help",
        "title": "Troubleshooting > Getting Help",
        "section": "Getting Help",
        "text": "If you encounter an issue not covered here:\nSearch existing issues: Check the GitHub Issues to see if your problem has already been reported.\nCreate a new issue: Provide a minimal reproducible example, error messages, and information about your environment (OS, PyEDB version, ansys-edb-core version).\nAsk the community: Start a discussion on GitHub Discussions.\nGetting Help"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_variable_value",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_variable_value.html#get_variable_value",
        "title": "get_variable_value",
        "section": "get_variable_value",
        "text": "Added to get closer architecture as for grpc.\nget_variable_value"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_variable_value",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_variable_value.html#pyedb.dotnet.edb.Edb.get_variable_value",
        "title": "get_variable_value > get_variable_value > get_variable_value",
        "section": "get_variable_value > get_variable_value",
        "text": "Edb.get_variable_value(variable_name)\n\nAdded to get closer architecture as for grpc.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "user_guide/core_concepts",
        "href": "user_guide/core_concepts.html#core-concepts",
        "title": "Core Concepts",
        "section": "Core Concepts",
        "text": "Understanding the client-server architecture and the EDB object hierarchy is key to working effectively with PyEDB.\nCore Concepts"
    },
    {
        "objectID": "user_guide/core_concepts",
        "href": "user_guide/core_concepts.html#architecture-client-server-model",
        "title": "Core Concepts > Architecture: Client-Server Model",
        "section": "Architecture: Client-Server Model",
        "text": "PyEDB operates on a client-server model:\nClient (Your Script): The lightweight pyedb Python package. It contains the high-level API and sends commands.\nServer (The Engine): The RPC service. It holds the actual EDB data, performs all computations on EDB.\nYour EDB project exists on the server. The client is a remote control. This is why PyEDB can be so lightweight and\nrun on systems without the full Ansys computational engine.\nArchitecture: Client-Server Model"
    },
    {
        "objectID": "user_guide/core_concepts",
        "href": "user_guide/core_concepts.html#the-edb-hierarchy",
        "title": "Core Concepts > The EDB Hierarchy",
        "section": "The EDB Hierarchy",
        "text": "The object model within the EDB server remains the same:\nEDB Project: The top-level object, representing the entire .edb file on the server.\n*   Cell: Represents the PCB design itself.\nLayout: The container for all the physical data.\n*   Stackup: The definition of layers.\n*   Primitives: The basic geometric shapes.\nNet List: The collection of all electrical nets.\nComponent List: The collection of all components.\nSimulation Setup: Definitions for how to analyze the design.\nKey PyEDB client classes (like Edb, Nets, Components) are handles or proxies that send commands to the\ncorresponding objects inside the server.\nThe EDB Hierarchy"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.save",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.save.html#save",
        "title": "save",
        "section": "save",
        "text": "Save the EDB file.\nTrue when successful, False when failed.\nsave\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.save",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.save.html#pyedb.dotnet.edb.Edb.save",
        "title": "save > save > save",
        "section": "save > save",
        "text": "Edb.save()\n\nSave the EDB file.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the terminal object to the correct concrete type, fetching the type if necessary.\ncast\nTerminalType\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.cast.html#pyedb.grpc.database.ports.ports.CoaxPort.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "CoaxPort.cast(term_type=None)\n\nCast the terminal object to the correct concrete type, fetching the type if necessary.\n\nParameters\n\nterm_type\n\nTerminalType\n\n\n\nReturns\n\nTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_dump",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#python-mode)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude: A set of fields to include in the output.\nexclude: A set of fields to exclude from the output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\nA dictionary representation of the model.\nmodel_dump"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_dump",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_dump.html#pyedb.workflows.drc.drc.BackDrillStubLength.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "BackDrillStubLength.model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -> dict[str, Any]\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#python-mode)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n\nmode: The mode in which to_python should run.\n\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude: A set of fields to include in the output.\nexclude: A set of fields to exclude from the output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\n\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\n\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback: A function to call when an unknown value is encountered. If not provided,\n\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_current_source_on_net",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_current_source_on_net.html#create_current_source_on_net",
        "title": "create_current_source_on_net",
        "section": "create_current_source_on_net",
        "text": "Create a current source.\nName of the positive component.\nName of the positive net.\nName of the negative component. The default is None, in which case the name of\nthe positive net is assigned.\nName of the negative net. The default is \"GND\".\nValue for the current. The default is 0.1.\nValue for the phase. The default is 0.\nName of the source. The default is \"\".\nSource Name.\ncreate_current_source_on_net\npython:str\npython:str\npython:str\noptional\nNone\npython:str\noptional\n\"GND\"\npython:float\noptional\n0.1\noptional\n0\npython:str\noptional\n\"\"\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_current_source_on_net",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_current_source_on_net.html#pyedb.dotnet.database.hfss.EdbHfss.create_current_source_on_net",
        "title": "create_current_source_on_net > create_current_source_on_net > create_current_source_on_net",
        "section": "create_current_source_on_net > create_current_source_on_net",
        "text": "EdbHfss.create_current_source_on_net(positive_component_name, positive_net_name, negative_component_name=None, negative_net_name='GND', current_value=0.1, phase_value=0, source_name='')\n\nCreate a current source.\n\nParameters\n\npositive_component_name\n\npython:str\n\nName of the positive component.\n\npositive_net_name\n\npython:str\n\nName of the positive net.\n\nnegative_component_name\n\npython:str, optional\n\nName of the negative component. The default is None, in which case the name of\nthe positive net is assigned.\n\nnegative_net_name\n\npython:str, optional\n\nName of the negative net. The default is \"GND\".\n\ncurrent_value\n\npython:float, optional\n\nValue for the current. The default is 0.1.\n\nphase_value\n\noptional\n\nValue for the phase. The default is 0.\n\nsource_name\n\npython:str, optional\n\nName of the source. The default is \"\".\n\nReturns\n\npython:str\n\nSource Name.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", \"project name\", \"release version\")\n>>> edb.hfss.create_current_source_on_net(\"U2A5\", \"V1P5_S3\", \"U2A5\", \"GND\", 0.1, 0, \"source_name\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.set_variable_desc",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.set_variable_desc.html#set_variable_desc",
        "title": "set_variable_desc",
        "section": "set_variable_desc",
        "text": "Set a variable to have a new description.\nVariable name.\nNew variable description.\nset_variable_desc\npython:str\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.set_variable_desc",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.set_variable_desc.html#pyedb.grpc.database.layout.layout.Layout.set_variable_desc",
        "title": "set_variable_desc > set_variable_desc > set_variable_desc",
        "section": "set_variable_desc > set_variable_desc",
        "text": "Layout.set_variable_desc(name, desc)\n\nSet a variable to have a new description.\n\nParameters\n\nname\n\npython:str\n\nVariable name.\n\ndesc\n\npython:str\n\nNew variable description.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_dump",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#python-mode)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude: A set of fields to include in the output.\nexclude: A set of fields to exclude from the output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\nA dictionary representation of the model.\nmodel_dump"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_dump",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_dump.html#pyedb.grpc.database.definition.materials.MaterialProperties.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "MaterialProperties.model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -> dict[str, Any]\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#python-mode)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n\nmode: The mode in which to_python should run.\n\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude: A set of fields to include in the output.\nexclude: A set of fields to exclude from the output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\n\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\n\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback: A function to call when an unknown value is encountered. If not provided,\n\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_icepak_project",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_icepak_project.html#export_icepak_project",
        "title": "export_icepak_project",
        "section": "export_icepak_project",
        "text": "Exports an Icepak project for standalone use.\nPath of the Icepak project.\nName of the DC simulation.\nTrue when successful, False when failed.\nexport_icepak_project\npython:str\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_icepak_project",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.export_icepak_project.html#pyedb.siwave.Siwave.export_icepak_project",
        "title": "export_icepak_project > export_icepak_project > export_icepak_project",
        "section": "export_icepak_project > export_icepak_project",
        "text": "Siwave.export_icepak_project(file_path, dc_simulation_name)\n\nExports an Icepak project for standalone use.\n\nParameters\n\nfile_path\n\nstr,\n\nPath of the Icepak project.\n\ndc_simulation_name\n\npython:str\n\nName of the DC simulation.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_rectangle_in_pad",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_rectangle_in_pad.html#create_rectangle_in_pad",
        "title": "create_rectangle_in_pad",
        "section": "create_rectangle_in_pad",
        "text": "Create a rectangle inscribed inside a padstack instance pad.\nThe rectangle is fully inscribed in the pad and has the maximum area.\nIt is necessary to specify the layer on which the rectangle will be created.\nName of the layer on which to create the polygon.\nIf True does not create the rectangle and just returns a list containing the rectangle vertices.\nDefault is False.\nOrder of the lattice partition used to find the quasi-lattice polygon that approximates polygon.\nDefault is 16.\nPolygon when successful, False when failed, list of list if return_points=True.\ncreate_rectangle_in_pad\npython:str\noptional\npython:float\noptional\npolygon\n16\nList\nPrimitive\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_rectangle_in_pad",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_rectangle_in_pad.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_rectangle_in_pad",
        "title": "create_rectangle_in_pad > create_rectangle_in_pad > create_rectangle_in_pad",
        "section": "create_rectangle_in_pad > create_rectangle_in_pad",
        "text": "PadstackInstance.create_rectangle_in_pad(layer_name, return_points=False, partition_max_order=16)\n\nCreate a rectangle inscribed inside a padstack instance pad.\n\nThe rectangle is fully inscribed in the pad and has the maximum area.\nIt is necessary to specify the layer on which the rectangle will be created.\n\nParameters\n\nlayer_name\n\npython:str\n\nName of the layer on which to create the polygon.\n\nreturn_points\n\nbool, optional\n\nIf True does not create the rectangle and just returns a list containing the rectangle vertices.\nDefault is False.\n\npartition_max_order\n\npython:float, optional\n\nOrder of the lattice partition used to find the quasi-lattice polygon that approximates polygon.\nDefault is 16.\n\nReturns\n\nbool, List, Primitive\n\nPolygon when successful, False when failed, list of list if return_points=True.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", edbversion=\"2021.2\")\n>>> edb_layout = edbapp.modeler\n>>> list_of_padstack_instances = list(edbapp.padstacks.instances.values())\n>>> padstack_inst = list_of_padstack_instances[0]\n>>> padstack_inst.create_rectangle_in_pad(\"TOP\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_pad_edge_terminal_reference_pin",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_pad_edge_terminal_reference_pin.html#get_pad_edge_terminal_reference_pin",
        "title": "get_pad_edge_terminal_reference_pin",
        "section": "get_pad_edge_terminal_reference_pin",
        "text": "Get the closest pin padstack instances and serves any edge terminal connected to a pad.\nPreferred reference net name. Optianal, default is None which will auto compute the gnd name.\nget_pad_edge_terminal_reference_pin\npython:str\noptional\nPadstackInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_pad_edge_terminal_reference_pin",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.get_pad_edge_terminal_reference_pin.html#pyedb.grpc.database.terminal.terminal.Terminal.get_pad_edge_terminal_reference_pin",
        "title": "get_pad_edge_terminal_reference_pin > get_pad_edge_terminal_reference_pin > get_pad_edge_terminal_reference_pin",
        "section": "get_pad_edge_terminal_reference_pin > get_pad_edge_terminal_reference_pin",
        "text": "Terminal.get_pad_edge_terminal_reference_pin(gnd_net_name_preference=None) -> PadstackInstance\n\nGet the closest pin padstack instances and serves any edge terminal connected to a pad.\n\nParameters\n\ngnd_net_name_preference\n\npython:str, optional\n\nPreferred reference net name. Optianal, default is None which will auto compute the gnd name.\n\nReturns\n\nPadstackInstance\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/siwave_simulation_setup",
        "href": "dotnet_api/dotnet/utilities/siwave_simulation_setup.html#siwave-simulation-setup",
        "title": "SIwave simulation setup",
        "section": "SIwave simulation setup",
        "text": "These classes are the containers of siwave simulation setup.\nSiwaveSimulationSetup\nManages EDB methods for SIwave simulation setup.\nSiwaveDCSimulationSetup\nManages EDB methods for SIwave DC simulation setup.\nSIwave simulation setup\nSiwaveSimulationSetup\nSiwaveDCSimulationSetup"
    },
    {
        "objectID": "grpc_api/grpc/database/components",
        "href": "grpc_api/grpc/database/components.html#components",
        "title": "Components",
        "section": "Components",
        "text": "These class is the containers of Components.\ncomponents.Components\nManages EDB components and related methods accessible from Edb.components.\nComponents\ncomponents.Components"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileMeshOp",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileMeshOp.html#controlfilemeshop",
        "title": "ControlFileMeshOp",
        "section": "ControlFileMeshOp",
        "text": "Represents a mesh operation.\nOperation name.\nRegion name.\nOperation type (“MeshOperationLength” or “MeshOperationSkinDepth”).\nDictionary of nets and layers.\nControlFileMeshOp\npython:str\npython:str\npython:str\npython:dict"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileMeshOp",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileMeshOp.html#pyedb.grpc.database.control_file.ControlFileMeshOp",
        "title": "ControlFileMeshOp > ControlFileMeshOp > ControlFileMeshOp",
        "section": "ControlFileMeshOp > ControlFileMeshOp",
        "text": "class pyedb.grpc.database.control_file.ControlFileMeshOp(name: str, region: str, type: str, nets_layers: Dict[str, str])\n\nRepresents a mesh operation.\n\nParameters\n\nname\n\npython:str\n\nOperation name.\n\nregion\n\npython:str\n\nRegion name.\n\ntype\n\npython:str\n\nOperation type (“MeshOperationLength” or “MeshOperationSkinDepth”).\n\nnets_layers\n\npython:dict\n\nDictionary of nets and layers.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.get_product_property_ids.html#pyedb.grpc.database.primitive.circle.Circle.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "Circle.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.find_by_name",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.find_by_name.html#find_by_name",
        "title": "find_by_name",
        "section": "find_by_name",
        "text": "Edb Dotnet Api Database Edb.Net.FindByName.\nfind_by_name"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.find_by_name",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.find_by_name.html#pyedb.dotnet.database.edb_data.nets_data.EDBNetsData.find_by_name",
        "title": "find_by_name > find_by_name > find_by_name",
        "section": "find_by_name > find_by_name",
        "text": "EDBNetsData.find_by_name(layout, net)\n\nEdb Dotnet Api Database Edb.Net.FindByName.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_validate_strings",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj: The object containing string data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nThe validated Pydantic model.\nmodel_validate_strings"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_validate_strings",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_validate_strings.html#pyedb.workflows.drc.drc.Rules.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod Rules.model_validate_strings(obj: Any, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\nValidate the given object with string data against the Pydantic model.\n\nArgs:\n\nobj: The object containing string data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nReturns:\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_end_elevation",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_end_elevation.html#set_end_elevation",
        "title": "set_end_elevation",
        "section": "set_end_elevation",
        "text": "Set the end elevation of the bondwire.\nEnd cell context of the bondwire. None means top-level.\nEnd layer of the bondwire.\nset_end_elevation\nCellInstance\nNone"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_end_elevation",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_end_elevation.html#pyedb.grpc.database.primitive.bondwire.Bondwire.set_end_elevation",
        "title": "set_end_elevation > set_end_elevation > set_end_elevation",
        "section": "set_end_elevation > set_end_elevation",
        "text": "Bondwire.set_end_elevation(end_context: CellInstance, layer: LayerLike)\n\nSet the end elevation of the bondwire.\n\nParameters\n\nend_context\n\nCellInstance\n\nEnd cell context of the bondwire. None means top-level.\n\nlayer\n\nLayerLike\n\nEnd layer of the bondwire.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_validate",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj: The object to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\nfrom_attributes: Whether to extract data from object attributes.\ncontext: Additional context to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nValidationError: If the object could not be validated.\nThe validated model instance.\nmodel_validate"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_validate",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_validate.html#pyedb.grpc.database.definition.materials.MaterialProperties.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod MaterialProperties.model_validate(obj: Any, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\nValidate a pydantic model instance.\n\nArgs:\n\nobj: The object to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\nfrom_attributes: Whether to extract data from object attributes.\ncontext: Additional context to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nRaises:\n\nValidationError: If the object could not be validated.\n\nReturns:\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlCircuitPt",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlCircuitPt.html#controlcircuitpt",
        "title": "ControlCircuitPt",
        "section": "ControlCircuitPt",
        "text": "Circuit Port.\nControlCircuitPt"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlCircuitPt",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlCircuitPt.html#pyedb.grpc.database.utility.xml_control_file.ControlCircuitPt",
        "title": "ControlCircuitPt > ControlCircuitPt > ControlCircuitPt",
        "section": "ControlCircuitPt > ControlCircuitPt",
        "text": "class pyedb.grpc.database.utility.xml_control_file.ControlCircuitPt(name, x1, y1, lay1, x2, y2, lay2, z0)\n\nCircuit Port.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.adaptive_frequency.AdaptiveFrequency",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.adaptive_frequency.AdaptiveFrequency.html#adaptivefrequency",
        "title": "AdaptiveFrequency",
        "section": "AdaptiveFrequency",
        "text": "EDB-core Adaptive Frequency class.\nAdaptiveFrequency"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.adaptive_frequency.AdaptiveFrequency",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.adaptive_frequency.AdaptiveFrequency.html#pyedb.grpc.database.simulation_setup.adaptive_frequency.AdaptiveFrequency",
        "title": "AdaptiveFrequency > AdaptiveFrequency > AdaptiveFrequency",
        "section": "AdaptiveFrequency > AdaptiveFrequency",
        "text": "class pyedb.grpc.database.simulation_setup.adaptive_frequency.AdaptiveFrequency(adaptive_frequency)\n\nEDB-core Adaptive Frequency class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.add_adaptive_frequency_data",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.add_adaptive_frequency_data.html#add_adaptive_frequency_data",
        "title": "add_adaptive_frequency_data",
        "section": "add_adaptive_frequency_data",
        "text": "Add adaptive frequency data to simulation setup.\nAdaptive frequency value.\nMaximum delta S value.\nadd_adaptive_frequency_data\npython:str\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.add_adaptive_frequency_data",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.add_adaptive_frequency_data.html#pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.add_adaptive_frequency_data",
        "title": "add_adaptive_frequency_data > add_adaptive_frequency_data > add_adaptive_frequency_data",
        "section": "add_adaptive_frequency_data > add_adaptive_frequency_data",
        "text": "HfssSimulationSetup.add_adaptive_frequency_data(frequency='5GHz', max_delta_s='0.01')\n\nAdd adaptive frequency data to simulation setup.\n\nParameters\n\nfrequency\n\npython:str\n\nAdaptive frequency value.\n\nmax_delta_s\n\npython:str\n\nMaximum delta S value.\n\nReturns\n\nbool.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product-specific property of the cell.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product-specific property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.get_product_property.html#pyedb.grpc.database.layout.cell.Cell.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "Cell.get_product_property(prod_id, attr_id)\n\nGet the product-specific property of the cell.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product-specific property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/hfss_simulation_settings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/hfss_simulation_settings.html#hfss-simulation-settings",
        "title": "HFSS simulation settings",
        "section": "HFSS simulation settings",
        "text": "This class is managing EDB HFSS simulation settings.\nHFSSSimulationSettings\nPyEDB-core HFSS simulation settings class.\nHFSS simulation settings\nHFSSSimulationSettings"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_through_resistor_list",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_through_resistor_list.html#get_through_resistor_list",
        "title": "get_through_resistor_list",
        "section": "get_through_resistor_list",
        "text": "Retrieve through resistors.\nThreshold value. The default is 1.\nList of through resistors.\nget_through_resistor_list\npython:int\noptional\n1\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_through_resistor_list",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_through_resistor_list.html#pyedb.dotnet.database.components.Components.get_through_resistor_list",
        "title": "get_through_resistor_list > get_through_resistor_list > get_through_resistor_list",
        "section": "get_through_resistor_list > get_through_resistor_list",
        "text": "Components.get_through_resistor_list(threshold=1)\n\nRetrieve through resistors.\n\nParameters\n\nthreshold\n\npython:int, optional\n\nThreshold value. The default is 1.\n\nReturns\n\npython:list\n\nList of through resistors.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", \"project name\", \"release version\")\n>>> edbapp.components.get_through_resistor_list()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFile.parse_technology",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFile.parse_technology.html#parse_technology",
        "title": "parse_technology",
        "section": "parse_technology",
        "text": "Parse technology files using Helic and convert it to xml file.\nFull path to technology file.\nparse_technology\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFile.parse_technology",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFile.parse_technology.html#pyedb.grpc.database.utility.xml_control_file.ControlFile.parse_technology",
        "title": "parse_technology > parse_technology > parse_technology",
        "section": "parse_technology > parse_technology",
        "text": "ControlFile.parse_technology(tecnhology, edbversion=None)\n\nParse technology files using Helic and convert it to xml file.\n\nParameters\n\nlayer_map\n\npython:str\n\nFull path to technology file.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/job_manager/index",
        "href": "workflows/job_manager/index.html#job-manager",
        "title": "Job manager",
        "section": "Job manager",
        "text": "This section describes job manager features.\nJob manager"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_fields.html#pyedb.workflows.drc.drc.BackDrillStubLength.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "BackDrillStubLength.model_fields = {'name': FieldInfo(annotation=str, required=True), 'value': FieldInfo(annotation=str, required=True)}\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.SkinDepthMeshOperation",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.SkinDepthMeshOperation.html#skindepthmeshoperation",
        "title": "SkinDepthMeshOperation",
        "section": "SkinDepthMeshOperation",
        "text": "Mesh operation Skin Depth class.\nThis class is accessible from Hfss Setup in EDB and assign_skin_depth_mesh_operation method.\nSkinDepthMeshOperation"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.SkinDepthMeshOperation",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.mesh_operation.SkinDepthMeshOperation.html#pyedb.dotnet.database.sim_setup_data.data.mesh_operation.SkinDepthMeshOperation",
        "title": "SkinDepthMeshOperation > SkinDepthMeshOperation > SkinDepthMeshOperation",
        "section": "SkinDepthMeshOperation > SkinDepthMeshOperation",
        "text": "class pyedb.dotnet.database.sim_setup_data.data.mesh_operation.SkinDepthMeshOperation(parent, edb_object)\n\nMesh operation Skin Depth class.\nThis class is accessible from Hfss Setup in EDB and assign_skin_depth_mesh_operation method.\n\nExamples\n\n>>> mop = edbapp.setups[\"setup1a\"].add_skin_depth_mesh_operation({\"GND\": [\"TOP\", \"BOTTOM\"]})\n>>> mop.max_elements = 3000\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_rebuild",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce: Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors: Whether to raise errors, defaults to True.\n_parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n_types_namespace: The types namespace, defaults to None.\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_rebuild",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_rebuild.html#pyedb.workflows.drc.drc.MinClearance.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod MinClearance.model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -> bool | None\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n\nforce: Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors: Whether to raise errors, defaults to True.\n_parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n_types_namespace: The types namespace, defaults to None.\n\nReturns:\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.duplicate_across_layers",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.duplicate_across_layers.html#duplicate_across_layers",
        "title": "duplicate_across_layers",
        "section": "duplicate_across_layers",
        "text": "Duplicate across layer a primitive object.\nParameters:\nlist of str, with layer names\nTrue when successful, False when failed.\nduplicate_across_layers\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.duplicate_across_layers",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.duplicate_across_layers.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.duplicate_across_layers",
        "title": "duplicate_across_layers > duplicate_across_layers > duplicate_across_layers",
        "section": "duplicate_across_layers > duplicate_across_layers",
        "text": "EdbPolygon.duplicate_across_layers(layers)\n\nDuplicate across layer a primitive object.\n\nParameters:\n\nlayers: list\n\nlist of str, with layer names\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.html#edbpadstack",
        "title": "EDBPadstack",
        "section": "EDBPadstack",
        "text": "Manages EDB functionalities for a padstack.\nInherited AEDT object.\nEDBPadstack.convert_to_3d_microvias([...])\nConvert actual padstack instance to microvias 3D Objects with a given aspect ratio.\nEDBPadstack.split_to_microvias()\nConvert actual padstack definition to multiple microvias definitions.\nEDBPadstack\npython:str\nEDBPadstack.convert_to_3d_microvias\nEDBPadstack.split_to_microvias"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack",
        "title": "EDBPadstack > EDBPadstack > EDBPadstack",
        "section": "EDBPadstack > EDBPadstack",
        "text": "class pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack(edb_padstack, ppadstack)\n\nManages EDB functionalities for a padstack.\n\nParameters\n\nedb_padstack\n\n\n\nppadstack\n\npython:str\n\nInherited AEDT object.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb(myedb, edbversion=\"2021.2\")\n>>> edb_padstack = edb.padstacks.definitions[\"MyPad\"]\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nEDBPadstack.convert_to_3d_microvias([...])\n\nConvert actual padstack instance to microvias 3D Objects with a given aspect ratio.\n\nEDBPadstack.split_to_microvias()\n\nConvert actual padstack definition to multiple microvias definitions.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.add_void",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.add_void.html#add_void",
        "title": "add_void",
        "section": "add_void",
        "text": "Add a void to current primitive.\nTrue if successful, either  False.\nadd_void\npython:list\nPrimitive\npoint\npython:list\nin\nthe\nformat\nof\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.add_void",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.add_void.html#pyedb.grpc.database.primitive.path.Path.add_void",
        "title": "add_void > add_void > add_void",
        "section": "add_void > add_void",
        "text": "Path.add_void(point_list) -> bool\n\nAdd a void to current primitive.\n\nParameters\n\npoint_list\n\npython:list or Primitive             or point python:list in the format of [[x1,y1], [x2,y2],..,[xn,yn]].\n\n\n\nReturns\n\nbool\n\nTrue if successful, either  False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.execute",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.execute.html#execute",
        "title": "execute",
        "section": "execute",
        "text": "Execute a function.\nFunction to execute.\nTrue when successful, False when failed.\nexecute\npython:str\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.execute",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.execute.html#pyedb.dotnet.edb.Edb.execute",
        "title": "execute > execute > execute",
        "section": "execute > execute",
        "text": "Edb.execute(func)\n\nExecute a function.\n\nParameters\n\nfunc\n\npython:str\n\nFunction to execute.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.scale",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.scale.html#scale",
        "title": "scale",
        "section": "scale",
        "text": "Scales the polygon relative to a center point by a factor.\nScaling factor.\nIf None scaling is done from polygon center.\nTrue when successful, False when failed.\nscale\npython:float\nList\nof\npython:float\npython:str\noptional\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.scale",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.scale.html#pyedb.grpc.database.primitive.circle.Circle.scale",
        "title": "scale > scale > scale",
        "section": "scale > scale",
        "text": "Circle.scale(factor, center=None) -> bool\n\nScales the polygon relative to a center point by a factor.\n\nParameters\n\nfactor\n\npython:float\n\nScaling factor.\n\ncenter\n\nList of python:float or python:str [x,y], optional\n\nIf None scaling is done from polygon center.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.value",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.value.html#value",
        "title": "value",
        "section": "value",
        "text": "value"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.value",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.value.html#pyedb.workflows.drc.drc.BackDrillStubLength.value",
        "title": "value > value > value",
        "section": "value > value",
        "text": "BackDrillStubLength.value: str\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_connected_object_id_set",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_connected_object_id_set.html#get_connected_object_id_set",
        "title": "get_connected_object_id_set",
        "section": "get_connected_object_id_set",
        "text": "Produce a list of all geometries physically connected to a given layout object.\nFound connected objects IDs with Layout object.\nget_connected_object_id_set\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_connected_object_id_set",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_connected_object_id_set.html#pyedb.dotnet.database.edb_data.ports.WavePort.get_connected_object_id_set",
        "title": "get_connected_object_id_set > get_connected_object_id_set > get_connected_object_id_set",
        "section": "get_connected_object_id_set > get_connected_object_id_set",
        "text": "WavePort.get_connected_object_id_set()\n\nProduce a list of all geometries physically connected to a given layout object.\n\nReturns\n\npython:list\n\nFound connected objects IDs with Layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_validate_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data: The JSON data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nThe validated Pydantic model.\nValidationError: If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_validate_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_validate_json.html#pyedb.workflows.drc.drc.CopperBalance.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod CopperBalance.model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n\njson_data: The JSON data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nReturns:\n\nThe validated Pydantic model.\n\nRaises:\n\nValidationError: If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.pin_pairs",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.pin_pairs.html#pin_pairs",
        "title": "pin_pairs",
        "section": "pin_pairs",
        "text": "Get all pin pairs.\npin_pairs\npython:list\npython:tuple\npython:str\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.pin_pairs",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.pin_pairs.html#pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.pin_pairs",
        "title": "pin_pairs > pin_pairs > pin_pairs",
        "section": "pin_pairs > pin_pairs",
        "text": "PinPairModel.pin_pairs()\n\nGet all pin pairs.\n\nReturns\n\npython:list[python:tuple[python:str, python:str]]\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.point_data",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.point_data.html#point_data",
        "title": "point_data",
        "section": "point_data",
        "text": "Compute the Edb Point Data.\nX value.\nY value.\npoint_data\npython:float\npython:int\npython:str\npython:float\npython:int\npython:str\noptional\nGeometry.PointData"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.point_data",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.point_data.html#pyedb.dotnet.edb.Edb.point_data",
        "title": "point_data > point_data > point_data",
        "section": "point_data > point_data",
        "text": "Edb.point_data(x, y=None)\n\nCompute the Edb Point Data.\n\nParameters\n\nx\n\npython:float, python:int or python:str\n\nX value.\n\ny\n\npython:float, python:int or python:str, optional\n\nY value.\n\nReturns\n\nGeometry.PointData.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.create_3d_comp.html#create_3d_comp",
        "title": "create_3d_comp",
        "section": "create_3d_comp",
        "text": "Create a 3D composite model from an MCAD file.\n3D composite model created.\ncreate_3d_comp\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.create_3d_comp",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.create_3d_comp.html#pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.create_3d_comp",
        "title": "create_3d_comp > create_3d_comp > create_3d_comp",
        "section": "create_3d_comp > create_3d_comp",
        "text": "PinGroupTerminal.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nReturns\n\nMcadModel\n\n3D composite model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "construct"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.construct.html#pyedb.workflows.drc.drc.CopperBalance.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod CopperBalance.construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/path",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/path.html#path",
        "title": "Path",
        "section": "Path",
        "text": "This class is managing EDB path.\nPath\n\nPath\nPath"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.json.html#json",
        "title": "json",
        "section": "json",
        "text": "json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.json.html#pyedb.workflows.drc.drc.BackDrillStubLength.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "BackDrillStubLength.json(*, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -> str\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_back_drill_by_depth",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_back_drill_by_depth.html#get_back_drill_by_depth",
        "title": "get_back_drill_by_depth",
        "section": "get_back_drill_by_depth",
        "text": "Get back drill by depth parameters\nParameters\n———-\nfrom_bottom : bool, optional\nDefault value is True.\nget_back_drill_by_depth"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_back_drill_by_depth",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_back_drill_by_depth.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_back_drill_by_depth",
        "title": "get_back_drill_by_depth > get_back_drill_by_depth > get_back_drill_by_depth",
        "section": "get_back_drill_by_depth > get_back_drill_by_depth",
        "text": "PadstackInstance.get_back_drill_by_depth(from_bottom=True) -> tuple[float, float]\n\nGet back drill by depth parameters\nParameters\n———-\nfrom_bottom : bool, optional\n\nDefault value is True.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.definitions.Definitions.add_package_def",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.definitions.Definitions.add_package_def.html#add_package_def",
        "title": "add_package_def",
        "section": "add_package_def",
        "text": "Add a package definition.\nName of the package definition.\nPart name of the component.\nBoundary points which define the shape of the package.\nExample 1: Create package using component’s bounding box\n>>> comp_def = edb.definitions.add_package_def(“QFP64”, “QFP64_COMPONENT”)\n>>> if comp_def:  # Check if created successfully\n…     print(f”Created package: {comp_def.name}”)\nExample 2: Create package with custom boundary\n>>> boundary = [[0, 0], [10e-3, 0], [10e-3, 10e-3], [0, 10e-3]]\n>>> custom_pkg = edb.definitions.add_package_def(“CustomIC”, boundary_points=boundary)\n>>> if custom_pkg:\n…     print(f”Custom package boundary: {custom_pkg.exterior_boundary}”)\nadd_package_def\npython:str\noptional\npython:list\noptional\nPackageDef"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.definitions.Definitions.add_package_def",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.definitions.Definitions.add_package_def.html#pyedb.grpc.database.definitions.Definitions.add_package_def",
        "title": "add_package_def > add_package_def > add_package_def",
        "section": "add_package_def > add_package_def",
        "text": "Definitions.add_package_def(name: str, component_part_name: str | None = None, boundary_points: List[List[float]] | None = None) -> PackageDef | bool\n\nAdd a package definition.\n\nParameters\n\nname: str\n\nName of the package definition.\n\ncomponent_part_name\n\npython:str, optional\n\nPart name of the component.\n\nboundary_points\n\npython:list, optional\n\nBoundary points which define the shape of the package.\n\nReturns\n\nPackageDef object.\n\n\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n\nExample 1: Create package using component’s bounding box\n>>> comp_def = edb.definitions.add_package_def(“QFP64”, “QFP64_COMPONENT”)\n>>> if comp_def:  # Check if created successfully\n…     print(f”Created package: {comp_def.name}”)\n\nExample 2: Create package with custom boundary\n>>> boundary = [[0, 0], [10e-3, 0], [10e-3, 10e-3], [0, 10e-3]]\n>>> custom_pkg = edb.definitions.add_package_def(“CustomIC”, boundary_points=boundary)\n>>> if custom_pkg:\n…     print(f”Custom package boundary: {custom_pkg.exterior_boundary}”)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.point_data",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.point_data.html#point_data",
        "title": "point_data",
        "section": "point_data",
        "text": "Create 2D point.\nX coordinate or PointData object.\nY coordinate.\n2D point object.\npoint_data\npython:float\npython:int\npython:str\nPointData\npython:float\npython:int\npython:str\noptional\nPointData"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.point_data",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.point_data.html#pyedb.grpc.edb.Edb.point_data",
        "title": "point_data > point_data > point_data",
        "section": "point_data > point_data",
        "text": "Edb.point_data(x, y=None)\n\nCreate 2D point.\n\nParameters\n\nx\n\npython:float, python:int, python:str or PointData\n\nX coordinate or PointData object.\n\ny\n\npython:float, python:int, python:str, optional\n\nY coordinate.\n\nReturns\n\nPointData\n\n2D point object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.update_layout",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.update_layout.html#update_layout",
        "title": "update_layout",
        "section": "update_layout",
        "text": "Set layer collection into edb.\nupdate_layout"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.update_layout",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.update_layout.html#pyedb.dotnet.database.stackup.Stackup.update_layout",
        "title": "update_layout > update_layout > update_layout",
        "section": "update_layout > update_layout",
        "text": "Stackup.update_layout()\n\nSet layer collection into edb.\n\nParameters\n\nstackup\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.html#coaxport",
        "title": "CoaxPort",
        "section": "CoaxPort",
        "text": "Manages bundle wave port properties.\nEDB object from the Edblib library.\nPadstackInstanceTerminal instance from EDB.\nCoaxPort.cast([term_type])\nCast the terminal object to the correct concrete type, fetching the type if necessary.\nCoaxPort.create(layout, name, ...[, is_ref])\nCreate a padstack instance terminal.\nCoaxPort.create_3d_comp()\nCreate a 3D composite model from an MCAD file.\nCoaxPort.create_hfss()\nCreate an HFSS model from an MCAD file.\nCoaxPort.create_stride()\nCreate a Stride model from an MCAD file.\nCoaxPort.delete()\nDelete the layout object.\nCoaxPort.find(layout, name)\nFind a terminal by name in a given layout.\nCoaxPort.find_by_id(layout, uid)\nFind a Connectable object by database ID in a given layout.\nCoaxPort.get_product_property(prod_id, attr_id)\nGet the product property of the layout object for a given product ID and attribute ID.\nCoaxPort.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nCoaxPort.product_solver_names(product_id)\nGet the list of solver names.\nCoaxPort.product_solver_option(product_id, ...)\nGet the name of the product solver option.\nCoaxPort.set_product_property(prod_id, ...)\nSet the product property of the layout object for a given product ID and attribute ID.\nCoaxPort.set_product_solver_option(...)\nSet the product solver option.\nCoaxPort.layout_obj_type\n\nCoaxPort.type\n\nCoaxPort\npyedb.edb.Edb\nEdblib\nAnsys.Ansoft.Edb.Cell.Terminal.PadstackInstanceTerminal\nCoaxPort.cast\nCoaxPort.create\nCoaxPort.create_3d_comp\nCoaxPort.create_hfss\nCoaxPort.create_stride\nCoaxPort.delete\nCoaxPort.find\nCoaxPort.find_by_id\nCoaxPort.get_product_property\nCoaxPort.get_product_property_ids\nCoaxPort.product_solver_names\nCoaxPort.product_solver_option\nCoaxPort.set_product_property\nCoaxPort.set_product_solver_option\nCoaxPort.layout_obj_type\nCoaxPort.type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.html#pyedb.grpc.database.ports.ports.CoaxPort",
        "title": "CoaxPort > CoaxPort > CoaxPort",
        "section": "CoaxPort > CoaxPort",
        "text": "class pyedb.grpc.database.ports.ports.CoaxPort(pedb, edb_object)\n\nManages bundle wave port properties.\n\nParameters\n\npedb\n\npyedb.edb.Edb\n\nEDB object from the Edblib library.\n\nedb_object\n\nAnsys.Ansoft.Edb.Cell.Terminal.PadstackInstanceTerminal\n\nPadstackInstanceTerminal instance from EDB.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nCoaxPort.cast([term_type])\n\nCast the terminal object to the correct concrete type, fetching the type if necessary.\n\nCoaxPort.create(layout, name, ...[, is_ref])\n\nCreate a padstack instance terminal.\n\nCoaxPort.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nCoaxPort.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nCoaxPort.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nCoaxPort.delete()\n\nDelete the layout object.\n\nCoaxPort.find(layout, name)\n\nFind a terminal by name in a given layout.\n\nCoaxPort.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nCoaxPort.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nCoaxPort.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nCoaxPort.product_solver_names(product_id)\n\nGet the list of solver names.\n\nCoaxPort.product_solver_option(product_id, ...)\n\nGet the name of the product solver option.\n\nCoaxPort.set_product_property(prod_id, ...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nCoaxPort.set_product_solver_option(...)\n\nSet the product solver option.\n\n\n\nAttributes\n\n\n\n\n\n\n\nCoaxPort.layout_obj_type\n\n\n\nCoaxPort.type\n\n\n\n"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.json.html#json",
        "title": "json",
        "section": "json",
        "text": "json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.json.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "DiffPairLengthMatch.json(*, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -> str\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.expand",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.expand.html#expand",
        "title": "expand",
        "section": "expand",
        "text": "Expand the polygon shape by an absolute value in all direction.\nOffset can be negative for negative expansion.\nOffset value in meters.\nTolerance in meters.\nWhether to round corners or not.\nIf True, use rounded corners in the expansion otherwise use straight edges (can be degenerate).\nThe maximum corner extension (when round corners are not used) at which point the corner is clipped.\nexpand\npython:float\noptional\npython:float\noptional\noptional\npython:float\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.expand",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.expand.html#pyedb.grpc.database.primitive.path.Path.expand",
        "title": "expand > expand > expand",
        "section": "expand > expand",
        "text": "Path.expand(offset=0.001, tolerance=1e-12, round_corners=True, maximum_corner_extension=0.001) -> list[any]\n\nExpand the polygon shape by an absolute value in all direction.\nOffset can be negative for negative expansion.\n\nParameters\n\noffset\n\npython:float, optional\n\nOffset value in meters.\n\ntolerance\n\npython:float, optional\n\nTolerance in meters.\n\nround_corners\n\nbool, optional\n\nWhether to round corners or not.\nIf True, use rounded corners in the expansion otherwise use straight edges (can be degenerate).\n\nmaximum_corner_extension\n\npython:float, optional\n\nThe maximum corner extension (when round corners are not used) at which point the corner is clipped.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.residual_copper_area_per_layer",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.residual_copper_area_per_layer.html#residual_copper_area_per_layer",
        "title": "residual_copper_area_per_layer",
        "section": "residual_copper_area_per_layer",
        "text": "Report residual copper area per layer in percentage.\nCopper area per layer.\nresidual_copper_area_per_layer\npython:dict"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.residual_copper_area_per_layer",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.residual_copper_area_per_layer.html#pyedb.dotnet.database.stackup.Stackup.residual_copper_area_per_layer",
        "title": "residual_copper_area_per_layer > residual_copper_area_per_layer > residual_copper_area_per_layer",
        "section": "residual_copper_area_per_layer > residual_copper_area_per_layer",
        "text": "Stackup.residual_copper_area_per_layer()\n\nReport residual copper area per layer in percentage.\n\nReturns\n\npython:dict\n\nCopper area per layer.\n\nExamples\n\n>>> edb = Edb(edbpath=targetfile1, edbversion=\"2021.2\")\n>>> edb.stackup.residual_copper_area_per_layer()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_product_property_ids",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs for a given product ID for the layer collection.\nProduct ID.\nList of attribute IDs for the given product ID.\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_product_property_ids",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.get_product_property_ids.html#pyedb.grpc.database.stackup.Stackup.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "Stackup.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs for a given product ID for the layer collection.\n\nParameters\n\nprod_id\n\nProductIdType\n\nProduct ID.\n\nReturns\n\npython:list[python:int]\n\nList of attribute IDs for the given product ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.sin",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.sin.html#sin",
        "title": "sin",
        "section": "sin",
        "text": "Sine of the value.\nsin"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.sin",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.sin.html#pyedb.grpc.database.utility.value.Value.sin",
        "title": "sin > sin > sin",
        "section": "sin > sin",
        "text": "Value.sin()\n\nSine of the value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.html#layer",
        "title": "Layer",
        "section": "Layer",
        "text": "Manages Layer.\nLayer.cast()\nCast the layer object to the correct concrete type.\nLayer.clone([copy_id])\nCreate a clone of the layer.\nLayer.create(name, lyr_type)\nCreate a non-stackup layer.\nLayer.get_product_property(prod_id, attr_it)\nGet the product property of the layer for a given product ID and attribute ID.\nLayer.get_product_property_ids(prod_id)\nGet a list of attribute IDs for a given product ID for the layer.\nLayer.is_in_zone(zone)\nDetermine if the layer exists in the given zone.\nLayer.set_is_in_zone(zone[, in_zone])\nSet whether the layer exists in a given zone.\nLayer.set_product_property(prod_id, attr_it, ...)\nSet the product property of the layer for a given product ID and attribute ID.\nLayer.update(**kwargs)\n\nLayer.layout_obj_type\n\nLayer\nLayer.cast\nLayer.clone\nLayer.create\nLayer.get_product_property\nLayer.get_product_property_ids\nLayer.is_in_zone\nLayer.set_is_in_zone\nLayer.set_product_property\nLayer.update\nLayer.layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.html#pyedb.grpc.database.layers.layer.Layer",
        "title": "Layer > Layer > Layer",
        "section": "Layer > Layer",
        "text": "class pyedb.grpc.database.layers.layer.Layer(pedb, edb_object=None, name='', layer_type='undefined', **kwargs)\n\nManages Layer.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nLayer.cast()\n\nCast the layer object to the correct concrete type.\n\nLayer.clone([copy_id])\n\nCreate a clone of the layer.\n\nLayer.create(name, lyr_type)\n\nCreate a non-stackup layer.\n\nLayer.get_product_property(prod_id, attr_it)\n\nGet the product property of the layer for a given product ID and attribute ID.\n\nLayer.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs for a given product ID for the layer.\n\nLayer.is_in_zone(zone)\n\nDetermine if the layer exists in the given zone.\n\nLayer.set_is_in_zone(zone[, in_zone])\n\nSet whether the layer exists in a given zone.\n\nLayer.set_product_property(prod_id, attr_it, ...)\n\nSet the product property of the layer for a given product ID and attribute ID.\n\nLayer.update(**kwargs)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nLayer.layout_obj_type\n\n\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.delete_frequency_sweep",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.delete_frequency_sweep.html#delete_frequency_sweep",
        "title": "delete_frequency_sweep",
        "section": "delete_frequency_sweep",
        "text": "Delete a frequency sweep.\ndelete_frequency_sweep"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.delete_frequency_sweep",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.delete_frequency_sweep.html#pyedb.dotnet.database.edb_data.raptor_x_simulation_setup_data.RaptorXSimulationSetup.delete_frequency_sweep",
        "title": "delete_frequency_sweep > delete_frequency_sweep > delete_frequency_sweep",
        "section": "delete_frequency_sweep > delete_frequency_sweep",
        "text": "RaptorXSimulationSetup.delete_frequency_sweep(sweep_data)\n\nDelete a frequency sweep.\n\nParameters\n\nsweep_data\n\nEdbFrequencySweep.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kDDRwizard",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kDDRwizard.html#kddrwizard",
        "title": "kDDRwizard",
        "section": "kDDRwizard",
        "text": "kDDRwizard"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kDDRwizard",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kDDRwizard.html#pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kDDRwizard",
        "title": "kDDRwizard > kDDRwizard > kDDRwizard",
        "section": "kDDRwizard > kDDRwizard",
        "text": "SimulationSetupType.kDDRwizard = 'ddrwizard'\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.html#extendednet",
        "title": "ExtendedNet",
        "section": "ExtendedNet",
        "text": "Manages EDB functionalities for a primitives.\nIt Inherits EDB Object properties.\nExtendedNet.add_net(net)\nAdd a net to the extended net.\nExtendedNet.contains_net(net)\nDetermine if a net exists in the net class.\nExtendedNet.create(layout, name)\nCreate an extended net.\nExtendedNet.delete()\nDelete the layout object.\nExtendedNet.find_by_name(layout, name)\nFind an extended net by name in a given layout.\nExtendedNet.get_product_property(prod_id, ...)\nGet the product property of the layout object for a given product ID and attribute ID.\nExtendedNet.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nExtendedNet.remove_all_nets()\nRemove all nets from the extended net.\nExtendedNet.remove_net(net)\nRemove a net from the extended net.\nExtendedNet.set_product_property(prod_id, ...)\nSet the product property of the layout object for a given product ID and attribute ID.\nExtendedNet.layout_obj_type\n\nExtendedNet\nExtendedNet.add_net\nExtendedNet.contains_net\nExtendedNet.create\nExtendedNet.delete\nExtendedNet.find_by_name\nExtendedNet.get_product_property\nExtendedNet.get_product_property_ids\nExtendedNet.remove_all_nets\nExtendedNet.remove_net\nExtendedNet.set_product_property\nExtendedNet.layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.html#pyedb.grpc.database.net.extended_net.ExtendedNet",
        "title": "ExtendedNet > ExtendedNet > ExtendedNet",
        "section": "ExtendedNet > ExtendedNet",
        "text": "class pyedb.grpc.database.net.extended_net.ExtendedNet(pedb, edb_object)\n\nManages EDB functionalities for a primitives.\nIt Inherits EDB Object properties.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nExtendedNet.add_net(net)\n\nAdd a net to the extended net.\n\nExtendedNet.contains_net(net)\n\nDetermine if a net exists in the net class.\n\nExtendedNet.create(layout, name)\n\nCreate an extended net.\n\nExtendedNet.delete()\n\nDelete the layout object.\n\nExtendedNet.find_by_name(layout, name)\n\nFind an extended net by name in a given layout.\n\nExtendedNet.get_product_property(prod_id, ...)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nExtendedNet.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nExtendedNet.remove_all_nets()\n\nRemove all nets from the extended net.\n\nExtendedNet.remove_net(net)\n\nRemove a net from the extended net.\n\nExtendedNet.set_product_property(prod_id, ...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\n\n\nAttributes\n\n\n\n\n\n\n\nExtendedNet.layout_obj_type\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.set_product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.set_product_solver_option.html#set_product_solver_option",
        "title": "set_product_solver_option",
        "section": "set_product_solver_option",
        "text": "Set the product solver option.\nID of the product.\nName of the solver.\nName of the product solver option.\nset_product_solver_option\nProductIdType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.set_product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.set_product_solver_option.html#pyedb.grpc.database.ports.ports.CoaxPort.set_product_solver_option",
        "title": "set_product_solver_option > set_product_solver_option > set_product_solver_option",
        "section": "set_product_solver_option > set_product_solver_option",
        "text": "CoaxPort.set_product_solver_option(product_id, solver_name, option)\n\nSet the product solver option.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nsolver_name\n\nobj:str\n\nName of the solver.\n\noption\n\nobj:str\n\nName of the product solver option.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "user_guide/security_considerations",
        "href": "user_guide/security_considerations.html#security-considerations",
        "title": "Security considerations",
        "section": "Security considerations",
        "text": "This section provides information on security considerations for the use\nof pyedb. It is important to understand the capabilities which pyedb\nprovides, especially when using it to build applications or scripts that\naccept untrusted input.\nIf a function displays a warning that redirects to this page, it indicates\nthat the function may expose security risks when used improperly.\nIn such cases, it is essential to pay close attention to:\nFunction arguments: Ensure that arguments passed to the function are\nproperly validated and do not contain untrusted content such as arbitrary\nfile paths, shell commands, or serialized data.\nEnvironment variables: Be cautious of environment variables that can\ninfluence the behavior of the function, particularly if they are user-defined\nor inherited from an untrusted execution context.\nGlobal settings (`settings`): Pyedb settings control various aspects of\nruntime behavior such as AEDT features, use of LSF cluster or remote server\nconnections. Review these settings to avoid unexpected side effects or security\nvulnerabilities.\nAlways validate external input, avoid executing arbitrary commands or code,\nand follow the principle of least privilege when developing with pyedb.\nSecurity considerations"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the terminal object to the correct concrete type, fetching the type if necessary.\ncast\nTerminalType\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.cast.html#pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "BundleTerminal.cast(term_type=None)\n\nCast the terminal object to the correct concrete type, fetching the type if necessary.\n\nParameters\n\nterm_type\n\nTerminalType\n\n\n\nReturns\n\nTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sim_setup_info.SimSetupInfo",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sim_setup_info.SimSetupInfo.html#simsetupinfo",
        "title": "SimSetupInfo",
        "section": "SimSetupInfo",
        "text": "SimSetupInfo.add_sweep_data(sweep_data)\n\nSimSetupInfo\nSimSetupInfo.add_sweep_data"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sim_setup_info.SimSetupInfo",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sim_setup_info.SimSetupInfo.html#pyedb.dotnet.database.sim_setup_data.data.sim_setup_info.SimSetupInfo",
        "title": "SimSetupInfo > SimSetupInfo > SimSetupInfo",
        "section": "SimSetupInfo > SimSetupInfo",
        "text": "class pyedb.dotnet.database.sim_setup_data.data.sim_setup_info.SimSetupInfo(pedb, sim_setup, edb_object=None, setup_type: str | None = None, name: str | None = None)\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nSimSetupInfo.add_sweep_data(sweep_data)\n\n\n\n"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_rebuild",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce: Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors: Whether to raise errors, defaults to True.\n_parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n_types_namespace: The types namespace, defaults to None.\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_rebuild",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_rebuild.html#pyedb.workflows.drc.drc.BackDrillStubLength.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod BackDrillStubLength.model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -> bool | None\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n\nforce: Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors: Whether to raise errors, defaults to True.\n_parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n_types_namespace: The types namespace, defaults to None.\n\nReturns:\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_fields.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "DiffPairLengthMatch.model_fields = {'name': FieldInfo(annotation=str, required=True), 'pairs': FieldInfo(annotation=List[DiffPair], required=True), 'tolerance': FieldInfo(annotation=str, required=True)}\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.unite_polygons_on_layer",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.unite_polygons_on_layer.html#unite_polygons_on_layer",
        "title": "unite_polygons_on_layer",
        "section": "unite_polygons_on_layer",
        "text": "Try to unite all Polygons on specified layer.\nName of layer name to unite objects on. The default is None, in which case all layers are taken.\nWhether to delete all padstack geometries. The default is False.\nNet names list filter. The default is [], in which case all nets are taken.\nTrue is successful.\nunite_polygons_on_layer\npython:str\noptional\nNone\noptional\nFalse\npython:list\npython:str\noptional\n[]\nTrue"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.unite_polygons_on_layer",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.unite_polygons_on_layer.html#pyedb.dotnet.database.modeler.Modeler.unite_polygons_on_layer",
        "title": "unite_polygons_on_layer > unite_polygons_on_layer > unite_polygons_on_layer",
        "section": "unite_polygons_on_layer > unite_polygons_on_layer",
        "text": "Modeler.unite_polygons_on_layer(layer_name=None, delete_padstack_gemometries=False, net_names_list=None)\n\nTry to unite all Polygons on specified layer.\n\nParameters\n\nlayer_name\n\npython:str, optional\n\nName of layer name to unite objects on. The default is None, in which case all layers are taken.\n\ndelete_padstack_gemometries\n\nbool, optional\n\nWhether to delete all padstack geometries. The default is False.\n\nnet_names_list\n\npython:list[python:str]\n\noptional\n\nNet names list filter. The default is [], in which case all nets are taken.\n\nReturns\n\nbool\n\nTrue is successful.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.place_voltage_probe",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.place_voltage_probe.html#place_voltage_probe",
        "title": "place_voltage_probe",
        "section": "place_voltage_probe",
        "text": "Place a voltage probe between two points.\nName of the probe.\nName of the positive net.\nLocation of the positive terminal.\nLayer of the positive terminal.\nName of the negative net.\nLocation of the negative terminal.\nLayer of the negative terminal.\nplace_voltage_probe\npython:str\npython:list\npython:list\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.place_voltage_probe",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.place_voltage_probe.html#pyedb.grpc.database.source_excitations.SourceExcitation.place_voltage_probe",
        "title": "place_voltage_probe > place_voltage_probe > place_voltage_probe",
        "section": "place_voltage_probe > place_voltage_probe",
        "text": "SourceExcitation.place_voltage_probe(name: str, positive_net_name: str, positive_location: List[float], positive_layer: str, negative_net_name: str, negative_location: List[float], negative_layer: str) -> Terminal\n\nPlace a voltage probe between two points.\n\nParameters\n\nname\n\nstr,\n\nName of the probe.\n\npositive_net_name\n\npython:str\n\nName of the positive net.\n\npositive_location\n\npython:list\n\nLocation of the positive terminal.\n\npositive_layer\n\nstr,\n\nLayer of the positive terminal.\n\nnegative_net_name\n\nstr,\n\nName of the negative net.\n\nnegative_location\n\npython:list\n\nLocation of the negative terminal.\n\nnegative_layer\n\npython:str\n\nLayer of the negative terminal.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> probe = edb.source_excitation.place_voltage_probe(\n...     \"Probe1\", \"Net1\", [0, 0], \"TopLayer\", \"GND\", [0.1, 0], \"TopLayer\"\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "glossary",
        "href": "glossary.html#glossary",
        "title": "Glossary",
        "section": "Glossary",
        "text": "The standalone gRPC service that performs all EDB operations. PyEDB connects to this service as a client.\nIt is also called PyEDB-core.\nRepresents the PCB design itself within an EDB project. A project has one active cell. Adding multiple cells\nis actually adding multiple designs to the same project.\nA modern, high-performance open-source RPC framework. It is the communication protocol between PyEDB and the ansys-edb-core service.\nThe container within a Cell for all the physical data of the PCB (stackup, geometries, components).\nA collection of electrically connected pins and primitives (traces, pads) in a layout. Equivalent to a “signal” in schematic terms.\nA basic geometric shape (polygon, path, rectangle, circle) in an EDB layout.\nThe vertical arrangement of conductive and dielectric layers that make up a PCB.\nGlossary"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.get_zone_name",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.get_zone_name.html#get_zone_name",
        "title": "get_zone_name",
        "section": "get_zone_name",
        "text": "Get the name for a given zone.\nZone ID.\nName of the zone.\nget_zone_name\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.get_zone_name",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.get_zone_name.html#pyedb.grpc.database.stackup.LayerCollection.get_zone_name",
        "title": "get_zone_name > get_zone_name > get_zone_name",
        "section": "get_zone_name > get_zone_name",
        "text": "LayerCollection.get_zone_name(zone)\n\nGet the name for a given zone.\n\nParameters\n\nzone\n\npython:int\n\nZone ID.\n\nReturns\n\npython:str\n\nName of the zone.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.parse_obj",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "parse_obj"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.parse_obj",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.parse_obj.html#pyedb.workflows.drc.drc.Rules.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod Rules.parse_obj(obj: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.configure_siw_analysis_setup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.configure_siw_analysis_setup.html#configure_siw_analysis_setup",
        "title": "configure_siw_analysis_setup",
        "section": "configure_siw_analysis_setup",
        "text": "Configure Siwave analysis setup.\nEdb_DATA.SimulationConfiguration object.\nTrue when successful, False when failed.\nconfigure_siw_analysis_setup\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.configure_siw_analysis_setup",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.configure_siw_analysis_setup.html#pyedb.dotnet.database.siwave.EdbSiwave.configure_siw_analysis_setup",
        "title": "configure_siw_analysis_setup > configure_siw_analysis_setup > configure_siw_analysis_setup",
        "section": "configure_siw_analysis_setup > configure_siw_analysis_setup",
        "text": "EdbSiwave.configure_siw_analysis_setup(simulation_setup=None, delete_existing_setup=True)\n\nConfigure Siwave analysis setup.\n\nParameters\n\nsimulation_setup\n\nEdb_DATA.SimulationConfiguration object.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.get_product_property_ids.html#pyedb.grpc.database.ports.ports.CoaxPort.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "CoaxPort.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_traj",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_traj.html#set_traj",
        "title": "set_traj",
        "section": "set_traj",
        "text": "Set the parameters of the trajectory of the bondwire.\nX value of the start point.\nY value of the start point.\nX value of the end point.\nY value of the end point.\nset_traj"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_traj",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.set_traj.html#pyedb.grpc.database.primitive.bondwire.Bondwire.set_traj",
        "title": "set_traj > set_traj > set_traj",
        "section": "set_traj > set_traj",
        "text": "Bondwire.set_traj(x1: ValueLike, y1: ValueLike, x2: ValueLike, y2: ValueLike)\n\nSet the parameters of the trajectory of the bondwire.\n\nParameters\n\nx1\n\nValueLike\n\nX value of the start point.\n\ny1\n\nValueLike\n\nY value of the start point.\n\nx2\n\nValueLike\n\nX value of the end point.\n\ny2\n\nValueLike\n\nY value of the end point.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.product_solver_names",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.product_solver_names.html#product_solver_names",
        "title": "product_solver_names",
        "section": "product_solver_names",
        "text": "Get the list of solver names.\nID of the product.\nproduct_solver_names\nProductIdType\npython:list\nof\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.product_solver_names",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.product_solver_names.html#pyedb.grpc.database.terminal.point_terminal.PointTerminal.product_solver_names",
        "title": "product_solver_names > product_solver_names > product_solver_names",
        "section": "product_solver_names > product_solver_names",
        "text": "PointTerminal.product_solver_names(product_id)\n\nGet the list of solver names.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nReturns\n\npython:list of python:str\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.html#netclass",
        "title": "NetClass",
        "section": "NetClass",
        "text": "Manages EDB functionalities for a primitives.\nIt inherits EDB Object properties.\nNetClass.add_net(net)\nAdd a net to the net class.\nNetClass.contains_net(net)\nDetermine if a net exists in the net class.\nNetClass.create(layout, name)\nCreate a net.\nNetClass.delete()\nDelete the layout object.\nNetClass.find_by_name(layout, name)\nFind a net class by name in a given layout.\nNetClass.get_product_property(prod_id, attr_id)\nGet the product property of the layout object for a given product ID and attribute ID.\nNetClass.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nNetClass.remove_net(net)\nRemove net.\nNetClass.set_product_property(prod_id, ...)\nSet the product property of the layout object for a given product ID and attribute ID.\nNetClass.layout_obj_type\n\nNetClass\nNetClass.add_net\nNetClass.contains_net\nNetClass.create\nNetClass.delete\nNetClass.find_by_name\nNetClass.get_product_property\nNetClass.get_product_property_ids\nNetClass.remove_net\nNetClass.set_product_property\nNetClass.layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net_class.NetClass.html#pyedb.grpc.database.net.net_class.NetClass",
        "title": "NetClass > NetClass > NetClass",
        "section": "NetClass > NetClass",
        "text": "class pyedb.grpc.database.net.net_class.NetClass(pedb, net_class)\n\nManages EDB functionalities for a primitives.\nIt inherits EDB Object properties.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb(myedb, edbversion=\"2025.1\")\n>>> edb.net_classes\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nNetClass.add_net(net)\n\nAdd a net to the net class.\n\nNetClass.contains_net(net)\n\nDetermine if a net exists in the net class.\n\nNetClass.create(layout, name)\n\nCreate a net.\n\nNetClass.delete()\n\nDelete the layout object.\n\nNetClass.find_by_name(layout, name)\n\nFind a net class by name in a given layout.\n\nNetClass.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nNetClass.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nNetClass.remove_net(net)\n\nRemove net.\n\nNetClass.set_product_property(prod_id, ...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\n\n\nAttributes\n\n\n\n\n\n\n\nNetClass.layout_obj_type\n\n\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create_source_on_component",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create_source_on_component.html#create_source_on_component",
        "title": "create_source_on_component",
        "section": "create_source_on_component",
        "text": "Create voltage, current source, or resistor on component.\nList of edb_data.sources.Source objects.\nTrue when successful, False when failed.\ncreate_source_on_component\npython:list\nSource\nedb_data.sources.Source\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create_source_on_component",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.create_source_on_component.html#pyedb.dotnet.database.components.Components.create_source_on_component",
        "title": "create_source_on_component > create_source_on_component > create_source_on_component",
        "section": "create_source_on_component > create_source_on_component",
        "text": "Components.create_source_on_component(sources=None)\n\nCreate voltage, current source, or resistor on component.\n\nParameters\n\nsources\n\npython:list[Source]\n\nList of edb_data.sources.Source objects.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.normalized",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.normalized.html#normalized",
        "title": "normalized",
        "section": "normalized",
        "text": "Normalize the point vector.\nnormalized\nPointData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.normalized",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.point_data.PointData.normalized.html#pyedb.grpc.database.geometry.point_data.PointData.normalized",
        "title": "normalized > normalized > normalized",
        "section": "normalized > normalized",
        "text": "PointData.normalized() -> PointData\n\nNormalize the point vector.\n\nReturns\n\nPointData\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.set_product_property.html#pyedb.grpc.database.ports.ports.CircuitPort.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "CircuitPort.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_siwave_syz_setup",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_siwave_syz_setup.html#create_siwave_syz_setup",
        "title": "create_siwave_syz_setup",
        "section": "create_siwave_syz_setup",
        "text": "Create SIwave SYZ analysis setup.\nSetup name. Auto-generated if None.\nSetup properties to modify.\nSYZ analysis setup.\ncreate_siwave_syz_setup\npython:str\noptional\nSiwaveSimulationSetup"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_siwave_syz_setup",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_siwave_syz_setup.html#pyedb.grpc.edb.Edb.create_siwave_syz_setup",
        "title": "create_siwave_syz_setup > create_siwave_syz_setup > create_siwave_syz_setup",
        "section": "create_siwave_syz_setup > create_siwave_syz_setup",
        "text": "Edb.create_siwave_syz_setup(name=None, **kwargs) -> SiwaveSimulationSetup\n\nCreate SIwave SYZ analysis setup.\n\nParameters\n\nname\n\npython:str, optional\n\nSetup name. Auto-generated if None.\n\n**kwargs\n\nSetup properties to modify.\n\nReturns\n\nSiwaveSimulationSetup\n\nSYZ analysis setup.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.html#bundlewaveport",
        "title": "BundleWavePort",
        "section": "BundleWavePort",
        "text": "Manages bundle wave port properties.\nEDB object from the Edblib library.\nBundleTerminal instance from EDB.\nBundleWavePort.cast([term_type])\nCast the terminal object to the correct concrete type, fetching the type if necessary.\nBundleWavePort.create(terminals)\nCreate a bundle terminal.\nBundleWavePort.create_3d_comp()\nCreate a 3D composite model from an MCAD file.\nBundleWavePort.create_hfss()\nCreate an HFSS model from an MCAD file.\nBundleWavePort.create_stride()\nCreate a Stride model from an MCAD file.\nBundleWavePort.decouple()\nUngroup a bundle of terminals.\nBundleWavePort.delete()\nDelete the layout object.\nBundleWavePort.find(layout, name)\nFind a terminal by name in a given layout.\nBundleWavePort.find_by_id(layout, uid)\nFind a Connectable object by database ID in a given layout.\nBundleWavePort.get_product_property(prod_id, ...)\nGet the product property of the layout object for a given product ID and attribute ID.\nBundleWavePort.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nBundleWavePort.product_solver_names(product_id)\nGet the list of solver names.\nBundleWavePort.product_solver_option(...)\nGet the name of the product solver option.\nBundleWavePort.set_product_property(prod_id, ...)\nSet the product property of the layout object for a given product ID and attribute ID.\nBundleWavePort.set_product_solver_option(...)\nSet the product solver option.\nBundleWavePort.ungroup()\nDelete the grouping.\nBundleWavePort.layout_obj_type\n\nBundleWavePort.type\n\nBundleWavePort\npyedb.edb.Edb\nEdblib\nAnsys.Ansoft.Edb.Cell.Terminal.BundleTerminal\nBundleWavePort.cast\nBundleWavePort.create\nBundleWavePort.create_3d_comp\nBundleWavePort.create_hfss\nBundleWavePort.create_stride\nBundleWavePort.decouple\nBundleWavePort.delete\nBundleWavePort.find\nBundleWavePort.find_by_id\nBundleWavePort.get_product_property\nBundleWavePort.get_product_property_ids\nBundleWavePort.product_solver_names\nBundleWavePort.product_solver_option\nBundleWavePort.set_product_property\nBundleWavePort.set_product_solver_option\nBundleWavePort.ungroup\nBundleWavePort.layout_obj_type\nBundleWavePort.type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.html#pyedb.grpc.database.ports.ports.BundleWavePort",
        "title": "BundleWavePort > BundleWavePort > BundleWavePort",
        "section": "BundleWavePort > BundleWavePort",
        "text": "class pyedb.grpc.database.ports.ports.BundleWavePort(pedb, edb_object)\n\nManages bundle wave port properties.\n\nParameters\n\npedb\n\npyedb.edb.Edb\n\nEDB object from the Edblib library.\n\nedb_object\n\nAnsys.Ansoft.Edb.Cell.Terminal.BundleTerminal\n\nBundleTerminal instance from EDB.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nBundleWavePort.cast([term_type])\n\nCast the terminal object to the correct concrete type, fetching the type if necessary.\n\nBundleWavePort.create(terminals)\n\nCreate a bundle terminal.\n\nBundleWavePort.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nBundleWavePort.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nBundleWavePort.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nBundleWavePort.decouple()\n\nUngroup a bundle of terminals.\n\nBundleWavePort.delete()\n\nDelete the layout object.\n\nBundleWavePort.find(layout, name)\n\nFind a terminal by name in a given layout.\n\nBundleWavePort.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nBundleWavePort.get_product_property(prod_id, ...)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nBundleWavePort.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nBundleWavePort.product_solver_names(product_id)\n\nGet the list of solver names.\n\nBundleWavePort.product_solver_option(...)\n\nGet the name of the product solver option.\n\nBundleWavePort.set_product_property(prod_id, ...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nBundleWavePort.set_product_solver_option(...)\n\nSet the product solver option.\n\nBundleWavePort.ungroup()\n\nDelete the grouping.\n\n\n\nAttributes\n\n\n\n\n\n\n\nBundleWavePort.layout_obj_type\n\n\n\nBundleWavePort.type\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.html#path",
        "title": "Path",
        "section": "Path",
        "text": "Path.add_point(x, y[, incremental])\nAdd a point at the end of the path.\nPath.add_void(point_list)\nAdd a void to current primitive.\nPath.area([include_voids])\nReturn the total area.\nPath.cast()\nCast the primitive object to the correct concrete type.\nPath.clone()\nClone a primitive object with keeping same definition and location.\nPath.convert_to_polygon()\nConvert path to polygon.\nPath.create([layout, layer, net, width, ...])\nCreate a path in the specified layout, layer, and net with the given parameters.\nPath.create_3d_comp()\nCreate a 3D composite model from an MCAD file.\nPath.create_edge_port(name[, position, ...])\n\nPath.create_hfss()\nCreate an HFSS model from an MCAD file.\nPath.create_stride()\nCreate a Stride model from an MCAD file.\nPath.create_via_fence(distance, gap, ...[, ...])\nCreate via fences on both sides of the trace.\nPath.delete()\nDelete the path object.\nPath.expand([offset, tolerance, ...])\nExpand the polygon shape by an absolute value in all direction.\nPath.find_by_id(layout, uid)\nFind a Connectable object by database ID in a given layout.\nPath.get_center_line()\nRetrieve center line points list.\nPath.get_clip_info()\nGet the data used to clip the path.\nPath.get_closest_arc_midpoint(point)\nGet the closest arc midpoint of the primitive to the input data.\nPath.get_closest_point(point)\nGet the closest point of the primitive to the input data.\nPath.get_connected_object_id_set()\nProduce a list of all geometries physically connected to a given layout object.\nPath.get_connected_objects()\nGet connected objects.\nPath.get_end_cap_style()\nGet end cap styles for the path.\nPath.get_hfss_prop()\nGet HFSS properties.\nPath.get_product_property(prod_id, attr_id)\nGet the product property of the layout object for a given product ID and attribute ID.\nPath.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nPath.intersect(primitives)\nIntersect active primitive with one or more primitives.\nPath.intersection_type(primitive)\nGet intersection type between actual primitive and another primitive or polygon data.\nPath.is_intersecting(primitive)\nCheck if actual primitive and another primitive or polygon data intesects.\nPath.make_zone_primitive(zone_id)\nMake the primitive a zone primitive with a zone specified by the provided ID.\nPath.plot([plot_net, show, save_plot])\nPlot the current polygon on matplotlib.\nPath.points([arc_segments])\nReturn the list of points with arcs converted to segments.\nPath.remove_hfss_prop()\nRemove HFSS properties.\nPath.render(width, end_cap1, end_cap2, ...)\nRender a path.\nPath.scale(factor[, center])\nScales the polygon relative to a center point by a factor.\nPath.set_clip_info(clipping_poly[, keep_inside])\nSet the data used to clip the path.\nPath.set_end_cap_style(end_cap1, end_cap2)\nSet end cap styles for the path.\nPath.set_hfss_prop(material, solve_inside)\nSet HFSS properties.\nPath.set_product_property(prod_id, attr_id, ...)\nSet the product property of the layout object for a given product ID and attribute ID.\nPath.subtract(primitives)\nSubtract active primitive with one or more primitives.\nPath.unite(primitives)\nUnite active primitive with one or more primitives.\nPath.layout_obj_type\nLayoutObjType: Layout object type of the Primitive class.\nPath\nPath.add_point\nPath.add_void\nPath.area\nPath.cast\nPath.clone\nPath.convert_to_polygon\nPath.create\nPath.create_3d_comp\nPath.create_edge_port\nPath.create_hfss\nPath.create_stride\nPath.create_via_fence\nPath.delete\nPath.expand\nPath.find_by_id\nPath.get_center_line\nPath.get_clip_info\nPath.get_closest_arc_midpoint\nPath.get_closest_point\nPath.get_connected_object_id_set\nPath.get_connected_objects\nPath.get_end_cap_style\nPath.get_hfss_prop\nPath.get_product_property\nPath.get_product_property_ids\nPath.intersect\nPath.intersection_type\nPath.is_intersecting\nPath.make_zone_primitive\nPath.plot\nPath.points\nPath.remove_hfss_prop\nPath.render\nPath.scale\nPath.set_clip_info\nPath.set_end_cap_style\nPath.set_hfss_prop\nPath.set_product_property\nPath.subtract\nPath.unite\nPath.layout_obj_type\nLayoutObjType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.html#pyedb.grpc.database.primitive.path.Path",
        "title": "Path > Path > Path",
        "section": "Path > Path",
        "text": "class pyedb.grpc.database.primitive.path.Path(pedb, edb_object=None)\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nPath.add_point(x, y[, incremental])\n\nAdd a point at the end of the path.\n\nPath.add_void(point_list)\n\nAdd a void to current primitive.\n\nPath.area([include_voids])\n\nReturn the total area.\n\nPath.cast()\n\nCast the primitive object to the correct concrete type.\n\nPath.clone()\n\nClone a primitive object with keeping same definition and location.\n\nPath.convert_to_polygon()\n\nConvert path to polygon.\n\nPath.create([layout, layer, net, width, ...])\n\nCreate a path in the specified layout, layer, and net with the given parameters.\n\nPath.create_3d_comp()\n\nCreate a 3D composite model from an MCAD file.\n\nPath.create_edge_port(name[, position, ...])\n\n\n\nPath.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nPath.create_stride()\n\nCreate a Stride model from an MCAD file.\n\nPath.create_via_fence(distance, gap, ...[, ...])\n\nCreate via fences on both sides of the trace.\n\nPath.delete()\n\nDelete the path object.\n\nPath.expand([offset, tolerance, ...])\n\nExpand the polygon shape by an absolute value in all direction.\n\nPath.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nPath.get_center_line()\n\nRetrieve center line points list.\n\nPath.get_clip_info()\n\nGet the data used to clip the path.\n\nPath.get_closest_arc_midpoint(point)\n\nGet the closest arc midpoint of the primitive to the input data.\n\nPath.get_closest_point(point)\n\nGet the closest point of the primitive to the input data.\n\nPath.get_connected_object_id_set()\n\nProduce a list of all geometries physically connected to a given layout object.\n\nPath.get_connected_objects()\n\nGet connected objects.\n\nPath.get_end_cap_style()\n\nGet end cap styles for the path.\n\nPath.get_hfss_prop()\n\nGet HFSS properties.\n\nPath.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nPath.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nPath.intersect(primitives)\n\nIntersect active primitive with one or more primitives.\n\nPath.intersection_type(primitive)\n\nGet intersection type between actual primitive and another primitive or polygon data.\n\nPath.is_intersecting(primitive)\n\nCheck if actual primitive and another primitive or polygon data intesects.\n\nPath.make_zone_primitive(zone_id)\n\nMake the primitive a zone primitive with a zone specified by the provided ID.\n\nPath.plot([plot_net, show, save_plot])\n\nPlot the current polygon on matplotlib.\n\nPath.points([arc_segments])\n\nReturn the list of points with arcs converted to segments.\n\nPath.remove_hfss_prop()\n\nRemove HFSS properties.\n\nPath.render(width, end_cap1, end_cap2, ...)\n\nRender a path.\n\nPath.scale(factor[, center])\n\nScales the polygon relative to a center point by a factor.\n\nPath.set_clip_info(clipping_poly[, keep_inside])\n\nSet the data used to clip the path.\n\nPath.set_end_cap_style(end_cap1, end_cap2)\n\nSet end cap styles for the path.\n\nPath.set_hfss_prop(material, solve_inside)\n\nSet HFSS properties.\n\nPath.set_product_property(prod_id, attr_id, ...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nPath.subtract(primitives)\n\nSubtract active primitive with one or more primitives.\n\nPath.unite(primitives)\n\nUnite active primitive with one or more primitives.\n\n\n\nAttributes\n\n\n\n\n\n\n\nPath.layout_obj_type\n\nLayoutObjType: Layout object type of the Primitive class.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileComponent.add_pin",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileComponent.add_pin.html#add_pin",
        "title": "add_pin",
        "section": "add_pin",
        "text": "Add a pin to the component.\nPin name.\nX-coordinate.\nY-coordinate.\nLayer name.\nadd_pin\npython:str\npython:float\npython:float\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileComponent.add_pin",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileComponent.add_pin.html#pyedb.grpc.database.control_file.ControlFileComponent.add_pin",
        "title": "add_pin > add_pin > add_pin",
        "section": "add_pin > add_pin",
        "text": "ControlFileComponent.add_pin(name: str, x: float, y: float, layer: str) -> None\n\nAdd a pin to the component.\n\nParameters\n\nname\n\npython:str\n\nPin name.\n\nx\n\npython:float\n\nX-coordinate.\n\ny\n\npython:float\n\nY-coordinate.\n\nlayer\n\npython:str\n\nLayer name.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.fix_circle_void_for_clipping",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.fix_circle_void_for_clipping.html#fix_circle_void_for_clipping",
        "title": "fix_circle_void_for_clipping",
        "section": "fix_circle_void_for_clipping",
        "text": "Fix circle void clipping issues.\nTrue if changes made, False otherwise.\nfix_circle_void_for_clipping"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.fix_circle_void_for_clipping",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.fix_circle_void_for_clipping.html#pyedb.grpc.database.modeler.Modeler.fix_circle_void_for_clipping",
        "title": "fix_circle_void_for_clipping > fix_circle_void_for_clipping > fix_circle_void_for_clipping",
        "section": "fix_circle_void_for_clipping > fix_circle_void_for_clipping",
        "text": "Modeler.fix_circle_void_for_clipping() -> bool\n\nFix circle void clipping issues.\n\nReturns\n\nbool\n\nTrue if changes made, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.create",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create an edge terminal.\nLayout to create the edge terminal in.\nName of the edge terminal.\nNet reference. The default is None.\nWhether the edge terminal is a reference terminal.\ncreate\nLayout\nstr\npython:list\nof\nEdge\nNet\nstr\npython:None\nNone\nbool\npython:False\nEdgeTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.create",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.create.html#pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod EdgeTerminal.create(layout, name, edges, net=None, is_ref=False)\n\nCreate an edge terminal.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to create the edge terminal in.\n\nname\n\nstr\n\nName of the edge terminal.\n\nedges\n\npython:list of Edge\n\n\n\nnet\n\nNet or str or python:None\n\nNet reference. The default is None.\n\nis_ref\n\nbool, default: python:False\n\nWhether the edge terminal is a reference terminal.\n\nReturns\n\nEdgeTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.find",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.find.html#find",
        "title": "find",
        "section": "find",
        "text": "Find a terminal by name in a given layout.\nLayout to search for the terminal.\nName of the terminal.\nfind\nLayout\nstr\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.find",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.find.html#pyedb.grpc.database.ports.ports.CircuitPort.find",
        "title": "find > find > find",
        "section": "find > find",
        "text": "classmethod CircuitPort.find(layout, name)\n\nFind a terminal by name in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the terminal.\n\nname\n\nstr\n\nName of the terminal.\n\nReturns\n\nTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_all_variable_names",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_all_variable_names.html#get_all_variable_names",
        "title": "get_all_variable_names",
        "section": "get_all_variable_names",
        "text": "Method added for compatibility with grpc.\nList of variable names.\nget_all_variable_names\nList\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_all_variable_names",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_all_variable_names.html#pyedb.grpc.edb.Edb.get_all_variable_names",
        "title": "get_all_variable_names > get_all_variable_names > get_all_variable_names",
        "section": "get_all_variable_names > get_all_variable_names",
        "text": "Edb.get_all_variable_names() -> List[str]\n\nMethod added for compatibility with grpc.\n\nReturns\n\nList[python:str]\n\nList of variable names.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_dcir_simulation_setup.SIWaveDCIRSimulationSetup",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_dcir_simulation_setup.SIWaveDCIRSimulationSetup.html#siwavedcirsimulationsetup",
        "title": "SIWaveDCIRSimulationSetup",
        "section": "SIWaveDCIRSimulationSetup",
        "text": "Siwave Dcir simulation setup class.\nSIWaveDCIRSimulationSetup.cast()\nCast the base SimulationSetup object to correct subclass, if possible.\nSIWaveDCIRSimulationSetup.create(cell, name)\nCreate a SIWave DCIR simulation setup.\nSIWaveDCIRSimulationSetup\nSIWaveDCIRSimulationSetup.cast\nSIWaveDCIRSimulationSetup.create"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_dcir_simulation_setup.SIWaveDCIRSimulationSetup",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_dcir_simulation_setup.SIWaveDCIRSimulationSetup.html#pyedb.grpc.database.simulation_setup.siwave_dcir_simulation_setup.SIWaveDCIRSimulationSetup",
        "title": "SIWaveDCIRSimulationSetup > SIWaveDCIRSimulationSetup > SIWaveDCIRSimulationSetup",
        "section": "SIWaveDCIRSimulationSetup > SIWaveDCIRSimulationSetup",
        "text": "class pyedb.grpc.database.simulation_setup.siwave_dcir_simulation_setup.SIWaveDCIRSimulationSetup(pedb, edb_object)\n\nSiwave Dcir simulation setup class.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nSIWaveDCIRSimulationSetup.cast()\n\nCast the base SimulationSetup object to correct subclass, if possible.\n\nSIWaveDCIRSimulationSetup.create(cell, name)\n\nCreate a SIWave DCIR simulation setup.\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.set_layer_clone",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.set_layer_clone.html#set_layer_clone",
        "title": "set_layer_clone",
        "section": "set_layer_clone",
        "text": "set_layer_clone"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.set_layer_clone",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.stackup.Stackup.set_layer_clone.html#pyedb.dotnet.database.stackup.Stackup.set_layer_clone",
        "title": "set_layer_clone > set_layer_clone > set_layer_clone",
        "section": "set_layer_clone > set_layer_clone",
        "text": "Stackup.set_layer_clone(layer_clone)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_dump_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#json-mode)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent: Indentation to use in the JSON output. If None is passed, the output will be compact.\nensure_ascii: If True, the output is guaranteed to have all incoming non-ASCII characters escaped.\nIf False (the default), these characters will be output as-is.\ninclude: Field(s) to include in the JSON output.\nexclude: Field(s) to exclude from the JSON output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to serialize using field aliases.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\nA JSON string representation of the model.\nmodel_dump_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_dump_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_dump_json.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "DiffPairLengthMatch.model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -> str\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#json-mode)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nArgs:\n\nindent: Indentation to use in the JSON output. If None is passed, the output will be compact.\nensure_ascii: If True, the output is guaranteed to have all incoming non-ASCII characters escaped.\n\nIf False (the default), these characters will be output as-is.\n\ninclude: Field(s) to include in the JSON output.\nexclude: Field(s) to exclude from the JSON output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to serialize using field aliases.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\n\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\n\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback: A function to call when an unknown value is encountered. If not provided,\n\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.add_length_mesh_operation",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.add_length_mesh_operation.html#add_length_mesh_operation",
        "title": "add_length_mesh_operation",
        "section": "add_length_mesh_operation",
        "text": "Add a mesh operation to the setup.\nDictionary containing nets and layers on which enable Mesh operation. Example {\"A0_N\": [\"TOP\", \"PWR\"]}.\nMesh operation name.\nMaximum number of elements. Default is 1000.\nMaximum length of elements. Default is 1mm.\nWhether to restrict number of elements. Default is True.\nWhether to restrict length of elements. Default is True.\nMesh region name.\nWhether to refine inside or not.  Default is False.\nadd_length_mesh_operation\npython:dict\n{\"A0_N\": [\"TOP\", \"PWR\"]}\npython:str\noptional\npython:int\noptional\n1000\npython:str\noptional\n1mm\noptional\nTrue\noptional\nTrue\npython:str\noptional\noptional\nFalse\ndotnet.database.edb_data.hfss_simulation_setup_data.LengthMeshOperation"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.add_length_mesh_operation",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.add_length_mesh_operation.html#pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.add_length_mesh_operation",
        "title": "add_length_mesh_operation > add_length_mesh_operation > add_length_mesh_operation",
        "section": "add_length_mesh_operation > add_length_mesh_operation",
        "text": "HfssSimulationSetup.add_length_mesh_operation(net_layer_list, name=None, max_elements=1000, max_length='1mm', restrict_elements=True, restrict_length=True, refine_inside=False, mesh_region=None)\n\nAdd a mesh operation to the setup.\n\nParameters\n\nnet_layer_list\n\npython:dict\n\nDictionary containing nets and layers on which enable Mesh operation. Example {\"A0_N\": [\"TOP\", \"PWR\"]}.\n\nname\n\npython:str, optional\n\nMesh operation name.\n\nmax_elements\n\npython:int, optional\n\nMaximum number of elements. Default is 1000.\n\nmax_length\n\npython:str, optional\n\nMaximum length of elements. Default is 1mm.\n\nrestrict_elements\n\nbool, optional\n\nWhether to restrict number of elements. Default is True.\n\nrestrict_length\n\nbool, optional\n\nWhether to restrict length of elements. Default is True.\n\nmesh_region\n\npython:str, optional\n\nMesh region name.\n\nrefine_inside\n\nbool, optional\n\nWhether to refine inside or not.  Default is False.\n\nReturns\n\ndotnet.database.edb_data.hfss_simulation_setup_data.LengthMeshOperation\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings.html#advancedsettings",
        "title": "AdvancedSettings",
        "section": "AdvancedSettings",
        "text": "AdvancedSettings.get_configurations()\nGet all attributes.\nAdvancedSettings.restore_default()\n\nAdvancedSettings.set_pi_slider(value)\n\nAdvancedSettings.set_si_slider(value)\n\nAdvancedSettings\nAdvancedSettings.get_configurations\nAdvancedSettings.restore_default\nAdvancedSettings.set_pi_slider\nAdvancedSettings.set_si_slider"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings.html#pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings",
        "title": "AdvancedSettings > AdvancedSettings > AdvancedSettings",
        "section": "AdvancedSettings > AdvancedSettings",
        "text": "class pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings(parent)\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nAdvancedSettings.get_configurations()\n\nGet all attributes.\n\nAdvancedSettings.restore_default()\n\n\n\nAdvancedSettings.set_pi_slider(value)\n\n\n\nAdvancedSettings.set_si_slider(value)\n\n\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_trace",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_trace.html#create_trace",
        "title": "create_trace",
        "section": "create_trace",
        "text": "Create a trace based on a list of points.\nList of points.\nName of the layer on which to create the path.\nWidth of the path. The default is 1.\nName of the net. The default is \"\".\nStyle of the cap at its start. Options are \"Round\",\n\"Extended\", and \"Flat\". The default is\n\"Round\".\nStyle of the cap at its end. Options are \"Round\",\n\"Extended\", and \"Flat\". The default is\n\"Round\".\nStyle of the corner. Options are \"Round\",\n\"Sharp\" and \"Mitered\". The default is \"Round\".\ncreate_trace\npython:list\npython:str\npython:float\noptional\n1\npython:str\noptional\n\"\"\npython:str\noptional\n\"Round\"\n\"Extended\",\n\"Flat\"\n\"Round\"\npython:str\noptional\n\"Round\"\n\"Extended\",\n\"Flat\"\n\"Round\"\npython:str\noptional\n\"Round\"\n\"Sharp\"\n\"Mitered\"\n\"Round\"\npyedb.dotnet.database.edb_data.primitives_data.Primitive"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_trace",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.create_trace.html#pyedb.dotnet.database.modeler.Modeler.create_trace",
        "title": "create_trace > create_trace > create_trace",
        "section": "create_trace > create_trace",
        "text": "Modeler.create_trace(path_list, layer_name, width=1, net_name='', start_cap_style='Round', end_cap_style='Round', corner_style='Round')\n\nCreate a trace based on a list of points.\n\nParameters\n\npath_list\n\npython:list\n\nList of points.\n\nlayer_name\n\npython:str\n\nName of the layer on which to create the path.\n\nwidth\n\npython:float, optional\n\nWidth of the path. The default is 1.\n\nnet_name\n\npython:str, optional\n\nName of the net. The default is \"\".\n\nstart_cap_style\n\npython:str, optional\n\nStyle of the cap at its start. Options are \"Round\",\n\"Extended\", and \"Flat\". The default is\n\"Round\".\n\nend_cap_style\n\npython:str, optional\n\nStyle of the cap at its end. Options are \"Round\",\n\"Extended\", and \"Flat\". The default is\n\"Round\".\n\ncorner_style\n\npython:str, optional\n\nStyle of the corner. Options are \"Round\",\n\"Sharp\" and \"Mitered\". The default is \"Round\".\n\nReturns\n\npyedb.dotnet.database.edb_data.primitives_data.Primitive\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.create_pin_group_on_net",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.create_pin_group_on_net.html#create_pin_group_on_net",
        "title": "create_pin_group_on_net",
        "section": "create_pin_group_on_net",
        "text": "Create pin group by net name.\nReference designator.\nNet name.\nGroup name.\nPin group instance.\ncreate_pin_group_on_net\npython:str\npython:str\npython:str\noptional\npyedb.grpc.database.hierarchy.pingroup.PinGroup"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.create_pin_group_on_net",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.create_pin_group_on_net.html#pyedb.grpc.database.components.Components.create_pin_group_on_net",
        "title": "create_pin_group_on_net > create_pin_group_on_net > create_pin_group_on_net",
        "section": "create_pin_group_on_net > create_pin_group_on_net",
        "text": "Components.create_pin_group_on_net(reference_designator: str, net_name: str, group_name: str | None = None) -> PinGroup\n\nCreate pin group by net name.\n\nParameters\n\nreference_designator\n\npython:str\n\nReference designator.\n\nnet_name\n\npython:str\n\nNet name.\n\ngroup_name\n\npython:str, optional\n\nGroup name.\n\nReturns\n\npyedb.grpc.database.hierarchy.pingroup.PinGroup\n\nPin group instance.\n\nExamples\n\n>>> group = edbapp.components.create_pin_group_on_net(\"U1\", \"GND\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.unite_polygons_on_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.unite_polygons_on_layer.html#unite_polygons_on_layer",
        "title": "unite_polygons_on_layer",
        "section": "unite_polygons_on_layer",
        "text": "Unite polygons on layer.\nLayer name(s) to process.\nWhether to delete padstack geometries.\nNet names filter.\nTrue if successful, False otherwise.\nunite_polygons_on_layer\npython:str\npython:list\noptional\noptional\npython:list\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.unite_polygons_on_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.unite_polygons_on_layer.html#pyedb.grpc.database.modeler.Modeler.unite_polygons_on_layer",
        "title": "unite_polygons_on_layer > unite_polygons_on_layer > unite_polygons_on_layer",
        "section": "unite_polygons_on_layer > unite_polygons_on_layer",
        "text": "Modeler.unite_polygons_on_layer(layer_name: str | List[str] | None = None, delete_padstack_gemometries: bool = False, net_names_list: List[str] | None = None) -> bool\n\nUnite polygons on layer.\n\nParameters\n\nlayer_name\n\npython:str or python:list, optional\n\nLayer name(s) to process.\n\ndelete_padstack_gemometries\n\nbool, optional\n\nWhether to delete padstack geometries.\n\nnet_names_list\n\npython:list, optional\n\nNet names filter.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude: Optional set or mapping specifying which fields to include in the copied model.\nexclude: Optional set or mapping specifying which fields to exclude in the copied model.\nupdate: Optional dictionary of field-value pairs to override field values in the copied model.\ndeep: If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.copy.html#pyedb.workflows.drc.drc.MinClearance.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "MinClearance.copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -> Self\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nArgs:\n\ninclude: Optional set or mapping specifying which fields to include in the copied model.\nexclude: Optional set or mapping specifying which fields to exclude in the copied model.\nupdate: Optional dictionary of field-value pairs to override field values in the copied model.\ndeep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.solve_siwave",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.solve_siwave.html#solve_siwave",
        "title": "solve_siwave",
        "section": "solve_siwave",
        "text": "Close EDB and solve it with Siwave.\nSiwave project path.\nsolve_siwave\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.solve_siwave",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.solve_siwave.html#pyedb.dotnet.edb.Edb.solve_siwave",
        "title": "solve_siwave > solve_siwave > solve_siwave",
        "section": "solve_siwave > solve_siwave",
        "text": "Edb.solve_siwave()\n\nClose EDB and solve it with Siwave.\n\nReturns\n\npython:str\n\nSiwave project path.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.product_solver_option.html#product_solver_option",
        "title": "product_solver_option",
        "section": "product_solver_option",
        "text": "Get the name of the product solver option.\nID of the product.\nName of the solver.\nName of the product solver option.\nproduct_solver_option\nProductIdType\nstr\nstr"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.product_solver_option.html#pyedb.grpc.database.ports.ports.CoaxPort.product_solver_option",
        "title": "product_solver_option > product_solver_option > product_solver_option",
        "section": "product_solver_option > product_solver_option",
        "text": "CoaxPort.product_solver_option(product_id, solver_name)\n\nGet the name of the product solver option.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nsolver_name\n\nstr\n\nName of the solver.\n\nReturns\n\nstr\n\nName of the product solver option.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_dcir_simulation_setup.SIWaveDCIRSimulationSetup.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_dcir_simulation_setup.SIWaveDCIRSimulationSetup.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the base SimulationSetup object to correct subclass, if possible.\ncast\nSimulationSetup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_dcir_simulation_setup.SIWaveDCIRSimulationSetup.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_dcir_simulation_setup.SIWaveDCIRSimulationSetup.cast.html#pyedb.grpc.database.simulation_setup.siwave_dcir_simulation_setup.SIWaveDCIRSimulationSetup.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "SIWaveDCIRSimulationSetup.cast()\n\nCast the base SimulationSetup object to correct subclass, if possible.\n\nReturns\n\nSimulationSetup\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.create_from_bounding_box",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.create_from_bounding_box.html#create_from_bounding_box",
        "title": "create_from_bounding_box",
        "section": "create_from_bounding_box",
        "text": "Create PolygonData from point list.\ncreate_from_bounding_box\nPolygonData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.create_from_bounding_box",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.create_from_bounding_box.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.create_from_bounding_box",
        "title": "create_from_bounding_box > create_from_bounding_box > create_from_bounding_box",
        "section": "create_from_bounding_box > create_from_bounding_box",
        "text": "static PolygonData.create_from_bounding_box(points) -> PolygonData\n\nCreate PolygonData from point list.\n\nReturns\n\nPolygonData\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.create",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a stackup layer.\nName of the stackup layer.\nType of the stackup layer.\nThickness of the stackup layer.\nElevation  of the stackup layer.\nMaterial  of the stackup layer.\nStackup layer created.\ncreate\npython:str\nLayerType\npython:str\nStackupLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.create",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.create.html#pyedb.grpc.database.layers.stackup_layer.StackupLayer.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "static StackupLayer.create(name, layer_type, thickness, elevation, material)\n\nCreate a stackup layer.\n\nParameters\n\nname\n\npython:str\n\nName of the stackup layer.\n\nlayer_type\n\nLayerType\n\nType of the stackup layer.\n\nthickness\n\nValueLike\n\nThickness of the stackup layer.\n\nelevation\n\nValueLike\n\nElevation  of the stackup layer.\n\nmaterial\n\npython:str\n\nMaterial  of the stackup layer.\n\nReturns\n\nStackupLayer\n\nStackup layer created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_multipole_debye_material",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_multipole_debye_material.html#add_multipole_debye_material",
        "title": "add_multipole_debye_material",
        "section": "add_multipole_debye_material",
        "text": "Add a dielectric with the Multipole Debye model.\nName of the dielectric.\nFrequencies in GHz.\nRelative permittivities at each frequency.\nLoss tangents at each frequency.\nMaterial object.\nadd_multipole_debye_material\npython:str\npython:list\npython:list\npython:list\nMaterial"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_multipole_debye_material",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_multipole_debye_material.html#pyedb.grpc.database.definition.materials.Materials.add_multipole_debye_material",
        "title": "add_multipole_debye_material > add_multipole_debye_material > add_multipole_debye_material",
        "section": "add_multipole_debye_material > add_multipole_debye_material",
        "text": "Materials.add_multipole_debye_material(name, frequencies, permittivities, loss_tangents, **kwargs) -> Material\n\nAdd a dielectric with the Multipole Debye model.\n\nParameters\n\nname\n\npython:str\n\nName of the dielectric.\n\nfrequencies\n\npython:list\n\nFrequencies in GHz.\n\npermittivities\n\npython:list\n\nRelative permittivities at each frequency.\n\nloss_tangents\n\npython:list\n\nLoss tangents at each frequency.\n\nReturns\n\nMaterial\n\nMaterial object.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> freq = [0, 2, 3, 4, 5, 6]\n>>> rel_perm = [1e9, 1.1e9, 1.2e9, 1.3e9, 1.5e9, 1.6e9]\n>>> loss_tan = [0.025, 0.026, 0.027, 0.028, 0.029, 0.030]\n>>> diel = edb.materials.add_multipole_debye_material(\"My_MP_Debye\", freq, rel_perm, loss_tan)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/definitions",
        "href": "grpc_api/grpc/database/definitions.html#definitions",
        "title": "Definitions",
        "section": "Definitions",
        "text": "This class is the container for definitions.\ndefinitions.Definitions\n\nDefinitions\ndefinitions.Definitions"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.model_fields.html#pyedb.workflows.drc.drc.CopperBalance.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "CopperBalance.model_fields = {'layers': FieldInfo(annotation=List[str], required=True), 'max_percent': FieldInfo(annotation=int, required=True), 'name': FieldInfo(annotation=str, required=True)}\n\n"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.HatchGround.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.HatchGround.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Generate the stack-up, board outline and hatch pattern.\nTrue when geometry has been created successfully.\ncreate"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.HatchGround.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.HatchGround.create.html#pyedb.libraries.rf_libraries.base_functions.HatchGround.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "HatchGround.create() -> bool\n\nGenerate the stack-up, board outline and hatch pattern.\n\nReturns\n\nbool\n\nTrue when geometry has been created successfully.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.find_by_id.html#find_by_id",
        "title": "find_by_id",
        "section": "find_by_id",
        "text": "Find a Connectable object by database ID in a given layout.\nLayout to search for the Connectable object.\nDatabase ID.\nConnectable object with the given database ID.\nfind_by_id\nLayout\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.find_by_id.html#pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.find_by_id",
        "title": "find_by_id > find_by_id > find_by_id",
        "section": "find_by_id > find_by_id",
        "text": "classmethod EdgeTerminal.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the Connectable object.\n\nuid\n\npython:int\n\nDatabase ID.\n\nReturns\n\nConnectable\n\nConnectable object with the given database ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_solution_single_frequency",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_solution_single_frequency.html#set_solution_single_frequency",
        "title": "set_solution_single_frequency",
        "section": "set_solution_single_frequency",
        "text": "Set single-frequency solution.\nAdaptive frequency. The default is 5GHz.\nMaximum number of passes. The default is 10.\nMaximum delta S. The default is 0.02.\nset_solution_single_frequency\npython:str\npython:float\noptional\n5GHz\npython:int\noptional\n10\npython:float\noptional\n0.02"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_solution_single_frequency",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_solution_single_frequency.html#pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.set_solution_single_frequency",
        "title": "set_solution_single_frequency > set_solution_single_frequency > set_solution_single_frequency",
        "section": "set_solution_single_frequency > set_solution_single_frequency",
        "text": "HfssSimulationSetup.set_solution_single_frequency(frequency='5Ghz', max_num_passes=10, max_delta_s=0.02)\n\nSet single-frequency solution.\n\nParameters\n\nfrequency\n\npython:str, python:float, optional\n\nAdaptive frequency. The default is 5GHz.\n\nmax_num_passes\n\npython:int, optional\n\nMaximum number of passes. The default is 10.\n\nmax_delta_s\n\npython:float, optional\n\nMaximum delta S. The default is 0.02.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.is_intersecting",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.is_intersecting.html#is_intersecting",
        "title": "is_intersecting",
        "section": "is_intersecting",
        "text": "Check if actual primitive and another primitive or polygon data intesects.\nis_intersecting\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.is_intersecting",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.is_intersecting.html#pyedb.grpc.database.primitive.path.Path.is_intersecting",
        "title": "is_intersecting > is_intersecting > is_intersecting",
        "section": "is_intersecting > is_intersecting",
        "text": "Path.is_intersecting(primitive) -> bool\n\nCheck if actual primitive and another primitive or polygon data intesects.\n\nParameters\n\nprimitive\n\nPrimitive or PolygonData\n\n\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.points",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.points.html#points",
        "title": "points",
        "section": "points",
        "text": "Return the list of points with arcs converted to segments.\nNumber of facets to convert an arc. Default is 6.\n(X, Y).\npoints\npython:int\npython:tuple\npython:float\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.points",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.points.html#pyedb.grpc.database.primitive.rectangle.Rectangle.points",
        "title": "points > points > points",
        "section": "points > points",
        "text": "Rectangle.points(arc_segments=6) -> tuple[float, float]\n\nReturn the list of points with arcs converted to segments.\n\nParameters\n\narc_segments\n\npython:int\n\nNumber of facets to convert an arc. Default is 6.\n\nReturns\n\npython:tuple(python:float, python:float)\n\n(X, Y).\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.ResistorSource",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.ResistorSource.html#resistorsource",
        "title": "ResistorSource",
        "section": "ResistorSource",
        "text": "Manages a resistor source.\nResistorSource"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.ResistorSource",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.sources.ResistorSource.html#pyedb.grpc.database.utility.sources.ResistorSource",
        "title": "ResistorSource > ResistorSource > ResistorSource",
        "section": "ResistorSource > ResistorSource",
        "text": "class pyedb.grpc.database.utility.sources.ResistorSource\n\nManages a resistor source.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "schema"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.schema.html#pyedb.workflows.drc.drc.MinLineWidth.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod MinLineWidth.schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}') -> Dict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_port_between_pin_and_layer",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_port_between_pin_and_layer.html#create_port_between_pin_and_layer",
        "title": "create_port_between_pin_and_layer",
        "section": "create_port_between_pin_and_layer",
        "text": "Create circuit port between pin and a reference layer.\nComponent name. The default is None.\nPin name or list of pin names. The default is None.\nLayer name. The default is None.\nReference net name. The default is None.\nPort impedance. The default is 50.0 in ohms.\nCreated terminal.\ncreate_port_between_pin_and_layer\npython:str\nNone\npython:str\nNone\npython:str\nNone\npython:str\nNone\npython:float\noptional\n50.0\nPadstackInstanceTerminal"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_port_between_pin_and_layer",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_port_between_pin_and_layer.html#pyedb.dotnet.database.siwave.EdbSiwave.create_port_between_pin_and_layer",
        "title": "create_port_between_pin_and_layer > create_port_between_pin_and_layer > create_port_between_pin_and_layer",
        "section": "create_port_between_pin_and_layer > create_port_between_pin_and_layer",
        "text": "EdbSiwave.create_port_between_pin_and_layer(component_name=None, pins_name=None, layer_name=None, reference_net=None, impedance=50.0)\n\nCreate circuit port between pin and a reference layer.\n\nParameters\n\ncomponent_name\n\npython:str\n\nComponent name. The default is None.\n\npins_name\n\npython:str\n\nPin name or list of pin names. The default is None.\n\nlayer_name\n\npython:str\n\nLayer name. The default is None.\n\nreference_net\n\npython:str\n\nReference net name. The default is None.\n\nimpedance\n\npython:float, optional\n\nPort impedance. The default is 50.0 in ohms.\n\nReturns\n\nPadstackInstanceTerminal\n\nCreated terminal.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_point_terminal_reference_primitive",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_point_terminal_reference_primitive.html#get_point_terminal_reference_primitive",
        "title": "get_point_terminal_reference_primitive",
        "section": "get_point_terminal_reference_primitive",
        "text": "Find and return the primitive reference for the point terminal or the padstack instance.\nget_point_terminal_reference_primitive\ndotnet.database.edb_data.padstacks_data.EDBPadstackInstance\nor\npyedb.dotnet.database.edb_data.primitives_data.EDBPrimitives"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_point_terminal_reference_primitive",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.get_point_terminal_reference_primitive.html#pyedb.dotnet.database.edb_data.ports.GapPort.get_point_terminal_reference_primitive",
        "title": "get_point_terminal_reference_primitive > get_point_terminal_reference_primitive > get_point_terminal_reference_primitive",
        "section": "get_point_terminal_reference_primitive > get_point_terminal_reference_primitive",
        "text": "GapPort.get_point_terminal_reference_primitive()\n\nFind and return the primitive reference for the point terminal or the padstack instance.\n\nReturns\n\ndotnet.database.edb_data.padstacks_data.EDBPadstackInstance or\n\n\n\npyedb.dotnet.database.edb_data.primitives_data.EDBPrimitives\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_post_init",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nmodel_post_init"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_post_init",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinLineWidth.model_post_init.html#pyedb.workflows.drc.drc.MinLineWidth.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "MinLineWidth.model_post_init(context: Any, /) -> None\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/polygon_data",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/polygon_data.html#polygon-data",
        "title": "Polygon Data",
        "section": "Polygon Data",
        "text": "This class manages polygon data.\nPolygonData\nClass managing Polygon Data.\nPolygon Data\nPolygonData"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.set_pad_property",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.set_pad_property.html#set_pad_property",
        "title": "set_pad_property",
        "section": "set_pad_property",
        "text": "Set pad and anti-pad properties for a padstack definition.\nPadstack definition name.\nLayer name(s). Applies to all layers if None.\nPad geometry type (“Circle”, “Square”, “Rectangle”, “Oval”, “Bullet”). Default is \"Circle\".\nPad dimension(s). Default is 0.\nPad X-offset. Default is 0.\nPad Y-offset. Default is 0.\nPad rotation in degrees. Default is 0.\nAnti-pad geometry type (“Circle”, “Square”, “Rectangle”, “Oval”, “Bullet”). Default is \"Circle\".\nAnti-pad dimension(s). Default is 0.\nAnti-pad X-offset. Default is 0.\nAnti-pad Y-offset. Default is 0.\nAnti-pad rotation in degrees. Default is 0.\nTrue when successful, False when failed.\nset_pad_property\npython:str\npython:str\npython:list\noptional\nNone\npython:str\noptional\n\"Circle\"\npython:float\npython:list\noptional\n0\npython:float\noptional\n0\npython:float\noptional\n0\npython:float\noptional\n0\npython:str\noptional\n\"Circle\"\npython:float\npython:list\noptional\n0\npython:float\noptional\n0\npython:float\noptional\n0\npython:float\noptional\n0\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.set_pad_property",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.set_pad_property.html#pyedb.grpc.database.padstacks.Padstacks.set_pad_property",
        "title": "set_pad_property > set_pad_property > set_pad_property",
        "section": "set_pad_property > set_pad_property",
        "text": "Padstacks.set_pad_property(padstack_name: str, layer_name: str | None = None, pad_shape: str = 'Circle', pad_params: float | List[float] = 0, pad_x_offset: float = 0, pad_y_offset: float = 0, pad_rotation: float = 0, antipad_shape: str = 'Circle', antipad_params: float | List[float] = 0, antipad_x_offset: float = 0, antipad_y_offset: float = 0, antipad_rotation: float = 0)\n\nSet pad and anti-pad properties for a padstack definition.\n\nParameters\n\npadstack_name\n\npython:str\n\nPadstack definition name.\n\nlayer_name\n\npython:str or python:list, optional\n\nLayer name(s). Applies to all layers if None.\n\npad_shape\n\npython:str, optional\n\nPad geometry type (“Circle”, “Square”, “Rectangle”, “Oval”, “Bullet”). Default is \"Circle\".\n\npad_params\n\npython:float or python:list, optional\n\nPad dimension(s). Default is 0.\n\npad_x_offset\n\npython:float, optional\n\nPad X-offset. Default is 0.\n\npad_y_offset\n\npython:float, optional\n\nPad Y-offset. Default is 0.\n\npad_rotation\n\npython:float, optional\n\nPad rotation in degrees. Default is 0.\n\nantipad_shape\n\npython:str, optional\n\nAnti-pad geometry type (“Circle”, “Square”, “Rectangle”, “Oval”, “Bullet”). Default is \"Circle\".\n\nantipad_params\n\npython:float or python:list, optional\n\nAnti-pad dimension(s). Default is 0.\n\nantipad_x_offset\n\npython:float, optional\n\nAnti-pad X-offset. Default is 0.\n\nantipad_y_offset\n\npython:float, optional\n\nAnti-pad Y-offset. Default is 0.\n\nantipad_rotation\n\npython:float, optional\n\nAnti-pad rotation in degrees. Default is 0.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.delete_variable",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.delete_variable.html#delete_variable",
        "title": "delete_variable",
        "section": "delete_variable",
        "text": "Delete a variable.\nVariable name.\ndelete_variable\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.delete_variable",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.delete_variable.html#pyedb.grpc.database.layout.cell.Cell.delete_variable",
        "title": "delete_variable > delete_variable > delete_variable",
        "section": "delete_variable > delete_variable",
        "text": "Cell.delete_variable(name)\n\nDelete a variable.\n\nParameters\n\nname\n\npython:str\n\nVariable name.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/antennas",
        "href": "libraries/antennas.html#planar-antennas-libraries",
        "title": "Planar antennas Libraries",
        "section": "Planar antennas Libraries",
        "text": "These class is the containers of planar antennas libraries.\nRectangularPatch\nRectangular microstrip patch antenna (optionally inset-fed).\nCircularPatch\nCircular microstrip patch antenna (optionally probe-fed).\nTriangularPatch\nEquilateral-triangle microstrip patch antenna (optionally probe-fed).\nPlanar antennas Libraries\nRectangularPatch\nCircularPatch\nTriangularPatch"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.run_icepak_simulation",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.run_icepak_simulation.html#run_icepak_simulation",
        "title": "run_icepak_simulation",
        "section": "run_icepak_simulation",
        "text": "Runs an Icepak simulation.\nName of the Icepak simulation.\nName of the DC simulation.\nTrue when successful, False when failed.\nrun_icepak_simulation\npython:str\npython:str\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.run_icepak_simulation",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.run_icepak_simulation.html#pyedb.siwave.Siwave.run_icepak_simulation",
        "title": "run_icepak_simulation > run_icepak_simulation > run_icepak_simulation",
        "section": "run_icepak_simulation > run_icepak_simulation",
        "text": "Siwave.run_icepak_simulation(icepak_simulation_name, dc_simulation_name)\n\nRuns an Icepak simulation.\n\nParameters\n\nicepak_simulation_name\n\npython:str\n\nName of the Icepak simulation.\n\ndc_simulation_name\n\npython:str\n\nName of the DC simulation.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.plot",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.plot.html#plot",
        "title": "plot",
        "section": "plot",
        "text": "Plot a Net to Matplotlib 2D Chart.\nName of the net or list of nets to plot. If None all nets will be plotted.\nName of the layers to include in the plot. If None all the signal layers will be considered.\nIf True  the plot will be colored by net.\nIf False the plot will be colored by layer. (default)\nIf True the legend is shown in the plot. (default)\nIf False the legend is not shown.\nIf a path is specified the plot will be saved in this location.\nIf save_plot is provided, the show parameter is ignored.\nList of points of the outline to plot.\nImage size in pixel (width, height). Default value is (6000, 3000)\nWhether if use top view or bottom view. Components will be visible only for the highest layer in the view.\nIf True  the components placed on top layer are plotted.\nIf False the components are not plotted. (default).\nThis may impact in the plot computation time.\nIf nets and/or layers is specified, only the components belonging to the specified nets/layers are plotted.\nWhether to add the component names to the plot or not. Default is True.\nWhether to plot vias (circular and rectangular) or not. This may impact in the plot computation time.\nDefault is False.\nSpecify the default plot title. Is value is None the project name is assigned by default. Default value\nis None.\nWhether to show the plot or not. Default is True.\nMatplotlib ax and figures.\nplot\npython:str\npython:list\noptional\nNone\npython:str\npython:list\noptional\nNone\noptional\nTrue\nFalse\noptional\nTrue\nFalse\npython:str\noptional\nsave_plot\nshow\npython:list\noptional\npython:tuple\npython:int\noptional\n(6000, 3000)\noptional\noptional\nTrue\nFalse\nTrue\noptional\nFalse\npython:str\noptional\nNone\nNone\noptional\nax\nfig"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.plot",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.plot.html#pyedb.grpc.database.nets.Nets.plot",
        "title": "plot > plot > plot",
        "section": "plot > plot",
        "text": "Nets.plot(nets=None, layers=None, color_by_net=False, show_legend=True, save_plot=None, outline=None, size=(6000, 3000), plot_components=True, top_view=True, show=True, annotate_component_names=True, plot_vias=False, title=None, **kwargs)\n\nPlot a Net to Matplotlib 2D Chart.\n\nParameters\n\nnets\n\npython:str, python:list, optional\n\nName of the net or list of nets to plot. If None all nets will be plotted.\n\nlayers\n\npython:str, python:list, optional\n\nName of the layers to include in the plot. If None all the signal layers will be considered.\n\ncolor_by_net\n\nbool, optional\n\nIf True  the plot will be colored by net.\nIf False the plot will be colored by layer. (default)\n\nshow_legend\n\nbool, optional\n\nIf True the legend is shown in the plot. (default)\nIf False the legend is not shown.\n\nsave_plot\n\npython:str, optional\n\nIf a path is specified the plot will be saved in this location.\nIf save_plot is provided, the show parameter is ignored.\n\noutline\n\npython:list, optional\n\nList of points of the outline to plot.\n\nsize\n\npython:tuple, python:int, optional\n\nImage size in pixel (width, height). Default value is (6000, 3000)\n\ntop_view\n\nbool, optional\n\nWhether if use top view or bottom view. Components will be visible only for the highest layer in the view.\n\nplot_components\n\nbool, optional\n\nIf True  the components placed on top layer are plotted.\nIf False the components are not plotted. (default).\nThis may impact in the plot computation time.\nIf nets and/or layers is specified, only the components belonging to the specified nets/layers are plotted.\n\nannotate_component_names: bool, optional\n\nWhether to add the component names to the plot or not. Default is True.\n\nplot_vias\n\nbool, optional\n\nWhether to plot vias (circular and rectangular) or not. This may impact in the plot computation time.\nDefault is False.\n\ntitle\n\npython:str, optional\n\nSpecify the default plot title. Is value is None the project name is assigned by default. Default value\nis None.\n\nshow\n\nbool, optional\n\nWhether to show the plot or not. Default is True.\n\nReturns\n\n(ax, fig)\n\nMatplotlib ax and figures.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSetup",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSetup.html#controlfilesetup",
        "title": "ControlFileSetup",
        "section": "ControlFileSetup",
        "text": "Setup Class.\nControlFileSetup.add_mesh_operation(name, ...)\nAdd mesh operations.\nControlFileSetup.add_sweep(name, start, ...)\nAdd a new sweep.\nControlFileSetup\nControlFileSetup.add_mesh_operation\nControlFileSetup.add_sweep"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSetup",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSetup.html#pyedb.grpc.database.utility.xml_control_file.ControlFileSetup",
        "title": "ControlFileSetup > ControlFileSetup > ControlFileSetup",
        "section": "ControlFileSetup > ControlFileSetup",
        "text": "class pyedb.grpc.database.utility.xml_control_file.ControlFileSetup(name)\n\nSetup Class.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nControlFileSetup.add_mesh_operation(name, ...)\n\nAdd mesh operations.\n\nControlFileSetup.add_sweep(name, start, ...)\n\nAdd a new sweep.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_pinlist_from_component_and_net",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_pinlist_from_component_and_net.html#get_pinlist_from_component_and_net",
        "title": "get_pinlist_from_component_and_net",
        "section": "get_pinlist_from_component_and_net",
        "text": "Retrieve pins given a component’s reference designator and net name.\n. deprecated:: pyedb 0.28.0\nUse get_pin_from_component_and_net() instead.\nReference designator of the component. The default is None.\nName of the net. The default is None.\nDictionary of pins if the operation is successful.\nFalse is returned if the net does not belong to the component.\nget_pinlist_from_component_and_net\nget_pin_from_component_and_net()\npython:str\noptional\nNone\npython:str\noptional\nNone\npython:dict\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_pinlist_from_component_and_net",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_pinlist_from_component_and_net.html#pyedb.grpc.database.padstacks.Padstacks.get_pinlist_from_component_and_net",
        "title": "get_pinlist_from_component_and_net > get_pinlist_from_component_and_net > get_pinlist_from_component_and_net",
        "section": "get_pinlist_from_component_and_net > get_pinlist_from_component_and_net",
        "text": "Padstacks.get_pinlist_from_component_and_net(refdes=None, netname=None)\n\nRetrieve pins given a component’s reference designator and net name.\n\n. deprecated:: pyedb 0.28.0\nUse get_pin_from_component_and_net() instead.\n\nParameters\n\nrefdes\n\npython:str, optional\n\nReference designator of the component. The default is None.\n\nnetname\n\npython:str optional\n\nName of the net. The default is None.\n\nReturns\n\npython:dict\n\nDictionary of pins if the operation is successful.\nFalse is returned if the net does not belong to the component.\n\nExamples\n\n>>> pins = edb_padstacks.get_pinlist_from_component_and_net(refdes=\"U1\", netname=\"CLK\")  # Deprecated\n>>> pins = edb_padstacks.get_pin_from_component_and_net(refdes=\"U1\", netname=\"CLK\")  # New way\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_padstack_instances_intersecting_bounding_box",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_padstack_instances_intersecting_bounding_box.html#get_padstack_instances_intersecting_bounding_box",
        "title": "get_padstack_instances_intersecting_bounding_box",
        "section": "get_padstack_instances_intersecting_bounding_box",
        "text": "Returns the list of padstack instances ID intersecting a given bounding box and nets.\nParameters\n———-\nbounding_box : tuple or list.\nbounding box, [x1, y1, x2, y2]\nnet name of list of nets name applying filtering on padstack instances selection. If None is provided\nall instances are included in the index. Default value is None.\nCan be provided optionally to prevent computing padstack instances Rtree index again.\nget_padstack_instances_intersecting_bounding_box\nNone\nNone"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_padstack_instances_intersecting_bounding_box",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_padstack_instances_intersecting_bounding_box.html#pyedb.grpc.database.padstacks.Padstacks.get_padstack_instances_intersecting_bounding_box",
        "title": "get_padstack_instances_intersecting_bounding_box > get_padstack_instances_intersecting_bounding_box > get_padstack_instances_intersecting_bounding_box",
        "section": "get_padstack_instances_intersecting_bounding_box > get_padstack_instances_intersecting_bounding_box",
        "text": "Padstacks.get_padstack_instances_intersecting_bounding_box(bounding_box: List[float], nets: str | List[str] | None = None, padstack_instances_index: Index | None = None) -> List[PadstackInstance]\n\nReturns the list of padstack instances ID intersecting a given bounding box and nets.\nParameters\n———-\nbounding_box : tuple or list.\n\nbounding box, [x1, y1, x2, y2]\n\nnets\n\nstr or list, optional\n\nnet name of list of nets name applying filtering on padstack instances selection. If None is provided\nall instances are included in the index. Default value is None.\n\npadstack_instances_index\n\noptional, Rtree object.\n\nCan be provided optionally to prevent computing padstack instances Rtree index again."
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_padstack_instances_intersecting_bounding_box",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.get_padstack_instances_intersecting_bounding_box.html#returns",
        "title": "get_padstack_instances_intersecting_bounding_box > Returns",
        "section": "Returns",
        "text": "List of padstack instances ID intersecting the bounding box.\nReturns"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_lumped_port_on_net",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_lumped_port_on_net.html#create_lumped_port_on_net",
        "title": "create_lumped_port_on_net",
        "section": "create_lumped_port_on_net",
        "text": "Create an edge port on nets. This command looks for traces and polygons on the\nnets and tries to assign vertical lumped port.\nList of nets, str or Edb net.\nName or Edb layer object.\nUse this boolean when you want to return only the points from the edges and not creating ports. Default\nvalue is False.\nThe number of digits carried for the edge location accuracy. The default value is 6.\na cutout has been performed before and lumped ports have to be created on ending traces. Default value is\nTrue.\nTrue when successful, False when failed.\ncreate_lumped_port_on_net\npython:list\noptional\npython:str\nEdb\noptional\nFalse\npython:int\noptional\n6\nTrue\nTrue\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_lumped_port_on_net",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_lumped_port_on_net.html#pyedb.dotnet.database.hfss.EdbHfss.create_lumped_port_on_net",
        "title": "create_lumped_port_on_net > create_lumped_port_on_net > create_lumped_port_on_net",
        "section": "create_lumped_port_on_net > create_lumped_port_on_net",
        "text": "EdbHfss.create_lumped_port_on_net(nets=None, reference_layer=None, return_points_only=False, digit_resolution=6, at_bounding_box=True)\n\nCreate an edge port on nets. This command looks for traces and polygons on the\nnets and tries to assign vertical lumped port.\n\nParameters\n\nnets\n\npython:list, optional\n\nList of nets, str or Edb net.\n\nreference_layer\n\npython:str, Edb layer.\n\nName or Edb layer object.\n\nreturn_points_only\n\nbool, optional\n\nUse this boolean when you want to return only the points from the edges and not creating ports. Default\nvalue is False.\n\ndigit_resolution\n\npython:int, optional\n\nThe number of digits carried for the edge location accuracy. The default value is 6.\n\nat_bounding_box\n\nbool\n\nWhen True will keep the edges from traces at the layout bounding box location. This is recommended when\n\na cutout has been performed before and lumped ports have to be created on ending traces. Default value is\nTrue.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.import_layout_file",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.import_layout_file.html#import_layout_file",
        "title": "import_layout_file",
        "section": "import_layout_file",
        "text": "Import a board file and generate an edb.def file in the working directory.\nThis function supports all AEDT formats, including DXF, GDS, SML (IPC2581), BRD, MCM, SIP, ZIP and TGZ.\nDo not execute this function with untrusted function argument, environment\nvariables or pyedb global settings.\nSee the security guide for details.\nFull path to the board file.\nDirectory in which to create the aedb folder. The name given to the AEDB file\nis the same as the name of the board file.\nFull path to the Ansys translator. The default is \"\".\nWhether to use the PPE License. The default is False.\nPath to the XML file. The default is None, in which case an attempt is made to find\nthe XML file in the same directory as the board file. To succeed, the XML file and board file\nmust have the same name. Only the extension differs.\nTechnology file. The file can be *.ircx, *.vlc.tech, or *.itf\nLayer map .map file.\nLayer filter .txt file.\nimport_layout_file\nedb.def\npython:str\npython:str\noptional\naedb\npython:str\noptional\n\"\"\nFalse\npython:str\noptional\nNone\npython:str\noptional\npython:str\noptional\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.import_layout_file",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.import_layout_file.html#pyedb.dotnet.edb.Edb.import_layout_file",
        "title": "import_layout_file > import_layout_file > import_layout_file",
        "section": "import_layout_file > import_layout_file",
        "text": "Edb.import_layout_file(input_file, working_dir='', anstranslator_full_path='', use_ppe=False, control_file=None, map_file=None, tech_file=None, layer_filter=None)\n\nImport a board file and generate an edb.def file in the working directory.\n\nThis function supports all AEDT formats, including DXF, GDS, SML (IPC2581), BRD, MCM, SIP, ZIP and TGZ.\n\nDo not execute this function with untrusted function argument, environment\nvariables or pyedb global settings.\nSee the security guide for details.\n\nParameters\n\ninput_file\n\npython:str\n\nFull path to the board file.\n\nworking_dir\n\npython:str, optional\n\nDirectory in which to create the aedb folder. The name given to the AEDB file\nis the same as the name of the board file.\n\nanstranslator_full_path\n\npython:str, optional\n\nFull path to the Ansys translator. The default is \"\".\n\nuse_ppe\n\nbool\n\nWhether to use the PPE License. The default is False.\n\ncontrol_file\n\npython:str, optional\n\nPath to the XML file. The default is None, in which case an attempt is made to find\nthe XML file in the same directory as the board file. To succeed, the XML file and board file\nmust have the same name. Only the extension differs.\n\ntech_file\n\npython:str, optional\n\nTechnology file. The file can be *.ircx, *.vlc.tech, or *.itf\n\nmap_file\n\npython:str, optional\n\nLayer map .map file.\n\nlayer_filter:str,optional\n\nLayer filter .txt file.\n\nReturns\n\nFull path to the AEDB file\n\npython:str\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_circle",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_circle.html#is_circle",
        "title": "is_circle",
        "section": "is_circle",
        "text": "Determine whether the outer contour of the polygon is a circle.\nTrue when the outer contour of the polygon is a circle holes, False otherwise.\nis_circle\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_circle",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_circle.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.is_circle",
        "title": "is_circle > is_circle > is_circle",
        "section": "is_circle > is_circle",
        "text": "PolygonData.is_circle() -> bool\n\nDetermine whether the outer contour of the polygon is a circle.\n\nReturns\n\nbool\n\nTrue when the outer contour of the polygon is a circle holes, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData.api_create",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData.api_create.html#api_create",
        "title": "api_create",
        "section": "api_create",
        "text": "Edb Dotnet Api Database Edb.DifferentialPair.Create.\napi_create"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData.api_create",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData.api_create.html#pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData.api_create",
        "title": "api_create > api_create > api_create",
        "section": "api_create > api_create",
        "text": "EDBDifferentialPairData.api_create(name)\n\nEdb Dotnet Api Database Edb.DifferentialPair.Create.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.intersect",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.intersect.html#intersect",
        "title": "intersect",
        "section": "intersect",
        "text": "Intersect active primitive with one or more primitives.\nList of Primitive objects.\nintersect\nList\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.intersect",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.intersect.html#pyedb.grpc.database.primitive.rectangle.Rectangle.intersect",
        "title": "intersect > intersect > intersect",
        "section": "intersect > intersect",
        "text": "Rectangle.intersect(primitives) -> list[any]\n\nIntersect active primitive with one or more primitives.\n\nParameters\n\nprimitives :class:`Primitives <pyedb.grpc.database.primitive.primitive.Primitive>`\n\n\n\nor: List[:class:`Primitives <pyedb.grpc.database.primitive.primitive.Primitive>`]\n\n\n\nor: class:`PolygonData <ansys.edb.core.geometry.polygon_data.PolygonData>`\n\n\n\nReturns\n\nList[Primitive]\n\nList of Primitive objects.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.move_layer",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.move_layer.html#move_layer",
        "title": "move_layer",
        "section": "move_layer",
        "text": "Move polygon to given layer.\nlayer name.\nTrue when successful, False when failed.\nmove_layer\npython:str\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.move_layer",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.move_layer.html#pyedb.grpc.database.primitive.polygon.Polygon.move_layer",
        "title": "move_layer > move_layer > move_layer",
        "section": "move_layer > move_layer",
        "text": "Polygon.move_layer(layer) -> bool\n\nMove polygon to given layer.\n\nParameters\n\nlayer\n\npython:str\n\nlayer name.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.set_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.set_hfss_prop.html#set_hfss_prop",
        "title": "set_hfss_prop",
        "section": "set_hfss_prop",
        "text": "Set HFSS properties.\nMaterial property name to set.\nWhether to solve inside.\nset_hfss_prop\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.set_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.set_hfss_prop.html#pyedb.grpc.database.primitive.rectangle.Rectangle.set_hfss_prop",
        "title": "set_hfss_prop > set_hfss_prop > set_hfss_prop",
        "section": "set_hfss_prop > set_hfss_prop",
        "text": "Rectangle.set_hfss_prop(material: str, solve_inside: bool)\n\nSet HFSS properties.\n\nParameters\n\nmaterial\n\npython:str\n\nMaterial property name to set.\n\nsolve_inside\n\nbool\n\nWhether to solve inside.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Drc",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Drc.html#drc",
        "title": "Drc",
        "section": "Drc",
        "text": "Lightweight, high-accuracy DRC engine that runs inside an open PyEDB session.\nThe engine is thread-safe and uses an R-tree spatial index for\nscalable geometry queries.  All rule checks are parallelised with\nconcurrent.futures.ThreadPoolExecutor.\nActive EDB session (must already be open).\nDrc.check(rules)\nRun all rules and return a list of violations.\nDrc.to_ipc356a(file_path)\nWrite a complete IPC-D-356A netlist plus DRC comments for fab review.\nDrc\npyedb.Edb\nDrc.check\nDrc.to_ipc356a"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Drc",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Drc.html#pyedb.workflows.drc.drc.Drc",
        "title": "Drc > Drc > Drc",
        "section": "Drc > Drc",
        "text": "class pyedb.workflows.drc.drc.Drc(edb: Edb)\n\nLightweight, high-accuracy DRC engine that runs inside an open PyEDB session.\n\nThe engine is thread-safe and uses an R-tree spatial index for\nscalable geometry queries.  All rule checks are parallelised with\nconcurrent.futures.ThreadPoolExecutor.\n\nParameters\n\nedb\n\npyedb.Edb\n\nActive EDB session (must already be open).\n\nExamples\n\n>>> edb = pyedb.Edb(\"my_board.aedb\")\n>>> rules = Rules.load(\"rules.json\")\n>>> drc = Drc(edb)\n>>> violations = drc.check(rules)\n>>> drc.to_ipc356a(\"review.ipc\")\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nDrc.check(rules)\n\nRun all rules and return a list of violations.\n\nDrc.to_ipc356a(file_path)\n\nWrite a complete IPC-D-356A netlist plus DRC comments for fab review.\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData.find_by_name",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData.find_by_name.html#find_by_name",
        "title": "find_by_name",
        "section": "find_by_name",
        "text": "Edb Dotnet Api Database Edb.DifferentialPair.FindByName.\nfind_by_name"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData.find_by_name",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData.find_by_name.html#pyedb.dotnet.database.edb_data.nets_data.EDBDifferentialPairData.find_by_name",
        "title": "find_by_name > find_by_name > find_by_name",
        "section": "find_by_name > find_by_name",
        "text": "EDBDifferentialPairData.find_by_name(layout, net)\n\nEdb Dotnet Api Database Edb.DifferentialPair.FindByName.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.parse_obj",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "parse_obj"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.parse_obj",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.parse_obj.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod DiffPairLengthMatch.parse_obj(obj: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.delete",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete current simulation setup.\ndelete"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.delete",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.delete.html#pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "SimulationSetup.delete()\n\nDelete current simulation setup.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_layout_component",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_layout_component.html#import_layout_component",
        "title": "import_layout_component",
        "section": "import_layout_component",
        "text": "Import a layout component inside the current layout and place it at the origin.\nThis feature is only supported with PyEDB gRPC. Encryption is not yet supported.\nLayout component path (.aedbcomp file).\nimport_layout_component\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_layout_component",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.import_layout_component.html#pyedb.grpc.edb.Edb.import_layout_component",
        "title": "import_layout_component > import_layout_component > import_layout_component",
        "section": "import_layout_component > import_layout_component",
        "text": "Edb.import_layout_component(component_path) -> LayoutComponent\n\nImport a layout component inside the current layout and place it at the origin.\nThis feature is only supported with PyEDB gRPC. Encryption is not yet supported.\n\nParameters\n\ncomponent_path\n\npython:str\n\nLayout component path (.aedbcomp file).\n\nReturns\n\nclass:LayoutComponent <ansys.edb.core.hierarchy.layout_component.LayoutComponent>.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.schema_json",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "schema_json"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.schema_json",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.schema_json.html#pyedb.grpc.database.definition.materials.MaterialProperties.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod MaterialProperties.schema_json(*, by_alias: bool = True, ref_template: str = '#/$defs/{model}', **dumps_kwargs: Any) -> str\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_connected_objects",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_connected_objects.html#get_connected_objects",
        "title": "get_connected_objects",
        "section": "get_connected_objects",
        "text": "Get connected objects.\nget_connected_objects\npython:list"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_connected_objects",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.ExcitationSources.get_connected_objects.html#pyedb.grpc.database.ports.ports.ExcitationSources.get_connected_objects",
        "title": "get_connected_objects > get_connected_objects > get_connected_objects",
        "section": "get_connected_objects > get_connected_objects",
        "text": "ExcitationSources.get_connected_objects()\n\nGet connected objects.\n\nReturns\n\npython:list\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_dcir_simulation_setup.SIWaveDCIRSimulationSetup.create",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_dcir_simulation_setup.SIWaveDCIRSimulationSetup.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a SIWave DCIR simulation setup.\nCell to create the simulation setup in.\nName of the simulation setup.\nSimulation setup created.\ncreate\nCell\npython:str\nSIWaveDCIRSimulationSetup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_dcir_simulation_setup.SIWaveDCIRSimulationSetup.create",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_dcir_simulation_setup.SIWaveDCIRSimulationSetup.create.html#pyedb.grpc.database.simulation_setup.siwave_dcir_simulation_setup.SIWaveDCIRSimulationSetup.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod SIWaveDCIRSimulationSetup.create(cell, name)\n\nCreate a SIWave DCIR simulation setup.\n\nParameters\n\ncell\n\nCell\n\nCell to create the simulation setup in.\n\nname\n\npython:str\n\nName of the simulation setup.\n\nReturns\n\nSIWaveDCIRSimulationSetup\n\nSimulation setup created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.deactivate_rlc_component",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.deactivate_rlc_component.html#deactivate_rlc_component",
        "title": "deactivate_rlc_component",
        "section": "deactivate_rlc_component",
        "text": "Deactivate RLC component with a possibility to convert it to a circuit port.\nReference designator of the RLC component.\nWhether to replace the deactivated RLC component with a circuit port. The default\nis False.\nWhether to define the PEC boundary, The default is False. If set to True,\na perfect short is created between the pin and impedance is ignored. This\nparameter is only supported on a port created between two pins, such as\nwhen there is no pin group.\nTrue when successful, False when failed.\ndeactivate_rlc_component\npython:str\noptional\nFalse\noptional\nFalse\nTrue\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.deactivate_rlc_component",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.deactivate_rlc_component.html#pyedb.grpc.database.components.Components.deactivate_rlc_component",
        "title": "deactivate_rlc_component > deactivate_rlc_component > deactivate_rlc_component",
        "section": "deactivate_rlc_component > deactivate_rlc_component",
        "text": "Components.deactivate_rlc_component(component: str | None = None, create_circuit_port: bool = False, pec_boundary: bool = False) -> bool\n\nDeactivate RLC component with a possibility to convert it to a circuit port.\n\nParameters\n\ncomponent\n\npython:str\n\nReference designator of the RLC component.\n\ncreate_circuit_port\n\nbool, optional\n\nWhether to replace the deactivated RLC component with a circuit port. The default\nis False.\n\npec_boundary\n\nbool, optional\n\nWhether to define the PEC boundary, The default is False. If set to True,\na perfect short is created between the pin and impedance is ignored. This\nparameter is only supported on a port created between two pins, such as\nwhen there is no pin group.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb_file = r\"C:\\my_edb_file.aedb\"\n>>> edb = Edb(edb_file)\n>>> for cmp in list(edb.components.instances.keys()):\n>>>     edb.components.deactivate_rlc_component(component=cmp, create_circuit_port=False)\n>>> edb.save_edb()\n>>> edb.close_edb()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.couple_ports",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.couple_ports.html#couple_ports",
        "title": "couple_ports",
        "section": "couple_ports",
        "text": "Create a bundle wave port.\nPorts to be added.\ncouple_ports\ndotnet.database.ports.WavePort\ndotnet.database.ports.GapPort\npython:list\noptional\ndotnet.database.ports.BundleWavePort"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.couple_ports",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.GapPort.couple_ports.html#pyedb.dotnet.database.edb_data.ports.GapPort.couple_ports",
        "title": "couple_ports > couple_ports > couple_ports",
        "section": "couple_ports > couple_ports",
        "text": "GapPort.couple_ports(port)\n\nCreate a bundle wave port.\n\nParameters\n\nport\n\ndotnet.database.ports.WavePort, dotnet.database.ports.GapPort, python:list, optional\n\nPorts to be added.\n\nReturns\n\ndotnet.database.ports.BundleWavePort\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.negative",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.negative.html#negative",
        "title": "negative",
        "section": "negative",
        "text": "negative"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.negative",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.negative.html#pyedb.workflows.drc.drc.DiffPair.negative",
        "title": "negative > negative > negative",
        "section": "negative > negative",
        "text": "DiffPair.negative: str\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.cutout",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.cutout.html#cutout",
        "title": "cutout",
        "section": "cutout",
        "text": "Cut out an existing cell into a new cell.\nNets to keep after cutout.\nNets to kept and clip at the boundary after cutout.\nClipping polygon.\nWhether to perform clean clipping. The default is True.\nCell created.\ncutout\npython:list\nNet\npython:list\nNet\nPolygonData\noptional\nTrue\nCell"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.cutout",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.cutout.html#pyedb.grpc.database.layout.cell.Cell.cutout",
        "title": "cutout > cutout > cutout",
        "section": "cutout > cutout",
        "text": "Cell.cutout(included_nets, clipped_nets, clipping_polygon, clean_clipping=True)\n\nCut out an existing cell into a new cell.\n\nParameters\n\nincluded_nets\n\npython:list[Net]\n\nNets to keep after cutout.\n\nclipped_nets\n\npython:list[Net]\n\nNets to kept and clip at the boundary after cutout.\n\nclipping_polygon\n\nPolygonData\n\nClipping polygon.\n\nclean_clipping\n\nbool, optional\n\nWhether to perform clean clipping. The default is True.\n\nReturns\n\nCell\n\nCell created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.delete_simulation_setup",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.delete_simulation_setup.html#delete_simulation_setup",
        "title": "delete_simulation_setup",
        "section": "delete_simulation_setup",
        "text": "Delete a simulation setup by name.\nName of the setup.\ndelete_simulation_setup\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.delete_simulation_setup",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.delete_simulation_setup.html#pyedb.grpc.database.layout.cell.Cell.delete_simulation_setup",
        "title": "delete_simulation_setup > delete_simulation_setup > delete_simulation_setup",
        "section": "delete_simulation_setup > delete_simulation_setup",
        "text": "Cell.delete_simulation_setup(name)\n\nDelete a simulation setup by name.\n\nParameters\n\nname\n\npython:str\n\nName of the setup.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_edge_port_on_polygon",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_edge_port_on_polygon.html#create_edge_port_on_polygon",
        "title": "create_edge_port_on_polygon",
        "section": "create_edge_port_on_polygon",
        "text": "Create lumped port between two edges from two different polygons. Can also create a vertical port when\nthe reference layer name is only provided. When a port is created between two edge from two polygons which don’t\nbelong to the same layer, a circuit port will be automatically created instead of lumped. To enforce the circuit\nport instead of lumped,use the boolean force_circuit_port.\nEdb.Cell.Primitive.Polygon object.\nEdb.Cell.Primitive.Polygon object.\nlist[float, float] with values provided in meter.\nlist[float, float] with values provided in meter.\nstr the layer name.\nstr.\nfloat, impedance value.\ncreate_edge_port_on_polygon\nThe\nEDB\npolygon\nobject\nused\nto\nassign\nthe\nThe\nEDB\npolygon\nobject\nused\nto\ndefine\nthe\nport\nThe\ncoordinate\nof\nthe\npoint\nto\ndefine\nthe\nedge\nterminal\nof\nthe\nThis\npoint\nmust\nbe\nsame\nas\nterminal_point\nbut\nused\nfor\ndefining\nthe\nreference\nlocation\non\nthe\nName\nused\nto\ndefine\nport\nreference\nfor\nvertical\nName\nof\nthe\nport\nimpedance\nDefault\nvalue\nis"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_edge_port_on_polygon",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_edge_port_on_polygon.html#pyedb.dotnet.database.hfss.EdbHfss.create_edge_port_on_polygon",
        "title": "create_edge_port_on_polygon > create_edge_port_on_polygon > create_edge_port_on_polygon",
        "section": "create_edge_port_on_polygon > create_edge_port_on_polygon",
        "text": "EdbHfss.create_edge_port_on_polygon(polygon=None, reference_polygon=None, terminal_point=None, reference_point=None, reference_layer=None, port_name=None, port_impedance=50.0, force_circuit_port=False)\n\nCreate lumped port between two edges from two different polygons. Can also create a vertical port when\nthe reference layer name is only provided. When a port is created between two edge from two polygons which don’t\nbelong to the same layer, a circuit port will be automatically created instead of lumped. To enforce the circuit\nport instead of lumped,use the boolean force_circuit_port.\n\nParameters\n\npolygon\n\nThe EDB polygon object used to assign the port.\n\nEdb.Cell.Primitive.Polygon object.\n\nreference_polygon\n\nThe EDB polygon object used to define the port reference.\n\nEdb.Cell.Primitive.Polygon object.\n\nterminal_point\n\nThe coordinate of the point to define the edge terminal of the port. This point must be\n\n\n\nlocated on the edge of the polygon where the port has to be placed. For instance taking the middle point\n\n\n\nof an edge is a good practice but any point of the edge should be valid. Taking a corner might cause unwanted\n\n\n\nport location.\n\nlist[float, float] with values provided in meter.\n\nreference_point\n\nsame as terminal_point but used for defining the reference location on the edge.\n\nlist[float, float] with values provided in meter.\n\nreference_layer\n\nName used to define port reference for vertical ports.\n\nstr the layer name.\n\nport_name\n\nName of the port.\n\nstr.\n\nport_impedance\n\nport impedance value. Default value is 50 Ohms.\n\nfloat, impedance value.\n\nforce_circuit_port ; used to force circuit port creation instead of lumped. Works for vertical and coplanar\n\n\n\nports.\n\n\n\nExamples\n\n>>> edb_path = path_to_edb\n>>> edb = Edb(edb_path)\n>>> poly_list = [poly for poly in list(edb.layout.primitives) if poly.GetPrimitiveType() == 2]\n>>> port_poly = [poly for poly in poly_list if poly.GetId() == 17][0]\n>>> ref_poly = [poly for poly in poly_list if poly.GetId() == 19][0]\n>>> port_location = [-65e-3, -13e-3]\n>>> ref_location = [-63e-3, -13e-3]\n>>> edb.hfss.create_edge_port_on_polygon(polygon=port_poly, reference_polygon=ref_poly,\n>>> terminal_point=port_location, reference_point=ref_location)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.rotate",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.rotate.html#rotate",
        "title": "rotate",
        "section": "rotate",
        "text": "Rotate polygon around a center point by an angle.\nValue of the rotation angle in degree.\nIf None rotation is done from polygon center.\nTrue when successful, False when failed.\nrotate\npython:float\nList\nof\npython:float\npython:str\noptional\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.rotate",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.rotate.html#pyedb.grpc.database.primitive.polygon.Polygon.rotate",
        "title": "rotate > rotate > rotate",
        "section": "rotate > rotate",
        "text": "Polygon.rotate(angle, center=None) -> bool\n\nRotate polygon around a center point by an angle.\n\nParameters\n\nangle\n\npython:float\n\nValue of the rotation angle in degree.\n\ncenter\n\nList of python:float or python:str [x,y], optional\n\nIf None rotation is done from polygon center.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> edbapp = ansys.aedt.core.Edb(\"myproject.aedb\")\n>>> top_layer_polygon = [poly for poly in edbapp.modeler.polygons if poly.layer_name == \"Top Layer\"]\n>>> for polygon in top_layer_polygon:\n>>>     polygon.rotate(angle=45)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_terminal",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_terminal.html#get_terminal",
        "title": "get_terminal",
        "section": "get_terminal",
        "text": "Get PadstackInstanceTerminal object.\nName of the terminal. Only applicable when create_new_terminal is True.\nWhether to create a new terminal.\nget_terminal\npython:str\noptional\noptional\npyedb.dotnet.database.edb_data.terminals"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_terminal",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_terminal.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_terminal",
        "title": "get_terminal > get_terminal > get_terminal",
        "section": "get_terminal > get_terminal",
        "text": "EDBPadstackInstance.get_terminal(name=None, create_new_terminal=False)\n\nGet PadstackInstanceTerminal object.\n\nParameters\n\nname\n\npython:str, optional\n\nName of the terminal. Only applicable when create_new_terminal is True.\n\ncreate_new_terminal\n\nbool, optional\n\nWhether to create a new terminal.\n\nReturns\n\npyedb.dotnet.database.edb_data.terminals\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.insert_zone",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.insert_zone.html#insert_zone",
        "title": "insert_zone",
        "section": "insert_zone",
        "text": "Insert a zone.\nZone to copy from when inserting a new zone.\nIf valid, the new zone is inserted as a copy of the given zone.\nOtherwise, the new zone is empty.\nID of the zone inserted if successful.\ninsert_zone\npython:int\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.insert_zone",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.insert_zone.html#pyedb.grpc.database.stackup.Stackup.insert_zone",
        "title": "insert_zone > insert_zone > insert_zone",
        "section": "insert_zone > insert_zone",
        "text": "Stackup.insert_zone(copy_zone=-1)\n\nInsert a zone.\n\nParameters\n\ncopy_zone\n\npython:int, default: -1\n\nZone to copy from when inserting a new zone.\nIf valid, the new zone is inserted as a copy of the given zone.\nOtherwise, the new zone is empty.\n\nReturns\n\npython:int\n\nID of the zone inserted if successful.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.add_length_mesh_operation",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.add_length_mesh_operation.html#add_length_mesh_operation",
        "title": "add_length_mesh_operation",
        "section": "add_length_mesh_operation",
        "text": "Add a mesh operation to the setup.\nDictionary containing nets and layers on which enable Mesh operation. Example {\"A0_N\": [\"TOP\", \"PWR\"]}.\nMesh operation name.\nMaximum number of elements. Default is 1000.\nMaximum length of elements. Default is 1mm.\nWhether to restrict number of elements. Default is True.\nWhether to restrict length of elements. Default is True.\nMesh region name.\nWhether to refine inside or not.  Default is False.\nadd_length_mesh_operation\npython:dict\n{\"A0_N\": [\"TOP\", \"PWR\"]}\npython:str\noptional\npython:int\noptional\n1000\npython:str\noptional\n1mm\noptional\nTrue\noptional\nTrue\npython:str\noptional\noptional\nFalse\nLengthMeshOperation"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.add_length_mesh_operation",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.add_length_mesh_operation.html#pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.add_length_mesh_operation",
        "title": "add_length_mesh_operation > add_length_mesh_operation > add_length_mesh_operation",
        "section": "add_length_mesh_operation > add_length_mesh_operation",
        "text": "HfssSimulationSetup.add_length_mesh_operation(net_layer_list, name=None, max_elements=1000, max_length='1mm', restrict_elements=True, restrict_length=True, refine_inside=False, mesh_region=None)\n\nAdd a mesh operation to the setup.\n\nParameters\n\nnet_layer_list\n\npython:dict\n\nDictionary containing nets and layers on which enable Mesh operation. Example {\"A0_N\": [\"TOP\", \"PWR\"]}.\n\nname\n\npython:str, optional\n\nMesh operation name.\n\nmax_elements\n\npython:int, optional\n\nMaximum number of elements. Default is 1000.\n\nmax_length\n\npython:str, optional\n\nMaximum length of elements. Default is 1mm.\n\nrestrict_elements\n\nbool, optional\n\nWhether to restrict number of elements. Default is True.\n\nrestrict_length\n\nbool, optional\n\nWhether to restrict length of elements. Default is True.\n\nmesh_region\n\npython:str, optional\n\nMesh region name.\n\nrefine_inside\n\nbool, optional\n\nWhether to refine inside or not.  Default is False.\n\nReturns\n\nLengthMeshOperation\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFile.write_xml",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFile.write_xml.html#write_xml",
        "title": "write_xml",
        "section": "write_xml",
        "text": "Write control file to XML.\nOutput XML file path.\nTrue if file created successfully, False otherwise.\nwrite_xml\npython:str\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFile.write_xml",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFile.write_xml.html#pyedb.grpc.database.control_file.ControlFile.write_xml",
        "title": "write_xml > write_xml > write_xml",
        "section": "write_xml > write_xml",
        "text": "ControlFile.write_xml(xml_output)\n\nWrite control file to XML.\n\nParameters\n\nxml_output\n\npython:str\n\nOutput XML file path.\n\nReturns\n\nbool\n\nTrue if file created successfully, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.set_frequencies_log_scale",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.set_frequencies_log_scale.html#set_frequencies_log_scale",
        "title": "set_frequencies_log_scale",
        "section": "set_frequencies_log_scale",
        "text": "Set a log-count frequency sweep.\nStart frequency. The default is \"1kHz\".\nStop frequency. The default is \"0.1GHz\".\nStep frequency. The default is 10.\nTrue if correctly executed, False otherwise.\nset_frequencies_log_scale\npython:str\npython:float\noptional\n\"1kHz\"\npython:str\npython:float\noptional\n\"0.1GHz\"\npython:int\noptional\n10\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.set_frequencies_log_scale",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.set_frequencies_log_scale.html#pyedb.dotnet.database.sim_setup_data.data.sweep_data.SweepData.set_frequencies_log_scale",
        "title": "set_frequencies_log_scale > set_frequencies_log_scale > set_frequencies_log_scale",
        "section": "set_frequencies_log_scale > set_frequencies_log_scale",
        "text": "SweepData.set_frequencies_log_scale(start='1kHz', stop='0.1GHz', samples=10)\n\nSet a log-count frequency sweep.\n\nParameters\n\nstart\n\npython:str, python:float, optional\n\nStart frequency. The default is \"1kHz\".\n\nstop\n\npython:str, python:float, optional\n\nStop frequency. The default is \"0.1GHz\".\n\nsamples\n\npython:int, optional\n\nStep frequency. The default is 10.\n\nReturns\n\nbool\n\nTrue if correctly executed, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_hfss.html#create_hfss",
        "title": "create_hfss",
        "section": "create_hfss",
        "text": "Create an HFSS model from an MCAD file.\nHFSS model created.\ncreate_hfss\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_hfss.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.create_hfss",
        "title": "create_hfss > create_hfss > create_hfss",
        "section": "create_hfss > create_hfss",
        "text": "PadstackInstance.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nReturns\n\nMcadModel\n\nHFSS model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.type.html#type",
        "title": "type",
        "section": "type",
        "text": "type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.point_terminal.PointTerminal.type.html#pyedb.grpc.database.terminal.point_terminal.PointTerminal.type",
        "title": "type > type > type",
        "section": "type > type",
        "text": "PointTerminal.type = 1\n\n"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.RectangularPatch.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.RectangularPatch.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Draw the patch, ground plane and feed geometry in EDB.\nTrue when the geometry has been successfully created.\ncreate"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.RectangularPatch.create",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.RectangularPatch.create.html#pyedb.libraries.rf_libraries.planar_antennas.RectangularPatch.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "RectangularPatch.create() -> bool\n\nDraw the patch, ground plane and feed geometry in EDB.\n\nReturns\n\nbool\n\nTrue when the geometry has been successfully created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_port",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_port.html#create_port",
        "title": "create_port",
        "section": "create_port",
        "text": "Create a port.\nUse create_port() has been moved to source_excitation.create_port.\ncreate_port\ncreate_port()"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_port",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_port.html#pyedb.grpc.edb.Edb.create_port",
        "title": "create_port > create_port > create_port",
        "section": "create_port > create_port",
        "text": "Edb.create_port(terminal, ref_terminal=None, is_circuit_port=False, name=None)\n\nCreate a port.\n\n..deprecated:: 0.51.0\n\nUse create_port() has been moved to source_excitation.create_port.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.snap_vias",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.snap_vias.html#snap_vias",
        "title": "snap_vias",
        "section": "snap_vias",
        "text": "Snap vias on the specified layers to touching geometry.\nLayer containing the vias to be snapped.\nTolerance for snapping vias. If snap_by_area_factor is True, this\nvalue should not have a unit.\nTolerance for snapping primitives.\nIf True, the via snapping tolerance is a factor of the surface area of the via.\nIf False, the via snapping tolerance is treated as an absolute distance.\nIf True, vias not connected to any geometry are removed.\nsnap_vias\npython:list\nof\nTrue\nTrue\nFalse\nTrue"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.snap_vias",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.snap_vias.html#pyedb.grpc.database.layout.layout.Layout.snap_vias",
        "title": "snap_vias > snap_vias > snap_vias",
        "section": "snap_vias > snap_vias",
        "text": "Layout.snap_vias(layer: LayerListLike, via_snapping_tol: ValueLike = 3, prim_snapping_tol: ValueLike = '0.05um', snap_by_area_factor: bool = True, remove_dangling_vias: bool = True)\n\nSnap vias on the specified layers to touching geometry.\n\nParameters\n\nlayer\n\nLayerLike or python:list of LayerLike\n\nLayer containing the vias to be snapped.\n\nvia_snapping_tol\n\nValueLike\n\nTolerance for snapping vias. If snap_by_area_factor is True, this\nvalue should not have a unit.\n\nprim_snapping_tol\n\nValueLike\n\nTolerance for snapping primitives.\n\nsnap_by_area_factor\n\nbool\n\nIf True, the via snapping tolerance is a factor of the surface area of the via.\nIf False, the via snapping tolerance is treated as an absolute distance.\n\nremove_dangling_vias\n\nbool\n\nIf True, vias not connected to any geometry are removed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.product_solver_names",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.product_solver_names.html#product_solver_names",
        "title": "product_solver_names",
        "section": "product_solver_names",
        "text": "Get the list of solver names.\nID of the product.\nproduct_solver_names\nProductIdType\npython:list\nof\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.product_solver_names",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CoaxPort.product_solver_names.html#pyedb.grpc.database.ports.ports.CoaxPort.product_solver_names",
        "title": "product_solver_names > product_solver_names > product_solver_names",
        "section": "product_solver_names > product_solver_names",
        "text": "CoaxPort.product_solver_names(product_id)\n\nGet the list of solver names.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nReturns\n\npython:list of python:str\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave.add_siwave_dc_analysis",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave.add_siwave_dc_analysis.html#add_siwave_dc_analysis",
        "title": "add_siwave_dc_analysis",
        "section": "add_siwave_dc_analysis",
        "text": "Add a Siwave DC analysis in EDB.\nSource Reference to Ground settings works only from 2021.2\nSetup name.\nSetup object class.\nadd_siwave_dc_analysis\npython:str\noptional\npyedb.dotnet.database.edb_data.siwave_simulation_setup_data.SiwaveDCSimulationSetup"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave.add_siwave_dc_analysis",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave.add_siwave_dc_analysis.html#pyedb.grpc.database.siwave.Siwave.add_siwave_dc_analysis",
        "title": "add_siwave_dc_analysis > add_siwave_dc_analysis > add_siwave_dc_analysis",
        "section": "add_siwave_dc_analysis > add_siwave_dc_analysis",
        "text": "Siwave.add_siwave_dc_analysis(name: str | None = None) -> Any\n\nAdd a Siwave DC analysis in EDB.\n\nSource Reference to Ground settings works only from 2021.2\n\nParameters\n\nname\n\npython:str, optional\n\nSetup name.\n\nReturns\n\npyedb.dotnet.database.edb_data.siwave_simulation_setup_data.SiwaveDCSimulationSetup\n\nSetup object class.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb(\"pathtoaedb\", edbversion=\"2021.2\")\n>>> edb.siwave.add_siwave_ac_analysis()\n>>> edb.siwave.add_siwave_dc_analysis2(\"my_setup\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileMaterial",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileMaterial.html#controlfilematerial",
        "title": "ControlFileMaterial",
        "section": "ControlFileMaterial",
        "text": "ControlFileMaterial"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileMaterial",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileMaterial.html#pyedb.dotnet.database.edb_data.control_file.ControlFileMaterial",
        "title": "ControlFileMaterial > ControlFileMaterial > ControlFileMaterial",
        "section": "ControlFileMaterial > ControlFileMaterial",
        "text": "class pyedb.dotnet.database.edb_data.control_file.ControlFileMaterial(name, properties)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_dump_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#json-mode)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent: Indentation to use in the JSON output. If None is passed, the output will be compact.\nensure_ascii: If True, the output is guaranteed to have all incoming non-ASCII characters escaped.\nIf False (the default), these characters will be output as-is.\ninclude: Field(s) to include in the JSON output.\nexclude: Field(s) to exclude from the JSON output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to serialize using field aliases.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\nA JSON string representation of the model.\nmodel_dump_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_dump_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_dump_json.html#pyedb.workflows.drc.drc.DiffPair.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "DiffPair.model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -> str\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#json-mode)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nArgs:\n\nindent: Indentation to use in the JSON output. If None is passed, the output will be compact.\nensure_ascii: If True, the output is guaranteed to have all incoming non-ASCII characters escaped.\n\nIf False (the default), these characters will be output as-is.\n\ninclude: Field(s) to include in the JSON output.\nexclude: Field(s) to exclude from the JSON output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to serialize using field aliases.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\n\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\n\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback: A function to call when an unknown value is encountered. If not provided,\n\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/RaptorXSimulationSetup",
        "href": "dotnet_api/dotnet/edb_data/RaptorXSimulationSetup.html#raptorx-simulation-setup",
        "title": "RaptorX simulation setup",
        "section": "RaptorX simulation setup",
        "text": "These classes are the containers of RaptorX simulation setup.\nRaptorXSimulationSetup\nManages EDB methods for RaptorX simulation setup.\nRaptorXSimulationSettings\n\nRaptorXGeneralSettings\n\nRaptorXSimulationAdvancedSettings\n\nRaptorX simulation setup\nRaptorXSimulationSetup\nRaptorXSimulationSettings\nRaptorXGeneralSettings\nRaptorXSimulationAdvancedSettings"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.merge_dielectrics",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.merge_dielectrics.html#merge_dielectrics",
        "title": "merge_dielectrics",
        "section": "merge_dielectrics",
        "text": "Merge the dielectric layers in a range of layers into one large dielectric layer.\nmerge_dielectrics\nLayout\npython:str\npython:str\nDielectricMergingMethod\npython:str\npython:str\nStackupLayer"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.merge_dielectrics",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.merge_dielectrics.html#pyedb.grpc.database.stackup.Stackup.merge_dielectrics",
        "title": "merge_dielectrics > merge_dielectrics > merge_dielectrics",
        "section": "merge_dielectrics > merge_dielectrics",
        "text": "Stackup.merge_dielectrics(layout, start_layer_name, end_layer_name, merging_method, merged_layer_name, merged_mat_name)\n\nMerge the dielectric layers in a range of layers into one large dielectric layer.\n\nParameters\n\nlayout\n\nLayout\n\n\n\nstart_layer_name\n\npython:str\n\n\n\nend_layer_name\n\npython:str\n\n\n\nmerging_method\n\nDielectricMergingMethod\n\n\n\nmerged_layer_name\n\npython:str\n\n\n\nmerged_mat_name\n\npython:str\n\n\n\nReturns\n\nStackupLayer\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.create_hfss.html#create_hfss",
        "title": "create_hfss",
        "section": "create_hfss",
        "text": "Create an HFSS model from an MCAD file.\nHFSS model created.\ncreate_hfss\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.create_hfss.html#pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.create_hfss",
        "title": "create_hfss > create_hfss > create_hfss",
        "section": "create_hfss > create_hfss",
        "text": "PinGroupTerminal.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nReturns\n\nMcadModel\n\nHFSS model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.set_product_property",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layer collection for a given product ID and attribute ID.\nProduct ID.\nAttribute ID.\nNew property value.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.set_product_property",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.set_product_property.html#pyedb.grpc.database.stackup.Stackup.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "Stackup.set_product_property(prod_id, attr_it, prop_value)\n\nSet the product property of the layer collection for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nProduct ID.\n\nattr_it\n\npython:int\n\nAttribute ID.\n\nprop_value\n\npython:str\n\nNew property value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef.convert_to_3d_microvias",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef.convert_to_3d_microvias.html#convert_to_3d_microvias",
        "title": "convert_to_3d_microvias",
        "section": "convert_to_3d_microvias",
        "text": "Convert actual padstack instance to microvias 3D Objects with a given aspect ratio.\nEither to convert only vias belonging to signal nets or all vias. Defaults is True.\nAngle of laser penetration in degrees. The angle defines the lowest hole diameter with this formula:\nHoleDiameter -2*tan(laser_angle* Hole depth). Hole depth is the height of the via (dielectric thickness).\nThe default is 15.\nThe lowest hole is 0.75*HoleDepth/HoleDiam.\nWhether to delete the padstack definition. The default is True.\nIf False, the padstack definition is not deleted and the hole size is set to zero.\nconvert_to_3d_microvias\noptional\nTrue\npython:float\noptional\n15\n0.75*HoleDepth/HoleDiam\noptional\nTrue\nFalse\nTrue\nwhen\nsuccessful\nFalse\nwhen"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef.convert_to_3d_microvias",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef.convert_to_3d_microvias.html#pyedb.grpc.database.definition.padstack_def.PadstackDef.convert_to_3d_microvias",
        "title": "convert_to_3d_microvias > convert_to_3d_microvias > convert_to_3d_microvias",
        "section": "convert_to_3d_microvias > convert_to_3d_microvias",
        "text": "PadstackDef.convert_to_3d_microvias(convert_only_signal_vias=True, hole_wall_angle=15, delete_padstack_def=True) -> bool\n\nConvert actual padstack instance to microvias 3D Objects with a given aspect ratio.\n\nParameters\n\nconvert_only_signal_vias\n\nbool, optional\n\nEither to convert only vias belonging to signal nets or all vias. Defaults is True.\n\nhole_wall_angle\n\npython:float, optional\n\nAngle of laser penetration in degrees. The angle defines the lowest hole diameter with this formula:\nHoleDiameter -2*tan(laser_angle* Hole depth). Hole depth is the height of the via (dielectric thickness).\nThe default is 15.\nThe lowest hole is 0.75*HoleDepth/HoleDiam.\n\ndelete_padstack_def\n\nbool, optional\n\nWhether to delete the padstack definition. The default is True.\nIf False, the padstack definition is not deleted and the hole size is set to zero.\n\nReturns\n\nTrue when successful, False when failed.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.create_dielectric_filled_backdrills",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.create_dielectric_filled_backdrills.html#create_dielectric_filled_backdrills",
        "title": "create_dielectric_filled_backdrills",
        "section": "create_dielectric_filled_backdrills",
        "text": "Create dielectric-filled back-drills for through-hole vias.\nBack-drilling (a.k.a. controlled-depth drilling) is used to remove the\nunused via stub that acts as an unterminated transmission-line segment,\nthereby improving signal-integrity at high frequencies.  This routine\ngoes one step further: after the stub is removed the resulting cylindrical\ncavity is completely filled with a user-specified dielectric.  The\nfill material restores mechanical rigidity, prevents solder-wicking, and\nkeeps the original via’s electrical characteristics intact on the\nremaining, still-plated, portion.\nSignal layer name up to which the back-drill is performed (inclusive).\nThe drill always starts on the bottom-most signal layer of the stack-up.\nFinished hole diameter for the back-drill.  A numeric value is\ninterpreted in the database length unit; a string such as\n\"0.3mm\" is evaluated with units.\nName of the dielectric material that fills the drilled cavity.  If the\nmaterial does not yet exist in the central material library it is\ncreated on the fly.\nRelative permittivity \\varepsilon_{\\mathrm{r}} used when the\nmaterial has to be created.  Must be positive.\nExplicit list of via instances to process.  When provided,\npadstack_definition and nets are ignored for filtering.\nPad-stack definition(s) to process.  If omitted, all through-hole\ndefinitions are considered.\nLoss tangent \\tan\\delta used when the material has to be\ncreated.  Defaults to 0.0.\nNet name(s) used to filter vias.  If omitted, vias belonging to\nany net are processed.\nTrue when at least one back-drill was successfully created.\nFalse if no suitable via was found or any error occurred.\nIf material is empty or if permittivity is non-positive when a\nnew material must be created.\nThe routine is safe to call repeatedly: existing back-drills are not\nduplicated because the *_BD definition name is deterministic.\nThe original via keeps its pad-stack definition and net assignment; only\nits unused stub is removed.\nThe back-drill is not subtracted from anti-pads or plane clearances;\nthe filling material is assumed to be electrically invisible at the\nfrequencies of interest.\nCreate back-drills on all vias belonging to two specific pad-stack\ndefinitions and two DDR4 nets:\ncreate_dielectric_filled_backdrills\nstr\nfloat\nstr\n\"0.3mm\"\nstr\nfloat\nlist\nPadstackInstance\noptional\npadstack_definition\nnets\nstr\nlist\nstr\noptional\nfloat\noptional\n0.0\nstr\nlist\nstr\noptional\nbool\nTrue\nFalse\nValueError\nmaterial\npermittivity\n*_BD"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.create_dielectric_filled_backdrills",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.create_dielectric_filled_backdrills.html#pyedb.grpc.database.padstacks.Padstacks.create_dielectric_filled_backdrills",
        "title": "create_dielectric_filled_backdrills > create_dielectric_filled_backdrills > create_dielectric_filled_backdrills",
        "section": "create_dielectric_filled_backdrills > create_dielectric_filled_backdrills",
        "text": "Padstacks.create_dielectric_filled_backdrills(layer: str, diameter: float | str, material: str, permittivity: float, padstack_instances: List[PadstackInstance] | None = None, padstack_definition: str | List[str] | None = None, dielectric_loss_tangent: float | None = None, nets: str | List[str] | None = None) -> bool\n\nCreate dielectric-filled back-drills for through-hole vias.\n\nBack-drilling (a.k.a. controlled-depth drilling) is used to remove the\nunused via stub that acts as an unterminated transmission-line segment,\nthereby improving signal-integrity at high frequencies.  This routine\ngoes one step further: after the stub is removed the resulting cylindrical\ncavity is completely filled with a user-specified dielectric.  The\nfill material restores mechanical rigidity, prevents solder-wicking, and\nkeeps the original via’s electrical characteristics intact on the\nremaining, still-plated, portion.\n\nParameters\n\nlayer\n\nstr\n\nSignal layer name up to which the back-drill is performed (inclusive).\nThe drill always starts on the bottom-most signal layer of the stack-up.\n\ndiameter\n\nfloat or str\n\nFinished hole diameter for the back-drill.  A numeric value is\ninterpreted in the database length unit; a string such as\n\"0.3mm\" is evaluated with units.\n\nmaterial\n\nstr\n\nName of the dielectric material that fills the drilled cavity.  If the\nmaterial does not yet exist in the central material library it is\ncreated on the fly.\n\npermittivity\n\nfloat\n\nRelative permittivity \\varepsilon_{\\mathrm{r}} used when the\nmaterial has to be created.  Must be positive.\n\npadstack_instances\n\nlist [PadstackInstance ], optional\n\nExplicit list of via instances to process.  When provided,\npadstack_definition and nets are ignored for filtering.\n\npadstack_definition\n\nstr or list [str ], optional\n\nPad-stack definition(s) to process.  If omitted, all through-hole\ndefinitions are considered.\n\ndielectric_loss_tangent\n\nfloat, optional\n\nLoss tangent \\tan\\delta used when the material has to be\ncreated.  Defaults to 0.0.\n\nnets\n\nstr or list [str ], optional\n\nNet name(s) used to filter vias.  If omitted, vias belonging to\nany net are processed.\n\nReturns\n\nbool\n\nTrue when at least one back-drill was successfully created.\nFalse if no suitable via was found or any error occurred.\n\nRaises\n\nValueError\n\nIf material is empty or if permittivity is non-positive when a\nnew material must be created.\n\nNotes\n\nThe routine is safe to call repeatedly: existing back-drills are not\nduplicated because the *_BD definition name is deterministic.\n\nThe original via keeps its pad-stack definition and net assignment; only\nits unused stub is removed.\n\nThe back-drill is not subtracted from anti-pads or plane clearances;\nthe filling material is assumed to be electrically invisible at the\nfrequencies of interest.\n\nExamples\n\nCreate back-drills on all vias belonging to two specific pad-stack\ndefinitions and two DDR4 nets:\n\n>>> edb.padstacks.create_dielectric_filled_backdrills(\n...     layer=\"L3\",\n...     diameter=\"0.25mm\",\n...     material=\"EPON_827\",\n...     permittivity=3.8,\n...     dielectric_loss_tangent=0.015,\n...     padstack_definition=[\"VIA_10MIL\", \"VIA_16MIL\"],\n...     nets=[\"DDR4_DQ0\", \"DDR4_DQ1\"],\n... )\nTrue\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.find",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.find.html#find",
        "title": "find",
        "section": "find",
        "text": "Find a terminal by name in a given layout.\nLayout to search for the terminal.\nName of the terminal.\nfind\nLayout\nstr\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.find",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.find.html#pyedb.grpc.database.terminal.terminal.Terminal.find",
        "title": "find > find > find",
        "section": "find > find",
        "text": "classmethod Terminal.find(layout, name)\n\nFind a terminal by name in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the terminal.\n\nname\n\nstr\n\nName of the terminal.\n\nReturns\n\nTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.dict",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "dict"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.dict",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.dict.html#pyedb.workflows.drc.drc.MinClearance.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "MinClearance.dict(*, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Dict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/terminal.html#terminal",
        "title": "Terminal",
        "section": "Terminal",
        "text": "This class is managing EDB terminal.\nTerminal\n\nTerminal\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.remove_zone",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.remove_zone.html#remove_zone",
        "title": "remove_zone",
        "section": "remove_zone",
        "text": "Remove a zone.\nID of the zone.\nremove_zone\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.remove_zone",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.remove_zone.html#pyedb.grpc.database.stackup.Stackup.remove_zone",
        "title": "remove_zone > remove_zone > remove_zone",
        "section": "remove_zone > remove_zone",
        "text": "Stackup.remove_zone(zone)\n\nRemove a zone.\n\nParameters\n\nzone\n\npython:int\n\nID of the zone.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_vertical_circuit_port_on_clipped_traces",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_vertical_circuit_port_on_clipped_traces.html#create_vertical_circuit_port_on_clipped_traces",
        "title": "create_vertical_circuit_port_on_clipped_traces",
        "section": "create_vertical_circuit_port_on_clipped_traces",
        "text": "Create an edge port on clipped signal traces.\nString of one net or EDB net or a list of multiple nets or EDB nets.\nName or EDB reference net.\nUse this point list or PolygonData object to check if ports are at this polygon border.\nNested list of str, with net name as first value, X value for point at border, Y value for point at border,\nand terminal name.\ncreate_vertical_circuit_port_on_clipped_traces\npython:list\noptional\npython:str\nEdb\nx\ny\nEDB\nPolygonData\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_vertical_circuit_port_on_clipped_traces",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_vertical_circuit_port_on_clipped_traces.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_vertical_circuit_port_on_clipped_traces",
        "title": "create_vertical_circuit_port_on_clipped_traces > create_vertical_circuit_port_on_clipped_traces > create_vertical_circuit_port_on_clipped_traces",
        "section": "create_vertical_circuit_port_on_clipped_traces > create_vertical_circuit_port_on_clipped_traces",
        "text": "SourceExcitation.create_vertical_circuit_port_on_clipped_traces(nets: str | List[str] | Net | List[Net] | None = None, reference_net: str | Net | None = None, user_defined_extent: List[float] | PolygonData | None = None) -> List[List[str]] | bool\n\nCreate an edge port on clipped signal traces.\n\nParameters\n\nnets\n\npython:list, optional\n\nString of one net or EDB net or a list of multiple nets or EDB nets.\n\nreference_net\n\npython:str, Edb net.\n\nName or EDB reference net.\n\nuser_defined_extent\n\n[x, y], EDB PolygonData\n\nUse this point list or PolygonData object to check if ports are at this polygon border.\n\nReturns\n\n[[python:str]]\n\nNested list of str, with net name as first value, X value for point at border, Y value for point at border,\nand terminal name.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> terminals = edb.source_excitation.create_vertical_circuit_port_on_clipped_traces([\"Net1\"], \"GND\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_hfss_prop.html#get_hfss_prop",
        "title": "get_hfss_prop",
        "section": "get_hfss_prop",
        "text": "Get HFSS properties.\nReturns a tuple in this format:\n(material, solve_inside)\nmaterial :  Name of the material property.\nsolve_inside : Whether to solve inside.\nget_hfss_prop\npython:tuple\nof\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_hfss_prop",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.get_hfss_prop.html#pyedb.grpc.database.primitive.polygon.Polygon.get_hfss_prop",
        "title": "get_hfss_prop > get_hfss_prop > get_hfss_prop",
        "section": "get_hfss_prop > get_hfss_prop",
        "text": "Polygon.get_hfss_prop() -> tuple[str, bool]\n\nGet HFSS properties.\n\nReturns\n\npython:tuple of (python:str, bool)\n\nReturns a tuple in this format:\n\n(material, solve_inside)\n\nmaterial :  Name of the material property.\n\nsolve_inside : Whether to solve inside.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_primitive",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_primitive.html#get_primitive",
        "title": "get_primitive",
        "section": "get_primitive",
        "text": "Retrieve primitive from give id.\nPrimitive id.\nList of primitives.\nget_primitive\npython:int\npython:list\nof\npyedb.dotnet.database.edb_data.primitives_data.Primitive"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_primitive",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_primitive.html#pyedb.dotnet.database.modeler.Modeler.get_primitive",
        "title": "get_primitive > get_primitive > get_primitive",
        "section": "get_primitive > get_primitive",
        "text": "Modeler.get_primitive(primitive_id)\n\nRetrieve primitive from give id.\n\nParameters\n\nprimitive_id\n\npython:int\n\nPrimitive id.\n\nReturns\n\npython:list of pyedb.dotnet.database.edb_data.primitives_data.Primitive\n\nList of primitives.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.find_instance_by_id",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.find_instance_by_id.html#find_instance_by_id",
        "title": "find_instance_by_id",
        "section": "find_instance_by_id",
        "text": "Find a padstack instance by database ID.\nDatabase ID of the padstack instance.\nPadstack instance if found, otherwise None.\nfind_instance_by_id\npython:int\npyedb.grpc.database.primitive.padstack_instance.PadstackInstance\npython:None\nNone"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.find_instance_by_id",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.find_instance_by_id.html#pyedb.grpc.database.padstacks.Padstacks.find_instance_by_id",
        "title": "find_instance_by_id > find_instance_by_id > find_instance_by_id",
        "section": "find_instance_by_id > find_instance_by_id",
        "text": "Padstacks.find_instance_by_id(value: int) -> PadstackInstance | None\n\nFind a padstack instance by database ID.\n\nParameters\n\nvalue\n\npython:int\n\nDatabase ID of the padstack instance.\n\nReturns\n\npyedb.grpc.database.primitive.padstack_instance.PadstackInstance or python:None\n\nPadstack instance if found, otherwise None.\n\nExamples\n\n>>> via = edb_padstacks.find_instance_by_id(123)\n>>> if via:\n...     print(f\"Found via: {via.name}\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the layout object.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.delete.html#pyedb.grpc.database.primitive.primitive.Primitive.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "Primitive.delete()\n\nDelete the layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.find",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.find.html#find",
        "title": "find",
        "section": "find",
        "text": "Find a terminal by name in a given layout.\nLayout to search for the terminal.\nName of the terminal.\nfind\nLayout\nstr\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.find",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.find.html#pyedb.grpc.database.terminal.bundle_terminal.BundleTerminal.find",
        "title": "find > find > find",
        "section": "find > find",
        "text": "classmethod BundleTerminal.find(layout, name)\n\nFind a terminal by name in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the terminal.\n\nname\n\nstr\n\nName of the terminal.\n\nReturns\n\nTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.create",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.create.html#create",
        "title": "create",
        "section": "create",
        "text": "Create a pin pair model.\nPin pair model created.\ncreate\nPinPairModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.create",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.create.html#pyedb.grpc.database.hierarchy.pin_pair_model.PinPairModel.create",
        "title": "create > create > create",
        "section": "create > create",
        "text": "classmethod PinPairModel.create()\n\nCreate a pin pair model.\n\nReturns\n\nPinPairModel\n\nPin pair model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_connected_objects",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_connected_objects.html#get_connected_objects",
        "title": "get_connected_objects",
        "section": "get_connected_objects",
        "text": "Get connected objects.\nget_connected_objects\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_connected_objects",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_connected_objects.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.get_connected_objects",
        "title": "get_connected_objects > get_connected_objects > get_connected_objects",
        "section": "get_connected_objects > get_connected_objects",
        "text": "EDBPadstackInstance.get_connected_objects()\n\nGet connected objects.\n\nReturns\n\npython:list\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_polygon_points",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_polygon_points.html#get_polygon_points",
        "title": "get_polygon_points",
        "section": "get_polygon_points",
        "text": "Retrieve polygon points.\nFor arcs, one point is returned.\nclass: dotnet.database.edb_data.primitives_data.Primitive\nfrom the list equals 2, a segment is defined. The first tuple defines the starting point while the second\ntuple the ending one. If the length of one tuple equals one, that means a polyline is defined and the value\nis giving the arc height. Therefore to polyline is defined as starting point for the tuple\nbefore in the list, the current one the arc height and the tuple after the polyline ending point.\nget_polygon_points\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_polygon_points",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_polygon_points.html#pyedb.dotnet.database.modeler.Modeler.get_polygon_points",
        "title": "get_polygon_points > get_polygon_points > get_polygon_points",
        "section": "get_polygon_points > get_polygon_points",
        "text": "Modeler.get_polygon_points(polygon)\n\nRetrieve polygon points.\n\nFor arcs, one point is returned.\n\nParameters\n\npolygon\n\nclass: dotnet.database.edb_data.primitives_data.Primitive\n\nReturns\n\npython:list\n\nList of tuples. Each tuple provides x, y point coordinate. If the length of two consecutives tuples\n\nfrom the list equals 2, a segment is defined. The first tuple defines the starting point while the second\ntuple the ending one. If the length of one tuple equals one, that means a polyline is defined and the value\nis giving the arc height. Therefore to polyline is defined as starting point for the tuple\nbefore in the list, the current one the arc height and the tuple after the polyline ending point.\n\nExamples\n\n>>> poly = database.modeler.get_polygons_by_layer(\"GND\")\n>>> points = database.modeler.get_polygon_points(poly[0])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.to_dict",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.to_dict.html#to_dict",
        "title": "to_dict",
        "section": "to_dict",
        "text": "Convert material into dictionary.\nto_dict"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.to_dict",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.to_dict.html#pyedb.grpc.database.definition.materials.Material.to_dict",
        "title": "to_dict > to_dict > to_dict",
        "section": "to_dict > to_dict",
        "text": "Material.to_dict()\n\nConvert material into dictionary.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.disjoint_nets",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.disjoint_nets.html#disjoint_nets",
        "title": "disjoint_nets",
        "section": "disjoint_nets",
        "text": "Find and fix disjoint nets from a given netlist.\nList of nets on which check disjoints. If None is provided then the algorithm will loop on all nets.\nRemove all secondary nets other than principal one (the one with more objects in it). Default is False.\nClean all disjoint nets with area less than specified area in square meters. Default is 0.0 to disable it.\nWhether if the naming order has to be by number of objects (fastest) or area (slowest but more accurate).\nDefault is False.\nWhether if delete disjoints pins not connected to any other primitive or not. Default is False.\nNew nets created.\ndisjoint_nets\npython:str\npython:list\noptional\noptional\noptional\noptional\nFalse\noptional\nFalse\nList"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.disjoint_nets",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.disjoint_nets.html#pyedb.dotnet.database.layout_validation.LayoutValidation.disjoint_nets",
        "title": "disjoint_nets > disjoint_nets > disjoint_nets",
        "section": "disjoint_nets > disjoint_nets",
        "text": "LayoutValidation.disjoint_nets(net_list=None, keep_only_main_net=False, clean_disjoints_less_than=0.0, order_by_area=False, keep_disjoint_pins=False)\n\nFind and fix disjoint nets from a given netlist.\n\nParameters\n\nnet_list\n\npython:str, python:list, optional\n\nList of nets on which check disjoints. If None is provided then the algorithm will loop on all nets.\n\nkeep_only_main_net\n\nbool, optional\n\nRemove all secondary nets other than principal one (the one with more objects in it). Default is False.\n\nclean_disjoints_less_than\n\nbool, optional\n\nClean all disjoint nets with area less than specified area in square meters. Default is 0.0 to disable it.\n\norder_by_area\n\nbool, optional\n\nWhether if the naming order has to be by number of objects (fastest) or area (slowest but more accurate).\nDefault is False.\n\nkeep_disjoint_pins\n\nbool, optional\n\nWhether if delete disjoints pins not connected to any other primitive or not. Default is False.\n\nReturns\n\nList\n\nNew nets created.\n\nExamples\n\n>>> renamed_nets = edb.layout_validation.disjoint_nets([\"GND\", \"Net2\"])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.create_hfss.html#create_hfss",
        "title": "create_hfss",
        "section": "create_hfss",
        "text": "Create an HFSS model from an MCAD file.\nHFSS model created.\ncreate_hfss\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.create_hfss.html#pyedb.grpc.database.primitive.rectangle.Rectangle.create_hfss",
        "title": "create_hfss > create_hfss > create_hfss",
        "section": "create_hfss > create_hfss",
        "text": "Rectangle.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nReturns\n\nMcadModel\n\nHFSS model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get a list of attribute IDs given a product ID for the layout object.\nID representing a product that supports the EDB.\nAll user-defined attribute IDs for properties stored in the object\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.get_product_property_ids.html#pyedb.grpc.database.hierarchy.component.Component.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "Component.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nReturns\n\npython:list[python:int]\n\nAll user-defined attribute IDs for properties stored in the object\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.CircularPatch",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.CircularPatch.html#circularpatch",
        "title": "CircularPatch",
        "section": "CircularPatch",
        "text": "Circular microstrip patch antenna (optionally probe-fed).\nThe class automatically determines the physical dimensions for a\ndesired resonance frequency, creates the patch, ground plane and\neither an inset microstrip feed or a coaxial probe feed, and\noptionally sets up an HFSS simulation.\nEDB project/cell in which the antenna will be built.\nTarget resonance frequency of the patch.  A string such as\n\"2.4GHz\" or a numeric value in Hz can be given.\nRadial offset of the 50 Ω coax probe from the patch center.\nA value of 0 places the probe at the center (not recommended\nfor good matching).\nMetallization layer on which the patch polygon is drawn.\nMetallization layer on which the ground polygon is drawn.\nIf True, create a lumped port (probe feed) and add an HFSS\nsetup with a frequency sweep.\nBuild a 5.8 GHz circular patch on a 0.787 mm Rogers RO4350B substrate:\nProbe-fed 2.4 GHz patch with default 0 offset (center feed):\nSubstrate definition (er, tand, h) used for all\nanalytical calculations.\nCircularPatch.create()\nDraw the patch, ground plane and feed geometry in EDB.\nCircularPatch\npyedb.Edb\noptional\npython:str\npython:float\ndefault\n\"2.4GHz\"\npython:str\npython:float\ndefault\npython:str\ndefault\npython:str\ndefault\ndefault\npython:True\nSubstrate\ner\ntand\nh\nCircularPatch.create"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.CircularPatch",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.planar_antennas.CircularPatch.html#pyedb.libraries.rf_libraries.planar_antennas.CircularPatch",
        "title": "CircularPatch > CircularPatch > CircularPatch",
        "section": "CircularPatch > CircularPatch",
        "text": "class pyedb.libraries.rf_libraries.planar_antennas.CircularPatch(edb_cell=None, target_frequency: str | float = '2.4GHz', length_feeding_line: str | float = 0, layer: str = 'TOP_METAL', bottom_layer: str = 'BOT_METAL', add_port: bool = True)\n\nCircular microstrip patch antenna (optionally probe-fed).\n\nThe class automatically determines the physical dimensions for a\ndesired resonance frequency, creates the patch, ground plane and\neither an inset microstrip feed or a coaxial probe feed, and\noptionally sets up an HFSS simulation.\n\nParameters\n\nedb_cell\n\npyedb.Edb, optional\n\nEDB project/cell in which the antenna will be built.\n\nfreq\n\npython:str or python:float, default “2.4GHz”\n\nTarget resonance frequency of the patch.  A string such as\n\"2.4GHz\" or a numeric value in Hz can be given.\n\nprobe_offset\n\npython:str or python:float, default 0\n\nRadial offset of the 50 Ω coax probe from the patch center.\nA value of 0 places the probe at the center (not recommended\nfor good matching).\n\nlayer\n\npython:str, default “TOP_METAL”\n\nMetallization layer on which the patch polygon is drawn.\n\nbottom_layer\n\npython:str, default “BOT_METAL”\n\nMetallization layer on which the ground polygon is drawn.\n\nadd_port\n\nbool, default python:True\n\nIf True, create a lumped port (probe feed) and add an HFSS\nsetup with a frequency sweep.\n\nExamples\n\nBuild a 5.8 GHz circular patch on a 0.787 mm Rogers RO4350B substrate:\n\n>>> edb = pyedb.Edb()\n>>> patch = CircularPatch(edb_cell=edb, freq=\"5.8GHz\", probe_offset=\"6.4mm\", layer=\"TOP\", bottom_layer=\"GND\")\n>>> patch.substrate.er = 3.66\n>>> patch.substrate.tand = 0.0037\n>>> patch.substrate.h = 0.000787\n>>> patch.create()\n>>> edb.save_as(\"circ_patch_5p8GHz.aedb\")\n\nProbe-fed 2.4 GHz patch with default 0 offset (center feed):\n\n>>> edb = pyedb.Edb()\n>>> CircularPatch(edb, freq=2.4e9).create()\n>>> edb.save_as(\"probe_circ_patch_2p4GHz.aedb\")\n\nAttributes\n\nsubstrate\n\nSubstrate\n\nSubstrate definition (er, tand, h) used for all\nanalytical calculations.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nCircularPatch.create()\n\nDraw the patch, ground plane and feed geometry in EDB.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.set_is_in_zone",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.set_is_in_zone.html#set_is_in_zone",
        "title": "set_is_in_zone",
        "section": "set_is_in_zone",
        "text": "Set whether the layer exists in a given zone.\nZone.\nWhether the layer exists in this zone.\nset_is_in_zone\npython:int\npython:True"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.set_is_in_zone",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.layer.Layer.set_is_in_zone.html#pyedb.grpc.database.layers.layer.Layer.set_is_in_zone",
        "title": "set_is_in_zone > set_is_in_zone > set_is_in_zone",
        "section": "set_is_in_zone > set_is_in_zone",
        "text": "Layer.set_is_in_zone(zone, in_zone=True)\n\nSet whether the layer exists in a given zone.\n\nParameters\n\nzone\n\npython:int\n\nZone.\n\nin_zone\n\nbool, default: python:True\n\nWhether the layer exists in this zone.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.html#layercollection",
        "title": "LayerCollection",
        "section": "LayerCollection",
        "text": "Manages layer collections in an EDB database.\nEDB object.\nEDB layer collection object.\nLayerCollection.add_document_layer(name[, ...])\nAdd a document layer.\nLayerCollection.add_layer_above(name, ...[, ...])\nAdd a layer above a specified layer.\nLayerCollection.add_layer_below(name, ...[, ...])\nAdd a layer below a specified layer.\nLayerCollection.add_layer_bottom(name[, ...])\nAdd a layer at the bottom of the stackup.\nLayerCollection.add_layer_top(name[, layer_type])\nAdd a layer on top of the stackup.\nLayerCollection.add_layers(layers)\nAdd a list of layers to the layer collection.\nLayerCollection.add_stackup_layer_at_elevation(...)\nAdd a stackup layer at a user-specified elevation.\nLayerCollection.add_via_layer(via_layer_to_add)\nAdd a via layer to the layer collection.\nLayerCollection.add_zone_to_layer(layer, ...)\nSet the zone to the layer and update the layer in the collection.\nLayerCollection.clone()\nCreate a clone of the layer collection.\nLayerCollection.create([mode])\nCreate a layer collection.\nLayerCollection.find_by_name(layer_name)\nFind a layer in the layer collection.\nLayerCollection.get_layers([layer_filter])\nGet a list of layers in the layer collection using a layer filter.\nLayerCollection.get_product_property(...)\nGet the product property of the layer collection for a given product ID and attribute ID.\nLayerCollection.get_product_property_ids(prod_id)\nGet a list of attribute IDs for a given product ID for the layer collection.\nLayerCollection.get_top_bottom_stackup_layers(...)\nGet the top and bottom stackup layers of a specific type and their elevations.\nLayerCollection.get_zone_name(zone)\nGet the name for a given zone.\nLayerCollection.import_from_control_file(...)\nImport layers from a control file and optional XML schema file.\nLayerCollection.insert_zone([copy_zone])\nInsert a zone.\nLayerCollection.is_valid()\nDetermine if the layer collection is in a valid state.\nLayerCollection.merge_dielectrics(layout, ...)\nMerge the dielectric layers in a range of layers into one large dielectric layer.\nLayerCollection.remove_zone(zone)\nRemove a zone.\nLayerCollection.set_product_property(...)\nSet the product property of the layer collection for a given product ID and attribute ID.\nLayerCollection.set_zone_name(zone, name)\nSet the name for a given zone.\nLayerCollection.simplify_dielectrics_for_phi(...)\nSplit dielectric layers at the boundaries of signal layers and merge them.\nLayerCollection.update_layout()\nUpdate the layout with the current layer collection.\nLayerCollection\npyedb.Edb\nansys.edb.core.layer.LayerCollection\nLayerCollection.add_document_layer\nLayerCollection.add_layer_above\nLayerCollection.add_layer_below\nLayerCollection.add_layer_bottom\nLayerCollection.add_layer_top\nLayerCollection.add_layers\nLayerCollection.add_stackup_layer_at_elevation\nLayerCollection.add_via_layer\nLayerCollection.add_zone_to_layer\nLayerCollection.clone\nLayerCollection.create\nLayerCollection.find_by_name\nLayerCollection.get_layers\nLayerCollection.get_product_property\nLayerCollection.get_product_property_ids\nLayerCollection.get_top_bottom_stackup_layers\nLayerCollection.get_zone_name\nLayerCollection.import_from_control_file\nLayerCollection.insert_zone\nLayerCollection.is_valid\nLayerCollection.merge_dielectrics\nLayerCollection.remove_zone\nLayerCollection.set_product_property\nLayerCollection.set_zone_name\nLayerCollection.simplify_dielectrics_for_phi\nLayerCollection.update_layout"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.html#pyedb.grpc.database.stackup.LayerCollection",
        "title": "LayerCollection > LayerCollection > LayerCollection",
        "section": "LayerCollection > LayerCollection",
        "text": "class pyedb.grpc.database.stackup.LayerCollection(pedb, edb_object)\n\nManages layer collections in an EDB database.\n\nParameters\n\npedb\n\npyedb.Edb\n\nEDB object.\n\nedb_object\n\nansys.edb.core.layer.LayerCollection\n\nEDB layer collection object.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nLayerCollection.add_document_layer(name[, ...])\n\nAdd a document layer.\n\nLayerCollection.add_layer_above(name, ...[, ...])\n\nAdd a layer above a specified layer.\n\nLayerCollection.add_layer_below(name, ...[, ...])\n\nAdd a layer below a specified layer.\n\nLayerCollection.add_layer_bottom(name[, ...])\n\nAdd a layer at the bottom of the stackup.\n\nLayerCollection.add_layer_top(name[, layer_type])\n\nAdd a layer on top of the stackup.\n\nLayerCollection.add_layers(layers)\n\nAdd a list of layers to the layer collection.\n\nLayerCollection.add_stackup_layer_at_elevation(...)\n\nAdd a stackup layer at a user-specified elevation.\n\nLayerCollection.add_via_layer(via_layer_to_add)\n\nAdd a via layer to the layer collection.\n\nLayerCollection.add_zone_to_layer(layer, ...)\n\nSet the zone to the layer and update the layer in the collection.\n\nLayerCollection.clone()\n\nCreate a clone of the layer collection.\n\nLayerCollection.create([mode])\n\nCreate a layer collection.\n\nLayerCollection.find_by_name(layer_name)\n\nFind a layer in the layer collection.\n\nLayerCollection.get_layers([layer_filter])\n\nGet a list of layers in the layer collection using a layer filter.\n\nLayerCollection.get_product_property(...)\n\nGet the product property of the layer collection for a given product ID and attribute ID.\n\nLayerCollection.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs for a given product ID for the layer collection.\n\nLayerCollection.get_top_bottom_stackup_layers(...)\n\nGet the top and bottom stackup layers of a specific type and their elevations.\n\nLayerCollection.get_zone_name(zone)\n\nGet the name for a given zone.\n\nLayerCollection.import_from_control_file(...)\n\nImport layers from a control file and optional XML schema file.\n\nLayerCollection.insert_zone([copy_zone])\n\nInsert a zone.\n\nLayerCollection.is_valid()\n\nDetermine if the layer collection is in a valid state.\n\nLayerCollection.merge_dielectrics(layout, ...)\n\nMerge the dielectric layers in a range of layers into one large dielectric layer.\n\nLayerCollection.remove_zone(zone)\n\nRemove a zone.\n\nLayerCollection.set_product_property(...)\n\nSet the product property of the layer collection for a given product ID and attribute ID.\n\nLayerCollection.set_zone_name(zone, name)\n\nSet the name for a given zone.\n\nLayerCollection.simplify_dielectrics_for_phi(...)\n\nSplit dielectric layers at the boundaries of signal layers and merge them.\n\nLayerCollection.update_layout()\n\nUpdate the layout with the current layer collection.\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.import_edb",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.import_edb.html#import_edb",
        "title": "import_edb",
        "section": "import_edb",
        "text": "Import layout from EDB.\nPath to the EDB file.\nimport_edb\nStr"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.import_edb",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.siwave.Siwave.import_edb.html#pyedb.siwave.Siwave.import_edb",
        "title": "import_edb > import_edb > import_edb",
        "section": "import_edb > import_edb",
        "text": "Siwave.import_edb(file_path: str)\n\nImport layout from EDB.\n\nParameters\n\nfile_path\n\nStr\n\nPath to the EDB file.\n\nReturns\n\n\n\n——-\n\n\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.delete_empty_pin_groups",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.delete_empty_pin_groups.html#delete_empty_pin_groups",
        "title": "delete_empty_pin_groups",
        "section": "delete_empty_pin_groups",
        "text": "delete_empty_pin_groups"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.delete_empty_pin_groups",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.layout_validation.LayoutValidation.delete_empty_pin_groups.html#pyedb.dotnet.database.layout_validation.LayoutValidation.delete_empty_pin_groups",
        "title": "delete_empty_pin_groups > delete_empty_pin_groups > delete_empty_pin_groups",
        "section": "delete_empty_pin_groups > delete_empty_pin_groups",
        "text": "LayoutValidation.delete_empty_pin_groups()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_port_between_pin_and_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_port_between_pin_and_layer.html#create_port_between_pin_and_layer",
        "title": "create_port_between_pin_and_layer",
        "section": "create_port_between_pin_and_layer",
        "text": "Create circuit port between pin and a reference layer.\nComponent name. The default is None.\nPin name or list of pin names. The default is None.\nLayer name. The default is None.\nReference net name. The default is None.\nPort impedance. The default is 50.0 in ohms.\nCreated terminal.\ncreate_port_between_pin_and_layer\npython:str\nNone\npython:str\nNone\npython:str\nNone\npython:str\nNone\npython:float\noptional\n50.0\nPadstackInstanceTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_port_between_pin_and_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_port_between_pin_and_layer.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_port_between_pin_and_layer",
        "title": "create_port_between_pin_and_layer > create_port_between_pin_and_layer > create_port_between_pin_and_layer",
        "section": "create_port_between_pin_and_layer > create_port_between_pin_and_layer",
        "text": "SourceExcitation.create_port_between_pin_and_layer(component_name: str | None = None, pins_name: str | List[str] | None = None, layer_name: str | None = None, reference_net: str | None = None, impedance: int | float = 50.0) -> bool\n\nCreate circuit port between pin and a reference layer.\n\nParameters\n\ncomponent_name\n\npython:str\n\nComponent name. The default is None.\n\npins_name\n\npython:str\n\nPin name or list of pin names. The default is None.\n\nlayer_name\n\npython:str\n\nLayer name. The default is None.\n\nreference_net\n\npython:str\n\nReference net name. The default is None.\n\nimpedance\n\npython:float, optional\n\nPort impedance. The default is 50.0 in ohms.\n\nReturns\n\nPadstackInstanceTerminal\n\nCreated terminal.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> terms = edb.source_excitation.create_port_between_pin_and_layer(\"U1\", \"Pin1\", \"GND\", \"GND\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_voltage_source",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_voltage_source.html#create_voltage_source",
        "title": "create_voltage_source",
        "section": "create_voltage_source",
        "text": "Create a voltage source.\nUse: func:create_voltage_source has been moved to edb.source_excitation.create_voltage_source.\ncreate_voltage_source"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_voltage_source",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.create_voltage_source.html#pyedb.grpc.edb.Edb.create_voltage_source",
        "title": "create_voltage_source > create_voltage_source > create_voltage_source",
        "section": "create_voltage_source > create_voltage_source",
        "text": "Edb.create_voltage_source(terminal, ref_terminal)\n\nCreate a voltage source.\n\n..deprecated:: 0.50.0\n\nUse: func:create_voltage_source has been moved to edb.source_excitation.create_voltage_source.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.delete_material",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.delete_material.html#delete_material",
        "title": "delete_material",
        "section": "delete_material",
        "text": ".deprecated: pyedb 0.32.0 use delete instead.\nName of the material to delete.\ndelete_material\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.delete_material",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.delete_material.html#pyedb.grpc.database.definition.materials.Materials.delete_material",
        "title": "delete_material > delete_material > delete_material",
        "section": "delete_material > delete_material",
        "text": "Materials.delete_material(material_name)\n\n.deprecated: pyedb 0.32.0 use delete instead.\n\nParameters\n\nmaterial_name\n\npython:str\n\nName of the material to delete.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.subtract",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.subtract.html#subtract",
        "title": "subtract",
        "section": "subtract",
        "text": "Subtract a set of polygons from another set of polygons.\nList of base polygons.\nList of polygons to subtract.\nsubtract\npython:list\nof\nPolygonData\nPolygonData\npython:list\nof\nPolygonData\nPolygonData\npython:list\nof\nPolygonData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.subtract",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.subtract.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.subtract",
        "title": "subtract > subtract > subtract",
        "section": "subtract > subtract",
        "text": "classmethod PolygonData.subtract(polygons1: list[PolygonData] | PolygonData, polygons2: list[PolygonData] | PolygonData) -> list[PolygonData]\n\nSubtract a set of polygons from another set of polygons.\n\nParameters\n\npolygons1\n\npython:list of PolygonData or PolygonData\n\nList of base polygons.\n\npolygons2\n\npython:list of PolygonData or PolygonData\n\nList of polygons to subtract.\n\nReturns\n\npython:list of PolygonData\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/models.md#model-copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nbefore creating the new model. You should trust this data.\ndeep: Set to True to make a deep copy of the model.\nNew model instance.\nmodel_copy"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_copy.html#pyedb.workflows.drc.drc.DiffPair.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "DiffPair.model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -> Self\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/models.md#model-copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nArgs:\n\nupdate: Values to change/add in the new model. Note: the data is not validated\n\nbefore creating the new model. You should trust this data.\n\ndeep: Set to True to make a deep copy of the model.\n\nReturns:\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.bbox_of_polygons",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.bbox_of_polygons.html#bbox_of_polygons",
        "title": "bbox_of_polygons",
        "section": "bbox_of_polygons",
        "text": "Compute the bounding box of a list of polygons.\nList of polygons.\nbbox_of_polygons\npython:list\nof\nPolygonData\npython:tuple\nof\nPointData\nPointData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.bbox_of_polygons",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.bbox_of_polygons.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.bbox_of_polygons",
        "title": "bbox_of_polygons > bbox_of_polygons > bbox_of_polygons",
        "section": "bbox_of_polygons > bbox_of_polygons",
        "text": "classmethod PolygonData.bbox_of_polygons(polygons: list[PolygonData]) -> tuple[PointData, PointData]\n\nCompute the bounding box of a list of polygons.\n\nParameters\n\npolygons\n\npython:list of PolygonData\n\nList of polygons.\n\nReturns\n\npython:tuple of (PointData, PointData)\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSetups",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSetups.html#controlfilesetups",
        "title": "ControlFileSetups",
        "section": "ControlFileSetups",
        "text": "Setup manager class.\nControlFileSetups.add_setup(name, frequency)\nAdd a new setup\nControlFileSetups\nControlFileSetups.add_setup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSetups",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileSetups.html#pyedb.grpc.database.utility.xml_control_file.ControlFileSetups",
        "title": "ControlFileSetups > ControlFileSetups > ControlFileSetups",
        "section": "ControlFileSetups > ControlFileSetups",
        "text": "class pyedb.grpc.database.utility.xml_control_file.ControlFileSetups\n\nSetup manager class.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nControlFileSetups.add_setup(name, frequency)\n\nAdd a new setup\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_advanced_settings.RaptorXAdvancedSettings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_advanced_settings.RaptorXAdvancedSettings.html#raptorxadvancedsettings",
        "title": "RaptorXAdvancedSettings",
        "section": "RaptorXAdvancedSettings",
        "text": "Raptor X advanced settings class.\nRaptorXAdvancedSettings"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_advanced_settings.RaptorXAdvancedSettings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.raptor_x_advanced_settings.RaptorXAdvancedSettings.html#pyedb.grpc.database.simulation_setup.raptor_x_advanced_settings.RaptorXAdvancedSettings",
        "title": "RaptorXAdvancedSettings > RaptorXAdvancedSettings > RaptorXAdvancedSettings",
        "section": "RaptorXAdvancedSettings > RaptorXAdvancedSettings",
        "text": "class pyedb.grpc.database.simulation_setup.raptor_x_advanced_settings.RaptorXAdvancedSettings(pedb, edb_object)\n\nRaptor X advanced settings class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.set_component_rlc",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.set_component_rlc.html#set_component_rlc",
        "title": "set_component_rlc",
        "section": "set_component_rlc",
        "text": "Update values for an RLC component.\nName of the RLC component.\nResistance value. The default is None.\nInductor value.  The default is None.\nCapacitor value.  The default is None.\nWhether the RLC component is parallel. The default is False.\nTrue when successful, False when failed.\nset_component_rlc\npython:float\noptional\nNone\npython:float\noptional\nNone\npython:float\noptional\nNone\noptional\nFalse\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.set_component_rlc",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.set_component_rlc.html#pyedb.dotnet.database.components.Components.set_component_rlc",
        "title": "set_component_rlc > set_component_rlc > set_component_rlc",
        "section": "set_component_rlc > set_component_rlc",
        "text": "Components.set_component_rlc(componentname, res_value=None, ind_value=None, cap_value=None, isparallel=False)\n\nUpdate values for an RLC component.\n\nParameters\n\ncomponentname\n\nName of the RLC component.\n\nres_value\n\npython:float, optional\n\nResistance value. The default is None.\n\nind_value\n\npython:float, optional\n\nInductor value.  The default is None.\n\ncap_value\n\npython:float optional\n\nCapacitor value.  The default is None.\n\nisparallel\n\nbool, optional\n\nWhether the RLC component is parallel. The default is False.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\")\n>>> edbapp.components.set_component_rlc(\"R1\", res_value=50, ind_value=1e-9, cap_value=1e-12, isparallel=False)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave.create_exec_file",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave.create_exec_file.html#create_exec_file",
        "title": "create_exec_file",
        "section": "create_exec_file",
        "text": "Create an executable file.\nWhether to add the DC option in the EXE file. Default is False.\nWhether to add the AC option in the EXE file. Default is False.\nWhether to add the SYZ option in the EXE file. Default is False.\nAdd the Touchstone file export option in the EXE file. Default is False.\nFile path for the Touchstone file. Default is \"\". When no path is\nspecified and export_touchstone=True, the project path is used.\nTrue if file was created, False otherwise.\ncreate_exec_file\noptional\nFalse\noptional\nFalse\noptional\nFalse\noptional\nFalse\npython:str\noptional\n\"\"\nexport_touchstone=True\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave.create_exec_file",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave.create_exec_file.html#pyedb.grpc.database.siwave.Siwave.create_exec_file",
        "title": "create_exec_file > create_exec_file > create_exec_file",
        "section": "create_exec_file > create_exec_file",
        "text": "Siwave.create_exec_file(add_dc: bool = False, add_ac: bool = False, add_syz: bool = False, export_touchstone: bool = False, touchstone_file_path: str = '') -> bool\n\nCreate an executable file.\n\nParameters\n\nadd_dc\n\nbool, optional\n\nWhether to add the DC option in the EXE file. Default is False.\n\nadd_ac\n\nbool, optional\n\nWhether to add the AC option in the EXE file. Default is False.\n\nadd_syz\n\nbool, optional\n\nWhether to add the SYZ option in the EXE file. Default is False.\n\nexport_touchstone\n\nbool, optional\n\nAdd the Touchstone file export option in the EXE file. Default is False.\n\ntouchstone_file_path\n\npython:str, optional\n\nFile path for the Touchstone file. Default is \"\". When no path is\nspecified and export_touchstone=True, the project path is used.\n\nReturns\n\nbool\n\nTrue if file was created, False otherwise.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", edbversion=\"2021.2\")\n>>> # Create exec file with AC and SYZ options\n>>> success = edbapp.siwave.create_exec_file(add_ac=True, add_syz=True)\n>>> # Create exec file with Touchstone export\n>>> success = edbapp.siwave.create_exec_file(\n...     add_ac=True, export_touchstone=True, touchstone_file_path=\"C:/temp/my_touchstone.s2p\"\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_edb",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_edb.html#create_edb",
        "title": "create_edb",
        "section": "create_edb",
        "text": "Create EDB.\ncreate_edb"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_edb",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_edb.html#pyedb.dotnet.edb.Edb.create_edb",
        "title": "create_edb > create_edb > create_edb",
        "section": "create_edb > create_edb",
        "text": "Edb.create_edb()\n\nCreate EDB.\n\nReturns\n\n``True`` when succeed ``False`` if failed\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/index",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/index.html#layers-classes",
        "title": "Layers classes",
        "section": "Layers classes",
        "text": "This section describes EDB layers classes.\nLayers classes"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude: Optional set or mapping specifying which fields to include in the copied model.\nexclude: Optional set or mapping specifying which fields to exclude in the copied model.\nupdate: Optional dictionary of field-value pairs to override field values in the copied model.\ndeep: If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.CopperBalance.copy.html#pyedb.workflows.drc.drc.CopperBalance.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "CopperBalance.copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -> Self\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nArgs:\n\ninclude: Optional set or mapping specifying which fields to include in the copied model.\nexclude: Optional set or mapping specifying which fields to exclude in the copied model.\nupdate: Optional dictionary of field-value pairs to override field values in the copied model.\ndeep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.product_solver_option.html#product_solver_option",
        "title": "product_solver_option",
        "section": "product_solver_option",
        "text": "Get the name of the product solver option.\nID of the product.\nName of the solver.\nName of the product solver option.\nproduct_solver_option\nProductIdType\nstr\nstr"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.WavePort.product_solver_option.html#pyedb.grpc.database.ports.ports.WavePort.product_solver_option",
        "title": "product_solver_option > product_solver_option > product_solver_option",
        "section": "product_solver_option > product_solver_option",
        "text": "WavePort.product_solver_option(product_id, solver_name)\n\nGet the name of the product solver option.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nsolver_name\n\nstr\n\nName of the solver.\n\nReturns\n\nstr\n\nName of the product solver option.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.place",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.place.html#place",
        "title": "place",
        "section": "place",
        "text": "Place a padstack instance.\n[x, y] position for placement.\nPadstack definition name.\nNet name. Default is \"\".\nInstance name. Default is \"\".\nRotation in degrees. Default is 0.0.\nStarting layer name.\nEnding layer name.\nSolder ball layer name.\nWhether the instance is a pin. Default is False.\nCreated padstack instance or False if failed.\nplace\npython:list\npython:float\npython:float\npython:str\npython:str\noptional\n\"\"\npython:str\noptional\n\"\"\npython:float\noptional\n0.0\npython:str\noptional\npython:str\noptional\npython:str\noptional\noptional\nFalse\npyedb.grpc.database.primitive.padstack_instance.PadstackInstance\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.place",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.place.html#pyedb.grpc.database.padstacks.Padstacks.place",
        "title": "place > place > place",
        "section": "place > place",
        "text": "Padstacks.place(position: List[float], definition_name: str, net_name: str = '', via_name: str = '', rotation: float = 0.0, fromlayer: str | None = None, tolayer: str | None = None, solderlayer: str | None = None, is_pin: bool = False) -> PadstackInstance\n\nPlace a padstack instance.\n\nParameters\n\nposition\n\npython:list[python:float, python:float]\n\n[x, y] position for placement.\n\ndefinition_name\n\npython:str\n\nPadstack definition name.\n\nnet_name\n\npython:str, optional\n\nNet name. Default is \"\".\n\nvia_name\n\npython:str, optional\n\nInstance name. Default is \"\".\n\nrotation\n\npython:float, optional\n\nRotation in degrees. Default is 0.0.\n\nfromlayer\n\npython:str, optional\n\nStarting layer name.\n\ntolayer\n\npython:str, optional\n\nEnding layer name.\n\nsolderlayer\n\npython:str, optional\n\nSolder ball layer name.\n\nis_pin\n\nbool, optional\n\nWhether the instance is a pin. Default is False.\n\nReturns\n\npyedb.grpc.database.primitive.padstack_instance.PadstackInstance or bool\n\nCreated padstack instance or False if failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.hfss.Hfss.get_layout_bounding_box",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.hfss.Hfss.get_layout_bounding_box.html#get_layout_bounding_box",
        "title": "get_layout_bounding_box",
        "section": "get_layout_bounding_box",
        "text": "Calculate layout bounding box.\nLayout object (uses active layout if None).\nCoordinate rounding precision.\n[min_x, min_y, max_x, max_y] coordinates.\nget_layout_bounding_box\nEdb.Cell.Layout\noptional\npython:int\noptional\npython:list"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.hfss.Hfss.get_layout_bounding_box",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.hfss.Hfss.get_layout_bounding_box.html#pyedb.grpc.database.hfss.Hfss.get_layout_bounding_box",
        "title": "get_layout_bounding_box > get_layout_bounding_box > get_layout_bounding_box",
        "section": "get_layout_bounding_box > get_layout_bounding_box",
        "text": "Hfss.get_layout_bounding_box(layout=None, digit_resolution=6)\n\nCalculate layout bounding box.\n\nParameters\n\nlayout\n\nEdb.Cell.Layout, optional\n\nLayout object (uses active layout if None).\n\ndigit_resolution\n\npython:int, optional\n\nCoordinate rounding precision.\n\nReturns\n\npython:list\n\n[min_x, min_y, max_x, max_y] coordinates.\n\nExamples\n\n>>> bbox = edb.hfss.get_layout_bounding_box()\n>>> print(f\"Layout Bounding Box: {bbox}\")\n>>>\n>>> # With custom parameters\n>>> custom_layout = edb.layouts[\"MyLayout\"]\n>>> bbox = edb.hfss.get_layout_bounding_box(custom_layout, 5)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/hfss_solver_settings",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/hfss_solver_settings.html#hfss-solver-settings",
        "title": "HFSS solver settings",
        "section": "HFSS solver settings",
        "text": "This class is managing EDB HFSS solver settings.\nHFSSSolverSettings\nHFSS solver settings class.\nHFSS solver settings\nHFSSSolverSettings"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.html#sourceexcitation",
        "title": "SourceExcitation",
        "section": "SourceExcitation",
        "text": "Manage sources and excitations.\nSourceExcitation.add_port_on_rlc_component([...])\nDeactivate RLC component and replace it with a circuit port.\nSourceExcitation.add_rlc_boundary([...])\nAdd RLC gap boundary on component and replace it with a circuit port.\nSourceExcitation.check_before_terminal_assignement(...)\n\nSourceExcitation.create_bundle_wave_port(...)\nCreate a bundle wave port.\nSourceExcitation.create_circuit_port_on_net(...)\nCreate a circuit port on a NET.\nSourceExcitation.create_circuit_port_on_pin(...)\nCreate a circuit port on a pin.\nSourceExcitation.create_circuit_port_on_pin_group(...)\nCreate a port between two pin groups.\nSourceExcitation.create_coax_port(...[, ...])\nCreate HFSS 3Dlayout coaxial lumped port on a pastack Requires to have solder ball defined before calling this method.\nSourceExcitation.create_coax_port_on_component(...)\nCreate a coaxial port on a component or component list on a net or net list.\nSourceExcitation.create_current_source(...)\nCreate a current source.\nSourceExcitation.create_current_source_on_net(...)\nCreate a voltage source.\nSourceExcitation.create_current_source_on_pin(...)\nCreate a voltage source.\nSourceExcitation.create_current_source_on_pin_group(...)\nCreate current source between two pin groups.\nSourceExcitation.create_dc_terminal(...[, ...])\nCreate a dc terminal.\nSourceExcitation.create_differential_wave_port(...)\nCreate a differential wave port.\nSourceExcitation.create_edge_port_horizontal(...)\nCreate a horizontal edge port.\nSourceExcitation.create_edge_port_on_polygon([...])\nCreate lumped port between two edges from two different polygons.\nSourceExcitation.create_edge_port_vertical(...)\nCreate a vertical edge port.\nSourceExcitation.create_hfss_ports_on_padstack(pinpos)\nCreate an HFSS port on a padstack.\nSourceExcitation.create_lumped_port_on_net([...])\nCreate an edge port on nets.\nSourceExcitation.create_pin_group_terminal(...)\nCreate a pin group terminal.\nSourceExcitation.create_port(terminal[, ...])\nCreate a port.\nSourceExcitation.create_port_between_pin_and_layer([...])\nCreate circuit port between pin and a reference layer.\nSourceExcitation.create_port_on_component(...)\nCreate ports on a component.\nSourceExcitation.create_port_on_pins(refdes, ...)\nCreate circuit port between pins and reference ones.\nSourceExcitation.create_resistor_on_pin(...)\nCreate a Resistor boundary between two given pins..\nSourceExcitation.create_rlc_boundary_on_pins([...])\nCreate hfss rlc boundary on pins.\nSourceExcitation.create_source_on_component([...])\nCreate voltage, current source, or resistor on component.\nSourceExcitation.create_vertical_circuit_port_on_clipped_traces([...])\nCreate an edge port on clipped signal traces.\nSourceExcitation.create_voltage_probe(...)\nCreate a voltage probe.\nSourceExcitation.create_voltage_probe_on_pin_group(...)\nCreate voltage probe between two pin groups.\nSourceExcitation.create_voltage_source(...)\nCreate a voltage source.\nSourceExcitation.create_voltage_source_on_net(...)\nCreate a voltage source.\nSourceExcitation.create_voltage_source_on_pin(...)\nCreate a voltage source.\nSourceExcitation.create_voltage_source_on_pin_group(...)\nCreate voltage source between two pin groups.\nSourceExcitation.create_wave_port(prim_id, ...)\nCreate a wave port.\nSourceExcitation.get_point_terminal(name, ...)\nPlace terminal between two points.\nSourceExcitation.get_ports_number()\nReturn the total number of excitation ports in a layout.\nSourceExcitation.place_voltage_probe(name, ...)\nPlace a voltage probe between two points.\nSourceExcitation\nSourceExcitation.add_port_on_rlc_component\nSourceExcitation.add_rlc_boundary\nSourceExcitation.check_before_terminal_assignement\nSourceExcitation.create_bundle_wave_port\nSourceExcitation.create_circuit_port_on_net\nSourceExcitation.create_circuit_port_on_pin\nSourceExcitation.create_circuit_port_on_pin_group\nSourceExcitation.create_coax_port\nSourceExcitation.create_coax_port_on_component\nSourceExcitation.create_current_source\nSourceExcitation.create_current_source_on_net\nSourceExcitation.create_current_source_on_pin\nSourceExcitation.create_current_source_on_pin_group\nSourceExcitation.create_dc_terminal\nSourceExcitation.create_differential_wave_port\nSourceExcitation.create_edge_port_horizontal\nSourceExcitation.create_edge_port_on_polygon\nSourceExcitation.create_edge_port_vertical\nSourceExcitation.create_hfss_ports_on_padstack\nSourceExcitation.create_lumped_port_on_net\nSourceExcitation.create_pin_group_terminal\nSourceExcitation.create_port\nSourceExcitation.create_port_between_pin_and_layer\nSourceExcitation.create_port_on_component\nSourceExcitation.create_port_on_pins\nSourceExcitation.create_resistor_on_pin\nSourceExcitation.create_rlc_boundary_on_pins\nSourceExcitation.create_source_on_component\nSourceExcitation.create_vertical_circuit_port_on_clipped_traces\nSourceExcitation.create_voltage_probe\nSourceExcitation.create_voltage_probe_on_pin_group\nSourceExcitation.create_voltage_source\nSourceExcitation.create_voltage_source_on_net\nSourceExcitation.create_voltage_source_on_pin\nSourceExcitation.create_voltage_source_on_pin_group\nSourceExcitation.create_wave_port\nSourceExcitation.get_point_terminal\nSourceExcitation.get_ports_number\nSourceExcitation.place_voltage_probe"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.html#pyedb.grpc.database.source_excitations.SourceExcitation",
        "title": "SourceExcitation > SourceExcitation > SourceExcitation",
        "section": "SourceExcitation > SourceExcitation",
        "text": "class pyedb.grpc.database.source_excitations.SourceExcitation(pedb)\n\nManage sources and excitations.\n\nExamples\n\n>>> # Initialize EDB session\n>>> from pyedb import Edb\n>>> edb = Edb(edbpath=\"path/to/your/edb\")\n\n>>> # Access SourceExcitation class\n>>> source_excitations = edb.source_excitation\n\n>>> # 1. create_source_on_component\n>>> # Create voltage source on component pins\n>>> from pyedb.grpc.database.utility.sources import Source, SourceType\n>>> source = Source(\n...     source_type=SourceType.Vsource,\n...     name=\"V1\",\n...     positive_node=(\"U1\", \"VCC\"),\n...     negative_node=(\"U1\", \"GND\"),\n...     amplitude=\"1V\",\n...     phase=\"0deg\",\n...     impedance=\"50ohm\",\n... )\n>>> source_excitations.create_source_on_component([source])\n\n>>> # 2. create_port\n>>> # Create port between two terminals\n>>> pos_terminal = edb.terminals[\"MyTerminal\"]\n>>> ref_terminal = edb.terminals[\"MyRefTerminal\"]\n>>> port = source_excitations.create_port(pos_terminal, ref_terminal)\n\n>>> # 3. create_port_on_pins\n>>> # Create circuit port between component pins\n>>> port_term = source_excitations.create_port_on_pins(\n...     refdes=\"U1\", pins=\"Pin1\", reference_pins=[\"GND_Pin1\", \"GND_Pin2\"], impedance=50, port_name=\"Port1\"\n... )\n\n>>> # 4. create_port_on_component\n>>> # Create coaxial ports on component nets\n>>> source_excitations.create_port_on_component(\n...     component=\"U1\", net_list=[\"PCIe_RX0\", \"PCIe_RX1\"], port_type=SourceType.CoaxPort, reference_net=\"GND\"\n... )\n\n>>> # 5. add_port_on_rlc_component\n>>> # Replace RLC component with circuit port\n>>> source_excitations.add_port_on_rlc_component(\"R1\")\n\n>>> # 6. _create_terminal (Internal method - typically not called directly)\n\n>>> # 7. _create_pin_group_terminal (Internal method)\n\n>>> # 8. create_coax_port\n>>> # Create coaxial port on padstack\n>>> pin = edb.components[\"U1\"].pins[\"Pin1\"]\n>>> port_name = source_excitations.create_coax_port(pin)\n\n>>> # 9. create_circuit_port_on_pin\n>>> # Create circuit port between two pins\n>>> pin1 = edb.components[\"U1\"].pins[\"Pin1\"]\n>>> pin2 = edb.components[\"U1\"].pins[\"Pin2\"]\n>>> port_name = source_excitations.create_circuit_port_on_pin(pin1, pin2, 50, \"Port1\")\n\n>>> # 10. create_voltage_source_on_pin\n>>> # Create voltage source between pins\n>>> source_name = source_excitations.create_voltage_source_on_pin(pin1, pin2, 3.3, 0, \"V1\")\n\n>>> # 11. create_current_source_on_pin\n>>> # Create current source between pins\n>>> source_name = source_excitations.create_current_source_on_pin(pin1, pin2, 0.1, 0, \"I1\")\n\n>>> # 12. create_resistor_on_pin\n>>> # Create resistor between pins\n>>> res_name = source_excitations.create_resistor_on_pin(pin1, pin2, 100, \"R1\")\n\n>>> # 13. create_circuit_port_on_net\n>>> # Create port between component nets\n>>> port_name = source_excitations.create_circuit_port_on_net(\n>>> \"U1\", \"SignalNet\", \"U1\", \"GND\", 50, \"Port1\"\n>>> )\n\n>>> # 14. create_voltage_source_on_net\n>>> # Create voltage source between nets\n>>> source_name = source_excitations.create_voltage_source_on_net(\n>>> \"U1\", \"VCC\", \"U1\", \"GND\", 5.0, 0, \"VCC_Source\"\n>>> )\n\n>>> # 15. create_current_source_on_net\n>>> # Create current source between nets\n>>> source_name = source_excitations.create_current_source_on_net(\n>>> \"U1\", \"InputNet\", \"U1\", \"GND\", 0.02, 0, \"InputCurrent\"\n>>> )\n\n>>> # 16. create_coax_port_on_component\n>>> # Create coaxial ports on component\n>>> ports = source_excitations.create_coax_port_on_component(\n...     [\"U1\", \"U2\"], [\"PCIe_RX0\", \"PCIe_TX0\"], delete_existing_terminal=True\n... )\n\n>>> # 17. create_differential_wave_port\n>>> # Create differential wave port\n>>> pos_prim = edb.modeler.primitives[0]\n>>> neg_prim = edb.modeler.primitives[1]\n>>> port_name, diff_port = source_excitations.create_differential_wave_port(\n...     pos_prim.id, [0, 0], neg_prim.id, [0, 0.2], \"DiffPort\"\n... )\n\n>>> # 18. create_wave_port\n>>> # Create wave port\n>>> port_name, wave_port = source_excitations.create_wave_port(pos_prim.id, [0, 0], \"WavePort\")\n\n>>> # 19. create_bundle_wave_port\n>>> # Create bundle wave port\n>>> port_name, bundle_port = source_excitations.create_bundle_wave_port(\n...     [pos_prim.id, neg_prim.id], [[0, 0], [0, 0.2]], \"BundlePort\"\n... )\n\n>>> # 20. create_dc_terminal\n>>> # Create DC terminal\n>>> source_excitations.create_dc_terminal(\"U1\", \"VCC\", \"VCC_Terminal\")\n\n>>> # 21. create_voltage_probe\n>>> # Create voltage probe\n>>> probe = source_excitations.create_voltage_probe(term1, term2)\n\n>>> # 22. place_voltage_probe\n>>> # Place voltage probe between points\n>>> source_excitations.place_voltage_probe(\n...     \"Probe1\", \"SignalNet\", [0, 0], \"TopLayer\", \"GND\", [0.1, 0.1], \"BottomLayer\"\n... )\n\n>>> # Save and close EDB\n>>> edb.save()\n>>> edb.close()\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nSourceExcitation.add_port_on_rlc_component([...])\n\nDeactivate RLC component and replace it with a circuit port.\n\nSourceExcitation.add_rlc_boundary([...])\n\nAdd RLC gap boundary on component and replace it with a circuit port.\n\nSourceExcitation.check_before_terminal_assignement(...)\n\n\n\nSourceExcitation.create_bundle_wave_port(...)\n\nCreate a bundle wave port.\n\nSourceExcitation.create_circuit_port_on_net(...)\n\nCreate a circuit port on a NET.\n\nSourceExcitation.create_circuit_port_on_pin(...)\n\nCreate a circuit port on a pin.\n\nSourceExcitation.create_circuit_port_on_pin_group(...)\n\nCreate a port between two pin groups.\n\nSourceExcitation.create_coax_port(...[, ...])\n\nCreate HFSS 3Dlayout coaxial lumped port on a pastack Requires to have solder ball defined before calling this method.\n\nSourceExcitation.create_coax_port_on_component(...)\n\nCreate a coaxial port on a component or component list on a net or net list.\n\nSourceExcitation.create_current_source(...)\n\nCreate a current source.\n\nSourceExcitation.create_current_source_on_net(...)\n\nCreate a voltage source.\n\nSourceExcitation.create_current_source_on_pin(...)\n\nCreate a voltage source.\n\nSourceExcitation.create_current_source_on_pin_group(...)\n\nCreate current source between two pin groups.\n\nSourceExcitation.create_dc_terminal(...[, ...])\n\nCreate a dc terminal.\n\nSourceExcitation.create_differential_wave_port(...)\n\nCreate a differential wave port.\n\nSourceExcitation.create_edge_port_horizontal(...)\n\nCreate a horizontal edge port.\n\nSourceExcitation.create_edge_port_on_polygon([...])\n\nCreate lumped port between two edges from two different polygons.\n\nSourceExcitation.create_edge_port_vertical(...)\n\nCreate a vertical edge port.\n\nSourceExcitation.create_hfss_ports_on_padstack(pinpos)\n\nCreate an HFSS port on a padstack.\n\nSourceExcitation.create_lumped_port_on_net([...])\n\nCreate an edge port on nets.\n\nSourceExcitation.create_pin_group_terminal(...)\n\nCreate a pin group terminal.\n\nSourceExcitation.create_port(terminal[, ...])\n\nCreate a port.\n\nSourceExcitation.create_port_between_pin_and_layer([...])\n\nCreate circuit port between pin and a reference layer.\n\nSourceExcitation.create_port_on_component(...)\n\nCreate ports on a component.\n\nSourceExcitation.create_port_on_pins(refdes, ...)\n\nCreate circuit port between pins and reference ones.\n\nSourceExcitation.create_resistor_on_pin(...)\n\nCreate a Resistor boundary between two given pins..\n\nSourceExcitation.create_rlc_boundary_on_pins([...])\n\nCreate hfss rlc boundary on pins.\n\nSourceExcitation.create_source_on_component([...])\n\nCreate voltage, current source, or resistor on component.\n\nSourceExcitation.create_vertical_circuit_port_on_clipped_traces([...])\n\nCreate an edge port on clipped signal traces.\n\nSourceExcitation.create_voltage_probe(...)\n\nCreate a voltage probe.\n\nSourceExcitation.create_voltage_probe_on_pin_group(...)\n\nCreate voltage probe between two pin groups.\n\nSourceExcitation.create_voltage_source(...)\n\nCreate a voltage source.\n\nSourceExcitation.create_voltage_source_on_net(...)\n\nCreate a voltage source.\n\nSourceExcitation.create_voltage_source_on_pin(...)\n\nCreate a voltage source.\n\nSourceExcitation.create_voltage_source_on_pin_group(...)\n\nCreate voltage source between two pin groups.\n\nSourceExcitation.create_wave_port(prim_id, ...)\n\nCreate a wave port.\n\nSourceExcitation.get_point_terminal(name, ...)\n\nPlace terminal between two points.\n\nSourceExcitation.get_ports_number()\n\nReturn the total number of excitation ports in a layout.\n\nSourceExcitation.place_voltage_probe(name, ...)\n\nPlace a voltage probe between two points.\n\n"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues: Trusted or pre-validated data dictionary.\nA new instance of the Model class with validated data.\nmodel_construct"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_construct",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_construct.html#pyedb.workflows.drc.drc.BackDrillStubLength.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod BackDrillStubLength.model_construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nArgs:\n\n_fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues: Trusted or pre-validated data dictionary.\n\nReturns:\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_maxwell",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_maxwell.html#export_maxwell",
        "title": "export_maxwell",
        "section": "export_maxwell",
        "text": "Export EDB to Maxwell 3D.\nFull path and name for saving the AEDT file.\nList of nets to export only if certain ones are to be\nexported. The default is None, in which case all nets are exported.\nNumber of cores to use for the export. The default is None.\nName of the AEDT output file without the .aedt extension. The default is None,\nin which case the default name is used.\nOpen Siwave in embedding mode. User will only see Siwave Icon but UI will be hidden.\nFull path to the AEDT file.\nexport_maxwell\npython:str\npython:list\noptional\nNone\npython:int\noptional\nNone.\npython:str\noptional\n.aedt\nNone\noptional\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_maxwell",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.export_maxwell.html#pyedb.dotnet.edb.Edb.export_maxwell",
        "title": "export_maxwell > export_maxwell > export_maxwell",
        "section": "export_maxwell > export_maxwell",
        "text": "Edb.export_maxwell(path_to_output, net_list=None, num_cores=None, aedt_file_name=None, hidden=False)\n\nExport EDB to Maxwell 3D.\n\nParameters\n\npath_to_output\n\npython:str\n\nFull path and name for saving the AEDT file.\n\nnet_list\n\npython:list, optional\n\nList of nets to export only if certain ones are to be\nexported. The default is None, in which case all nets are exported.\n\nnum_cores\n\npython:int, optional\n\nNumber of cores to use for the export. The default is None.\n\naedt_file_name\n\npython:str, optional\n\nName of the AEDT output file without the .aedt extension. The default is None,\nin which case the default name is used.\n\nhidden\n\nbool, optional\n\nOpen Siwave in embedding mode. User will only see Siwave Icon but UI will be hidden.\n\nReturns\n\npython:str\n\nFull path to the AEDT file.\n\nExamples\n\n>>> from pyedb import Edb\n\n>>> edb = Edb(edbpath=\"C:\\temp\\myproject.aedb\", version=\"2021.2\")\n\n>>> options_config = {\"UNITE_NETS\": 1, \"LAUNCH_Q3D\": 0}\n>>> edb.write_export3d_option_config_file(\"C:\\temp\", options_config)\n>>> edb.export_maxwell(\"C:\\temp\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_property",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_property.html#set_property",
        "title": "set_property",
        "section": "set_property",
        "text": "Set a material property value.\nTo define a simple material property, the material_property                     and value parameters should be provided.\nTo define a component of an anisotropic material property, the material_property,                     value, and component_id parameters should be provided.\ncomponent_id specifies the                     anisotropic component ID                     of the component to set the value of.\nTo define an entry in a tensor material property, the material_property,                     value, col and row parameters should be provided. The entry at T[row,col]                     will be set to the provided value.\nID of the material property.\nNew value.\nID of the anisotropic component (only used for anisotropic material properties).\nTensor row (only used for tensor material properties).\nTensor column (only used for tensor material properties).\nset_property\nmaterial_property\nvalue\nmaterial_property\nvalue\ncomponent_id\ncomponent_id\nmaterial_property\nvalue\ncol\nrow\nT[row,col]\nvalue\nMaterialProperty\npython:int\npython:None\npython:int\npython:None\npython:int\npython:None"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_property",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_property.html#pyedb.grpc.database.definition.materials.Material.set_property",
        "title": "set_property > set_property > set_property",
        "section": "set_property > set_property",
        "text": "Material.set_property(material_property: MaterialProperty, value: ValueLike, component_id: int = None, col: int = None, row: int = None)\n\nSet a material property value.\n\nMaterial properties can be defined in 3 ways:\n\nSimple: A constant value.\n\nTo define a simple material property, the material_property                     and value parameters should be provided.\n\nAnisotropic: A 3x3 tensor consisting of only diagonal entries.\n\nTo define a component of an anisotropic material property, the material_property,                     value, and component_id parameters should be provided.\n\ncomponent_id specifies the                     anisotropic component ID                     of the component to set the value of.\n\nTensor: A 3x3 tensor consisting of diagonal and off-diagonal entries.\n\nTo define an entry in a tensor material property, the material_property,                     value, col and row parameters should be provided. The entry at T[row,col]                     will be set to the provided value.\n\nParameters\n\nmaterial_property\n\nMaterialProperty\n\nID of the material property.\n\nvalue\n\nValueLike\n\nNew value.\n\ncomponent_id\n\npython:int, default: python:None\n\nID of the anisotropic component (only used for anisotropic material properties).\n\nrow\n\npython:int, default: python:None\n\nTensor row (only used for tensor material properties).\n\ncol\n\npython:int, default: python:None\n\nTensor column (only used for tensor material properties).\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.update",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.update.html#update",
        "title": "update",
        "section": "update",
        "text": "update"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.update",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.update.html#pyedb.grpc.database.definition.materials.Material.update",
        "title": "update > update > update",
        "section": "update > update",
        "text": "Material.update(input_dict: dict)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_conformal_polygon_from_netlist",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_conformal_polygon_from_netlist.html#get_conformal_polygon_from_netlist",
        "title": "get_conformal_polygon_from_netlist",
        "section": "get_conformal_polygon_from_netlist",
        "text": "Return an EDB conformal polygon based on a netlist.\nlist[str]\nEdb polygon object.\nget_conformal_polygon_from_netlist\nList\nof\nnet\nEdb.Cell.Primitive.Polygon"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_conformal_polygon_from_netlist",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_conformal_polygon_from_netlist.html#pyedb.dotnet.edb.Edb.get_conformal_polygon_from_netlist",
        "title": "get_conformal_polygon_from_netlist > get_conformal_polygon_from_netlist > get_conformal_polygon_from_netlist",
        "section": "get_conformal_polygon_from_netlist > get_conformal_polygon_from_netlist",
        "text": "Edb.get_conformal_polygon_from_netlist(netlist=None)\n\nReturn an EDB conformal polygon based on a netlist.\n\nParameters\n\nnetlist\n\nList of net names.\n\nlist[str]\n\nReturns\n\nEdb.Cell.Primitive.Polygon\n\nEdb polygon object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSetup.add_sweep",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSetup.add_sweep.html#add_sweep",
        "title": "add_sweep",
        "section": "add_sweep",
        "text": "Add a frequency sweep.\nSweep name.\nStart frequency.\nStop frequency.\nFrequency step/count.\nSweep type (“Discrete” or “Interpolating”). Default is “Interpolating”.\nStep type (“LinearStep”, “DecadeCount”, or “LinearCount”). Default is “LinearStep”.\nWhether to use Q3D for DC point. Default is True.\nCreated sweep object.\nadd_sweep\npython:str\npython:str\npython:str\npython:str\npython:str\noptional\npython:str\noptional\noptional\nTrue\nControlFileSweep"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSetup.add_sweep",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileSetup.add_sweep.html#pyedb.grpc.database.control_file.ControlFileSetup.add_sweep",
        "title": "add_sweep > add_sweep > add_sweep",
        "section": "add_sweep > add_sweep",
        "text": "ControlFileSetup.add_sweep(name: str, start: str, stop: str, step: str, sweep_type: str = 'Interpolating', step_type: str = 'LinearStep', use_q3d: bool = True) -> ControlFileSweep\n\nAdd a frequency sweep.\n\nParameters\n\nname\n\npython:str\n\nSweep name.\n\nstart\n\npython:str\n\nStart frequency.\n\nstop\n\npython:str\n\nStop frequency.\n\nstep\n\npython:str\n\nFrequency step/count.\n\nsweep_type\n\npython:str, optional\n\nSweep type (“Discrete” or “Interpolating”). Default is “Interpolating”.\n\nstep_type\n\npython:str, optional\n\nStep type (“LinearStep”, “DecadeCount”, or “LinearCount”). Default is “LinearStep”.\n\nuse_q3d\n\nbool, optional\n\nWhether to use Q3D for DC point. Default is True.\n\nReturns\n\nControlFileSweep\n\nCreated sweep object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_closest_point",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_closest_point.html#get_closest_point",
        "title": "get_closest_point",
        "section": "get_closest_point",
        "text": "Get the closest point of the primitive to the input data.\n[x, y].\nget_closest_point\npython:list\nof\npython:float\nPointData\nList\npython:float\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_closest_point",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.get_closest_point.html#pyedb.grpc.database.primitive.primitive.Primitive.get_closest_point",
        "title": "get_closest_point > get_closest_point > get_closest_point",
        "section": "get_closest_point > get_closest_point",
        "text": "Primitive.get_closest_point(point) -> list[float]\n\nGet the closest point of the primitive to the input data.\n\nParameters\n\npoint\n\npython:list of python:float or PointData\n\n\n\nReturns\n\nList[python:float, python:float]\n\n[x, y].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_layout_statistics",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_layout_statistics.html#get_layout_statistics",
        "title": "get_layout_statistics",
        "section": "get_layout_statistics",
        "text": "Return EDBStatistics object from a layout.\nWhen True evaluates the layout metal surface, can take time-consuming,\navoid using this option on large design.\nget_layout_statistics\noptional\nEDBStatistics"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_layout_statistics",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.modeler.Modeler.get_layout_statistics.html#pyedb.dotnet.database.modeler.Modeler.get_layout_statistics",
        "title": "get_layout_statistics > get_layout_statistics > get_layout_statistics",
        "section": "get_layout_statistics > get_layout_statistics",
        "text": "Modeler.get_layout_statistics(evaluate_area=False, net_list=None)\n\nReturn EDBStatistics object from a layout.\n\nParameters\n\nevaluate_area\n\noptional bool\n\nWhen True evaluates the layout metal surface, can take time-consuming,\navoid using this option on large design.\n\nReturns\n\nEDBStatistics object.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_gds_comp_xml",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_gds_comp_xml.html#export_gds_comp_xml",
        "title": "export_gds_comp_xml",
        "section": "export_gds_comp_xml",
        "text": "Export component data to GDS XML control file.\nComponents to export.\nOutput units. Default “mm”.\nOutput XML path.\nTrue if successful, False otherwise.\nexport_gds_comp_xml\npython:list\npython:str\noptional\npython:str\noptional"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_gds_comp_xml",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.export_gds_comp_xml.html#pyedb.grpc.edb.Edb.export_gds_comp_xml",
        "title": "export_gds_comp_xml > export_gds_comp_xml > export_gds_comp_xml",
        "section": "export_gds_comp_xml > export_gds_comp_xml",
        "text": "Edb.export_gds_comp_xml(comps_to_export, gds_comps_unit='mm', control_path=None)\n\nExport component data to GDS XML control file.\n\nParameters\n\ncomps_to_export\n\npython:list\n\nComponents to export.\n\ngds_comps_unit\n\npython:str, optional\n\nOutput units. Default “mm”.\n\ncontrol_path\n\npython:str, optional\n\nOutput XML path.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_voltage_source_on_net",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_voltage_source_on_net.html#create_voltage_source_on_net",
        "title": "create_voltage_source_on_net",
        "section": "create_voltage_source_on_net",
        "text": "Create a voltage source.\nName of the positive component.\nName of the positive net.\nName of the negative component. The default is None, in which case the name of\nthe positive net is assigned.\nName of the negative net. The default is \"GND\".\nValue for the voltage. The default is 3.3.\nValue for the phase. The default is 0.\nName of the source. The default is \"\".\nSource Name.\ncreate_voltage_source_on_net\npython:str\npython:str\npython:str\noptional\nNone\npython:str\noptional\n\"GND\"\npython:float\noptional\n3.3\noptional\n0\npython:str\noptional\n\"\"\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_voltage_source_on_net",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_voltage_source_on_net.html#pyedb.dotnet.database.hfss.EdbHfss.create_voltage_source_on_net",
        "title": "create_voltage_source_on_net > create_voltage_source_on_net > create_voltage_source_on_net",
        "section": "create_voltage_source_on_net > create_voltage_source_on_net",
        "text": "EdbHfss.create_voltage_source_on_net(positive_component_name, positive_net_name, negative_component_name=None, negative_net_name='GND', voltage_value=3.3, phase_value=0, source_name='')\n\nCreate a voltage source.\n\nParameters\n\npositive_component_name\n\npython:str\n\nName of the positive component.\n\npositive_net_name\n\npython:str\n\nName of the positive net.\n\nnegative_component_name\n\npython:str, optional\n\nName of the negative component. The default is None, in which case the name of\nthe positive net is assigned.\n\nnegative_net_name\n\npython:str, optional\n\nName of the negative net. The default is \"GND\".\n\nvoltage_value\n\npython:float, optional\n\nValue for the voltage. The default is 3.3.\n\nphase_value\n\noptional\n\nValue for the phase. The default is 0.\n\nsource_name\n\npython:str, optional\n\nName of the source. The default is \"\".\n\nReturns\n\npython:str\n\nSource Name.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", \"project name\", \"release version\")\n>>> edb.hfss.create_voltage_source_on_net(\"U2A5\", \"V1P5_S3\", \"U2A5\", \"GND\", 3.3, 0, \"source_name\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude: Optional set or mapping specifying which fields to include in the copied model.\nexclude: Optional set or mapping specifying which fields to exclude in the copied model.\nupdate: Optional dictionary of field-value pairs to override field values in the copied model.\ndeep: If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.copy.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "DiffPairLengthMatch.copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -> Self\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nArgs:\n\ninclude: Optional set or mapping specifying which fields to include in the copied model.\nexclude: Optional set or mapping specifying which fields to exclude in the copied model.\nupdate: Optional dictionary of field-value pairs to override field values in the copied model.\ndeep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_voltage_probe",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_voltage_probe.html#create_voltage_probe",
        "title": "create_voltage_probe",
        "section": "create_voltage_probe",
        "text": "Create a voltage probe.\npyedb.dotnet.database.edb_data.terminals.PadstackInstanceTerminal,\npyedb.dotnet.database.edb_data.terminals.PointTerminal,\npyedb.dotnet.database.edb_data.terminals.PinGroupTerminal,\nPositive terminal of the port.\npyedb.dotnet.database.edb_data.terminals.PadstackInstanceTerminal,\npyedb.dotnet.database.edb_data.terminals.PointTerminal,\npyedb.dotnet.database.edb_data.terminals.PinGroupTerminal,\nNegative terminal of the probe.\ncreate_voltage_probe\npyedb.dotnet.database.edb_data.terminals.EdgeTerminal\npyedb.dotnet.database.edb_data.terminals.PadstackInstanceTerminal\npyedb.dotnet.database.edb_data.terminals.PointTerminal\npyedb.dotnet.database.edb_data.terminals.PinGroupTerminal\npyedb.dotnet.database.edb_data.terminals.EdgeTerminal\npyedb.dotnet.database.edb_data.terminals.PadstackInstanceTerminal\npyedb.dotnet.database.edb_data.terminals.PointTerminal\npyedb.dotnet.database.edb_data.terminals.PinGroupTerminal\npyedb.dotnet.database.edb_data.terminals.Terminal"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_voltage_probe",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_voltage_probe.html#pyedb.dotnet.edb.Edb.create_voltage_probe",
        "title": "create_voltage_probe > create_voltage_probe > create_voltage_probe",
        "section": "create_voltage_probe > create_voltage_probe",
        "text": "Edb.create_voltage_probe(terminal, ref_terminal)\n\nCreate a voltage probe.\n\nParameters\n\nterminal\n\npyedb.dotnet.database.edb_data.terminals.EdgeTerminal,\n\npyedb.dotnet.database.edb_data.terminals.PadstackInstanceTerminal,\npyedb.dotnet.database.edb_data.terminals.PointTerminal,\npyedb.dotnet.database.edb_data.terminals.PinGroupTerminal,\nPositive terminal of the port.\n\nref_terminal\n\npyedb.dotnet.database.edb_data.terminals.EdgeTerminal,\n\npyedb.dotnet.database.edb_data.terminals.PadstackInstanceTerminal,\npyedb.dotnet.database.edb_data.terminals.PointTerminal,\npyedb.dotnet.database.edb_data.terminals.PinGroupTerminal,\nNegative terminal of the probe.\n\nReturns\n\npyedb.dotnet.database.edb_data.terminals.Terminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#hfss-automatic-configuration",
        "title": "HFSS automatic configuration",
        "section": "HFSS automatic configuration",
        "text": "Purpose\nTypical use-cases\nWhat the helper does\nDesign philosophy\nMinimal quick-start\nClass and data model\nHFSSAutoConfiguration\nSimulation setup\nBatchGroup\nSolderBallsInfo\nFactory function\nNet grouping logic\nDifferential-pair preservation\nPrefix patterns\nReference-net selection\nPort creation details\nCoaxial ports\nCircuit ports\nMesh and sweep defaults\nFile and folder layout\nLogging and error handling\nPerformance notes\nAPI reference index\nExamples\nComplete PCIe Gen-4 sign-off\nTroubleshooting\nLicense\nHFSS automatic configuration"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#purpose",
        "title": "HFSS automatic configuration > Purpose",
        "section": "Purpose",
        "text": "The HFSSAutoConfiguration class (and its factory function create_hfss_auto_configuration) is a\nproduction-ready, declarative helper that turns a full-board EDB into analysis-ready HFSS cut-out\nprojects without manual intervention.\nPurpose\nHFSSAutoConfiguration\ncreate_hfss_auto_configuration"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#typical-use-cases",
        "title": "HFSS automatic configuration > Typical use-cases",
        "section": "Typical use-cases",
        "text": "Post-layout signal-integrity sign-off for high-speed digital interfaces (PCIe, DDR, USB, Ethernet, etc.)\nAutomated impedance, insertion-loss and return-loss validation for every active net in the design\nRegression testing across design spins—every net is simulated with identical boundary conditions, mesh\nsettings, and port types\nDesign-of-experiments (DoE) where the same schematic is re-simulated with different stack-ups, materials, or\nsolder-ball geometries\nTypical use-cases"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#what-the-helper-does",
        "title": "HFSS automatic configuration > What the helper does",
        "section": "What the helper does",
        "text": "Opens the source EDB (board layout)\nIdentifies signal and power/ground nets automatically\nPicks the best reference net (GND, VSS, AGND …) using a curated regex table\nOptionally groups nets into batches (differential pairs are never split)\nCreates a cut-out for every batch (bounding box or convex-hull)\nPlaces coaxial or circuit ports on every component that touches the signal nets\nApplies solder-ball geometry when supplied (cylinder, sphere, spheroid)\nWrites a ready-to-solve HFSS setup (adaptive mesh, broadband sweep, auto-seeding)\nSaves an independent EDB project per batch so that simulations can be distributed on a compute farm\nThe user only supplies:\npath to the source EDB\n(optionally) a list of nets or prefix patterns—everything else is auto-discovered\nWhat the helper does"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#design-philosophy",
        "title": "HFSS automatic configuration > Design philosophy",
        "section": "Design philosophy",
        "text": "No manual GUI work—100 % script driven\nRepeatable—identical settings for every net, every run\nScalable—cut-outs + batching keep problem size small enough for overnight turnaround on a 32-core box\nExtensible—every numeric setting, port type or mesh strategy is exposed as a dataclass field\nDesign philosophy"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#minimal-quick-start",
        "title": "HFSS automatic configuration > Minimal quick-start",
        "section": "Minimal quick-start",
        "text": "The snippet above produces a folder ../hfss/serdes.aedb that contains:\na cut-out with ≤ 50 nets\ncoaxial ports on every component pin\nadaptive mesh 10 GHz–40 GHz sweep\nready to be solved\nMinimal quick-start\n../hfss/serdes.aedb"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#class-and-data-model",
        "title": "HFSS automatic configuration > Class and data model",
        "section": "Class and data model",
        "text": "Class and data model"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#hfssautoconfiguration",
        "title": "HFSS automatic configuration > HFSSAutoConfiguration",
        "section": "HFSSAutoConfiguration",
        "text": "Append a new BatchGroup to the configuration.\nDescriptive name for the group (will also become the regex\npattern when the group is built automatically).\nList of net names that belong to this batch.  If omitted\nan empty list is assumed and you can fill it later.\nPer-batch simulation settings.  When None the global\nself.simulation_setup is used.\nThe freshly created instance (already appended to\nself.batch_groups) so the caller can further\nmanipulate it if desired.\nCreate a: class:.SimulationSetup instance and attach it to the configuration.\nDriven frequency used during mesh generation.\nMaximum number of adaptive passes.\nLower bound of the sweep window.\nUpper bound of the sweep window.\nLinear step size for the frequency sweep.\nMaximum element size for mesh operations.  When None HFSS\ncomputes an appropriate value automatically.\nPlacement strategy for the new setup:\nFalse – append a per-batch setup by creating an auxiliary\nBatchGroup (name=\"extra_setup\") whose\nBatchGroup.simulation_setup points to the new object.\nTrue – overwrite the global: attr:simulation_setup\nattribute of the current HfssAutoConfig instance.\nThe newly created instance (already stored inside the configuration).\nAppend a new SolderBallsInfo entry to the configuration.\nReference designator of the component to which the solder-ball\ndefinition applies (e.g. \"U1\").\nGeometric model used for the solder ball. Supported values are\n\"cylinder\", \"sphere\", \"spheroid\", etc.\nNominal diameter.  When None HFSS auto-evaluates the value\nfrom the footprint.\nMiddle diameter required only for spheroid shapes.  Ignored\nfor all other geometries.\nBall height.  When None HFSS computes an appropriate value\nautomatically.\nThe newly created instance (already appended to\nsolder_balls).  The object can be further edited in-place\nby the caller if desired.\nAutomatically create and populate batch_groups from the current\nsignal_nets.\nThis is a thin convenience wrapper around group_nets_by_prefix().\nIt only executes when both:\nauto_evaluate_batch_groups is True, and\nsignal_nets is non-empty.\nPOSIX ERE prefix pattern(s) that control which nets are grouped.\nNone (default) – activate auto-discovery mode: nets are\nclustered heuristically and then split into chunks of size\nbatch_size.\nstr – treat the single string as a prefix pattern\n(automatically anchored: pattern + \".*\").\nlist [str] – each list element becomes its own\nprefix pattern; one BatchGroup is created per list\nentry, regardless of batch_size.\nGroup signal nets into disjoint batches while preserving differential pairs.\nPOSIX ERE patterns that define the prefixes to be grouped.\nExample: [\"PCIe\", \"USB\"]  ➜  interpreted as [\"PCIe.*\", \"USB.*\"].\nIf None patterns are derived heuristically from the data set\n(see _infer_prefix_patterns()).\nKeys are the original / generated pattern strings.\nValues are lists of batches; each batch is an alphabetically sorted\nlist of net names.  When prefix_patterns was supplied the list\ncontains exactly one element (the complete group); in auto-discovery\nmode the list may contain multiple slices sized according to\nbatch_size.\nDifferential recognition strips the suffixes _[PN], _[ML], _[+-]\n(case-insensitive).\nThe function updates the instance attribute batch_groups in place.\nExplicit grouping (production intent):\nAuto-discovery with batching:\nHFSSAutoConfiguration\npython:str\nSequence\npython:str\noptional\nSimulationSetup\noptional\nself.simulation_setup\nBatchGroup\nself.batch_groups\nUnion\nstr\n\"10GHz\"\n15\nUnion\nstr\n0\nUnion\nstr\n\"40GHz\"\nUnion\nstr\n\"0.05GHz\"\nUnion\nstr\nNone\noptional\nNone\nFalse\nFalse\nBatchGroup\nname=\"extra_setup\"\nBatchGroup.simulation_setup\nTrue\nHfssAutoConfig\nSimulationSetup\nSolderBallsInfo\nstr\n\"U1\"\nstr\ndefault\n\"cylinder\"\n\"cylinder\"\n\"sphere\"\n\"spheroid\"\nstr\nfloat\nNone\noptional\nNone\nstr\nfloat\nNone\noptional\nstr\nfloat\nNone\noptional\nNone\nSolderBallsInfo\nsolder_balls\nbatch_groups\nsignal_nets\ngroup_nets_by_prefix()\nauto_evaluate_batch_groups\nTrue\nsignal_nets\nstr\nlist\nstr\nNone\noptional\nNone\nbatch_size\nstr\npattern + \".*\"\nlist\nstr\nBatchGroup\nbatch_size\nSequence\npython:str\noptional\n[\"PCIe\", \"USB\"]\n[\"PCIe.*\", \"USB.*\"]\nNone\n_infer_prefix_patterns()\nDict\npython:str\nList\nList\npython:str\nbatch_size\n_[PN]\n_[ML]\n_[+-]\nbatch_groups"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#pyedb.workflows.sipi.hfss_auto_configuration.HFSSAutoConfiguration",
        "title": "HFSS automatic configuration > HFSSAutoConfiguration > HFSSAutoConfiguration",
        "section": "HFSSAutoConfiguration > HFSSAutoConfiguration",
        "text": "class pyedb.workflows.sipi.hfss_auto_configuration.HFSSAutoConfiguration(edb=None)\n\n!! processed by numpydoc !!\n\n\n\nadd_batch_group(name: str, nets: Sequence[str] | None = None, *, simulation_setup: SimulationSetup | None = None) -> BatchGroup\n\nAppend a new BatchGroup to the configuration.\n\nParameters\n\nname\n\npython:str\n\nDescriptive name for the group (will also become the regex\npattern when the group is built automatically).\n\nnets\n\nSequence[python:str], optional\n\nList of net names that belong to this batch.  If omitted\nan empty list is assumed and you can fill it later.\n\nsimulation_setup\n\nSimulationSetup, optional\n\nPer-batch simulation settings.  When None the global\nself.simulation_setup is used.\n\nReturns\n\nBatchGroup\n\nThe freshly created instance (already appended to\nself.batch_groups) so the caller can further\nmanipulate it if desired.\n\n!! processed by numpydoc !!\n\n\n\nadd_simulation_setup(meshing_frequency: float | str | None = '10GHz', maximum_pass_number: int = 15, start_frequency: float | str | None = 0, stop_frequency: float | str | None = '40GHz', frequency_step: float | str | None = '0.05GHz', replace: bool = True) -> SimulationSetup\n\nCreate a: class:.SimulationSetup instance and attach it to the configuration.\n\nParameters\n\nmeshing_frequency\n\nUnion[str,: class:float], default \"10GHz\"\n\nDriven frequency used during mesh generation.\n\nmaximum_pass_number\n\nclass:int, default 15\n\nMaximum number of adaptive passes.\n\nstart_frequency\n\nUnion[str,: class:float], default 0\n\nLower bound of the sweep window.\n\nstop_frequency\n\nUnion[str,: class:float], default \"40GHz\"\n\nUpper bound of the sweep window.\n\nfrequency_step\n\nUnion[str,: class:float], default \"0.05GHz\"\n\nLinear step size for the frequency sweep.\n\nmesh_operation_size\n\nUnion[str,: class:float, None], optional\n\nMaximum element size for mesh operations.  When None HFSS\ncomputes an appropriate value automatically.\n\nreplace\n\nclass:bool, default False\n\nPlacement strategy for the new setup:\n\nFalse – append a per-batch setup by creating an auxiliary\nBatchGroup (name=\"extra_setup\") whose\nBatchGroup.simulation_setup points to the new object.\n\nTrue – overwrite the global: attr:simulation_setup\nattribute of the current HfssAutoConfig instance.\n\nReturns\n\nSimulationSetup\n\nThe newly created instance (already stored inside the configuration).\n\nExamples\n\n>>> cfg = HfssAutoConfig()\n>>> # global setup\n>>> cfg.add_simulation_setup(frequency_max=\"60GHz\", replace=True)\n>>> # per-batch setup\n>>> cfg.add_simulation_setup(frequency_step=\"0.1GHz\")\n\n!! processed by numpydoc !!\n\n\n\nadd_solder_ball(ref_des: str, shape: str = 'cylinder', diameter: float | str | None = None, mid_diameter: float | str | None = None, height: float | str | None = None) -> SolderBallsInfo\n\nAppend a new SolderBallsInfo entry to the configuration.\n\nParameters\n\nref_des\n\nstr\n\nReference designator of the component to which the solder-ball\ndefinition applies (e.g. \"U1\").\n\nshape\n\nstr, default \"cylinder\"\n\nGeometric model used for the solder ball. Supported values are\n\"cylinder\", \"sphere\", \"spheroid\", etc.\n\ndiameter\n\nstr | float | None, optional\n\nNominal diameter.  When None HFSS auto-evaluates the value\nfrom the footprint.\n\nmid_diameter\n\nstr | float | None, optional\n\nMiddle diameter required only for spheroid shapes.  Ignored\nfor all other geometries.\n\nheight\n\nstr | float | None, optional\n\nBall height.  When None HFSS computes an appropriate value\nautomatically.\n\nReturns\n\nSolderBallsInfo\n\nThe newly created instance (already appended to\nsolder_balls).  The object can be further edited in-place\nby the caller if desired.\n\nExamples\n\n>>> cfg = HfssAutoConfig()\n>>> cfg.add_solder_ball(\"U1\", diameter=\"0.3mm\", height=\"0.2mm\")\n>>> cfg.add_solder_ball(\n...     \"U2\",\n...     shape=\"spheroid\",\n...     diameter=\"0.25mm\",\n...     mid_diameter=\"0.35mm\",\n...     height=\"0.18mm\",\n... )\n\n!! processed by numpydoc !!\n\n\n\nauto_populate_batch_groups(pattern: str | list[str] | None = None) -> None\n\nAutomatically create and populate batch_groups from the current\nsignal_nets.\n\nThis is a thin convenience wrapper around group_nets_by_prefix().\nIt only executes when both:\n\nauto_evaluate_batch_groups is True, and\n\nsignal_nets is non-empty.\n\nParameters\n\npattern\n\nstr | list [str] | None, optional\n\nPOSIX ERE prefix pattern(s) that control which nets are grouped.\n\nNone (default) – activate auto-discovery mode: nets are\nclustered heuristically and then split into chunks of size\nbatch_size.\n\nstr – treat the single string as a prefix pattern\n(automatically anchored: pattern + \".*\").\n\nlist [str] – each list element becomes its own\nprefix pattern; one BatchGroup is created per list\nentry, regardless of batch_size.\n\n!! processed by numpydoc !!\n\n\n\ncreate_projects()\n\n!! processed by numpydoc !!\n\n\n\ngroup_nets_by_prefix(prefix_patterns: Sequence[str] | None = None) -> Dict[str, List[List[str]]]\n\nGroup signal nets into disjoint batches while preserving differential pairs.\n\nParameters\n\nprefix_patterns\n\nSequence[python:str], optional\n\nPOSIX ERE patterns that define the prefixes to be grouped.\nExample: [\"PCIe\", \"USB\"]  ➜  interpreted as [\"PCIe.*\", \"USB.*\"].\nIf None patterns are derived heuristically from the data set\n(see _infer_prefix_patterns()).\n\nReturns\n\nDict[python:str, List[List[python:str]]]\n\nKeys are the original / generated pattern strings.\nValues are lists of batches; each batch is an alphabetically sorted\nlist of net names.  When prefix_patterns was supplied the list\ncontains exactly one element (the complete group); in auto-discovery\nmode the list may contain multiple slices sized according to\nbatch_size.\n\nNotes\n\nDifferential recognition strips the suffixes _[PN], _[ML], _[+-]\n(case-insensitive).\n\nThe function updates the instance attribute batch_groups in place.\n\nExamples\n\nExplicit grouping (production intent):\n\n>>> cfg.signal_nets = [\"PCIe_RX0_P\", \"PCIe_RX0_N\", \"PCIe_TX0_P\",\n...                    \"USB3_DP\", \"USB3_DN\", \"DDR4_A0\", \"DDR4_A1\"]\n>>> cfg.batch_size = 1_000          # ignored when patterns are supplied\n>>> cfg.group_nets_by_prefix([\"PCIe\", \"USB\"])\n{'PCIe.*': [['PCIe_RX0_N', 'PCIe_RX0_P', 'PCIe_TX0_P']],\n 'USB.*':  [['USB3_DN', 'USB3_DP']]}\n\nAuto-discovery with batching:\n\n>>> cfg.group_nets_by_prefix()      # batch_size = 2\n{'PCIe.*': [['PCIe_RX0_N', 'PCIe_RX0_P'], ['PCIe_TX0_P']],\n 'USB.*':  [['USB3_DN', 'USB3_DP']],\n 'DDR4.*': [['DDR4_A0', 'DDR4_A1']]}\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#pyedb.workflows.sipi.hfss_auto_configuration.HFSSAutoConfiguration.add_batch_group",
        "title": "HFSS automatic configuration > HFSSAutoConfiguration > add_batch_group",
        "section": "HFSSAutoConfiguration > add_batch_group",
        "text": "add_batch_group(name: str, nets: Sequence[str] | None = None, *, simulation_setup: SimulationSetup | None = None) -> BatchGroup\n\nAppend a new BatchGroup to the configuration.\n\nParameters\n\nname\n\npython:str\n\nDescriptive name for the group (will also become the regex\npattern when the group is built automatically).\n\nnets\n\nSequence[python:str], optional\n\nList of net names that belong to this batch.  If omitted\nan empty list is assumed and you can fill it later.\n\nsimulation_setup\n\nSimulationSetup, optional\n\nPer-batch simulation settings.  When None the global\nself.simulation_setup is used.\n\nReturns\n\nBatchGroup\n\nThe freshly created instance (already appended to\nself.batch_groups) so the caller can further\nmanipulate it if desired.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#pyedb.workflows.sipi.hfss_auto_configuration.HFSSAutoConfiguration.add_simulation_setup",
        "title": "HFSS automatic configuration > HFSSAutoConfiguration > add_simulation_setup",
        "section": "HFSSAutoConfiguration > add_simulation_setup",
        "text": "add_simulation_setup(meshing_frequency: float | str | None = '10GHz', maximum_pass_number: int = 15, start_frequency: float | str | None = 0, stop_frequency: float | str | None = '40GHz', frequency_step: float | str | None = '0.05GHz', replace: bool = True) -> SimulationSetup\n\nCreate a: class:.SimulationSetup instance and attach it to the configuration.\n\nParameters\n\nmeshing_frequency\n\nUnion[str,: class:float], default \"10GHz\"\n\nDriven frequency used during mesh generation.\n\nmaximum_pass_number\n\nclass:int, default 15\n\nMaximum number of adaptive passes.\n\nstart_frequency\n\nUnion[str,: class:float], default 0\n\nLower bound of the sweep window.\n\nstop_frequency\n\nUnion[str,: class:float], default \"40GHz\"\n\nUpper bound of the sweep window.\n\nfrequency_step\n\nUnion[str,: class:float], default \"0.05GHz\"\n\nLinear step size for the frequency sweep.\n\nmesh_operation_size\n\nUnion[str,: class:float, None], optional\n\nMaximum element size for mesh operations.  When None HFSS\ncomputes an appropriate value automatically.\n\nreplace\n\nclass:bool, default False\n\nPlacement strategy for the new setup:\n\nFalse – append a per-batch setup by creating an auxiliary\nBatchGroup (name=\"extra_setup\") whose\nBatchGroup.simulation_setup points to the new object.\n\nTrue – overwrite the global: attr:simulation_setup\nattribute of the current HfssAutoConfig instance.\n\nReturns\n\nSimulationSetup\n\nThe newly created instance (already stored inside the configuration).\n\nExamples\n\n>>> cfg = HfssAutoConfig()\n>>> # global setup\n>>> cfg.add_simulation_setup(frequency_max=\"60GHz\", replace=True)\n>>> # per-batch setup\n>>> cfg.add_simulation_setup(frequency_step=\"0.1GHz\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#pyedb.workflows.sipi.hfss_auto_configuration.HFSSAutoConfiguration.add_solder_ball",
        "title": "HFSS automatic configuration > HFSSAutoConfiguration > add_solder_ball",
        "section": "HFSSAutoConfiguration > add_solder_ball",
        "text": "add_solder_ball(ref_des: str, shape: str = 'cylinder', diameter: float | str | None = None, mid_diameter: float | str | None = None, height: float | str | None = None) -> SolderBallsInfo\n\nAppend a new SolderBallsInfo entry to the configuration.\n\nParameters\n\nref_des\n\nstr\n\nReference designator of the component to which the solder-ball\ndefinition applies (e.g. \"U1\").\n\nshape\n\nstr, default \"cylinder\"\n\nGeometric model used for the solder ball. Supported values are\n\"cylinder\", \"sphere\", \"spheroid\", etc.\n\ndiameter\n\nstr | float | None, optional\n\nNominal diameter.  When None HFSS auto-evaluates the value\nfrom the footprint.\n\nmid_diameter\n\nstr | float | None, optional\n\nMiddle diameter required only for spheroid shapes.  Ignored\nfor all other geometries.\n\nheight\n\nstr | float | None, optional\n\nBall height.  When None HFSS computes an appropriate value\nautomatically.\n\nReturns\n\nSolderBallsInfo\n\nThe newly created instance (already appended to\nsolder_balls).  The object can be further edited in-place\nby the caller if desired.\n\nExamples\n\n>>> cfg = HfssAutoConfig()\n>>> cfg.add_solder_ball(\"U1\", diameter=\"0.3mm\", height=\"0.2mm\")\n>>> cfg.add_solder_ball(\n...     \"U2\",\n...     shape=\"spheroid\",\n...     diameter=\"0.25mm\",\n...     mid_diameter=\"0.35mm\",\n...     height=\"0.18mm\",\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#pyedb.workflows.sipi.hfss_auto_configuration.HFSSAutoConfiguration.auto_populate_batch_groups",
        "title": "HFSS automatic configuration > HFSSAutoConfiguration > auto_populate_batch_groups",
        "section": "HFSSAutoConfiguration > auto_populate_batch_groups",
        "text": "auto_populate_batch_groups(pattern: str | list[str] | None = None) -> None\n\nAutomatically create and populate batch_groups from the current\nsignal_nets.\n\nThis is a thin convenience wrapper around group_nets_by_prefix().\nIt only executes when both:\n\nauto_evaluate_batch_groups is True, and\n\nsignal_nets is non-empty.\n\nParameters\n\npattern\n\nstr | list [str] | None, optional\n\nPOSIX ERE prefix pattern(s) that control which nets are grouped.\n\nNone (default) – activate auto-discovery mode: nets are\nclustered heuristically and then split into chunks of size\nbatch_size.\n\nstr – treat the single string as a prefix pattern\n(automatically anchored: pattern + \".*\").\n\nlist [str] – each list element becomes its own\nprefix pattern; one BatchGroup is created per list\nentry, regardless of batch_size.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#pyedb.workflows.sipi.hfss_auto_configuration.HFSSAutoConfiguration.create_projects",
        "title": "HFSS automatic configuration > HFSSAutoConfiguration > create_projects",
        "section": "HFSSAutoConfiguration > create_projects",
        "text": "create_projects()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#pyedb.workflows.sipi.hfss_auto_configuration.HFSSAutoConfiguration.group_nets_by_prefix",
        "title": "HFSS automatic configuration > HFSSAutoConfiguration > group_nets_by_prefix",
        "section": "HFSSAutoConfiguration > group_nets_by_prefix",
        "text": "group_nets_by_prefix(prefix_patterns: Sequence[str] | None = None) -> Dict[str, List[List[str]]]\n\nGroup signal nets into disjoint batches while preserving differential pairs.\n\nParameters\n\nprefix_patterns\n\nSequence[python:str], optional\n\nPOSIX ERE patterns that define the prefixes to be grouped.\nExample: [\"PCIe\", \"USB\"]  ➜  interpreted as [\"PCIe.*\", \"USB.*\"].\nIf None patterns are derived heuristically from the data set\n(see _infer_prefix_patterns()).\n\nReturns\n\nDict[python:str, List[List[python:str]]]\n\nKeys are the original / generated pattern strings.\nValues are lists of batches; each batch is an alphabetically sorted\nlist of net names.  When prefix_patterns was supplied the list\ncontains exactly one element (the complete group); in auto-discovery\nmode the list may contain multiple slices sized according to\nbatch_size.\n\nNotes\n\nDifferential recognition strips the suffixes _[PN], _[ML], _[+-]\n(case-insensitive).\n\nThe function updates the instance attribute batch_groups in place.\n\nExamples\n\nExplicit grouping (production intent):\n\n>>> cfg.signal_nets = [\"PCIe_RX0_P\", \"PCIe_RX0_N\", \"PCIe_TX0_P\",\n...                    \"USB3_DP\", \"USB3_DN\", \"DDR4_A0\", \"DDR4_A1\"]\n>>> cfg.batch_size = 1_000          # ignored when patterns are supplied\n>>> cfg.group_nets_by_prefix([\"PCIe\", \"USB\"])\n{'PCIe.*': [['PCIe_RX0_N', 'PCIe_RX0_P', 'PCIe_TX0_P']],\n 'USB.*':  [['USB3_DN', 'USB3_DP']]}\n\nAuto-discovery with batching:\n\n>>> cfg.group_nets_by_prefix()      # batch_size = 2\n{'PCIe.*': [['PCIe_RX0_N', 'PCIe_RX0_P'], ['PCIe_TX0_P']],\n 'USB.*':  [['USB3_DN', 'USB3_DP']],\n 'DDR4.*': [['DDR4_A0', 'DDR4_A1']]}\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#simulation-setup",
        "title": "HFSS automatic configuration > Simulation setup",
        "section": "Simulation setup",
        "text": "Simulation setup"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#pyedb.workflows.sipi.hfss_auto_configuration.SimulationSetup",
        "title": "HFSS automatic configuration > Simulation setup > SimulationSetup",
        "section": "Simulation setup > SimulationSetup",
        "text": "class pyedb.workflows.sipi.hfss_auto_configuration.SimulationSetup(meshing_frequency: 'Union[str, float]' = '10GHz', maximum_pass_number: 'int' = 15, start_frequency: 'Union[str, float]' = 0, stop_frequency: 'Union[str, float]' = '40GHz', frequency_step: 'Union[str, float]' = '0.05GHz')\n\n!! processed by numpydoc !!\n\n\n\nfrequency_step: str | float = '0.05GHz'\n\n\n\n\n\nmaximum_pass_number: int = 15\n\n\n\n\n\nmeshing_frequency: str | float = '10GHz'\n\n\n\n\n\nstart_frequency: str | float = 0\n\n\n\n\n\nstop_frequency: str | float = '40GHz'\n\n"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#pyedb.workflows.sipi.hfss_auto_configuration.SimulationSetup.frequency_step",
        "title": "HFSS automatic configuration > Simulation setup > frequency_step",
        "section": "Simulation setup > frequency_step",
        "text": "frequency_step: str | float = '0.05GHz'\n\n"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#pyedb.workflows.sipi.hfss_auto_configuration.SimulationSetup.maximum_pass_number",
        "title": "HFSS automatic configuration > Simulation setup > maximum_pass_number",
        "section": "Simulation setup > maximum_pass_number",
        "text": "maximum_pass_number: int = 15\n\n"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#pyedb.workflows.sipi.hfss_auto_configuration.SimulationSetup.meshing_frequency",
        "title": "HFSS automatic configuration > Simulation setup > meshing_frequency",
        "section": "Simulation setup > meshing_frequency",
        "text": "meshing_frequency: str | float = '10GHz'\n\n"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#pyedb.workflows.sipi.hfss_auto_configuration.SimulationSetup.start_frequency",
        "title": "HFSS automatic configuration > Simulation setup > start_frequency",
        "section": "Simulation setup > start_frequency",
        "text": "start_frequency: str | float = 0\n\n"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#pyedb.workflows.sipi.hfss_auto_configuration.SimulationSetup.stop_frequency",
        "title": "HFSS automatic configuration > Simulation setup > stop_frequency",
        "section": "Simulation setup > stop_frequency",
        "text": "stop_frequency: str | float = '40GHz'\n\n"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#batchgroup",
        "title": "HFSS automatic configuration > BatchGroup",
        "section": "BatchGroup",
        "text": "BatchGroup"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#pyedb.workflows.sipi.hfss_auto_configuration.BatchGroup",
        "title": "HFSS automatic configuration > BatchGroup > BatchGroup",
        "section": "BatchGroup > BatchGroup",
        "text": "class pyedb.workflows.sipi.hfss_auto_configuration.BatchGroup(name: 'str' = '', nets: 'List[str]' = <factory>, simulation_setup: 'SimulationSetup' = None)\n\n!! processed by numpydoc !!\n\n\n\nname: str = ''\n\n\n\n\n\nnets: List[str]\n\n\n\n\n\nsimulation_setup: SimulationSetup = None\n\n"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#pyedb.workflows.sipi.hfss_auto_configuration.BatchGroup.name",
        "title": "HFSS automatic configuration > BatchGroup > name",
        "section": "BatchGroup > name",
        "text": "name: str = ''\n\n"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#pyedb.workflows.sipi.hfss_auto_configuration.BatchGroup.nets",
        "title": "HFSS automatic configuration > BatchGroup > nets",
        "section": "BatchGroup > nets",
        "text": "nets: List[str]\n\n"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#pyedb.workflows.sipi.hfss_auto_configuration.BatchGroup.simulation_setup",
        "title": "HFSS automatic configuration > BatchGroup > simulation_setup",
        "section": "BatchGroup > simulation_setup",
        "text": "simulation_setup: SimulationSetup = None\n\n"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#solderballsinfo",
        "title": "HFSS automatic configuration > SolderBallsInfo",
        "section": "SolderBallsInfo",
        "text": "SolderBallsInfo"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#pyedb.workflows.sipi.hfss_auto_configuration.SolderBallsInfo",
        "title": "HFSS automatic configuration > SolderBallsInfo > SolderBallsInfo",
        "section": "SolderBallsInfo > SolderBallsInfo",
        "text": "class pyedb.workflows.sipi.hfss_auto_configuration.SolderBallsInfo(ref_des: 'str' = '', shape: 'str' = 'cylinder', diameter: 'Optional[Union[str, float]]' = None, mid_diameter: 'Optional[Union[str, float]]' = None, height: 'Optional[Union[str, float]]' = None)\n\n!! processed by numpydoc !!\n\n\n\ndiameter: float | str | None = None\n\n\n\n\n\nheight: float | str | None = None\n\n\n\n\n\nmid_diameter: float | str | None = None\n\n\n\n\n\nref_des: str = ''\n\n\n\n\n\nshape: str = 'cylinder'\n\n"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#pyedb.workflows.sipi.hfss_auto_configuration.SolderBallsInfo.diameter",
        "title": "HFSS automatic configuration > SolderBallsInfo > diameter",
        "section": "SolderBallsInfo > diameter",
        "text": "diameter: float | str | None = None\n\n"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#pyedb.workflows.sipi.hfss_auto_configuration.SolderBallsInfo.height",
        "title": "HFSS automatic configuration > SolderBallsInfo > height",
        "section": "SolderBallsInfo > height",
        "text": "height: float | str | None = None\n\n"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#pyedb.workflows.sipi.hfss_auto_configuration.SolderBallsInfo.mid_diameter",
        "title": "HFSS automatic configuration > SolderBallsInfo > mid_diameter",
        "section": "SolderBallsInfo > mid_diameter",
        "text": "mid_diameter: float | str | None = None\n\n"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#pyedb.workflows.sipi.hfss_auto_configuration.SolderBallsInfo.ref_des",
        "title": "HFSS automatic configuration > SolderBallsInfo > ref_des",
        "section": "SolderBallsInfo > ref_des",
        "text": "ref_des: str = ''\n\n"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#pyedb.workflows.sipi.hfss_auto_configuration.SolderBallsInfo.shape",
        "title": "HFSS automatic configuration > SolderBallsInfo > shape",
        "section": "SolderBallsInfo > shape",
        "text": "shape: str = 'cylinder'\n\n"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#factory-function",
        "title": "HFSS automatic configuration > Factory function",
        "section": "Factory function",
        "text": "Factory function"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#net-grouping-logic",
        "title": "HFSS automatic configuration > Net grouping logic",
        "section": "Net grouping logic",
        "text": "Net grouping logic"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#differential-pair-preservation",
        "title": "HFSS automatic configuration > Differential-pair preservation",
        "section": "Differential-pair preservation",
        "text": "The helper recognises the suffixes _P/_N, _M/_P, _+/- (case-insensitive) and keeps those nets in the same\nbatch regardless of the requested batch_size.\nDifferential-pair preservation\n_P/_N\n_M/_P\n_+/-\nbatch_size"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#prefix-patterns",
        "title": "HFSS automatic configuration > Prefix patterns",
        "section": "Prefix patterns",
        "text": "Auto-discovery mode (pattern=None)\nNets are clustered by longest common prefix; each cluster is then split into chunks of size batch_size.\nExplicit mode (pattern=[\"PCIe\", \"USB\"])\nOne batch group per pattern is created; batch_size is ignored.\nPatterns are automatically treated as POSIX ERE anchored at the start: PCIe.*, USB.*.\nPrefix patterns\npattern=None\nbatch_size\npattern=[\"PCIe\", \"USB\"]\nbatch_size\nPCIe.*\nUSB.*"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#reference-net-selection",
        "title": "HFSS automatic configuration > Reference-net selection",
        "section": "Reference-net selection",
        "text": "The first net that matches any of the following regexes (case-insensitive) is used as reference:\nIf multiple candidates exist, the one whose name contains the string “GND” is preferred; the rest become power nets.\nReference-net selection"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#port-creation-details",
        "title": "HFSS automatic configuration > Port creation details",
        "section": "Port creation details",
        "text": "Port creation details"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#coaxial-ports",
        "title": "HFSS automatic configuration > Coaxial ports",
        "section": "Coaxial ports",
        "text": "A coaxial cylinder is constructed normal to the component pin.\nThe outer radius is derived from the pad-stack anti-pad; the inner radius from the finished hole size.\nWhen solder_balls are supplied the 3-D model is extended by the ball height and diameter.\nCoaxial ports\nsolder_balls"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#circuit-ports",
        "title": "HFSS automatic configuration > Circuit ports",
        "section": "Circuit ports",
        "text": "A two-pin circuit port is placed between the signal pin and the nearest reference (ground) pin on the same component.\nIf create_pin_group=True all pins of the same net are shorted into a single pin-group before the port is attached.\nCircuit ports\ncreate_pin_group=True"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#mesh-and-sweep-defaults",
        "title": "HFSS automatic configuration > Mesh and sweep defaults",
        "section": "Mesh and sweep defaults",
        "text": "All values can be overridden globally (simulation_setup) or per batch (BatchGroup.simulation_setup).\nMesh and sweep defaults\nsimulation_setup\nBatchGroup.simulation_setup"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#file-and-folder-layout",
        "title": "HFSS automatic configuration > File and folder layout",
        "section": "File and folder layout",
        "text": "After create_projects() finishes you obtain:\nEach *.aedb folder is an independent HFSS project that can be opened, solved and post-processed separately.\nFile and folder layout\ncreate_projects()\n*.aedb"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#logging-and-error-handling",
        "title": "HFSS automatic configuration > Logging and error handling",
        "section": "Logging and error handling",
        "text": "Every operation is logged through the native EDB logger (INFO level)\nMissing components, duplicate net names or impossible cut-outs raise before any file is written\nIf a batch group ends up with only one net, it is automatically merged into the largest compatible group to avoid degenerate simulations\nLogging and error handling"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#performance-notes",
        "title": "HFSS automatic configuration > Performance notes",
        "section": "Performance notes",
        "text": "Typical cut-out + port creation time: 2–5 s per batch (201 GB DDR4 board, 3000 nets, 32 cores)\nMemory footprint: < 2 GB per batch because only the clipped geometry is kept in memory\nScales linearly with number of batches—jobs can be dispatched to an HPC cluster independently\nPerformance notes"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#api-reference-index",
        "title": "HFSS automatic configuration > API reference index",
        "section": "API reference index",
        "text": "HFSSAutoConfiguration\nSimulationSetup\nBatchGroup\nSolderBallsInfo\ncreate_hfss_auto_configuration()\nAPI reference index\nHFSSAutoConfiguration\nSimulationSetup\nBatchGroup\nSolderBallsInfo\ncreate_hfss_auto_configuration()"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#examples",
        "title": "HFSS automatic configuration > Examples",
        "section": "Examples",
        "text": "Examples"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#complete-pcie-gen-4-sign-off",
        "title": "HFSS automatic configuration > Complete PCIe Gen-4 sign-off",
        "section": "Complete PCIe Gen-4 sign-off",
        "text": "Complete PCIe Gen-4 sign-off"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#troubleshooting",
        "title": "HFSS automatic configuration > Troubleshooting",
        "section": "Troubleshooting",
        "text": "“No reference net found”\n→ Add your ground name to ref_patterns or set reference_net manually.\n“Empty batch group”\n→ Check that signal_nets is non-empty and that the supplied prefix patterns actually match net names in the design.\n“Project fails to solve”\n→ Inspect the cut-out in AEDT: look for overlapping ports or missing reference pins; reduce batch_size to isolate the problematic net.\nTroubleshooting\nref_patterns\nreference_net\nsignal_nets\nbatch_size"
    },
    {
        "objectID": "workflows/sipi/hfss_auto_configuration",
        "href": "workflows/sipi/hfss_auto_configuration.html#license",
        "title": "HFSS automatic configuration > License",
        "section": "License",
        "text": "MIT License, see file header for full text.\nLicense"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.assign_roughness_model",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.assign_roughness_model.html#assign_roughness_model",
        "title": "assign_roughness_model",
        "section": "assign_roughness_model",
        "text": "Assign roughness model on this layer.\nType of roughness model. The default is \"huray\". Options are \"huray\", \"groisse\".\nRadius of huray model. The default is \"0.5um\".\nSurface ratio of huray model. The default is \"2.9\".\nRoughness of groisse model. The default is \"1um\".\n\"side\".\nassign_roughness_model\npython:str\noptional\n\"huray\"\n\"huray\"\n\"groisse\"\npython:str\npython:float\noptional\n\"0.5um\"\npython:str\npython:float\n\"2.9\"\npython:str\npython:float\noptional\n\"1um\"\npython:str\n\"all\"\n\"top\"\n\"bottom\"\n\"side\""
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.assign_roughness_model",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.assign_roughness_model.html#pyedb.grpc.database.layers.stackup_layer.StackupLayer.assign_roughness_model",
        "title": "assign_roughness_model > assign_roughness_model > assign_roughness_model",
        "section": "assign_roughness_model > assign_roughness_model",
        "text": "StackupLayer.assign_roughness_model(model_type='huray', huray_radius='0.5um', huray_surface_ratio='2.9', groisse_roughness='1um', apply_on_surface='all') -> bool\n\nAssign roughness model on this layer.\n\nParameters\n\nmodel_type\n\npython:str, optional\n\nType of roughness model. The default is \"huray\". Options are \"huray\", \"groisse\".\n\nhuray_radius\n\npython:str, python:float, optional\n\nRadius of huray model. The default is \"0.5um\".\n\nhuray_surface_ratio\n\npython:str, python:float, optional.\n\nSurface ratio of huray model. The default is \"2.9\".\n\ngroisse_roughness\n\npython:str, python:float, optional\n\nRoughness of groisse model. The default is \"1um\".\n\napply_on_surface\n\npython:str, optional.\n\nWhere to assign roughness model. The default is \"all\". Options are \"top\", \"bottom\",\n\n\"side\".\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/siw_dc_ir_settings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/siw_dc_ir_settings.html#siwave-dc-ir-settings",
        "title": "SIwave DC-IR settings",
        "section": "SIwave DC-IR settings",
        "text": "This class is the container of SIwave DC-IR settings.\nSiwaveDCIRSettings\nClass for DC IR settings.\nSIwave DC-IR settings\nSiwaveDCIRSettings"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_pins_name_from_net",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_pins_name_from_net.html#get_pins_name_from_net",
        "title": "get_pins_name_from_net",
        "section": "get_pins_name_from_net",
        "text": "Get pin names from net.\nNet name.\nList of pins to search.\nList of pin names.\nget_pins_name_from_net\npython:str\npython:list\noptional\npython:list\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_pins_name_from_net",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_pins_name_from_net.html#pyedb.grpc.database.components.Components.get_pins_name_from_net",
        "title": "get_pins_name_from_net > get_pins_name_from_net > get_pins_name_from_net",
        "section": "get_pins_name_from_net > get_pins_name_from_net",
        "text": "Components.get_pins_name_from_net(net_name: str, pin_list: List[Any] | None = None) -> List[str]\n\nGet pin names from net.\n\nParameters\n\nnet_name\n\npython:str\n\nNet name.\n\npin_list\n\npython:list, optional\n\nList of pins to search.\n\nReturns\n\npython:list[python:str]\n\nList of pin names.\n\nExamples\n\n>>> pins = edbapp.components.get_pins_name_from_net(\"GND\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_all_variable_names",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_all_variable_names.html#get_all_variable_names",
        "title": "get_all_variable_names",
        "section": "get_all_variable_names",
        "text": "Method added for compatibility with grpc.\nList of variables name.\nget_all_variable_names\nList\nStr"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_all_variable_names",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.get_all_variable_names.html#pyedb.dotnet.edb.Edb.get_all_variable_names",
        "title": "get_all_variable_names > get_all_variable_names > get_all_variable_names",
        "section": "get_all_variable_names > get_all_variable_names",
        "text": "Edb.get_all_variable_names()\n\nMethod added for compatibility with grpc.\n\nReturns\n\nList[Str]\n\nList of variables name.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "validate"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.validate.html#pyedb.workflows.drc.drc.DiffPair.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod DiffPair.validate(value: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_voltage_source",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_voltage_source.html#create_voltage_source",
        "title": "create_voltage_source",
        "section": "create_voltage_source",
        "text": "Create a voltage source.\nPositive terminal of the port.\nNegative terminal of the source.\ncreate_voltage_source\npyedb.dotnet.database.edb_data.terminals.EdgeTerminal\npyedb.dotnet.database.edb_data.terminals.PadstackInstanceTerminal\npyedb.dotnet.database.edb_data.terminals.PointTerminal\npyedb.dotnet.database.edb_data.terminals.PinGroupTerminal\npyedb.dotnet.database.edb_data.terminals.PadstackInstanceTerminal\npyedb.dotnet.database.edb_data.terminals.PointTerminal\npyedb.dotnet.database.edb_data.terminals.PinGroupTerminal"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_voltage_source",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.create_voltage_source.html#pyedb.dotnet.edb.Edb.create_voltage_source",
        "title": "create_voltage_source > create_voltage_source > create_voltage_source",
        "section": "create_voltage_source > create_voltage_source",
        "text": "Edb.create_voltage_source(terminal, ref_terminal)\n\nCreate a voltage source.\n\nParameters\n\nterminal\n\npyedb.dotnet.database.edb_data.terminals.EdgeTerminal,             pyedb.dotnet.database.edb_data.terminals.PadstackInstanceTerminal,             pyedb.dotnet.database.edb_data.terminals.PointTerminal,             pyedb.dotnet.database.edb_data.terminals.PinGroupTerminal\n\nPositive terminal of the port.\n\nref_terminal\n\nclass:pyedb.dotnet.database.edb_data.terminals.EdgeTerminal,             pyedb.dotnet.database.edb_data.terminals.PadstackInstanceTerminal,             pyedb.dotnet.database.edb_data.terminals.PointTerminal,             pyedb.dotnet.database.edb_data.terminals.PinGroupTerminal\n\nNegative terminal of the source.\n\nReturns\n\nclass:legacy.database.edb_data.ports.ExcitationSources\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.layout_defeaturing",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.layout_defeaturing.html#layout_defeaturing",
        "title": "layout_defeaturing",
        "section": "layout_defeaturing",
        "text": "Defeature the layout by reducing the number of points for polygons based on surface deviation criteria.\nTrue when successful, False when failed.\nlayout_defeaturing\nEdb_DATA.SimulationConfiguration\nobject\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.layout_defeaturing",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.layout_defeaturing.html#pyedb.dotnet.database.hfss.EdbHfss.layout_defeaturing",
        "title": "layout_defeaturing > layout_defeaturing > layout_defeaturing",
        "section": "layout_defeaturing > layout_defeaturing",
        "text": "EdbHfss.layout_defeaturing(simulation_setup=None)\n\nDefeature the layout by reducing the number of points for polygons based on surface deviation criteria.\n\nParameters\n\nsimulation_setup\n\nEdb_DATA.SimulationConfiguration object\n\n\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_box",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_box.html#is_box",
        "title": "is_box",
        "section": "is_box",
        "text": "Determine whether the outer contour of the polygon is a box.\nTrue when the outer corner of the polygon is a box, False otherwise.\nis_box\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_box",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_box.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.is_box",
        "title": "is_box > is_box > is_box",
        "section": "is_box > is_box",
        "text": "PolygonData.is_box() -> bool\n\nDetermine whether the outer contour of the polygon is a box.\n\nReturns\n\nbool\n\nTrue when the outer corner of the polygon is a box, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.has_self_intersections",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.has_self_intersections.html#has_self_intersections",
        "title": "has_self_intersections",
        "section": "has_self_intersections",
        "text": "Determine whether the polygon contains any self-intersections.\nTolerance.\nTrue when the polygon contains self-intersections, False otherwise.\nhas_self_intersections\npython:float\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.has_self_intersections",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.has_self_intersections.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.has_self_intersections",
        "title": "has_self_intersections > has_self_intersections > has_self_intersections",
        "section": "has_self_intersections > has_self_intersections",
        "text": "PolygonData.has_self_intersections(tol: float = 1e-09) -> bool\n\nDetermine whether the polygon contains any self-intersections.\n\nParameters\n\ntol\n\npython:float, default: 1e-9\n\nTolerance.\n\nReturns\n\nbool\n\nTrue when the polygon contains self-intersections, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "why_pyedb",
        "href": "why_pyedb.html#why-pyedb",
        "title": "Why PyEDB?",
        "section": "Why PyEDB?",
        "text": "PyEDB represents a modern, decoupled approach to PCB design automation, offering significant advantages over traditional methods.\nWhy PyEDB?"
    },
    {
        "objectID": "why_pyedb",
        "href": "why_pyedb.html#server-side-automation--headless-operation",
        "title": "Why PyEDB? > Server-Side Automation & Headless Operation",
        "section": "Server-Side Automation & Headless Operation",
        "text": "The core innovation of PyEDB is its client-server architecture:\nPyEDB (Client): A pure Python library you install and run in your environment.\nansys-edb-core (Server): A separate, high-performance gRPC service that handles all EDB operations.\nThis means you can run PyEDB on a machine without a graphical user interface (GUI), such as:\nLinux servers and high-performance computing (HPC) clusters.\nDocker containers for consistent, reproducible environments.\nCloud platforms like AWS, Azure, or GCP.\nThis enables true CI/CD (Continuous Integration/Continuous Deployment) for PCB design. You can automate checks,\nsimulations, and reports every time a design change is committed.\nServer-Side Automation & Headless Operation"
    },
    {
        "objectID": "why_pyedb",
        "href": "why_pyedb.html#performance-and-integration",
        "title": "Why PyEDB? > Performance and Integration",
        "section": "Performance and Integration",
        "text": "Performance: The gRPC protocol is fast and efficient, ideal for automating complex tasks and processing large\ndesigns.\n*   Python Ecosystem: Being a pure Python client, PyEDB integrates seamlessly with the vast Python data science and\nmachine learning stack (NumPy, Pandas, Matplotlib, Scikit-learn, PyTorch, etc.). You can easily post-process simulation\nresults or use AI/ML to guide design decisions.\nPerformance and Integration"
    },
    {
        "objectID": "why_pyedb",
        "href": "why_pyedb.html#use-cases",
        "title": "Why PyEDB? > Use Cases",
        "section": "Use Cases",
        "text": "Automated Design Rule Checking (DRC): Script checks for your team’s specific design rules.\nRegression Testing: Ensure a new design change doesn’t break SI/PI/thermal performance.\nParameter Sweeping: Automatically analyze hundreds of variations of a design (for example via spacing, layer\nthickness).\nBatch Processing: Extract S-parameters from a library of interconnects.\nReport Generation: Automatically generate standardized PDF/HTML reports with plots and tables.\nUse Cases"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_lumped_port_on_net",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_lumped_port_on_net.html#create_lumped_port_on_net",
        "title": "create_lumped_port_on_net",
        "section": "create_lumped_port_on_net",
        "text": "Create an edge port on nets. This command looks for traces and polygons on the\nnets and tries to assign vertical lumped port.\nList of nets, str or Edb net.\nName or Edb layer object.\nUse this boolean when you want to return only the points from the edges and not creating ports. Default\nvalue is False.\nThe number of digits carried for the edge location accuracy. The default value is 6.\na cutout has been performed before and lumped ports have to be created on ending traces. Default value is\nTrue.\nTrue when successful, False when failed.\ncreate_lumped_port_on_net\npython:list\noptional\npython:str\nEdb\noptional\nFalse\npython:int\noptional\n6\nTrue\nTrue\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_lumped_port_on_net",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_lumped_port_on_net.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_lumped_port_on_net",
        "title": "create_lumped_port_on_net > create_lumped_port_on_net > create_lumped_port_on_net",
        "section": "create_lumped_port_on_net > create_lumped_port_on_net",
        "text": "SourceExcitation.create_lumped_port_on_net(nets: str | List[str] | None = None, reference_layer: str | StackupLayer | None = None, return_points_only: bool = False, digit_resolution: int = 6, at_bounding_box: bool = True) -> bool\n\nCreate an edge port on nets. This command looks for traces and polygons on the\nnets and tries to assign vertical lumped port.\n\nParameters\n\nnets\n\npython:list, optional\n\nList of nets, str or Edb net.\n\nreference_layer\n\npython:str, Edb layer.\n\nName or Edb layer object.\n\nreturn_points_only\n\nbool, optional\n\nUse this boolean when you want to return only the points from the edges and not creating ports. Default\nvalue is False.\n\ndigit_resolution\n\npython:int, optional\n\nThe number of digits carried for the edge location accuracy. The default value is 6.\n\nat_bounding_box\n\nbool\n\nWhen True will keep the edges from traces at the layout bounding box location. This is recommended when\n\na cutout has been performed before and lumped ports have to be created on ending traces. Default value is\nTrue.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> points = edb.source_excitation.create_lumped_port_on_net([\"Net1\"], return_points_only=True)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/siwave_cpa_simulation_setup",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/siwave_cpa_simulation_setup.html#siwave-cpa-simulation-setup",
        "title": "Siwave CPA simulation setup",
        "section": "Siwave CPA simulation setup",
        "text": "This class is managing EDB siwave CPA simulation setup.\nSIWaveCPASimulationSetup\nRepresents the setup configuration for SIwave CPA simulations.\nSiwave CPA simulation setup\nSIWaveCPASimulationSetup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.load_material",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.load_material.html#load_material",
        "title": "load_material",
        "section": "load_material",
        "text": "Load material.\nload_material"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.load_material",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.load_material.html#pyedb.grpc.database.definition.materials.Materials.load_material",
        "title": "load_material > load_material > load_material",
        "section": "load_material > load_material",
        "text": "Materials.load_material(material: dict)\n\nLoad material.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.insert_zone",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.insert_zone.html#insert_zone",
        "title": "insert_zone",
        "section": "insert_zone",
        "text": "Insert a zone.\nZone to copy from when inserting a new zone.\nIf valid, the new zone is inserted as a copy of the given zone.\nOtherwise, the new zone is empty.\nID of the zone inserted if successful.\ninsert_zone\npython:int\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.insert_zone",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.insert_zone.html#pyedb.grpc.database.stackup.LayerCollection.insert_zone",
        "title": "insert_zone > insert_zone > insert_zone",
        "section": "insert_zone > insert_zone",
        "text": "LayerCollection.insert_zone(copy_zone=-1)\n\nInsert a zone.\n\nParameters\n\ncopy_zone\n\npython:int, default: -1\n\nZone to copy from when inserting a new zone.\nIf valid, the new zone is inserted as a copy of the given zone.\nOtherwise, the new zone is empty.\n\nReturns\n\npython:int\n\nID of the zone inserted if successful.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_nets_from_pin_list",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_nets_from_pin_list.html#get_nets_from_pin_list",
        "title": "get_nets_from_pin_list",
        "section": "get_nets_from_pin_list",
        "text": "Retrieve nets with one or more pins.\nList of pins.\nList of nets with one or more pins.\nget_nets_from_pin_list\npython:list\npython:list"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_nets_from_pin_list",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.components.Components.get_nets_from_pin_list.html#pyedb.dotnet.database.components.Components.get_nets_from_pin_list",
        "title": "get_nets_from_pin_list > get_nets_from_pin_list > get_nets_from_pin_list",
        "section": "get_nets_from_pin_list > get_nets_from_pin_list",
        "text": "Components.get_nets_from_pin_list(PinList)\n\nRetrieve nets with one or more pins.\n\nParameters\n\nPinList\n\npython:list\n\nList of pins.\n\nReturns\n\npython:list\n\nList of nets with one or more pins.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", \"project name\", \"release version\")\n>>> edbapp.components.get_nets_from_pin_list(pinlist)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.calculate_initial_extent",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.calculate_initial_extent.html#calculate_initial_extent",
        "title": "calculate_initial_extent",
        "section": "calculate_initial_extent",
        "text": "Compute a float representing the larger number between the dielectric thickness or trace width\nmultiplied by the nW factor. The trace width search is limited to nets with ports attached.\nValue for the width multiplier (nW factor).\ncalculate_initial_extent\npython:float\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.calculate_initial_extent",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.calculate_initial_extent.html#pyedb.grpc.edb.Edb.calculate_initial_extent",
        "title": "calculate_initial_extent > calculate_initial_extent > calculate_initial_extent",
        "section": "calculate_initial_extent > calculate_initial_extent",
        "text": "Edb.calculate_initial_extent(expansion_factor)\n\nCompute a float representing the larger number between the dielectric thickness or trace width\nmultiplied by the nW factor. The trace width search is limited to nets with ports attached.\n\nParameters\n\nexpansion_factor\n\npython:float\n\nValue for the width multiplier (nW factor).\n\nReturns\n\npython:float\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.is_valid",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.is_valid.html#is_valid",
        "title": "is_valid",
        "section": "is_valid",
        "text": "Determine if the layer collection is in a valid state.\nFor a laminate stackup, this method checks whether there is layer overlapping or a gap.\nFor an overlapping stackup, this method checks whether there is a dielectric layer\noverlapping or a gap.\nTrue if the layer collection is in a valid state, False otherwise.\nis_valid\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.is_valid",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.is_valid.html#pyedb.grpc.database.stackup.LayerCollection.is_valid",
        "title": "is_valid > is_valid > is_valid",
        "section": "is_valid > is_valid",
        "text": "LayerCollection.is_valid()\n\nDetermine if the layer collection is in a valid state.\n\nFor a laminate stackup, this method checks whether there is layer overlapping or a gap.\nFor an overlapping stackup, this method checks whether there is a dielectric layer\noverlapping or a gap.\n\nReturns\n\nbool\n\nTrue if the layer collection is in a valid state, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_config",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_config",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_config.html#pyedb.workflows.drc.drc.BackDrillStubLength.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "BackDrillStubLength.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.create_hfss.html#create_hfss",
        "title": "create_hfss",
        "section": "create_hfss",
        "text": "Create an HFSS model from an MCAD file.\nHFSS model created.\ncreate_hfss\nMcadModel"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.create_hfss",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.create_hfss.html#pyedb.grpc.database.ports.ports.CircuitPort.create_hfss",
        "title": "create_hfss > create_hfss > create_hfss",
        "section": "create_hfss > create_hfss",
        "text": "CircuitPort.create_hfss()\n\nCreate an HFSS model from an MCAD file.\n\nReturns\n\nMcadModel\n\nHFSS model created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.add_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.add_sweep.html#add_sweep",
        "title": "add_sweep",
        "section": "add_sweep",
        "text": "Add frequency sweep.\nName of the frequency sweep. The default is None.\nAdded for grpc compatibility.\nAdded for rpc compatibility.\nAdded for grpc compatibility.\nAdded for grpc compatibility.\nList of frequency points. The default is None.\nSweep type. The default is \"interpolation\". Options are \"discrete\",”discrete”``.\nadd_sweep\npython:str\noptional\nNone\npython:str\noptional\npython:str\noptional\npython:str\noptional\noptional\npython:list\noptional\nNone\npython:str\noptional\n\"interpolation\"\n\"discrete\""
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.add_sweep",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.add_sweep.html#pyedb.dotnet.database.utilities.hfss_simulation_setup.HFSSPISimulationSetup.add_sweep",
        "title": "add_sweep > add_sweep > add_sweep",
        "section": "add_sweep > add_sweep",
        "text": "HFSSPISimulationSetup.add_sweep(name: str | None = None, distribution: str | None = None, start_freq: str | None = None, stop_freq: str | None = None, step=None, frequency_set: list | None = None, sweep_type: str = 'interpolation', **kwargs)\n\nAdd frequency sweep.\n\nParameters\n\nname\n\npython:str, optional\n\nName of the frequency sweep. The default is None.\n\ndistribution\n\npython:str, optional\n\nAdded for grpc compatibility.\n\nstart_freq\n\npython:str, optional\n\nAdded for rpc compatibility.\n\nstop_freq\n\npython:str, optional\n\nAdded for grpc compatibility.\n\nstep\n\noptional\n\nAdded for grpc compatibility.\n\nfrequency_set\n\npython:list, optional\n\nList of frequency points. The default is None.\n\nsweep_type\n\npython:str, optional\n\nSweep type. The default is \"interpolation\". Options are \"discrete\",”discrete”``.\n\nReturns\n\n\n\n——-\n\n\n\nExamples\n\n>>> setup1 = edbapp.create_siwave_syz_setup(\"setup1\")\n>>> setup1.add_sweep(name=\"sw1\", frequency_set=[\"linear count\", \"1MHz\", \"100MHz\", 10])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_circuit_port_on_net",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_circuit_port_on_net.html#create_circuit_port_on_net",
        "title": "create_circuit_port_on_net",
        "section": "create_circuit_port_on_net",
        "text": "Create a circuit port on a NET.\nIt groups all pins belonging to the specified net and then applies the port on PinGroups.\nName of the positive component.\nName of the positive net.\nName of the negative component. The default is None, in which case the name of\nthe positive net is assigned.\nName of the negative net name. The default is \"GND\".\nPort impedance value. The default is 50.\nName of the port. The default is \"\".\nThe name of the port.\ncreate_circuit_port_on_net\npython:str\npython:str\npython:str\noptional\nNone\npython:str\noptional\n\"GND\"\npython:float\noptional\n50\npython:str\noptional\n\"\"\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_circuit_port_on_net",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.hfss.EdbHfss.create_circuit_port_on_net.html#pyedb.dotnet.database.hfss.EdbHfss.create_circuit_port_on_net",
        "title": "create_circuit_port_on_net > create_circuit_port_on_net > create_circuit_port_on_net",
        "section": "create_circuit_port_on_net > create_circuit_port_on_net",
        "text": "EdbHfss.create_circuit_port_on_net(positive_component_name, positive_net_name, negative_component_name=None, negative_net_name='GND', impedance_value=50, port_name='')\n\nCreate a circuit port on a NET.\nIt groups all pins belonging to the specified net and then applies the port on PinGroups.\n\nParameters\n\npositive_component_name\n\npython:str\n\nName of the positive component.\n\npositive_net_name\n\npython:str\n\nName of the positive net.\n\nnegative_component_name\n\npython:str, optional\n\nName of the negative component. The default is None, in which case the name of\nthe positive net is assigned.\n\nnegative_net_name\n\npython:str, optional\n\nName of the negative net name. The default is \"GND\".\n\nimpedance_value\n\npython:float, optional\n\nPort impedance value. The default is 50.\n\nport_name\n\npython:str, optional\n\nName of the port. The default is \"\".\n\nReturns\n\npython:str\n\nThe name of the port.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", \"project name\", \"release version\")\n>>> edbapp.hfss.create_circuit_port_on_net(\"U2A5\", \"V1P5_S3\", \"U2A5\", \"GND\", 50, \"port_name\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.edb_exception",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.edb_exception.html#edb_exception",
        "title": "edb_exception",
        "section": "edb_exception",
        "text": "Write the trace stack to AEDT when a Python error occurs.\nedb_exception\npython:None"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.edb_exception",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.edb_exception.html#pyedb.dotnet.edb.Edb.edb_exception",
        "title": "edb_exception > edb_exception > edb_exception",
        "section": "edb_exception > edb_exception",
        "text": "Edb.edb_exception(ex_value, tb_data)\n\nWrite the trace stack to AEDT when a Python error occurs.\n\nParameters\n\nex_value\n\n\n\ntb_data\n\n\n\nReturns\n\npython:None\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.MetalLayer",
        "href": "libraries/_autosummary/pyedb.libraries.common.MetalLayer.html#metallayer",
        "title": "MetalLayer",
        "section": "MetalLayer",
        "text": "Convenience wrapper for metallic layers.\nAutomatically creates a Conductor material.\nActive EDB session.\nLayer name.\nThickness in meters.  Default is 1 µm.\nName of the conductor material.  Default is \"Copper\".\nMetalLayer\nConductor\nansys.edb.core.database.Database\npython:str\npython:float\noptional\npython:str\noptional\n\"Copper\""
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.MetalLayer",
        "href": "libraries/_autosummary/pyedb.libraries.common.MetalLayer.html#pyedb.libraries.common.MetalLayer",
        "title": "MetalLayer > MetalLayer > MetalLayer",
        "section": "MetalLayer > MetalLayer",
        "text": "class pyedb.libraries.common.MetalLayer(pedb, name, thickness=1e-06, material: str = 'Copper')\n\nConvenience wrapper for metallic layers.\n\nAutomatically creates a Conductor material.\n\nParameters\n\npedb\n\nansys.edb.core.database.Database\n\nActive EDB session.\n\nname\n\npython:str\n\nLayer name.\n\nthickness\n\npython:float, optional\n\nThickness in meters.  Default is 1 µm.\n\nmaterial\n\npython:str, optional\n\nName of the conductor material.  Default is \"Copper\".\n\nExamples\n\n>>> top = MetalLayer(edb, \"TOP\", thickness=18e-6, material=\"Gold\")\n>>> top.material.conductivity\n58000000.0\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.Substrate.er",
        "href": "libraries/_autosummary/pyedb.libraries.common.Substrate.er.html#er",
        "title": "er",
        "section": "er",
        "text": "er"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.common.Substrate.er",
        "href": "libraries/_autosummary/pyedb.libraries.common.Substrate.er.html#pyedb.libraries.common.Substrate.er",
        "title": "er > er > er",
        "section": "er > er",
        "text": "Substrate.er: float = 4.4\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/hfss_simulation_setup",
        "href": "dotnet_api/dotnet/utilities/hfss_simulation_setup.html#hfss-simulation-setup",
        "title": "HFSS simulation setup",
        "section": "HFSS simulation setup",
        "text": "These classes are the containers of HFSS simulation setup.\nHfssSimulationSetup\nManages EDB methods for HFSS simulation setup.\nHFSSPISimulationSetup\nManages EDB methods for HFSSPI simulation setup.\nHFSS simulation setup\nHfssSimulationSetup\nHFSSPISimulationSetup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.layout_obj_type.html#pyedb.grpc.database.layout.voltage_regulator.VoltageRegulator.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "VoltageRegulator.layout_obj_type = 13\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.iterate_materials_in_amat",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.iterate_materials_in_amat.html#iterate_materials_in_amat",
        "title": "iterate_materials_in_amat",
        "section": "iterate_materials_in_amat",
        "text": "Iterate over material description in an AMAT file.\nFull path to the AMAT file to read.\niterate_materials_in_amat\npython:str\npython:dict"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.iterate_materials_in_amat",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.iterate_materials_in_amat.html#pyedb.dotnet.database.materials.Materials.iterate_materials_in_amat",
        "title": "iterate_materials_in_amat > iterate_materials_in_amat > iterate_materials_in_amat",
        "section": "iterate_materials_in_amat > iterate_materials_in_amat",
        "text": "Materials.iterate_materials_in_amat(amat_file=None)\n\nIterate over material description in an AMAT file.\n\nParameters\n\namat_file\n\npython:str\n\nFull path to the AMAT file to read.\n\nYields\n\npython:dict\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.find_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.find_primitive.html#find_primitive",
        "title": "find_primitive",
        "section": "find_primitive",
        "text": "Find a primitive objects by layer name.\nParameters\n———-\nlayer_name : str, list\nlayer_name : str, list, optional\nName of the layer.\nName of the primitive\nName of the primitive\nfind_primitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.find_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.find_primitive.html#pyedb.grpc.database.layout.layout.Layout.find_primitive",
        "title": "find_primitive > find_primitive > find_primitive",
        "section": "find_primitive > find_primitive",
        "text": "Layout.find_primitive(layer_name: str | list | None = None, name: str | list | None = None, net_name: str | list | None = None) -> list[any]\n\nFind a primitive objects by layer name.\nParameters\n———-\nlayer_name : str, list\nlayer_name : str, list, optional\n\nName of the layer.\n\nname\n\nstr, list, optional\n\nName of the primitive\n\nnet_name\n\nstr, list, optional\n\nName of the primitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.find_primitive",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.layout.Layout.find_primitive.html#returns",
        "title": "find_primitive > Returns",
        "section": "Returns",
        "text": "List of Primitive.\nReturns\nPrimitive <pyedb.grpc.database.primitive.primitive.Primitive"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_pin_group_terminal",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_pin_group_terminal.html#create_pin_group_terminal",
        "title": "create_pin_group_terminal",
        "section": "create_pin_group_terminal",
        "text": "Create a pin group terminal.\nPadstackInstance or List[:class: ´PadstackInstance´]\nPadstackInstance or List[:class: ´PadstackInstance´]\nTerminal impedance. Default value is 50 Ohms.\nSource type assigned on terminal. Supported values : “circuit_port”, “lumped_port”, “current_source”,\n“voltage_source”, “rlc”, “dc_terminal”. Default value is “circuit_port”.\nSource name.\nsource magnitude.\nphase magnitude.\nResistor value.\nInductor value.\nCapacitor value.\ncreate_pin_group_terminal\npositive\npins\nnegative\npins\npython:float\npython:int\npython:str\npython:str\npython:str\noptional\npython:float\npython:int\npython:str\noptional\npython:float\npython:int\npython:str\noptional\npython:float\noptional\npython:float\noptional\npython:float\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_pin_group_terminal",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_pin_group_terminal.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_pin_group_terminal",
        "title": "create_pin_group_terminal > create_pin_group_terminal > create_pin_group_terminal",
        "section": "create_pin_group_terminal > create_pin_group_terminal",
        "text": "SourceExcitation.create_pin_group_terminal(positive_pins: PadstackInstance | List[PadstackInstance], negatives_pins: PadstackInstance | List[PadstackInstance] | None = None, name: str | None = None, impedance: int | float | str = 50, source_type: str = 'circuit_port', magnitude: float | str = 1.0, phase: float | str = 0, r: float = 0.0, l: float = 0.0, c: float = 0.0) -> str | None\n\nCreate a pin group terminal.\n\nParameters\n\npositive_pins\n\npositive pins used.\n\nclass\n\nPadstackInstance or List[:class: ´PadstackInstance´]\n\nnegatives_pins\n\nnegative pins used.\n\nclass\n\nPadstackInstance or List[:class: ´PadstackInstance´]\n\nimpedance\n\npython:float, python:int or python:str\n\nTerminal impedance. Default value is 50 Ohms.\n\nsource_type\n\npython:str\n\nSource type assigned on terminal. Supported values : “circuit_port”, “lumped_port”, “current_source”,\n“voltage_source”, “rlc”, “dc_terminal”. Default value is “circuit_port”.\n\nname\n\npython:str, optional\n\nSource name.\n\nmagnitude\n\npython:float, python:int or python:str, optional\n\nsource magnitude.\n\nphase\n\npython:float, python:int or python:str, optional\n\nphase magnitude.\n\nr\n\npython:float, optional\n\nResistor value.\n\nl\n\npython:float, optional\n\nInductor value.\n\nc\n\npython:float, optional\n\nCapacitor value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.get_product_property.html#pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "EdgeTerminal.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/LayerData",
        "href": "dotnet_api/dotnet/edb_data/LayerData.html#stackup--layers",
        "title": "Stackup & layers",
        "section": "Stackup & layers",
        "text": "These classes are the containers of the layer and stackup manager of the EDB API.\nLayerEdbClass\nManages Edb Layers.\nStackup & layers\nLayerEdbClass"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_dump_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#json-mode)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent: Indentation to use in the JSON output. If None is passed, the output will be compact.\nensure_ascii: If True, the output is guaranteed to have all incoming non-ASCII characters escaped.\nIf False (the default), these characters will be output as-is.\ninclude: Field(s) to include in the JSON output.\nexclude: Field(s) to exclude from the JSON output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to serialize using field aliases.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\nA JSON string representation of the model.\nmodel_dump_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_dump_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.model_dump_json.html#pyedb.workflows.drc.drc.Rules.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "Rules.model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -> str\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#json-mode)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nArgs:\n\nindent: Indentation to use in the JSON output. If None is passed, the output will be compact.\nensure_ascii: If True, the output is guaranteed to have all incoming non-ASCII characters escaped.\n\nIf False (the default), these characters will be output as-is.\n\ninclude: Field(s) to include in the JSON output.\nexclude: Field(s) to exclude from the JSON output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to serialize using field aliases.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\n\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\n\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback: A function to call when an unknown value is encountered. If not provided,\n\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileComponent.add_port",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileComponent.add_port.html#add_port",
        "title": "add_port",
        "section": "add_port",
        "text": "add_port"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileComponent.add_port",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.control_file.ControlFileComponent.add_port.html#pyedb.dotnet.database.edb_data.control_file.ControlFileComponent.add_port",
        "title": "add_port > add_port > add_port",
        "section": "add_port > add_port",
        "text": "ControlFileComponent.add_port(name, z0, pospin, refpin=None, pos_type='pin', ref_type='pin')\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.net1",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.net1.html#net1",
        "title": "net1",
        "section": "net1",
        "text": "net1"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.net1",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.net1.html#pyedb.workflows.drc.drc.MinClearance.net1",
        "title": "net1 > net1 > net1",
        "section": "net1 > net1",
        "text": "MinClearance.net1: str\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.is_power_gound_net",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.is_power_gound_net.html#is_power_gound_net",
        "title": "is_power_gound_net",
        "section": "is_power_gound_net",
        "text": "Determine if one of the  nets in a list is power or ground.\nList of net names.\nTrue when one of the net names is \"power\" or \"ground\", False otherwise.\nis_power_gound_net\npython:list\nTrue\n\"power\"\n\"ground\"\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.is_power_gound_net",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.is_power_gound_net.html#pyedb.dotnet.database.nets.EdbNets.is_power_gound_net",
        "title": "is_power_gound_net > is_power_gound_net > is_power_gound_net",
        "section": "is_power_gound_net > is_power_gound_net",
        "text": "EdbNets.is_power_gound_net(netname_list)\n\nDetermine if one of the  nets in a list is power or ground.\n\nParameters\n\nnetname_list\n\npython:list\n\nList of net names.\n\nReturns\n\nbool\n\nTrue when one of the net names is \"power\" or \"ground\", False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_conductor_material",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_conductor_material.html#add_conductor_material",
        "title": "add_conductor_material",
        "section": "add_conductor_material",
        "text": "Add a new conductor material.\nName of the new material.\nConductivity of the new material.\nadd_conductor_material\npython:str\npython:str\npython:float\npython:int\noptional\npyedb.dotnet.database.materials.Material"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_conductor_material",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_conductor_material.html#pyedb.dotnet.database.materials.Materials.add_conductor_material",
        "title": "add_conductor_material > add_conductor_material > add_conductor_material",
        "section": "add_conductor_material > add_conductor_material",
        "text": "Materials.add_conductor_material(name, conductivity=58000000, **kwargs)\n\nAdd a new conductor material.\n\nParameters\n\nname\n\npython:str\n\nName of the new material.\n\nconductivity\n\npython:str, python:float, python:int, optional\n\nConductivity of the new material.\n\nReturns\n\npyedb.dotnet.database.materials.Material\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.remove_zone",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.remove_zone.html#remove_zone",
        "title": "remove_zone",
        "section": "remove_zone",
        "text": "Remove a zone.\nID of the zone.\nremove_zone\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.remove_zone",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.remove_zone.html#pyedb.grpc.database.stackup.LayerCollection.remove_zone",
        "title": "remove_zone > remove_zone > remove_zone",
        "section": "remove_zone > remove_zone",
        "text": "LayerCollection.remove_zone(zone)\n\nRemove a zone.\n\nParameters\n\nzone\n\npython:int\n\nID of the zone.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.move",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.move.html#move",
        "title": "move",
        "section": "move",
        "text": "Move the polygon by a vector.\nVector in the form: (x, y).\nmove\n(x, y)\nPolygonData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.move",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.move.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.move",
        "title": "move > move > move",
        "section": "move > move",
        "text": "PolygonData.move(vector: PointLike) -> PolygonData\n\nMove the polygon by a vector.\n\nParameters\n\nvector\n\nPoint2DLike\n\nVector in the form: (x, y).\n\nReturns\n\nPolygonData\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.set_product_property",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layer collection for a given product ID and attribute ID.\nProduct ID.\nAttribute ID.\nNew property value.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.set_product_property",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.LayerCollection.set_product_property.html#pyedb.grpc.database.stackup.LayerCollection.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "LayerCollection.set_product_property(prod_id, attr_it, prop_value)\n\nSet the product property of the layer collection for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nProduct ID.\n\nattr_it\n\npython:int\n\nAttribute ID.\n\nprop_value\n\npython:str\n\nNew property value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.place_instance",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.place_instance.html#place_instance",
        "title": "place_instance",
        "section": "place_instance",
        "text": "Place a component instance in the layout using 3D placement.\nComponent Edb object to place.\nRotation angle in degrees. The default is 0.0.\nX offset value. The default is 0.0.\nY offset value. The default is 0.0.\nZ offset value (elevation offset). The default is 0.0.\nWhether to flip the component stackup. The default is True.\nWhether to place the component on top of the target layout. The default is True.\nSolder ball or bumps height. The default is 0.\nCell instance created.\nplace_instance\npyedb.Edb\npython:float\noptional\n0.0\npython:float\noptional\n0.0\npython:float\noptional\n0.0\npython:float\noptional\n0.0\noptional\nTrue\noptional\nTrue\npython:float\noptional\n0\nansys.edb.core.hierarchy.CellInstance"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.place_instance",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.place_instance.html#pyedb.grpc.database.stackup.Stackup.place_instance",
        "title": "place_instance > place_instance > place_instance",
        "section": "place_instance > place_instance",
        "text": "Stackup.place_instance(component_edb: Edb, angle: float = 0.0, offset_x: float = 0.0, offset_y: float = 0.0, offset_z: float = 0.0, flipped_stackup: bool = True, place_on_top: bool = True, solder_height: float = 0) -> CellInstance\n\nPlace a component instance in the layout using 3D placement.\n\nParameters\n\ncomponent_edb\n\npyedb.Edb\n\nComponent Edb object to place.\n\nangle\n\npython:float, optional\n\nRotation angle in degrees. The default is 0.0.\n\noffset_x\n\npython:float, optional\n\nX offset value. The default is 0.0.\n\noffset_y\n\npython:float, optional\n\nY offset value. The default is 0.0.\n\noffset_z\n\npython:float, optional\n\nZ offset value (elevation offset). The default is 0.0.\n\nflipped_stackup\n\nbool, optional\n\nWhether to flip the component stackup. The default is True.\n\nplace_on_top\n\nbool, optional\n\nWhether to place the component on top of the target layout. The default is True.\n\nsolder_height\n\npython:float, optional\n\nSolder ball or bumps height. The default is 0.\n\nReturns\n\nansys.edb.core.hierarchy.CellInstance\n\nCell instance created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_back_drill_stub_length",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_back_drill_stub_length.html#add_back_drill_stub_length",
        "title": "add_back_drill_stub_length",
        "section": "add_back_drill_stub_length",
        "text": "Append a maximum-allowed back-drill stub-length rule.\nRule identifier.\nMaximum allowed stub length with unit, e.g. \"6mil\".\nSelf to enable method chaining.\nadd_back_drill_stub_length\npython:str\npython:str\n\"6mil\"\nRules"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_back_drill_stub_length",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_back_drill_stub_length.html#pyedb.workflows.drc.drc.Rules.add_back_drill_stub_length",
        "title": "add_back_drill_stub_length > add_back_drill_stub_length > add_back_drill_stub_length",
        "section": "add_back_drill_stub_length > add_back_drill_stub_length",
        "text": "Rules.add_back_drill_stub_length(name: str, value: str) -> Rules\n\nAppend a maximum-allowed back-drill stub-length rule.\n\nParameters\n\nname\n\npython:str\n\nRule identifier.\n\nvalue\n\npython:str\n\nMaximum allowed stub length with unit, e.g. \"6mil\".\n\nReturns\n\nRules\n\nSelf to enable method chaining.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.set_solution_multi_frequencies",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.set_solution_multi_frequencies.html#set_solution_multi_frequencies",
        "title": "set_solution_multi_frequencies",
        "section": "set_solution_multi_frequencies",
        "text": "Set HFSS setup multi frequencies adaptive.\nAdaptive frequencies.\nMax delta S values.\nset_solution_multi_frequencies\npython:str\nList\npython:str\npython:float\nList\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.set_solution_multi_frequencies",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.set_solution_multi_frequencies.html#pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.set_solution_multi_frequencies",
        "title": "set_solution_multi_frequencies > set_solution_multi_frequencies > set_solution_multi_frequencies",
        "section": "set_solution_multi_frequencies > set_solution_multi_frequencies",
        "text": "HfssSimulationSetup.set_solution_multi_frequencies(frequencies='5GHz', max_delta_s=0.02) -> bool\n\nSet HFSS setup multi frequencies adaptive.\n\nParameters\n\nfrequencies\n\npython:str, List[python:str].\n\nAdaptive frequencies.\n\nmax_delta_s\n\npython:float, List[python:float].\n\nMax delta S values.\n\nReturns\n\nbool.\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.sqrt",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.sqrt.html#sqrt",
        "title": "sqrt",
        "section": "sqrt",
        "text": "Square root of the value.\nsqrt"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.sqrt",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.sqrt.html#pyedb.grpc.database.utility.value.Value.sqrt",
        "title": "sqrt > sqrt > sqrt",
        "section": "sqrt > sqrt",
        "text": "Value.sqrt()\n\nSquare root of the value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/Utilities",
        "href": "dotnet_api/dotnet/edb_data/Utilities.html#edb-utilities",
        "title": "EDB utilities",
        "section": "EDB utilities",
        "text": "Class managing EDB utilities.\nEDBStatistics\nStatistics object\nEDB utilities\nEDBStatistics"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_dump_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#json-mode)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent: Indentation to use in the JSON output. If None is passed, the output will be compact.\nensure_ascii: If True, the output is guaranteed to have all incoming non-ASCII characters escaped.\nIf False (the default), these characters will be output as-is.\ninclude: Field(s) to include in the JSON output.\nexclude: Field(s) to exclude from the JSON output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to serialize using field aliases.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\nA JSON string representation of the model.\nmodel_dump_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_dump_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.BackDrillStubLength.model_dump_json.html#pyedb.workflows.drc.drc.BackDrillStubLength.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "BackDrillStubLength.model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: set[int] | set[str] | Mapping[int, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, set[int] | set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -> str\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#json-mode)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nArgs:\n\nindent: Indentation to use in the JSON output. If None is passed, the output will be compact.\nensure_ascii: If True, the output is guaranteed to have all incoming non-ASCII characters escaped.\n\nIf False (the default), these characters will be output as-is.\n\ninclude: Field(s) to include in the JSON output.\nexclude: Field(s) to exclude from the JSON output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to serialize using field aliases.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of None.\nexclude_computed_fields: Whether to exclude computed fields.\n\nWhile this can be useful for round-tripping, it is usually recommended to use the dedicated\nround_trip parameter instead.\n\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback: A function to call when an unknown value is encountered. If not provided,\n\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.html#net",
        "title": "Net",
        "section": "Net",
        "text": "Manages EDB functionalities for net objects and their primitives.\nInherits properties from EDB objects and provides additional functionality\nspecific to nets.\nMain EDB object.\nRaw net object from gRPC.\nNet.create(layout, name)\nCreate a net.\nNet.delete()\nDelete the layout object.\nNet.find_by_name(layout, name)\nFind a net by name in a given layout.\nNet.find_dc_short([fix])\nFind DC-shorted nets connected to this net.\nNet.get_product_property(prod_id, attr_id)\nGet the product property of the layout object for a given product ID and attribute ID.\nNet.get_product_property_ids(prod_id)\nGet a list of attribute IDs given a product ID for the layout object.\nNet.get_smallest_trace_width()\nGet the minimum trace width from path primitives in this net.\nNet.plot([layers, show_legend, save_plot, ...])\nPlot the net using Matplotlib.\nNet.set_product_property(prod_id, attr_id, ...)\nSet the product property of the layout object for a given product ID and attribute ID.\nNet.layout_obj_type\n\nNet.no_net_name\n\nNet\npyedb.Edb\nNet.create\nNet.delete\nNet.find_by_name\nNet.find_dc_short\nNet.get_product_property\nNet.get_product_property_ids\nNet.get_smallest_trace_width\nNet.plot\nNet.set_product_property\nNet.layout_obj_type\nNet.no_net_name"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.html#pyedb.grpc.database.net.net.Net",
        "title": "Net > Net > Net",
        "section": "Net > Net",
        "text": "class pyedb.grpc.database.net.net.Net(pedb, raw_net)\n\nManages EDB functionalities for net objects and their primitives.\n\nInherits properties from EDB objects and provides additional functionality\nspecific to nets.\n\nParameters\n\npedb\n\npyedb.Edb\n\nMain EDB object.\n\nraw_net\n\nRaw net object from gRPC.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb(myedb, edbversion=\"2021.2\")\n>>> edb_net = edb.nets[\"GND\"]\n>>> edb_net.name\n'GND'\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nNet.create(layout, name)\n\nCreate a net.\n\nNet.delete()\n\nDelete the layout object.\n\nNet.find_by_name(layout, name)\n\nFind a net by name in a given layout.\n\nNet.find_dc_short([fix])\n\nFind DC-shorted nets connected to this net.\n\nNet.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nNet.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs given a product ID for the layout object.\n\nNet.get_smallest_trace_width()\n\nGet the minimum trace width from path primitives in this net.\n\nNet.plot([layers, show_legend, save_plot, ...])\n\nPlot the net using Matplotlib.\n\nNet.set_product_property(prod_id, attr_id, ...)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\n\n\nAttributes\n\n\n\n\n\n\n\nNet.layout_obj_type\n\n\n\nNet.no_net_name\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.set_product_property.html#pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "PadstackInstanceTerminal.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.get_simulation_settings",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.get_simulation_settings.html#get_simulation_settings",
        "title": "get_simulation_settings",
        "section": "get_simulation_settings",
        "text": "get_simulation_settings"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.get_simulation_settings",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.get_simulation_settings.html#pyedb.dotnet.database.utilities.simulation_setup.SimulationSetup.get_simulation_settings",
        "title": "get_simulation_settings > get_simulation_settings > get_simulation_settings",
        "section": "get_simulation_settings > get_simulation_settings",
        "text": "SimulationSetup.get_simulation_settings()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_computed_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_computed_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPairLengthMatch.model_computed_fields.html#pyedb.workflows.drc.drc.DiffPairLengthMatch.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "DiffPairLengthMatch.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_material",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_material.html#set_material",
        "title": "set_material",
        "section": "set_material",
        "text": "Set the name of the material of the layer.\nNew name of the material.\nset_material\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_material",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_material.html#pyedb.grpc.database.layers.stackup_layer.StackupLayer.set_material",
        "title": "set_material > set_material > set_material",
        "section": "set_material > set_material",
        "text": "StackupLayer.set_material(material_name)\n\nSet the name of the material of the layer.\n\nParameters\n\nmaterial_name\n\npython:str\n\nNew name of the material.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.type.html#type",
        "title": "type",
        "section": "type",
        "text": "type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.type.html#pyedb.grpc.database.terminal.padstack_instance_terminal.PadstackInstanceTerminal.type",
        "title": "type > type > type",
        "section": "type > type",
        "text": "PadstackInstanceTerminal.type = 3\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_closest_point",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_closest_point.html#get_closest_point",
        "title": "get_closest_point",
        "section": "get_closest_point",
        "text": "Get the closest point of the primitive to the input data.\n[x, y].\nget_closest_point\npython:list\nof\npython:float\nPointData\nList\npython:float\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_closest_point",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.rectangle.Rectangle.get_closest_point.html#pyedb.grpc.database.primitive.rectangle.Rectangle.get_closest_point",
        "title": "get_closest_point > get_closest_point > get_closest_point",
        "section": "get_closest_point > get_closest_point",
        "text": "Rectangle.get_closest_point(point) -> list[float]\n\nGet the closest point of the primitive to the input data.\n\nParameters\n\npoint\n\npython:list of python:float or PointData\n\n\n\nReturns\n\nList[python:float, python:float]\n\n[x, y].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.product_solver_option.html#product_solver_option",
        "title": "product_solver_option",
        "section": "product_solver_option",
        "text": "Get the name of the product solver option.\nID of the product.\nName of the solver.\nName of the product solver option.\nproduct_solver_option\nProductIdType\nstr\nstr"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.product_solver_option.html#pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.product_solver_option",
        "title": "product_solver_option > product_solver_option > product_solver_option",
        "section": "product_solver_option > product_solver_option",
        "text": "EdgeTerminal.product_solver_option(product_id, solver_name)\n\nGet the name of the product solver option.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nsolver_name\n\nstr\n\nName of the solver.\n\nReturns\n\nstr\n\nName of the product solver option.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.dc_permittivity",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.dc_permittivity.html#dc_permittivity",
        "title": "dc_permittivity",
        "section": "dc_permittivity",
        "text": "dc_permittivity"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.dc_permittivity",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.dc_permittivity.html#pyedb.grpc.database.definition.materials.MaterialProperties.dc_permittivity",
        "title": "dc_permittivity > dc_permittivity > dc_permittivity",
        "section": "dc_permittivity > dc_permittivity",
        "text": "MaterialProperties.dc_permittivity: Annotated[float, Gt(gt=0)] | None\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_polygon",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_polygon.html#create_polygon",
        "title": "create_polygon",
        "section": "create_polygon",
        "text": "Create polygon primitive.\nPolygon points or PolygonData object.\nLayer name.\nList of void shapes or points.\nAssociated net name.\nPolygon object if created, False otherwise.\ncreate_polygon\npython:list\nansys.edb.core.geometry.polygon_data.PolygonData\npython:str\npython:list\noptional\npython:str\noptional\npyedb.dotnet.database.edb_data.primitives_data.Polygon"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_polygon",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.modeler.Modeler.create_polygon.html#pyedb.grpc.database.modeler.Modeler.create_polygon",
        "title": "create_polygon > create_polygon > create_polygon",
        "section": "create_polygon > create_polygon",
        "text": "Modeler.create_polygon(points: List[List[float]] | PolygonData, layer_name: str, voids: List[Any] | None = [], net_name: str = '') -> Primitive | None\n\nCreate polygon primitive.\n\nParameters\n\npoints\n\npython:list or ansys.edb.core.geometry.polygon_data.PolygonData\n\nPolygon points or PolygonData object.\n\nlayer_name\n\npython:str\n\nLayer name.\n\nvoids\n\npython:list, optional\n\nList of void shapes or points.\n\nnet_name\n\npython:str, optional\n\nAssociated net name.\n\nReturns\n\npyedb.dotnet.database.edb_data.primitives_data.Polygon or bool\n\nPolygon object if created, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.DifferentialTLine.List",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.DifferentialTLine.List.html#list",
        "title": "List",
        "section": "List",
        "text": "alias of List\nalias of List\n.. autoattribute:: DifferentialTLine.List\nList\nList\nList"
    },
    {
        "objectID": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.DifferentialTLine.List",
        "href": "libraries/_autosummary/pyedb.libraries.rf_libraries.base_functions.DifferentialTLine.List.html#pyedb.libraries.rf_libraries.base_functions.DifferentialTLine.List",
        "title": "List > List > List",
        "section": "List > List",
        "text": "DifferentialTLine.List\n\nalias of List"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.parse_obj",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "parse_obj"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.parse_obj",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.parse_obj.html#pyedb.workflows.drc.drc.MinAnnularRing.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod MinAnnularRing.parse_obj(obj: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.add_void",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.add_void.html#add_void",
        "title": "add_void",
        "section": "add_void",
        "text": "Add a void to current primitive.\nTrue if successful, either  False.\nadd_void\npython:list\nPrimitive\npoint\npython:list\nin\nthe\nformat\nof\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.add_void",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.primitive.Primitive.add_void.html#pyedb.grpc.database.primitive.primitive.Primitive.add_void",
        "title": "add_void > add_void > add_void",
        "section": "add_void > add_void",
        "text": "Primitive.add_void(point_list) -> bool\n\nAdd a void to current primitive.\n\nParameters\n\npoint_list\n\npython:list or Primitive             or point python:list in the format of [[x1,y1], [x2,y2],..,[xn,yn]].\n\n\n\nReturns\n\nbool\n\nTrue if successful, either  False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_min_annular_ring",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_min_annular_ring.html#add_min_annular_ring",
        "title": "add_min_annular_ring",
        "section": "add_min_annular_ring",
        "text": "Append a minimum-annular-ring rule for drilled holes.\nRule identifier.\nMinimum annular ring with unit, e.g. \"2mil\".\nSelf to enable method chaining.\nadd_min_annular_ring\npython:str\npython:str\n\"2mil\"\nRules"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_min_annular_ring",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.add_min_annular_ring.html#pyedb.workflows.drc.drc.Rules.add_min_annular_ring",
        "title": "add_min_annular_ring > add_min_annular_ring > add_min_annular_ring",
        "section": "add_min_annular_ring > add_min_annular_ring",
        "text": "Rules.add_min_annular_ring(name: str, value: str) -> Rules\n\nAppend a minimum-annular-ring rule for drilled holes.\n\nParameters\n\nname\n\npython:str\n\nRule identifier.\n\nvalue\n\npython:str\n\nMinimum annular ring with unit, e.g. \"2mil\".\n\nReturns\n\nRules\n\nSelf to enable method chaining.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.export_definition",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.export_definition.html#export_definition",
        "title": "export_definition",
        "section": "export_definition",
        "text": "Export component definitions to a JSON file.\nPath to the output JSON file.\nTrue if successful, False otherwise.\nexport_definition\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.export_definition",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.export_definition.html#pyedb.grpc.database.components.Components.export_definition",
        "title": "export_definition > export_definition > export_definition",
        "section": "export_definition > export_definition",
        "text": "Components.export_definition(file_path) -> bool\n\nExport component definitions to a JSON file.\n\nParameters\n\nfile_path\n\npython:str\n\nPath to the output JSON file.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\nExamples\n\n>>> edbapp.components.export_definition(\"exported_definitions.json\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_simulation_setup.SiwaveSimulationSetup",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_simulation_setup.SiwaveSimulationSetup.html#siwavesimulationsetup",
        "title": "SiwaveSimulationSetup",
        "section": "SiwaveSimulationSetup",
        "text": "SIwave simulation setup class.\nSiwaveSimulationSetup.add_sweep([name, ...])\nAdd a HFSS frequency sweep.\nSiwaveSimulationSetup.cast()\nCast the base SimulationSetup object to correct subclass, if possible.\nSiwaveSimulationSetup.create(cell, name)\nCreate a SIWave simulationsetup.\nSiwaveSimulationSetup\nSiwaveSimulationSetup.add_sweep\nSiwaveSimulationSetup.cast\nSiwaveSimulationSetup.create"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_simulation_setup.SiwaveSimulationSetup",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.siwave_simulation_setup.SiwaveSimulationSetup.html#pyedb.grpc.database.simulation_setup.siwave_simulation_setup.SiwaveSimulationSetup",
        "title": "SiwaveSimulationSetup > SiwaveSimulationSetup > SiwaveSimulationSetup",
        "section": "SiwaveSimulationSetup > SiwaveSimulationSetup",
        "text": "class pyedb.grpc.database.simulation_setup.siwave_simulation_setup.SiwaveSimulationSetup(pedb, edb_object=None)\n\nSIwave simulation setup class.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nSiwaveSimulationSetup.add_sweep([name, ...])\n\nAdd a HFSS frequency sweep.\n\nSiwaveSimulationSetup.cast()\n\nCast the base SimulationSetup object to correct subclass, if possible.\n\nSiwaveSimulationSetup.create(cell, name)\n\nCreate a SIWave simulationsetup.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.render",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.render.html#render",
        "title": "render",
        "section": "render",
        "text": "Render a circle.\nX value of the center point.\nY value of the center point.\nRadius value of the circle.\nWhether the circle object is a hole.\nCircle created.\nrender\nPolygonData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.render",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.render.html#pyedb.grpc.database.primitive.circle.Circle.render",
        "title": "render > render > render",
        "section": "render > render",
        "text": "classmethod Circle.render(center_x: ValueLike, center_y: ValueLike, radius: ValueLike, is_hole: bool) -> PolygonData\n\nRender a circle.\n\nParameters\n\ncenter_x\n\nValueLike\n\nX value of the center point.\n\ncenter_y\n\nValueLike\n\nY value of the center point.\n\nradius\n\nValueLike\n\nRadius value of the circle.\n\nis_hole\n\nbool\n\nWhether the circle object is a hole.\n\nReturns\n\nPolygonData\n\nCircle created.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_validate_strings",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj: The object containing string data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\nThe validated Pydantic model.\nmodel_validate_strings"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_validate_strings",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.model_validate_strings.html#pyedb.workflows.drc.drc.MinClearance.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod MinClearance.model_validate_strings(obj: Any, *, strict: bool | None = None, extra: Literal['allow', 'ignore', 'forbid'] | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -> Self\n\nValidate the given object with string data against the Pydantic model.\n\nArgs:\n\nobj: The object containing string data to validate.\nstrict: Whether to enforce types strictly.\nextra: Whether to ignore, allow, or forbid extra data during model validation.\n\nSee the [extra configuration value][pydantic.ConfigDict.extra] for details.\n\ncontext: Extra variables to pass to the validator.\nby_alias: Whether to use the field’s alias when validating against the provided input data.\nby_name: Whether to use the field’s name when validating against the provided input data.\n\nReturns:\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_probe_on_pin_group",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_probe_on_pin_group.html#create_voltage_probe_on_pin_group",
        "title": "create_voltage_probe_on_pin_group",
        "section": "create_voltage_probe_on_pin_group",
        "text": "Create voltage probe between two pin groups.\nName of the probe.\nName of the positive pin group.\nName of the negative pin group.\nPhase of the source.\ncreate_voltage_probe_on_pin_group\npython:str\npython:str\npython:str\npython:int\npython:float\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_probe_on_pin_group",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_probe_on_pin_group.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_voltage_probe_on_pin_group",
        "title": "create_voltage_probe_on_pin_group > create_voltage_probe_on_pin_group > create_voltage_probe_on_pin_group",
        "section": "create_voltage_probe_on_pin_group > create_voltage_probe_on_pin_group",
        "text": "SourceExcitation.create_voltage_probe_on_pin_group(probe_name: str, pos_pin_group_name: str, neg_pin_group_name: str, impedance: int | float = 1000000) -> bool\n\nCreate voltage probe between two pin groups.\n\nParameters\n\nprobe_name\n\npython:str\n\nName of the probe.\n\npos_pin_group_name\n\npython:str\n\nName of the positive pin group.\n\nneg_pin_group_name\n\npython:str\n\nName of the negative pin group.\n\nimpedance\n\npython:int, python:float, optional\n\nPhase of the source.\n\nReturns\n\nbool\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.intersect",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.intersect.html#intersect",
        "title": "intersect",
        "section": "intersect",
        "text": "Intersect active primitive with one or more primitives.\nList of Primitive objects.\nintersect\nList\nPrimitive"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.intersect",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.path.Path.intersect.html#pyedb.grpc.database.primitive.path.Path.intersect",
        "title": "intersect > intersect > intersect",
        "section": "intersect > intersect",
        "text": "Path.intersect(primitives) -> list[any]\n\nIntersect active primitive with one or more primitives.\n\nParameters\n\nprimitives :class:`Primitives <pyedb.grpc.database.primitive.primitive.Primitive>`\n\n\n\nor: List[:class:`Primitives <pyedb.grpc.database.primitive.primitive.Primitive>`]\n\n\n\nor: class:`PolygonData <ansys.edb.core.geometry.polygon_data.PolygonData>`\n\n\n\nReturns\n\nList[Primitive]\n\nList of Primitive objects.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.html#edbpadstack",
        "title": "EDBPadstack",
        "section": "EDBPadstack",
        "text": "Manages EDB functionalities for a padstack.\nInherited AEDT object.\nEDBPadstack.convert_to_3d_microvias([...])\nConvert actual padstack instance to microvias 3D Objects with a given aspect ratio.\nEDBPadstack.split_to_microvias()\nConvert actual padstack definition to multiple microvias definitions.\nEDBPadstack\npython:str\nEDBPadstack.convert_to_3d_microvias\nEDBPadstack.split_to_microvias"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack",
        "title": "EDBPadstack > EDBPadstack > EDBPadstack",
        "section": "EDBPadstack > EDBPadstack",
        "text": "class pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstack(edb_padstack, ppadstack)\n\nManages EDB functionalities for a padstack.\n\nParameters\n\nedb_padstack\n\n\n\nppadstack\n\npython:str\n\nInherited AEDT object.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb(myedb, edbversion=\"2021.2\")\n>>> edb_padstack = edb.padstacks.definitions[\"MyPad\"]\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nEDBPadstack.convert_to_3d_microvias([...])\n\nConvert actual padstack instance to microvias 3D Objects with a given aspect ratio.\n\nEDBPadstack.split_to_microvias()\n\nConvert actual padstack definition to multiple microvias definitions.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.get_all_variable_names",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.get_all_variable_names.html#get_all_variable_names",
        "title": "get_all_variable_names",
        "section": "get_all_variable_names",
        "text": "Get all variable names.\nNames of all variables.\nget_all_variable_names\npython:list\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.get_all_variable_names",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.get_all_variable_names.html#pyedb.grpc.database.layout.cell.Cell.get_all_variable_names",
        "title": "get_all_variable_names > get_all_variable_names > get_all_variable_names",
        "section": "get_all_variable_names > get_all_variable_names",
        "text": "Cell.get_all_variable_names()\n\nGet all variable names.\n\nReturns\n\npython:list[python:str]\n\nNames of all variables.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_material",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_material.html#add_material",
        "title": "add_material",
        "section": "add_material",
        "text": "Add a new material.\nMaterial name.\nadd_material\npython:str\npyedb.dotnet.database.materials.Material"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_material",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.materials.Materials.add_material.html#pyedb.dotnet.database.materials.Materials.add_material",
        "title": "add_material > add_material > add_material",
        "section": "add_material > add_material",
        "text": "Materials.add_material(name: str, **kwargs)\n\nAdd a new material.\n\nParameters\n\nname\n\npython:str\n\nMaterial name.\n\nReturns\n\npyedb.dotnet.database.materials.Material\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.are_port_reference_terminals_connected",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.are_port_reference_terminals_connected.html#are_port_reference_terminals_connected",
        "title": "are_port_reference_terminals_connected",
        "section": "are_port_reference_terminals_connected",
        "text": "Check if all terminal references in design are connected.\nIf the reference nets are different, there is no hope for the terminal references to be connected.\nAfter we have identified a common reference net we need to loop the terminals again to get\nthe correct reference terminals that uses that net.\nCommon Reference name. If None it will be searched in ports terminal.\nIf a string is passed then all excitations must have such reference assigned.\nEither if the ports are connected to reference_name or not.\nare_port_reference_terminals_connected\npython:str\noptional\nNone"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.are_port_reference_terminals_connected",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.are_port_reference_terminals_connected.html#pyedb.dotnet.edb.Edb.are_port_reference_terminals_connected",
        "title": "are_port_reference_terminals_connected > are_port_reference_terminals_connected > are_port_reference_terminals_connected",
        "section": "are_port_reference_terminals_connected > are_port_reference_terminals_connected",
        "text": "Edb.are_port_reference_terminals_connected(common_reference=None)\n\nCheck if all terminal references in design are connected.\nIf the reference nets are different, there is no hope for the terminal references to be connected.\nAfter we have identified a common reference net we need to loop the terminals again to get\nthe correct reference terminals that uses that net.\n\nParameters\n\ncommon_reference\n\npython:str, optional\n\nCommon Reference name. If None it will be searched in ports terminal.\nIf a string is passed then all excitations must have such reference assigned.\n\nReturns\n\nbool\n\nEither if the ports are connected to reference_name or not.\n\nExamples\n\n>>> from pyedb import Edb\n>>>edb = Edb()\n>>> edb.hfss.create_edge_port_vertical(prim_1_id, [\"-66mm\", \"-4mm\"], \"port_ver\")\n>>> edb.hfss.create_edge_port_horizontal(\n>>> ... prim_1_id, [\"-60mm\", \"-4mm\"], prim_2_id, [\"-59mm\", \"-4mm\"], \"port_hori\", 30, \"Lower\"\n>>> ... )\n>>> edb.hfss.create_wave_port(traces[0].id, trace_paths[0][0], \"wave_port\")\n>>> edb.cutout([\"Net1\"])\n>>> assert edb.are_port_reference_terminals_connected()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layer for a given product ID and attribute ID.\nProduct ID.\nAttribute ID.\nProduct property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_product_property.html#pyedb.grpc.database.layers.stackup_layer.StackupLayer.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "StackupLayer.get_product_property(prod_id, attr_it)\n\nGet the product property of the layer for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nProduct ID.\n\nattr_it\n\npython:int\n\nAttribute ID.\n\nReturns\n\npython:str\n\nProduct property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_conductor_material",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_conductor_material.html#add_conductor_material",
        "title": "add_conductor_material",
        "section": "add_conductor_material",
        "text": "Add a new conductor material.\nName of the new material.\nConductivity of the new material.\nMaterial object.\nadd_conductor_material\npython:str\npython:str\npython:float\npython:int\nMaterial"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_conductor_material",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Materials.add_conductor_material.html#pyedb.grpc.database.definition.materials.Materials.add_conductor_material",
        "title": "add_conductor_material > add_conductor_material > add_conductor_material",
        "section": "add_conductor_material > add_conductor_material",
        "text": "Materials.add_conductor_material(name, conductivity, **kwargs) -> Material\n\nAdd a new conductor material.\n\nParameters\n\nname\n\npython:str\n\nName of the new material.\n\nconductivity\n\npython:str, python:float, python:int\n\nConductivity of the new material.\n\nReturns\n\nMaterial\n\nMaterial object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.save_as",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.save_as.html#save_as",
        "title": "save_as",
        "section": "save_as",
        "text": "Save this Database to a new location and older EDB version.\nNew Database file location.\nEDB version to save to. Empty string means current version.\nsave_as\npython:str\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.save_as",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.save_as.html#pyedb.grpc.edb.Edb.save_as",
        "title": "save_as > save_as > save_as",
        "section": "save_as > save_as",
        "text": "Edb.save_as(path, version='')\n\nSave this Database to a new location and older EDB version.\n\nParameters\n\npath\n\npython:str\n\nNew Database file location.\n\nversion\n\npython:str\n\nEDB version to save to. Empty string means current version.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_resistor_on_pin",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_resistor_on_pin.html#create_resistor_on_pin",
        "title": "create_resistor_on_pin",
        "section": "create_resistor_on_pin",
        "text": "Create a Resistor boundary between two given pins..\nPositive Pin.\nNegative Pin.\nResistance value. The default is 1.\nName of the resistor. The default is \"\".\nName of the resistor.\ncreate_resistor_on_pin\nObject\nObject\npython:float\noptional\n1\npython:str\noptional\n\"\"\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_resistor_on_pin",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.source_excitations.SourceExcitation.create_resistor_on_pin.html#pyedb.grpc.database.source_excitations.SourceExcitation.create_resistor_on_pin",
        "title": "create_resistor_on_pin > create_resistor_on_pin > create_resistor_on_pin",
        "section": "create_resistor_on_pin > create_resistor_on_pin",
        "text": "SourceExcitation.create_resistor_on_pin(pos_pin: str | PadstackInstance, neg_pin: str | PadstackInstance, rvalue: int | float = 1, resistor_name: str | None = '') -> str | None\n\nCreate a Resistor boundary between two given pins..\n\nParameters\n\npos_pin\n\nObject\n\nPositive Pin.\n\nneg_pin\n\nObject\n\nNegative Pin.\n\nrvalue\n\npython:float, optional\n\nResistance value. The default is 1.\n\nresistor_name\n\npython:str, optional\n\nName of the resistor. The default is \"\".\n\nReturns\n\npython:str\n\nName of the resistor.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb()\n>>> pin1 = edb.components[\"U1\"].pins[\"R1_p\"]\n>>> pin2 = edb.components[\"U1\"].pins[\"R1_n\"]\n>>> edb.source_excitation.create_resistor_on_pin(pin1, pin2, 50, \"R1\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.get_product_property_ids.html#get_product_property_ids",
        "title": "get_product_property_ids",
        "section": "get_product_property_ids",
        "text": "Get the list of property IDs for a given property ID.\nProduct ID.\nAttribute IDs for the given product ID.\nget_product_property_ids\nProductIdType\npython:list\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.get_product_property_ids",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.component_def.ComponentDef.get_product_property_ids.html#pyedb.grpc.database.definition.component_def.ComponentDef.get_product_property_ids",
        "title": "get_product_property_ids > get_product_property_ids > get_product_property_ids",
        "section": "get_product_property_ids > get_product_property_ids",
        "text": "ComponentDef.get_product_property_ids(prod_id: ProductIdType) -> List[int]\n\nGet the list of property IDs for a given property ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nProduct ID.\n\nReturns\n\npython:list[python:int]\n\nAttribute IDs for the given product ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.set_product_property.html#set_product_property",
        "title": "set_product_property",
        "section": "set_product_property",
        "text": "Set the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the property.\nset_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.set_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.set_product_property.html#pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.set_product_property",
        "title": "set_product_property > set_product_property > set_product_property",
        "section": "set_product_property > set_product_property",
        "text": "EdgeTerminal.set_product_property(prod_id, attr_id, prop_value)\n\nSet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nprop_value\n\npython:str\n\nString stored in the property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the terminal object to the correct concrete type, fetching the type if necessary.\ncast\nTerminalType\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.CircuitPort.cast.html#pyedb.grpc.database.ports.ports.CircuitPort.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "CircuitPort.cast(term_type=None)\n\nCast the terminal object to the correct concrete type, fetching the type if necessary.\n\nParameters\n\nterm_type\n\nTerminalType\n\n\n\nReturns\n\nTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.set_product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.set_product_solver_option.html#set_product_solver_option",
        "title": "set_product_solver_option",
        "section": "set_product_solver_option",
        "text": "Set the product solver option.\nID of the product.\nName of the solver.\nName of the product solver option.\nset_product_solver_option\nProductIdType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.set_product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.GapPort.set_product_solver_option.html#pyedb.grpc.database.ports.ports.GapPort.set_product_solver_option",
        "title": "set_product_solver_option > set_product_solver_option > set_product_solver_option",
        "section": "set_product_solver_option > set_product_solver_option",
        "text": "GapPort.set_product_solver_option(product_id, solver_name, option)\n\nSet the product solver option.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nsolver_name\n\nobj:str\n\nName of the solver.\n\noption\n\nobj:str\n\nName of the product solver option.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.html#edb",
        "title": "Edb",
        "section": "Edb",
        "text": "Provides the EDB application interface.\nThis module inherits all objects that belong to EDB.\nFull path to the aedb folder. The variable can also contain\nthe path to a layout to import. Allowed formats are BRD, MCM,\nXML (IPC2581), GDS, ODB++(TGZ and ZIP) and DXF. The default is None.\nFor GDS import, the Ansys control file (also XML) should have the same\nname as the GDS file. Only the file extension differs.\nName of the cell to select. The default is None.\nWhether to open EBD in read-only mode when it is\nowned by HFSS 3D Layout. The default is False.\nVersion of EDB to use. The default is None.\nExamples of input values are 232, 23.2, 2023.2, \"2023.2\".\nWhether to launch EDB from HFSS 3D Layout. The\ndefault is False.\nReference to the AEDT project object.\nWhether to open the AEDT student version. The default is False.\nPath to the XML file. The default is None, in which case an attempt is made to find\nthe XML file in the same directory as the board file. To succeed, the XML file and board file\nmust have the same name. Only the extension differs.\nLayer map .map file.\nFull path to technology file to be converted to xml before importing or xml.\nSupported by GDS format only.\nLayer filter .txt file.\nCreate an Edb object and a new EDB cell.\nAdd a new variable named “s1” to the Edb instance.\nor add a new parameter with description:\nCreate an Edb object and open the specified project.\nCreate an Edb object from GDS and control files.\nThe XML control file resides in the same directory as the GDS file: (myfile.xml).\nEdb.add_design_variable(variable_name, ...)\nAdd a variable to edb.\nEdb.add_project_variable(variable_name, ...)\nAdd a variable to edb database (project).\nEdb.are_port_reference_terminals_connected([...])\nCheck if all terminal references in design are connected.\nEdb.auto_parametrize_design([layers, ...])\nAssign automatically design and project variables with current values.\nEdb.build_simulation_project(simulation_setup)\nBuild a ready-to-solve simulation project.\nEdb.calculate_initial_extent(expansion_factor)\nCompute a float representing the larger number between the dielectric thickness or trace width multiplied by the nW factor.\nEdb.change_design_variable_value(...)\nChange a variable value.\nEdb.close(**kwargs)\nClose EDB and cleanup variables.\nEdb.close_edb()\nClose EDB and cleanup variables.\nEdb.compare(input_file[, results])\nCompares current open database with another one.\nEdb.copy_cells(cells_to_copy)\nCopy Cells from other Databases or this Database into this Database.\nEdb.copy_zones([working_directory])\nCopy multizone EDB project to one new edb per zone.\nEdb.create_current_source(terminal, ref_terminal)\nCreate a current source.\nEdb.create_edb()\nCreate EDB.\nEdb.create_hfss_setup([name])\nCreate an HFSS simulation setup from a template.\nEdb.create_hfsspi_setup([name])\nCreate an HFSS PI simulation setup from a template.\nEdb.create_model_for_arbitrary_wave_ports(...)\nGenerate EDB design to be consumed by PyAEDT to generate arbitrary wave ports shapes.\nEdb.create_port(terminal[, ref_terminal, ...])\nCreate a port.\nEdb.create_raptorx_setup([name])\nCreate an RaptorX simulation setup from a template.\nEdb.create_siwave_dc_setup([name])\nCreate a setup from a template.\nEdb.create_siwave_syz_setup([name])\nCreate a setup from a template.\nEdb.create_voltage_probe(terminal, ref_terminal)\nCreate a voltage probe.\nEdb.create_voltage_source(terminal, ref_terminal)\nCreate a voltage source.\nEdb.cutout([signal_nets, reference_nets, ...])\nCreate a cutout using an approach entirely based on PyAEDT.\nEdb.cutout_multizone_layout(zone_dict[, ...])\nCreate a multizone project cutout.\nEdb.edb_exception(ex_value, tb_data)\nWrite the trace stack to AEDT when a Python error occurs.\nEdb.edb_value(value[, var_server])\nConvert a value to an EDB value.\nEdb.execute(func)\nExecute a function.\nEdb.export_gds_comp_xml(comps_to_export[, ...])\nExports an XML file with selected components information for use in a GDS import.\nEdb.export_hfss(path_to_output[, net_list, ...])\nExport EDB to HFSS.\nEdb.export_maxwell(path_to_output[, ...])\nExport EDB to Maxwell 3D.\nEdb.export_q3d(path_to_output[, net_list, ...])\nExport EDB to Q3D.\nEdb.export_siwave_dc_results(siwave_project, ...)\nClose EDB and solve it with Siwave.\nEdb.export_to_ipc2581([edbpath, ...])\nExport design to IPC2581 format.\nEdb.get_all_variable_names()\nMethod added for compatibility with grpc.\nEdb.get_bounding_box()\nGet the layout bounding box.\nEdb.get_conformal_polygon_from_netlist([netlist])\nReturn an EDB conformal polygon based on a netlist.\nEdb.get_connected_objects(layout_object_instance)\nGet connected objects.\nEdb.get_point_terminal(name, net_name, ...)\nPlace a voltage probe between two points.\nEdb.get_statistics([compute_area])\nGet the EDBStatistics object.\nEdb.get_variable(variable_name)\nReturn Variable Value if variable exists.\nEdb.get_variable_value(variable_name)\nAdded to get closer architecture as for grpc.\nEdb.import_cadence_file(inputBrd[, WorkDir, ...])\nImport a board file and generate an edb.def file in the working directory.\nEdb.import_layout_file(input_file[, ...])\nImport a board file and generate an edb.def file in the working directory.\nEdb.import_vlctech_stackup(vlctech_file[, ...])\nImport a vlc.tech file and generate an edb.def file in the working directory containing only the stackup.\nEdb.new_simulation_configuration([filename])\nNew SimulationConfiguration Object.\nEdb.number_with_units(value[, units])\nConvert a number to a string with units.\nEdb.open_edb()\nOpen EDB.\nEdb.point_3d(x, y[, z])\nCompute the Edb 3d Point Data.\nEdb.point_data(x[, y])\nCompute the Edb Point Data.\nEdb.save()\nSave the EDB file.\nEdb.save_as(path)\nSave the EDB file as another file.\nEdb.save_edb()\nSave the EDB file.\nEdb.save_edb_as(path)\nSave the EDB file as another file.\nEdb.solve_siwave()\nClose EDB and solve it with Siwave.\nEdb.value(val)\nConvert a value into a pyedb value.\nEdb.variable_exists(variable_name)\nCheck if a variable exists or not.\nEdb.write_export3d_option_config_file(...[, ...])\nWrite the options for a 3D export to a configuration file.\nEdb\npython:str\noptional\naedb\nNone\npython:str\noptional\nNone\noptional\nFalse\npython:str\npython:int\npython:float\noptional\nNone\n232\n23.2\n2023.2\n\"2023.2\"\noptional\nFalse\noptional\noptional\nFalse.\npython:str\noptional\nNone\npython:str\noptional\npython:str\noptional\nEdb\nEdb\nEdb\nEdb\nEdb.add_design_variable\nEdb.add_project_variable\nEdb.are_port_reference_terminals_connected\nEdb.auto_parametrize_design\nEdb.build_simulation_project\nEdb.calculate_initial_extent\nEdb.change_design_variable_value\nEdb.close\nEdb.close_edb\nEdb.compare\nEdb.copy_cells\nEdb.copy_zones\nEdb.create_current_source\nEdb.create_edb\nEdb.create_hfss_setup\nEdb.create_hfsspi_setup\nEdb.create_model_for_arbitrary_wave_ports\nEdb.create_port\nEdb.create_raptorx_setup\nEdb.create_siwave_dc_setup\nEdb.create_siwave_syz_setup\nEdb.create_voltage_probe\nEdb.create_voltage_source\nEdb.cutout\nEdb.cutout_multizone_layout\nEdb.edb_exception\nEdb.edb_value\nEdb.execute\nEdb.export_gds_comp_xml\nEdb.export_hfss\nEdb.export_maxwell\nEdb.export_q3d\nEdb.export_siwave_dc_results\nEdb.export_to_ipc2581\nEdb.get_all_variable_names\nEdb.get_bounding_box\nEdb.get_conformal_polygon_from_netlist\nEdb.get_connected_objects\nEdb.get_point_terminal\nEdb.get_statistics\nEdb.get_variable\nEdb.get_variable_value\nEdb.import_cadence_file\nedb.def\nEdb.import_layout_file\nedb.def\nEdb.import_vlctech_stackup\nedb.def\nEdb.new_simulation_configuration\nEdb.number_with_units\nEdb.open_edb\nEdb.point_3d\nEdb.point_data\nEdb.save\nEdb.save_as\nEdb.save_edb\nEdb.save_edb_as\nEdb.solve_siwave\nEdb.value\nEdb.variable_exists\nEdb.write_export3d_option_config_file"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.html#pyedb.dotnet.edb.Edb",
        "title": "Edb > Edb > Edb",
        "section": "Edb > Edb",
        "text": "class pyedb.dotnet.edb.Edb(edbpath: str | Path = None, cellname: str = None, isreadonly: bool = False, isaedtowned: bool = False, oproject=None, use_ppe: bool = False, control_file: str = None, map_file: str = None, technology_file: str = None, layer_filter: str = None, remove_existing_aedt: bool = False)\n\nProvides the EDB application interface.\n\nThis module inherits all objects that belong to EDB.\n\nParameters\n\nedbpath\n\npython:str, optional\n\nFull path to the aedb folder. The variable can also contain\nthe path to a layout to import. Allowed formats are BRD, MCM,\nXML (IPC2581), GDS, ODB++(TGZ and ZIP) and DXF. The default is None.\nFor GDS import, the Ansys control file (also XML) should have the same\nname as the GDS file. Only the file extension differs.\n\ncellname\n\npython:str, optional\n\nName of the cell to select. The default is None.\n\nisreadonly\n\nbool, optional\n\nWhether to open EBD in read-only mode when it is\nowned by HFSS 3D Layout. The default is False.\n\nversion\n\npython:str, python:int, python:float, optional\n\nVersion of EDB to use. The default is None.\nExamples of input values are 232, 23.2, 2023.2, \"2023.2\".\n\nisaedtowned\n\nbool, optional\n\nWhether to launch EDB from HFSS 3D Layout. The\ndefault is False.\n\noproject\n\noptional\n\nReference to the AEDT project object.\n\nstudent_version\n\nbool, optional\n\nWhether to open the AEDT student version. The default is False.\n\ncontrol_file\n\npython:str, optional\n\nPath to the XML file. The default is None, in which case an attempt is made to find\nthe XML file in the same directory as the board file. To succeed, the XML file and board file\nmust have the same name. Only the extension differs.\n\nmap_file\n\npython:str, optional\n\nLayer map .map file.\n\ntechnology_file\n\npython:str, optional\n\nFull path to technology file to be converted to xml before importing or xml.\nSupported by GDS format only.\n\nlayer_filter:str,optional\n\nLayer filter .txt file.\n\nExamples\n\nCreate an Edb object and a new EDB cell.\n\n>>> from pyedb import Edb\n>>> app = Edb()\n\nAdd a new variable named “s1” to the Edb instance.\n\n>>> app[\"s1\"] = \"0.25 mm\"\n>>> app[\"s1\"].tofloat\n>>> 0.00025\n>>> app[\"s1\"].tostring\n>>> \"0.25mm\"\n\nor add a new parameter with description:\n\n>>> app[\"s2\"] = [\"20um\", \"Spacing between traces\"]\n>>> app[\"s2\"].value\n>>> 1.9999999999999998e-05\n>>> app[\"s2\"].description\n>>> \"Spacing between traces\"\n\nCreate an Edb object and open the specified project.\n\n>>> app = Edb(\"myfile.aedb\")\n\nCreate an Edb object from GDS and control files.\nThe XML control file resides in the same directory as the GDS file: (myfile.xml).\n\n>>> app = Edb(\"/path/to/file/myfile.gds\")\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nEdb.add_design_variable(variable_name, ...)\n\nAdd a variable to edb.\n\nEdb.add_project_variable(variable_name, ...)\n\nAdd a variable to edb database (project).\n\nEdb.are_port_reference_terminals_connected([...])\n\nCheck if all terminal references in design are connected.\n\nEdb.auto_parametrize_design([layers, ...])\n\nAssign automatically design and project variables with current values.\n\nEdb.build_simulation_project(simulation_setup)\n\nBuild a ready-to-solve simulation project.\n\nEdb.calculate_initial_extent(expansion_factor)\n\nCompute a float representing the larger number between the dielectric thickness or trace width multiplied by the nW factor.\n\nEdb.change_design_variable_value(...)\n\nChange a variable value.\n\nEdb.close(**kwargs)\n\nClose EDB and cleanup variables.\n\nEdb.close_edb()\n\nClose EDB and cleanup variables.\n\nEdb.compare(input_file[, results])\n\nCompares current open database with another one.\n\nEdb.copy_cells(cells_to_copy)\n\nCopy Cells from other Databases or this Database into this Database.\n\nEdb.copy_zones([working_directory])\n\nCopy multizone EDB project to one new edb per zone.\n\nEdb.create_current_source(terminal, ref_terminal)\n\nCreate a current source.\n\nEdb.create_edb()\n\nCreate EDB.\n\nEdb.create_hfss_setup([name])\n\nCreate an HFSS simulation setup from a template.\n\nEdb.create_hfsspi_setup([name])\n\nCreate an HFSS PI simulation setup from a template.\n\nEdb.create_model_for_arbitrary_wave_ports(...)\n\nGenerate EDB design to be consumed by PyAEDT to generate arbitrary wave ports shapes.\n\nEdb.create_port(terminal[, ref_terminal, ...])\n\nCreate a port.\n\nEdb.create_raptorx_setup([name])\n\nCreate an RaptorX simulation setup from a template.\n\nEdb.create_siwave_dc_setup([name])\n\nCreate a setup from a template.\n\nEdb.create_siwave_syz_setup([name])\n\nCreate a setup from a template.\n\nEdb.create_voltage_probe(terminal, ref_terminal)\n\nCreate a voltage probe.\n\nEdb.create_voltage_source(terminal, ref_terminal)\n\nCreate a voltage source.\n\nEdb.cutout([signal_nets, reference_nets, ...])\n\nCreate a cutout using an approach entirely based on PyAEDT.\n\nEdb.cutout_multizone_layout(zone_dict[, ...])\n\nCreate a multizone project cutout.\n\nEdb.edb_exception(ex_value, tb_data)\n\nWrite the trace stack to AEDT when a Python error occurs.\n\nEdb.edb_value(value[, var_server])\n\nConvert a value to an EDB value.\n\nEdb.execute(func)\n\nExecute a function.\n\nEdb.export_gds_comp_xml(comps_to_export[, ...])\n\nExports an XML file with selected components information for use in a GDS import.\n\nEdb.export_hfss(path_to_output[, net_list, ...])\n\nExport EDB to HFSS.\n\nEdb.export_maxwell(path_to_output[, ...])\n\nExport EDB to Maxwell 3D.\n\nEdb.export_q3d(path_to_output[, net_list, ...])\n\nExport EDB to Q3D.\n\nEdb.export_siwave_dc_results(siwave_project, ...)\n\nClose EDB and solve it with Siwave.\n\nEdb.export_to_ipc2581([edbpath, ...])\n\nExport design to IPC2581 format.\n\nEdb.get_all_variable_names()\n\nMethod added for compatibility with grpc.\n\nEdb.get_bounding_box()\n\nGet the layout bounding box.\n\nEdb.get_conformal_polygon_from_netlist([netlist])\n\nReturn an EDB conformal polygon based on a netlist.\n\nEdb.get_connected_objects(layout_object_instance)\n\nGet connected objects.\n\nEdb.get_point_terminal(name, net_name, ...)\n\nPlace a voltage probe between two points.\n\nEdb.get_statistics([compute_area])\n\nGet the EDBStatistics object.\n\nEdb.get_variable(variable_name)\n\nReturn Variable Value if variable exists.\n\nEdb.get_variable_value(variable_name)\n\nAdded to get closer architecture as for grpc.\n\nEdb.import_cadence_file(inputBrd[, WorkDir, ...])\n\nImport a board file and generate an edb.def file in the working directory.\n\nEdb.import_layout_file(input_file[, ...])\n\nImport a board file and generate an edb.def file in the working directory.\n\nEdb.import_vlctech_stackup(vlctech_file[, ...])\n\nImport a vlc.tech file and generate an edb.def file in the working directory containing only the stackup.\n\nEdb.new_simulation_configuration([filename])\n\nNew SimulationConfiguration Object.\n\nEdb.number_with_units(value[, units])\n\nConvert a number to a string with units.\n\nEdb.open_edb()\n\nOpen EDB.\n\nEdb.point_3d(x, y[, z])\n\nCompute the Edb 3d Point Data.\n\nEdb.point_data(x[, y])\n\nCompute the Edb Point Data.\n\nEdb.save()\n\nSave the EDB file.\n\nEdb.save_as(path)\n\nSave the EDB file as another file.\n\nEdb.save_edb()\n\nSave the EDB file.\n\nEdb.save_edb_as(path)\n\nSave the EDB file as another file.\n\nEdb.solve_siwave()\n\nClose EDB and solve it with Siwave.\n\nEdb.value(val)\n\nConvert a value into a pyedb value.\n\nEdb.variable_exists(variable_name)\n\nCheck if a variable exists or not.\n\nEdb.write_export3d_option_config_file(...[, ...])\n\nWrite the options for a 3D export to a configuration file.\n\n"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.update_forward_refs",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "update_forward_refs"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.update_forward_refs",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.update_forward_refs.html#pyedb.workflows.drc.drc.DiffPair.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod DiffPair.update_forward_refs(**localns: Any) -> None\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the group object to the correct concrete type.\ncast\nGroup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.cast.html#pyedb.grpc.database.hierarchy.component.Component.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "Component.cast()\n\nCast the group object to the correct concrete type.\n\nReturns\n\nGroup\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.contains_net",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.contains_net.html#contains_net",
        "title": "contains_net",
        "section": "contains_net",
        "text": "Determine if a net exists in the net class.\nNet to search for.\nTrue if the net is in the net class, False otherwise.\ncontains_net\nNet\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.contains_net",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.differential_pair.DifferentialPair.contains_net.html#pyedb.grpc.database.net.differential_pair.DifferentialPair.contains_net",
        "title": "contains_net > contains_net > contains_net",
        "section": "contains_net > contains_net",
        "text": "DifferentialPair.contains_net(net)\n\nDetermine if a net exists in the net class.\n\nParameters\n\nnet\n\nNet\n\nNet to search for.\n\nReturns\n\nbool\n\nTrue if the net is in the net class, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the layout object.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.extended_net.ExtendedNet.delete.html#pyedb.grpc.database.net.extended_net.ExtendedNet.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "ExtendedNet.delete()\n\nDelete the layout object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.HfssPortSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.HfssPortSettings.html#hfssportsettings",
        "title": "HfssPortSettings",
        "section": "HfssPortSettings",
        "text": "Manages EDB methods for HFSS port settings.\nHfssPortSettings"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.HfssPortSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.settings.HfssPortSettings.html#pyedb.dotnet.database.sim_setup_data.data.settings.HfssPortSettings",
        "title": "HfssPortSettings > HfssPortSettings > HfssPortSettings",
        "section": "HfssPortSettings > HfssPortSettings",
        "text": "class pyedb.dotnet.database.sim_setup_data.data.settings.HfssPortSettings(parent)\n\nManages EDB methods for HFSS port settings.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the padstack definition.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.padstack_def.PadstackDef.delete.html#pyedb.grpc.database.definition.padstack_def.PadstackDef.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "PadstackDef.delete()\n\nDelete the padstack definition.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.auto_mesh_operation",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.auto_mesh_operation.html#auto_mesh_operation",
        "title": "auto_mesh_operation",
        "section": "auto_mesh_operation",
        "text": "Automatically create and apply a length-based mesh operation for all nets in the design.\nThe method inspects every signal net, determines the smallest trace width, and\nseeds a GrpcLengthMeshOperation whose maximum element length is\nsmallest_width * trace_ratio_seeding. Signal vias (padstack instances) are\nconfigured with the requested number of polygon sides, while power/ground vias\nare updated through the global num_via_sides advanced setting.\nRatio used to compute the maximum allowed element length from the\nsmallest trace width found in the design.  The resulting length is\nmin_width * trace_ratio_seeding.  Defaults to 3.\nNumber of sides (i.e. faceting resolution) assigned to signal\npadstack instances that belong to the nets being meshed.\nDefaults to 12.\nNumber of sides assigned to power/ground vias via the global\nadvanced.num_via_sides setting.  Defaults to 6.\nIf the design contains no terminals, making mesh seeding impossible.\nOnly primitives of type \"path\" are considered when determining the\nsmallest trace width.\nEvery (net, layer, sheet) tuple required by the mesher is\nautomatically populated; sheet are explicitly marked as False.\nExisting contents of mesh_operations are replaced by the\nsingle new operation.\nauto_mesh_operation\nGrpcLengthMeshOperation\nsmallest_width * trace_ratio_seeding\nnum_via_sides\npython:float\noptional\nmin_width * trace_ratio_seeding\n3\npython:int\noptional\n12\npython:int\noptional\nadvanced.num_via_sides\n6\nValueError\n\"path\"\n(net, layer, sheet)\nFalse\nmesh_operations"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.auto_mesh_operation",
        "href": "grpc_api/grpc/database/pyedb_lib/simulation_setup/_autosummary/pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.auto_mesh_operation.html#pyedb.grpc.database.simulation_setup.hfss_simulation_setup.HfssSimulationSetup.auto_mesh_operation",
        "title": "auto_mesh_operation > auto_mesh_operation > auto_mesh_operation",
        "section": "auto_mesh_operation > auto_mesh_operation",
        "text": "HfssSimulationSetup.auto_mesh_operation(trace_ratio_seeding: float = 3, signal_via_side_number: int = 12, power_ground_via_side_number: int = 6) -> bool\n\nAutomatically create and apply a length-based mesh operation for all nets in the design.\n\nThe method inspects every signal net, determines the smallest trace width, and\nseeds a GrpcLengthMeshOperation whose maximum element length is\nsmallest_width * trace_ratio_seeding. Signal vias (padstack instances) are\nconfigured with the requested number of polygon sides, while power/ground vias\nare updated through the global num_via_sides advanced setting.\n\nParameters\n\ntrace_ratio_seeding\n\npython:float, optional\n\nRatio used to compute the maximum allowed element length from the\nsmallest trace width found in the design.  The resulting length is\nmin_width * trace_ratio_seeding.  Defaults to 3.\n\nsignal_via_side_number\n\npython:int, optional\n\nNumber of sides (i.e. faceting resolution) assigned to signal\npadstack instances that belong to the nets being meshed.\nDefaults to 12.\n\npower_ground_via_side_number\n\npython:int, optional\n\nNumber of sides assigned to power/ground vias via the global\nadvanced.num_via_sides setting.  Defaults to 6.\n\nReturns\n\nbool\n\n\n\nRaises\n\nValueError\n\nIf the design contains no terminals, making mesh seeding impossible.\n\nNotes\n\nOnly primitives of type \"path\" are considered when determining the\nsmallest trace width.\n\nEvery (net, layer, sheet) tuple required by the mesher is\nautomatically populated; sheet are explicitly marked as False.\n\nExisting contents of mesh_operations are replaced by the\nsingle new operation.\n\nExamples\n\n>>> setup = edbapp.setups[\"my_setup\"]\n>>> setup.auto_mesh_operation(trace_ratio_seeding=4, signal_via_side_number=16)\n>>> setup.mesh_operations[0].max_length\n'2.5um'\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.set_hfss_extent_info",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.set_hfss_extent_info.html#set_hfss_extent_info",
        "title": "set_hfss_extent_info",
        "section": "set_hfss_extent_info",
        "text": "Set the HFSS extents of this cell.\nset_hfss_extent_info\nHfssExtentInfo"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.set_hfss_extent_info",
        "href": "grpc_api/grpc/database/pyedb_lib/layout/_autosummary/pyedb.grpc.database.layout.cell.Cell.set_hfss_extent_info.html#pyedb.grpc.database.layout.cell.Cell.set_hfss_extent_info",
        "title": "set_hfss_extent_info > set_hfss_extent_info > set_hfss_extent_info",
        "section": "set_hfss_extent_info > set_hfss_extent_info",
        "text": "Cell.set_hfss_extent_info(extents)\n\nSet the HFSS extents of this cell.\n\nParameters\n\nextents\n\nHfssExtentInfo\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_terminal.html#get_terminal",
        "title": "get_terminal",
        "section": "get_terminal",
        "text": "Returns padstack instance terminal.\nIf terminal instance is not created,\nand value is True, a new PadstackInstanceTerminal is created.\nPadstackInstanceTerminal object.\nget_terminal\noptional\nTrue"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_terminal",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_terminal.html#pyedb.grpc.database.primitive.padstack_instance.PadstackInstance.get_terminal",
        "title": "get_terminal > get_terminal > get_terminal",
        "section": "get_terminal > get_terminal",
        "text": "PadstackInstance.get_terminal(create_new_terminal=True) -> PadstackInstanceTerminal\n\nReturns padstack instance terminal.\n\nParameters\n\ncreate_new_terminal\n\nbool, optional\n\nIf terminal instance is not created,\nand value is True, a new PadstackInstanceTerminal is created.\n\nReturns\n\n:class:`PadstackInstanceTerminal <pyedb.grpc.database.terminal.padstack_instance_terminal.\n\n\n\nPadstackInstanceTerminal>`\n\nPadstackInstanceTerminal object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.simulation_settings.HFSSPISimulationSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.simulation_settings.HFSSPISimulationSettings.html#hfsspisimulationsettings",
        "title": "HFSSPISimulationSettings",
        "section": "HFSSPISimulationSettings",
        "text": "HFSSPISimulationSettings"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.simulation_settings.HFSSPISimulationSettings",
        "href": "dotnet_api/dotnet/sim_setup_data/data/_autosummary/pyedb.dotnet.database.sim_setup_data.data.simulation_settings.HFSSPISimulationSettings.html#pyedb.dotnet.database.sim_setup_data.data.simulation_settings.HFSSPISimulationSettings",
        "title": "HFSSPISimulationSettings > HFSSPISimulationSettings > HFSSPISimulationSettings",
        "section": "HFSSPISimulationSettings > HFSSPISimulationSettings",
        "text": "class pyedb.dotnet.database.sim_setup_data.data.simulation_settings.HFSSPISimulationSettings(pedb, sim_setup, edb_object)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_parametric",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_parametric.html#is_parametric",
        "title": "is_parametric",
        "section": "is_parametric",
        "text": "Determine whether a polygon contains any parametrized points.\nTrue when the polygon contains parametrized points, False otherwise.\nis_parametric\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_parametric",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.is_parametric.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.is_parametric",
        "title": "is_parametric > is_parametric > is_parametric",
        "section": "is_parametric > is_parametric",
        "text": "PolygonData.is_parametric() -> bool\n\nDetermine whether a polygon contains any parametrized points.\n\nReturns\n\nbool\n\nTrue when the polygon contains parametrized points, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.cast.html#cast",
        "title": "cast",
        "section": "cast",
        "text": "Cast the terminal object to the correct concrete type, fetching the type if necessary.\ncast\nTerminalType\nTerminal"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.cast",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.cast.html#pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.cast",
        "title": "cast > cast > cast",
        "section": "cast > cast",
        "text": "EdgeTerminal.cast(term_type=None)\n\nCast the terminal object to the correct concrete type, fetching the type if necessary.\n\nParameters\n\nterm_type\n\nTerminalType\n\n\n\nReturns\n\nTerminal\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.to_dict",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.to_dict.html#to_dict",
        "title": "to_dict",
        "section": "to_dict",
        "text": "Alias for model_dump.\nJSON-serialisable dictionary.\nto_dict\nmodel_dump\npython:dict"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.to_dict",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.Rules.to_dict.html#pyedb.workflows.drc.drc.Rules.to_dict",
        "title": "to_dict > to_dict > to_dict",
        "section": "to_dict > to_dict",
        "text": "Rules.to_dict() -> dict[str, Any]\n\nAlias for model_dump.\n\nReturns\n\npython:dict\n\nJSON-serialisable dictionary.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.compare",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.compare.html#compare",
        "title": "compare",
        "section": "compare",
        "text": "Compares current open database with another one.\nDo not execute this function with untrusted function argument, environment\nvariables or pyedb global settings.\nSee the security guide for details.\nPath to the edb file.\nPath to directory in which results will be saved. If no path is given, a new “_compare_results”\ndirectory will be created with the same naming and path as the .aedb folder.\nTrue when successful, False when failed.\ncompare\npython:str\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.compare",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.compare.html#pyedb.grpc.edb.Edb.compare",
        "title": "compare > compare > compare",
        "section": "compare > compare",
        "text": "Edb.compare(input_file, results='')\n\nCompares current open database with another one.\n\nDo not execute this function with untrusted function argument, environment\nvariables or pyedb global settings.\nSee the security guide for details.\n\nParameters\n\ninput_file\n\npython:str\n\nPath to the edb file.\n\nresults: str, optional\n\nPath to directory in which results will be saved. If no path is given, a new “_compare_results”\ndirectory will be created with the same naming and path as the .aedb folder.\n\nReturns\n\n\n\n——-\n\n\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetClassData",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetClassData.html#edbnetclassdata",
        "title": "EDBNetClassData",
        "section": "EDBNetClassData",
        "text": "Manages EDB functionalities for a primitives.\nIt inherits EDB Object properties.\nEDBNetClassData.add_net(name)\nAdd a new net.\nEDBNetClassData.api_create(name)\nEdb Dotnet Api Database Edb.NetClass.Create.\nEDBNetClassData.delete()\nEdb Dotnet Api Database Delete.\nEDBNetClassData\nEDBNetClassData.add_net\nEDBNetClassData.api_create\nEDBNetClassData.delete"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetClassData",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.nets_data.EDBNetClassData.html#pyedb.dotnet.database.edb_data.nets_data.EDBNetClassData",
        "title": "EDBNetClassData > EDBNetClassData > EDBNetClassData",
        "section": "EDBNetClassData > EDBNetClassData",
        "text": "class pyedb.dotnet.database.edb_data.nets_data.EDBNetClassData(core_app, raw_extended_net=None)\n\nManages EDB functionalities for a primitives.\nIt inherits EDB Object properties.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edb = Edb(myedb, edbversion=\"2021.2\")\n>>> edb.net_classes\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nEDBNetClassData.add_net(name)\n\nAdd a new net.\n\nEDBNetClassData.api_create(name)\n\nEdb Dotnet Api Database Edb.NetClass.Create.\n\nEDBNetClassData.delete()\n\nEdb Dotnet Api Database Delete.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.set_product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.set_product_solver_option.html#set_product_solver_option",
        "title": "set_product_solver_option",
        "section": "set_product_solver_option",
        "text": "Set the product solver option.\nID of the product.\nName of the solver.\nName of the product solver option.\nset_product_solver_option\nProductIdType"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.set_product_solver_option",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.set_product_solver_option.html#pyedb.grpc.database.terminal.edge_terminal.EdgeTerminal.set_product_solver_option",
        "title": "set_product_solver_option > set_product_solver_option > set_product_solver_option",
        "section": "set_product_solver_option > set_product_solver_option",
        "text": "EdgeTerminal.set_product_solver_option(product_id, solver_name, option)\n\nSet the product solver option.\n\nParameters\n\nproduct_id\n\nProductIdType\n\nID of the product.\n\nsolver_name\n\nobj:str\n\nName of the solver.\n\noption\n\nobj:str\n\nName of the product solver option.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.remove_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.remove_layer.html#remove_layer",
        "title": "remove_layer",
        "section": "remove_layer",
        "text": "Remove a layer from stackup.\nName of the layer to remove.\nTrue when successful.\nremove_layer\npython:str\nTrue"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.remove_layer",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.stackup.Stackup.remove_layer.html#pyedb.grpc.database.stackup.Stackup.remove_layer",
        "title": "remove_layer > remove_layer > remove_layer",
        "section": "remove_layer > remove_layer",
        "text": "Stackup.remove_layer(name: str) -> bool\n\nRemove a layer from stackup.\n\nParameters\n\nname\n\npython:str\n\nName of the layer to remove.\n\nReturns\n\nbool\n\nTrue when successful.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.alpha_shape",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.alpha_shape.html#alpha_shape",
        "title": "alpha_shape",
        "section": "alpha_shape",
        "text": "Compute the outline of a 2D point cloud using alpha shapes.\nList of points.\nalpha_shape\npython:list\nof\npython:float\npython:list\nof\nPolygonData"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.alpha_shape",
        "href": "grpc_api/grpc/database/pyedb_lib/geometry/_autosummary/pyedb.grpc.database.geometry.polygon_data.PolygonData.alpha_shape.html#pyedb.grpc.database.geometry.polygon_data.PolygonData.alpha_shape",
        "title": "alpha_shape > alpha_shape > alpha_shape",
        "section": "alpha_shape > alpha_shape",
        "text": "classmethod PolygonData.alpha_shape(points: list[PointLike], alpha: float) -> list[PolygonData]\n\nCompute the outline of a 2D point cloud using alpha shapes.\n\nParameters\n\npoints\n\npython:list of Point2DLike\n\nList of points.\n\nalpha\n\npython:float\n\n\n\nReturns\n\npython:list of PolygonData\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.find_by_def",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.find_by_def.html#find_by_def",
        "title": "find_by_def",
        "section": "find_by_def",
        "text": "Find all components belonging to a given component definition.\nLayout to search for component groups.\nName of the ComponentDef instance.\nList of component groups that are found.\nfind_by_def\nLayout\npython:str\nComponentDef\npython:list\nComponentGroup"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.find_by_def",
        "href": "grpc_api/grpc/database/pyedb_lib/hierarchy/_autosummary/pyedb.grpc.database.hierarchy.component.Component.find_by_def.html#pyedb.grpc.database.hierarchy.component.Component.find_by_def",
        "title": "find_by_def > find_by_def > find_by_def",
        "section": "find_by_def > find_by_def",
        "text": "classmethod Component.find_by_def(layout, comp_def_name)\n\nFind all components belonging to a given component definition.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for component groups.\n\ncomp_def_name\n\npython:str\n\nName of the ComponentDef instance.\n\nReturns\n\npython:list[ComponentGroup]\n\nList of component groups that are found.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.find_by_id.html#find_by_id",
        "title": "find_by_id",
        "section": "find_by_id",
        "text": "Find a Connectable object by database ID in a given layout.\nLayout to search for the Connectable object.\nDatabase ID.\nConnectable object with the given database ID.\nfind_by_id\nLayout\npython:int"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.find_by_id",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.bondwire.Bondwire.find_by_id.html#pyedb.grpc.database.primitive.bondwire.Bondwire.find_by_id",
        "title": "find_by_id > find_by_id > find_by_id",
        "section": "find_by_id > find_by_id",
        "text": "classmethod Bondwire.find_by_id(layout, uid)\n\nFind a Connectable object by database ID in a given layout.\n\nParameters\n\nlayout\n\nLayout\n\nLayout to search for the Connectable object.\n\nuid\n\npython:int\n\nDatabase ID.\n\nReturns\n\nConnectable\n\nConnectable object with the given database ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_parametrized_name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nString representing the new class where params are passed to cls as type variables.\nTypeError: Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_parametrized_name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_parametrized_name.html#pyedb.workflows.drc.drc.MinAnnularRing.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod MinAnnularRing.model_parametrized_name(params: tuple[type[Any], ...]) -> str\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n\nparams: Tuple of types of the class. Given a generic class\n\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturns:\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises:\n\nTypeError: Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "validate"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.validate",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinClearance.validate.html#pyedb.workflows.drc.drc.MinClearance.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod MinClearance.validate(value: Any) -> Self\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileStackup.add_via",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileStackup.add_via.html#add_via",
        "title": "add_via",
        "section": "add_via",
        "text": "Add a new via layer.\nLayer name.\nDefine the material for this layer.\nDefine the gds type.\nTarget layer used after layout import in EDB and HFSS 3D layout.\nDefine the start layer for the via\nDefine the stop layer for the via.\nWhen True solve inside this layer is anbled. Default value is True.\nDefine the via group method, default value is \"proximity\"\nDefine the via group tolerance.\nWhen True activated otherwise when False``is deactivated. Default value is ``True.\nDefine the via group method, default value is \"distance\"\nDefine the via group tolerance, default value is 10e-9.\nDictionary with key and  property value.\nadd_via\npython:str\npython:str\npython:int\npython:str\npython:str\npython:str\nTrue\nTrue\npython:str\n\"proximity\"\npython:float\nTrue\nFalse``is deactivated. Default value is ``True\npython:str\n\"distance\"\npython:float\npython:dict\npyedb.dotnet.database.edb_data.control_file.ControlFileVia"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileStackup.add_via",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileStackup.add_via.html#pyedb.grpc.database.utility.xml_control_file.ControlFileStackup.add_via",
        "title": "add_via > add_via > add_via",
        "section": "add_via > add_via",
        "text": "ControlFileStackup.add_via(layer_name, material='', gds_type=0, target_layer='', start_layer='', stop_layer='', solve_inside=True, via_group_method='proximity', via_group_tol=1e-06, via_group_persistent=True, snap_via_group_method='distance', snap_via_group_tol=1e-08, properties=None)\n\nAdd a new via layer.\n\nParameters\n\nlayer_name\n\npython:str\n\nLayer name.\n\nmaterial\n\npython:str\n\nDefine the material for this layer.\n\ngds_type\n\npython:int\n\nDefine the gds type.\n\ntarget_layer\n\npython:str\n\nTarget layer used after layout import in EDB and HFSS 3D layout.\n\nstart_layer\n\npython:str\n\nDefine the start layer for the via\n\nstop_layer\n\npython:str\n\nDefine the stop layer for the via.\n\nsolve_inside\n\nbool\n\nWhen True solve inside this layer is anbled. Default value is True.\n\nvia_group_method\n\npython:str\n\nDefine the via group method, default value is \"proximity\"\n\nvia_group_tol\n\npython:float\n\nDefine the via group tolerance.\n\nvia_group_persistent\n\nbool\n\nWhen True activated otherwise when False``is deactivated. Default value is ``True.\n\nsnap_via_group_method\n\npython:str\n\nDefine the via group method, default value is \"distance\"\n\nsnap_via_group_tol\n\npython:float\n\nDefine the via group tolerance, default value is 10e-9.\n\nproperties\n\npython:dict\n\nDictionary with key and  property value.\n\nReturns\n\npyedb.dotnet.database.edb_data.control_file.ControlFileVia\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/utilities/index",
        "href": "workflows/utilities/index.html#workflows",
        "title": "Workflows",
        "section": "Workflows",
        "text": "This section describes PyEDB utilities workflows features.\nWorkflows"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_parametrized_name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nString representing the new class where params are passed to cls as type variables.\nTypeError: Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_parametrized_name",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.model_parametrized_name.html#pyedb.workflows.drc.drc.DiffPair.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod DiffPair.model_parametrized_name(params: tuple[type[Any], ...]) -> str\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n\nparams: Tuple of types of the class. Given a generic class\n\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturns:\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises:\n\nTypeError: Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.schema_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "schema_json"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.schema_json",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.schema_json.html#pyedb.workflows.drc.drc.DiffPair.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod DiffPair.schema_json(*, by_alias: bool = True, ref_template: str = '#/$defs/{model}', **dumps_kwargs: Any) -> str\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "schema"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.schema",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.schema.html#pyedb.workflows.drc.drc.DiffPair.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod DiffPair.schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}') -> Dict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.html#edb",
        "title": "Edb",
        "section": "Edb",
        "text": "Main class for interacting with Ansys Electronics Desktop Database (EDB).\nProvides comprehensive control over EDB projects including:\n- Project creation/management\n- Layout import/export\n- Material/stackup configuration\n- Component/net management\n- Simulation setup\n- Cutout operations\n- Parameterization\nFull path to AEDB folder or layout file to import. Supported formats:\nBRD, MCM, XML (IPC2581), GDS, ODB++ (TGZ/ZIP), DXF.\nDefault creates new AEDB in documents folder.\nSpecific cell to open. Default opens first cell.\nOpen in read-only mode. Default False.\nEDB version (e.g., “2023.2”, 232, 23.2). Default uses latest.\nLaunch from HFSS 3D Layout. Default False.\nReference to AEDT project object.\nUse student version. Default False.\nUse PPE license. Default False.\nXML control file path for import.\nLayer map file for import.\nTechnology file for import (GDS only).\nLayer filter file for import.\nRemove existing AEDT project files. Default False.\nRestart gRPC server. Use with caution. Default False.\nEdb.add_design_variable(variable_name, ...)\nAdd design variable.\nEdb.add_project_variable(variable_name, ...)\nAdd project variable.\nEdb.are_port_reference_terminals_connected([...])\nCheck if port reference terminals are connected.\nEdb.auto_parametrize_design([layers, ...])\nAutomatically parametrize design elements.\nEdb.calculate_initial_extent(expansion_factor)\nCompute a float representing the larger number between the dielectric thickness or trace width multiplied by the nW factor.\nEdb.change_design_variable_value(...)\nUpdate variable value.\nEdb.close([terminate_rpc_session])\nClose the database.\nEdb.close_edb()\nClose EDB and clean up resources.\nEdb.compare(input_file[, results])\nCompares current open database with another one.\nEdb.copy_cells(cells_to_copy)\nCopy Cells from other Databases or this Database into this Database.\nEdb.copy_zones([working_directory])\nCopy multi-zone EDB project to one new edb per zone.\nEdb.create([restart_rpc_server])\nCreate new EDB database.\nEdb.create_current_source(terminal, ref_terminal)\nCreate a current source.\nEdb.create_hfss_setup([name, ...])\nCreate an HFSS simulation setup from a template.\nEdb.create_hfsspi_setup([name])\n\nEdb.create_model_for_arbitrary_wave_ports(...)\nCreate simplified model for arbitrary wave port generation.\nEdb.create_port(terminal[, ref_terminal, ...])\nCreate a port.\nEdb.create_raptorx_setup([name])\nCreate RaptorX analysis setup (2024R2+ only).\nEdb.create_siwave_dc_setup([name])\nCreate SIwave DC analysis setup.\nEdb.create_siwave_syz_setup([name])\nCreate SIwave SYZ analysis setup.\nEdb.create_voltage_probe(terminal, ref_terminal)\nCreate a voltage probe.\nEdb.create_voltage_source(terminal, ref_terminal)\nCreate a voltage source.\nEdb.cutout([signal_nets, reference_nets, ...])\nCreate a cutout using an approach entirely based on PyAEDT.\nEdb.cutout_multizone_layout(zone_dict[, ...])\nCreate a multizone project cutout.\nEdb.delete(db_path)\nDelete a database at the specified file location.\nEdb.edb_exception(ex_value, tb_data)\nLog Python exceptions to EDB logger.\nEdb.execute(func)\nExecute EDB utility command (Not implemented in gRPC).\nEdb.export_gds_comp_xml(comps_to_export[, ...])\nExport component data to GDS XML control file.\nEdb.export_hfss(path_to_output[, net_list, ...])\nExport to HFSS project.\nEdb.export_layout_component(component_path)\nExport a layout component from the current layout.\nEdb.export_maxwell(path_to_output[, ...])\nExport to Maxwell project.\nEdb.export_q3d(path_to_output[, net_list, ...])\nExport to Q3D project.\nEdb.export_siwave_dc_results(siwave_project, ...)\nExport SIwave DC results.\nEdb.export_to_ipc2581([edbpath, ...])\nExport design to IPC2581 format.\nEdb.find_by_id(db_id)\nFind a database by ID.\nEdb.get_all_variable_names()\nMethod added for compatibility with grpc.\nEdb.get_bounding_box()\nGet layout bounding box.\nEdb.get_connected_objects(layout_object_instance)\nGet objects connected to a layout object.\nEdb.get_point_terminal(name, net_name, ...)\nPlace terminal between two points.\nEdb.get_product_property(prod_id, attr_it)\nGet the product-specific property value.\nEdb.get_product_property_ids(prod_id)\nGet a list of attribute ids corresponding to a product property id.\nEdb.get_statistics([compute_area])\nGet layout statistics.\nEdb.get_variable(variable_name)\nGet variable value.\nEdb.import_gds_file(inputGDS[, ...])\nImport GDS file.\nEdb.import_layout_component(component_path)\nImport a layout component inside the current layout and place it at the origin.\nEdb.import_layout_file(input_file[, ...])\nImport a board file and generate an edb.def file in the working directory.\nEdb.import_layout_pcb(input_file[, ...])\nImport layout file and generate AEDB.\nEdb.import_material_from_control_file(...[, ...])\nImport materials from the provided control file.\nEdb.import_vlctech_stackup(vlctech_file[, ...])\nImport a vlc.tech file and generate an edb.def file in the working directory containing only the stackup.\nEdb.number_with_units(value[, units])\nConvert a number to a string with units.\nEdb.open([restart_rpc_server])\nOpen EDB database.\nEdb.point_3d(x, y[, z])\nCreate 3D point.\nEdb.point_data(x[, y])\nCreate 2D point.\nEdb.save()\nSave any changes into a file.\nEdb.save_as(path[, version])\nSave this Database to a new location and older EDB version.\nEdb.save_edb()\nSave current EDB database.\nEdb.save_edb_as(fname)\nSave EDB database to new location.\nEdb.scale(scale_factor)\nUniformly scale all geometry and their locations by a positive factor.\nEdb.set_product_property(prod_id, attr_it, ...)\nSet the product property associated with the given product and attribute ids.\nEdb.solve_siwave()\nSolve with SIwave.\nEdb.value(val)\nConvert a value into a pyedb value.\nEdb.variable_exists(variable_name)\nCheck if variable exists.\nEdb.write_export3d_option_config_file(...[, ...])\nWrite the options for a 3D export to a configuration file.\nEdb\npython:str\nPath\noptional\npython:str\noptional\noptional\npython:str\npython:int\npython:float\noptional\noptional\nobject\noptional\noptional\noptional\npython:str\noptional\npython:str\noptional\npython:str\noptional\npython:str\noptional\noptional\noptional\nEdb.add_design_variable\nEdb.add_project_variable\nEdb.are_port_reference_terminals_connected\nEdb.auto_parametrize_design\nEdb.calculate_initial_extent\nEdb.change_design_variable_value\nEdb.close\nEdb.close_edb\nEdb.compare\nEdb.copy_cells\nEdb.copy_zones\nEdb.create\nEdb.create_current_source\nEdb.create_hfss_setup\nEdb.create_hfsspi_setup\nEdb.create_model_for_arbitrary_wave_ports\nEdb.create_port\nEdb.create_raptorx_setup\nEdb.create_siwave_dc_setup\nEdb.create_siwave_syz_setup\nEdb.create_voltage_probe\nEdb.create_voltage_source\nEdb.cutout\nEdb.cutout_multizone_layout\nEdb.delete\nEdb.edb_exception\nEdb.execute\nEdb.export_gds_comp_xml\nEdb.export_hfss\nEdb.export_layout_component\nEdb.export_maxwell\nEdb.export_q3d\nEdb.export_siwave_dc_results\nEdb.export_to_ipc2581\nEdb.find_by_id\nEdb.get_all_variable_names\nEdb.get_bounding_box\nEdb.get_connected_objects\nEdb.get_point_terminal\nEdb.get_product_property\nEdb.get_product_property_ids\nEdb.get_statistics\nEdb.get_variable\nEdb.import_gds_file\nEdb.import_layout_component\nEdb.import_layout_file\nedb.def\nEdb.import_layout_pcb\nEdb.import_material_from_control_file\nEdb.import_vlctech_stackup\nedb.def\nEdb.number_with_units\nEdb.open\nEdb.point_3d\nEdb.point_data\nEdb.save\nEdb.save_as\nEdb.save_edb\nEdb.save_edb_as\nEdb.scale\nEdb.set_product_property\nEdb.solve_siwave\nEdb.value\nEdb.variable_exists\nEdb.write_export3d_option_config_file"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.html#pyedb.grpc.edb.Edb",
        "title": "Edb > Edb > Edb",
        "section": "Edb > Edb",
        "text": "class pyedb.grpc.edb.Edb(edbpath: str | Path | None = None, cellname: str | None = None, isreadonly: bool = False, edbversion: str | None = None, isaedtowned: bool = False, oproject=None, use_ppe: bool = False, control_file: str | None = None, map_file: str | None = None, technology_file: str | None = None, layer_filter: str | None = None, restart_rpc_server=False)\n\nMain class for interacting with Ansys Electronics Desktop Database (EDB).\n\nProvides comprehensive control over EDB projects including:\n- Project creation/management\n- Layout import/export\n- Material/stackup configuration\n- Component/net management\n- Simulation setup\n- Cutout operations\n- Parameterization\n\nParameters\n\nedbpath\n\npython:str or Path, optional\n\nFull path to AEDB folder or layout file to import. Supported formats:\nBRD, MCM, XML (IPC2581), GDS, ODB++ (TGZ/ZIP), DXF.\nDefault creates new AEDB in documents folder.\n\ncellname\n\npython:str, optional\n\nSpecific cell to open. Default opens first cell.\n\nisreadonly\n\nbool, optional\n\nOpen in read-only mode. Default False.\n\nedbversion\n\npython:str, python:int, python:float, optional\n\nEDB version (e.g., “2023.2”, 232, 23.2). Default uses latest.\n\nisaedtowned\n\nbool, optional\n\nLaunch from HFSS 3D Layout. Default False.\n\noproject\n\nobject, optional\n\nReference to AEDT project object.\n\nstudent_version\n\nbool, optional\n\nUse student version. Default False.\n\nuse_ppe\n\nbool, optional\n\nUse PPE license. Default False.\n\ncontrol_file\n\npython:str, optional\n\nXML control file path for import.\n\nmap_file\n\npython:str, optional\n\nLayer map file for import.\n\ntechnology_file\n\npython:str, optional\n\nTechnology file for import (GDS only).\n\nlayer_filter\n\npython:str, optional\n\nLayer filter file for import.\n\nremove_existing_aedt\n\nbool, optional\n\nRemove existing AEDT project files. Default False.\n\nrestart_rpc_server\n\nbool, optional\n\nRestart gRPC server. Use with caution. Default False.\n\nExamples\n\n>>> # Create new EDB:\n>>> edb = Edb()\n\n>>> # Open existing AEDB:\n>>> edb = Edb(\"myproject.aedb\")\n\n>>> # Import board file:\n>>> edb = Edb(\"my_board.brd\")\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nEdb.add_design_variable(variable_name, ...)\n\nAdd design variable.\n\nEdb.add_project_variable(variable_name, ...)\n\nAdd project variable.\n\nEdb.are_port_reference_terminals_connected([...])\n\nCheck if port reference terminals are connected.\n\nEdb.auto_parametrize_design([layers, ...])\n\nAutomatically parametrize design elements.\n\nEdb.calculate_initial_extent(expansion_factor)\n\nCompute a float representing the larger number between the dielectric thickness or trace width multiplied by the nW factor.\n\nEdb.change_design_variable_value(...)\n\nUpdate variable value.\n\nEdb.close([terminate_rpc_session])\n\nClose the database.\n\nEdb.close_edb()\n\nClose EDB and clean up resources.\n\nEdb.compare(input_file[, results])\n\nCompares current open database with another one.\n\nEdb.copy_cells(cells_to_copy)\n\nCopy Cells from other Databases or this Database into this Database.\n\nEdb.copy_zones([working_directory])\n\nCopy multi-zone EDB project to one new edb per zone.\n\nEdb.create([restart_rpc_server])\n\nCreate new EDB database.\n\nEdb.create_current_source(terminal, ref_terminal)\n\nCreate a current source.\n\nEdb.create_hfss_setup([name, ...])\n\nCreate an HFSS simulation setup from a template.\n\nEdb.create_hfsspi_setup([name])\n\n\n\nEdb.create_model_for_arbitrary_wave_ports(...)\n\nCreate simplified model for arbitrary wave port generation.\n\nEdb.create_port(terminal[, ref_terminal, ...])\n\nCreate a port.\n\nEdb.create_raptorx_setup([name])\n\nCreate RaptorX analysis setup (2024R2+ only).\n\nEdb.create_siwave_dc_setup([name])\n\nCreate SIwave DC analysis setup.\n\nEdb.create_siwave_syz_setup([name])\n\nCreate SIwave SYZ analysis setup.\n\nEdb.create_voltage_probe(terminal, ref_terminal)\n\nCreate a voltage probe.\n\nEdb.create_voltage_source(terminal, ref_terminal)\n\nCreate a voltage source.\n\nEdb.cutout([signal_nets, reference_nets, ...])\n\nCreate a cutout using an approach entirely based on PyAEDT.\n\nEdb.cutout_multizone_layout(zone_dict[, ...])\n\nCreate a multizone project cutout.\n\nEdb.delete(db_path)\n\nDelete a database at the specified file location.\n\nEdb.edb_exception(ex_value, tb_data)\n\nLog Python exceptions to EDB logger.\n\nEdb.execute(func)\n\nExecute EDB utility command (Not implemented in gRPC).\n\nEdb.export_gds_comp_xml(comps_to_export[, ...])\n\nExport component data to GDS XML control file.\n\nEdb.export_hfss(path_to_output[, net_list, ...])\n\nExport to HFSS project.\n\nEdb.export_layout_component(component_path)\n\nExport a layout component from the current layout.\n\nEdb.export_maxwell(path_to_output[, ...])\n\nExport to Maxwell project.\n\nEdb.export_q3d(path_to_output[, net_list, ...])\n\nExport to Q3D project.\n\nEdb.export_siwave_dc_results(siwave_project, ...)\n\nExport SIwave DC results.\n\nEdb.export_to_ipc2581([edbpath, ...])\n\nExport design to IPC2581 format.\n\nEdb.find_by_id(db_id)\n\nFind a database by ID.\n\nEdb.get_all_variable_names()\n\nMethod added for compatibility with grpc.\n\nEdb.get_bounding_box()\n\nGet layout bounding box.\n\nEdb.get_connected_objects(layout_object_instance)\n\nGet objects connected to a layout object.\n\nEdb.get_point_terminal(name, net_name, ...)\n\nPlace terminal between two points.\n\nEdb.get_product_property(prod_id, attr_it)\n\nGet the product-specific property value.\n\nEdb.get_product_property_ids(prod_id)\n\nGet a list of attribute ids corresponding to a product property id.\n\nEdb.get_statistics([compute_area])\n\nGet layout statistics.\n\nEdb.get_variable(variable_name)\n\nGet variable value.\n\nEdb.import_gds_file(inputGDS[, ...])\n\nImport GDS file.\n\nEdb.import_layout_component(component_path)\n\nImport a layout component inside the current layout and place it at the origin.\n\nEdb.import_layout_file(input_file[, ...])\n\nImport a board file and generate an edb.def file in the working directory.\n\nEdb.import_layout_pcb(input_file[, ...])\n\nImport layout file and generate AEDB.\n\nEdb.import_material_from_control_file(...[, ...])\n\nImport materials from the provided control file.\n\nEdb.import_vlctech_stackup(vlctech_file[, ...])\n\nImport a vlc.tech file and generate an edb.def file in the working directory containing only the stackup.\n\nEdb.number_with_units(value[, units])\n\nConvert a number to a string with units.\n\nEdb.open([restart_rpc_server])\n\nOpen EDB database.\n\nEdb.point_3d(x, y[, z])\n\nCreate 3D point.\n\nEdb.point_data(x[, y])\n\nCreate 2D point.\n\nEdb.save()\n\nSave any changes into a file.\n\nEdb.save_as(path[, version])\n\nSave this Database to a new location and older EDB version.\n\nEdb.save_edb()\n\nSave current EDB database.\n\nEdb.save_edb_as(fname)\n\nSave EDB database to new location.\n\nEdb.scale(scale_factor)\n\nUniformly scale all geometry and their locations by a positive factor.\n\nEdb.set_product_property(prod_id, attr_it, ...)\n\nSet the product property associated with the given product and attribute ids.\n\nEdb.solve_siwave()\n\nSolve with SIwave.\n\nEdb.value(val)\n\nConvert a value into a pyedb value.\n\nEdb.variable_exists(variable_name)\n\nCheck if variable exists.\n\nEdb.write_export3d_option_config_file(...[, ...])\n\nWrite the options for a 3D export to a configuration file.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.html#stackuplayer",
        "title": "StackupLayer",
        "section": "StackupLayer",
        "text": "StackupLayer.assign_roughness_model([...])\nAssign roughness model on this layer.\nStackupLayer.cast()\nCast the layer object to the correct concrete type.\nStackupLayer.clone([copy_id])\nCreate a clone of the layer.\nStackupLayer.create(name, layer_type, ...)\nCreate a stackup layer.\nStackupLayer.get_fill_material([evaluated])\nGet the name of the fill material of the layer.\nStackupLayer.get_material([evaluated])\nGet the name of the material of the layer.\nStackupLayer.get_product_property(prod_id, ...)\nGet the product property of the layer for a given product ID and attribute ID.\nStackupLayer.get_product_property_ids(prod_id)\nGet a list of attribute IDs for a given product ID for the layer.\nStackupLayer.get_roughness_model(region)\nGet the roughness model used by the layer.\nStackupLayer.is_in_zone(zone)\nDetermine if the layer exists in the given zone.\nStackupLayer.set_fill_material(...)\nSet the name of the fill material of the layer.\nStackupLayer.set_is_in_zone(zone[, in_zone])\nSet whether the layer exists in a given zone.\nStackupLayer.set_material(material_name)\nSet the name of the material of the layer.\nStackupLayer.set_product_property(prod_id, ...)\nSet the product property of the layer for a given product ID and attribute ID.\nStackupLayer.set_roughness_model(...)\nSet the roughness model used by the layer.\nStackupLayer.update(**kwargs)\n\nStackupLayer.layout_obj_type\n\nStackupLayer\nStackupLayer.assign_roughness_model\nStackupLayer.cast\nStackupLayer.clone\nStackupLayer.create\nStackupLayer.get_fill_material\nStackupLayer.get_material\nStackupLayer.get_product_property\nStackupLayer.get_product_property_ids\nStackupLayer.get_roughness_model\nStackupLayer.is_in_zone\nStackupLayer.set_fill_material\nStackupLayer.set_is_in_zone\nStackupLayer.set_material\nStackupLayer.set_product_property\nStackupLayer.set_roughness_model\nStackupLayer.update\nStackupLayer.layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer",
        "href": "grpc_api/grpc/database/pyedb_lib/layers/_autosummary/pyedb.grpc.database.layers.stackup_layer.StackupLayer.html#pyedb.grpc.database.layers.stackup_layer.StackupLayer",
        "title": "StackupLayer > StackupLayer > StackupLayer",
        "section": "StackupLayer > StackupLayer",
        "text": "class pyedb.grpc.database.layers.stackup_layer.StackupLayer(pedb, edb_object=None)\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nStackupLayer.assign_roughness_model([...])\n\nAssign roughness model on this layer.\n\nStackupLayer.cast()\n\nCast the layer object to the correct concrete type.\n\nStackupLayer.clone([copy_id])\n\nCreate a clone of the layer.\n\nStackupLayer.create(name, layer_type, ...)\n\nCreate a stackup layer.\n\nStackupLayer.get_fill_material([evaluated])\n\nGet the name of the fill material of the layer.\n\nStackupLayer.get_material([evaluated])\n\nGet the name of the material of the layer.\n\nStackupLayer.get_product_property(prod_id, ...)\n\nGet the product property of the layer for a given product ID and attribute ID.\n\nStackupLayer.get_product_property_ids(prod_id)\n\nGet a list of attribute IDs for a given product ID for the layer.\n\nStackupLayer.get_roughness_model(region)\n\nGet the roughness model used by the layer.\n\nStackupLayer.is_in_zone(zone)\n\nDetermine if the layer exists in the given zone.\n\nStackupLayer.set_fill_material(...)\n\nSet the name of the fill material of the layer.\n\nStackupLayer.set_is_in_zone(zone[, in_zone])\n\nSet whether the layer exists in a given zone.\n\nStackupLayer.set_material(material_name)\n\nSet the name of the material of the layer.\n\nStackupLayer.set_product_property(prod_id, ...)\n\nSet the product property of the layer for a given product ID and attribute ID.\n\nStackupLayer.set_roughness_model(...)\n\nSet the roughness model used by the layer.\n\nStackupLayer.update(**kwargs)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nStackupLayer.layout_obj_type\n\n\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.hfss.Hfss",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.hfss.Hfss.html#hfss",
        "title": "Hfss",
        "section": "Hfss",
        "text": "Manages EDB methods for HFSS setup configuration.\nProvides access to HFSS-specific operations including:\n- Excitation and port creation\n- Source and probe management\n- Simulation setup configuration\n- Boundary condition creation\n- Layout manipulation for simulation\nAccessed via Edb.hfss property.\nHfss.add_setup([name, distribution, ...])\nAdd HFSS analysis setup.\nHfss.get_layout_bounding_box([layout, ...])\nCalculate layout bounding box.\nHfss.get_trace_width_for_traces_with_ports()\nRetrieve trace widths for traces with ports.\nHfss\nHfss.add_setup\nHfss.get_layout_bounding_box\nHfss.get_trace_width_for_traces_with_ports"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.hfss.Hfss",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.hfss.Hfss.html#pyedb.grpc.database.hfss.Hfss",
        "title": "Hfss > Hfss > Hfss",
        "section": "Hfss > Hfss",
        "text": "class pyedb.grpc.database.hfss.Hfss(p_edb)\n\nManages EDB methods for HFSS setup configuration.\n\nProvides access to HFSS-specific operations including:\n- Excitation and port creation\n- Source and probe management\n- Simulation setup configuration\n- Boundary condition creation\n- Layout manipulation for simulation\n\nAccessed via Edb.hfss property.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nHfss.add_setup([name, distribution, ...])\n\nAdd HFSS analysis setup.\n\nHfss.get_layout_bounding_box([layout, ...])\n\nCalculate layout bounding box.\n\nHfss.get_trace_width_for_traces_with_ports()\n\nRetrieve trace widths for traces with ports.\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/ports/_autosummary/pyedb.grpc.database.ports.ports.BundleWavePort.layout_obj_type.html#pyedb.grpc.database.ports.ports.BundleWavePort.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "BundleWavePort.layout_obj_type = 2\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.cos",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.cos.html#cos",
        "title": "cos",
        "section": "cos",
        "text": "Cosine of the value.\ncos"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.cos",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.value.Value.cos.html#pyedb.grpc.database.utility.value.Value.cos",
        "title": "cos > cos > cos",
        "section": "cos > cos",
        "text": "Value.cos()\n\nCosine of the value.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFile.parse_layer_map",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFile.parse_layer_map.html#parse_layer_map",
        "title": "parse_layer_map",
        "section": "parse_layer_map",
        "text": "Parse a layer map file and update stackup.\nPath to layer map file.\nTrue if successful, False otherwise.\nparse_layer_map\npython:str\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFile.parse_layer_map",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFile.parse_layer_map.html#pyedb.grpc.database.control_file.ControlFile.parse_layer_map",
        "title": "parse_layer_map > parse_layer_map > parse_layer_map",
        "section": "parse_layer_map > parse_layer_map",
        "text": "ControlFile.parse_layer_map(layer_map: str) -> bool\n\nParse a layer map file and update stackup.\n\nParameters\n\nlayer_map\n\npython:str\n\nPath to layer map file.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave.create_impedance_crosstalk_scan",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave.create_impedance_crosstalk_scan.html#create_impedance_crosstalk_scan",
        "title": "create_impedance_crosstalk_scan",
        "section": "create_impedance_crosstalk_scan",
        "text": "Create Siwave crosstalk scan object.\nScan type to be analyzed. Options are:\n- \"impedance\" for frequency impedance scan\n- \"frequency_xtalk\" for frequency domain crosstalk\n- \"time_xtalk\" for time domain crosstalk\nDefault is \"impedance\".\nScan configuration object.\ncreate_impedance_crosstalk_scan\npython:str\noptional\n\"impedance\"\n\"frequency_xtalk\"\n\"time_xtalk\"\n\"impedance\"\nSiwaveScanConfig"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave.create_impedance_crosstalk_scan",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.siwave.Siwave.create_impedance_crosstalk_scan.html#pyedb.grpc.database.siwave.Siwave.create_impedance_crosstalk_scan",
        "title": "create_impedance_crosstalk_scan > create_impedance_crosstalk_scan > create_impedance_crosstalk_scan",
        "section": "create_impedance_crosstalk_scan > create_impedance_crosstalk_scan",
        "text": "Siwave.create_impedance_crosstalk_scan(scan_type: str = 'impedance') -> SiwaveScanConfig\n\nCreate Siwave crosstalk scan object.\n\nParameters\n\nscan_type\n\npython:str, optional\n\nScan type to be analyzed. Options are:\n- \"impedance\" for frequency impedance scan\n- \"frequency_xtalk\" for frequency domain crosstalk\n- \"time_xtalk\" for time domain crosstalk\nDefault is \"impedance\".\n\nReturns\n\nSiwaveScanConfig\n\nScan configuration object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.terminal.Terminal.layout_obj_type.html#pyedb.grpc.database.terminal.terminal.Terminal.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "Terminal.layout_obj_type = 2\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.get_product_property.html#get_product_property",
        "title": "get_product_property",
        "section": "get_product_property",
        "text": "Get the product property of the layout object for a given product ID and attribute ID.\nID representing a product that supports the EDB.\nUser-defined ID that identifies the string value stored in the property.\nString stored in the product property.\nget_product_property\nProductIdType\npython:int\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.get_product_property",
        "href": "grpc_api/grpc/database/pyedb_lib/net/_autosummary/pyedb.grpc.database.net.net.Net.get_product_property.html#pyedb.grpc.database.net.net.Net.get_product_property",
        "title": "get_product_property > get_product_property > get_product_property",
        "section": "get_product_property > get_product_property",
        "text": "Net.get_product_property(prod_id, attr_id)\n\nGet the product property of the layout object for a given product ID and attribute ID.\n\nParameters\n\nprod_id\n\nProductIdType\n\nID representing a product that supports the EDB.\n\nattr_id\n\npython:int\n\nUser-defined ID that identifies the string value stored in the property.\n\nReturns\n\npython:str\n\nString stored in the product property.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.move",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.move.html#move",
        "title": "move",
        "section": "move",
        "text": "Move polygon along a vector.\nTrue when successful, False when failed.\nmove\nList\nof\npython:float\npython:str\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.move",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.polygon.Polygon.move.html#pyedb.grpc.database.primitive.polygon.Polygon.move",
        "title": "move > move > move",
        "section": "move > move",
        "text": "Polygon.move(vector) -> bool\n\nMove polygon along a vector.\n\nParameters\n\nvector\n\nList of python:float or python:str [x,y].\n\n\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\nExamples\n\n>>> edbapp = ansys.aedt.core.Edb(\"myproject.aedb\")\n>>> top_layer_polygon = [poly for poly in edbapp.modeler.polygons if poly.layer_name == \"Top Layer\"]\n>>> for polygon in top_layer_polygon:\n>>>     polygon.move(vector=[\"2mm\", \"100um\"])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.layout_obj_type.html#layout_obj_type",
        "title": "layout_obj_type",
        "section": "layout_obj_type",
        "text": "layout_obj_type"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.layout_obj_type",
        "href": "grpc_api/grpc/database/pyedb_lib/terminal/_autosummary/pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.layout_obj_type.html#pyedb.grpc.database.terminal.pingroup_terminal.PinGroupTerminal.layout_obj_type",
        "title": "layout_obj_type > layout_obj_type > layout_obj_type",
        "section": "layout_obj_type > layout_obj_type",
        "text": "PinGroupTerminal.layout_obj_type = 2\n\n"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.save_as",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.save_as.html#save_as",
        "title": "save_as",
        "section": "save_as",
        "text": "Save the EDB file as another file.\nName of the new file to save to.\nTrue when successful, False when failed.\nsave_as\npython:str\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.save_as",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.edb.Edb.save_as.html#pyedb.dotnet.edb.Edb.save_as",
        "title": "save_as > save_as > save_as",
        "section": "save_as > save_as",
        "text": "Edb.save_as(path)\n\nSave the EDB file as another file.\n\nParameters\n\npath\n\npython:str\n\nName of the new file to save to.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.subtract",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.subtract.html#subtract",
        "title": "subtract",
        "section": "subtract",
        "text": "Subtract active primitive with one or more primitives.\nsubtract\ndotnet.database.edb_data.EDBPrimitives\nEDB\nPolygonData\nEDB\nPrimitive\npython:list\nList\nof\ndotnet.database.edb_data.EDBPrimitives"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.subtract",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.subtract.html#pyedb.dotnet.database.edb_data.primitives_data.EdbPolygon.subtract",
        "title": "subtract > subtract > subtract",
        "section": "subtract > subtract",
        "text": "EdbPolygon.subtract(primitives)\n\nSubtract active primitive with one or more primitives.\n\nParameters\n\nprimitives\n\ndotnet.database.edb_data.EDBPrimitives or EDB PolygonData or EDB Primitive or python:list\n\n\n\nReturns\n\nList of dotnet.database.edb_data.EDBPrimitives\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_variable",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_variable.html#get_variable",
        "title": "get_variable",
        "section": "get_variable",
        "text": "Get variable value.\nVariable name.\nVariable value if exists, else False.\nget_variable\npython:str\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_variable",
        "href": "grpc_api/grpc/_autosummary/pyedb.grpc.edb.Edb.get_variable.html#pyedb.grpc.edb.Edb.get_variable",
        "title": "get_variable > get_variable > get_variable",
        "section": "get_variable > get_variable",
        "text": "Edb.get_variable(variable_name)\n\nGet variable value.\n\nParameters\n\nvariable_name\n\npython:str\n\nVariable name.\n\nReturns\n\npython:float or bool\n\nVariable value if exists, else False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_rebuild",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce: Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors: Whether to raise errors, defaults to True.\n_parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n_types_namespace: The types namespace, defaults to None.\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_rebuild",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.MaterialProperties.model_rebuild.html#pyedb.grpc.database.definition.materials.MaterialProperties.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod MaterialProperties.model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -> bool | None\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n\nforce: Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors: Whether to raise errors, defaults to True.\n_parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n_types_namespace: The types namespace, defaults to None.\n\nReturns:\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kSIwave",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kSIwave.html#ksiwave",
        "title": "kSIwave",
        "section": "kSIwave",
        "text": "kSIwave"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kSIwave",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kSIwave.html#pyedb.dotnet.database.utilities.simulation_setup.SimulationSetupType.kSIwave",
        "title": "kSIwave > kSIwave > kSIwave",
        "section": "kSIwave > kSIwave",
        "text": "SimulationSetupType.kSIwave = 'siwave_ac'\n\n"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_pin_position",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_pin_position.html#get_pin_position",
        "title": "get_pin_position",
        "section": "get_pin_position",
        "text": "Get pin position.\nPin instance.\n[x, y] position in meters.\nget_pin_position\npyedb.grpc.database.padstacks.PadstackInstance\npython:list\npython:float"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_pin_position",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.components.Components.get_pin_position.html#pyedb.grpc.database.components.Components.get_pin_position",
        "title": "get_pin_position > get_pin_position > get_pin_position",
        "section": "get_pin_position > get_pin_position",
        "text": "Components.get_pin_position(pin: Any) -> List[float]\n\nGet pin position.\n\nParameters\n\npin\n\npyedb.grpc.database.padstacks.PadstackInstance\n\nPin instance.\n\nReturns\n\npython:list[python:float]\n\n[x, y] position in meters.\n\nExamples\n\n>>> pos = edbapp.components.get_pin_position(pin)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings.restore_default",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings.restore_default.html#restore_default",
        "title": "restore_default",
        "section": "restore_default",
        "text": "restore_default"
    },
    {
        "objectID": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings.restore_default",
        "href": "dotnet_api/dotnet/sim_setup_data/io/_autosummary/pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings.restore_default.html#pyedb.dotnet.database.sim_setup_data.io.siwave.AdvancedSettings.restore_default",
        "title": "restore_default > restore_default > restore_default",
        "section": "restore_default > restore_default",
        "text": "AdvancedSettings.restore_default()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.create_circular_padstack",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.create_circular_padstack.html#create_circular_padstack",
        "title": "create_circular_padstack",
        "section": "create_circular_padstack",
        "text": "Create a circular padstack.\nName of the padstack. The default is None.\nDiameter of the hole with units. The default is \"300um\".\nDiameter of the pad with units. The default is \"400um\".\nDiameter of the antipad with units. The default is \"600um\".\nStarting layer. The default is None, in which case the top\nis the starting layer.\nEnding layer. The default is None, in which case the bottom\nis the ending layer.\nName of the padstack if the operation is successful.\ncreate_circular_padstack\npython:str\noptional\nNone\npython:str\noptional\n\"300um\"\npython:str\noptional\n\"400um\"\npython:str\noptional\n\"600um\"\npython:str\noptional\nNone\npython:str\noptional\nNone\npython:str"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.create_circular_padstack",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.create_circular_padstack.html#pyedb.grpc.database.padstacks.Padstacks.create_circular_padstack",
        "title": "create_circular_padstack > create_circular_padstack > create_circular_padstack",
        "section": "create_circular_padstack > create_circular_padstack",
        "text": "Padstacks.create_circular_padstack(padstackname: str | None = None, holediam: str = '300um', paddiam: str = '400um', antipaddiam: str = '600um', startlayer: str | None = None, endlayer: str | None = None) -> str\n\nCreate a circular padstack.\n\nParameters\n\npadstackname\n\npython:str, optional\n\nName of the padstack. The default is None.\n\nholediam\n\npython:str, optional\n\nDiameter of the hole with units. The default is \"300um\".\n\npaddiam\n\npython:str, optional\n\nDiameter of the pad with units. The default is \"400um\".\n\nantipaddiam\n\npython:str, optional\n\nDiameter of the antipad with units. The default is \"600um\".\n\nstartlayer\n\npython:str, optional\n\nStarting layer. The default is None, in which case the top\nis the starting layer.\n\nendlayer\n\npython:str, optional\n\nEnding layer. The default is None, in which case the bottom\nis the ending layer.\n\nReturns\n\npython:str\n\nName of the padstack if the operation is successful.\n\nExamples\n\n>>> via_name = edb_padstacks.create_circular_padstack(\n...     padstackname=\"VIA1\", holediam=\"200um\", paddiam=\"400um\", antipaddiam=\"600um\"\n... )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.add_skin_depth_mesh_operation",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.add_skin_depth_mesh_operation.html#add_skin_depth_mesh_operation",
        "title": "add_skin_depth_mesh_operation",
        "section": "add_skin_depth_mesh_operation",
        "text": "Add a mesh operation to the setup.\nDictionary containing nets and layers on which enable Mesh operation. Example {\"A0_N\": [\"TOP\", \"PWR\"]}.\nMesh operation name.\nMaximum number of elements. Default is 1000.\nSkin Depth. Default is 1um.\nWhether to restrict number of elements. Default is True.\nSurface Triangle length. Default is 1mm.\nNumber of layers. Default is 2.\nMesh region name.\nWhether to refine inside or not.  Default is False.\nadd_skin_depth_mesh_operation\npython:dict\n{\"A0_N\": [\"TOP\", \"PWR\"]}\npython:str\noptional\npython:int\noptional\n1000\npython:str\noptional\n1um\noptional\nTrue\noptional\n1mm\npython:int\npython:str\noptional\n2\npython:str\noptional\noptional\nFalse\ndotnet.database.edb_data.hfss_simulation_setup_data.LengthMeshOperation"
    },
    {
        "objectID": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.add_skin_depth_mesh_operation",
        "href": "dotnet_api/dotnet/utilities/_autosummary/pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.add_skin_depth_mesh_operation.html#pyedb.dotnet.database.utilities.hfss_simulation_setup.HfssSimulationSetup.add_skin_depth_mesh_operation",
        "title": "add_skin_depth_mesh_operation > add_skin_depth_mesh_operation > add_skin_depth_mesh_operation",
        "section": "add_skin_depth_mesh_operation > add_skin_depth_mesh_operation",
        "text": "HfssSimulationSetup.add_skin_depth_mesh_operation(net_layer_list, name=None, max_elements=1000, skin_depth='1um', restrict_elements=True, surface_triangle_length='1mm', number_of_layers=2, refine_inside=False, mesh_region=None)\n\nAdd a mesh operation to the setup.\n\nParameters\n\nnet_layer_list\n\npython:dict\n\nDictionary containing nets and layers on which enable Mesh operation. Example {\"A0_N\": [\"TOP\", \"PWR\"]}.\n\nname\n\npython:str, optional\n\nMesh operation name.\n\nmax_elements\n\npython:int, optional\n\nMaximum number of elements. Default is 1000.\n\nskin_depth\n\npython:str, optional\n\nSkin Depth. Default is 1um.\n\nrestrict_elements\n\nbool, optional\n\nWhether to restrict number of elements. Default is True.\n\nsurface_triangle_length\n\nbool, optional\n\nSurface Triangle length. Default is 1mm.\n\nnumber_of_layers\n\npython:int, python:str, optional\n\nNumber of layers. Default is 2.\n\nmesh_region\n\npython:str, optional\n\nMesh region name.\n\nrefine_inside\n\nbool, optional\n\nWhether to refine inside or not.  Default is False.\n\nReturns\n\ndotnet.database.edb_data.hfss_simulation_setup_data.LengthMeshOperation\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_current_source_on_net",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_current_source_on_net.html#create_current_source_on_net",
        "title": "create_current_source_on_net",
        "section": "create_current_source_on_net",
        "text": "Create a current source.\nName of the positive component.\nName of the positive net.\nName of the negative component. The default is None, in which case the name of\nthe positive net is assigned.\nName of the negative net name. The default is None which will look for GND Nets.\nValue for the current. The default is 0.1.\nValue for the phase. The default is 0.\nName of the source. The default is \"\".\nThe name of the source.\ncreate_current_source_on_net\npython:str\npython:str\npython:str\noptional\nNone\npython:str\noptional\nNone\npython:float\noptional\n0.1\noptional\n0\npython:str\noptional\n\"\"\npython:str"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_current_source_on_net",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.siwave.EdbSiwave.create_current_source_on_net.html#pyedb.dotnet.database.siwave.EdbSiwave.create_current_source_on_net",
        "title": "create_current_source_on_net > create_current_source_on_net > create_current_source_on_net",
        "section": "create_current_source_on_net > create_current_source_on_net",
        "text": "EdbSiwave.create_current_source_on_net(positive_component_name, positive_net_name, negative_component_name=None, negative_net_name=None, current_value=0.1, phase_value=0, source_name='')\n\nCreate a current source.\n\nParameters\n\npositive_component_name\n\npython:str\n\nName of the positive component.\n\npositive_net_name\n\npython:str\n\nName of the positive net.\n\nnegative_component_name\n\npython:str, optional\n\nName of the negative component. The default is None, in which case the name of\nthe positive net is assigned.\n\nnegative_net_name\n\npython:str, optional\n\nName of the negative net name. The default is None which will look for GND Nets.\n\ncurrent_value\n\npython:float, optional\n\nValue for the current. The default is 0.1.\n\nphase_value\n\noptional\n\nValue for the phase. The default is 0.\n\nsource_name\n\npython:str, optional\n\nName of the source. The default is \"\".\n\nReturns\n\npython:str\n\nThe name of the source.\n\nExamples\n\n>>> from pyedb import Edb\n>>> edbapp = Edb(\"myaedbfolder\", \"project name\", \"release version\")\n>>> edb.siwave.create_current_source_on_net(\"U2A5\", \"V1P5_S3\", \"U2A5\", \"GND\", 0.1, 0, \"source_name\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_padstack_terminal_reference_pin",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_padstack_terminal_reference_pin.html#get_padstack_terminal_reference_pin",
        "title": "get_padstack_terminal_reference_pin",
        "section": "get_padstack_terminal_reference_pin",
        "text": "Get a list of pad stacks instances and serves Coax wave ports,\npingroup terminals, PadEdge terminals.\nPreferred reference net name.\nget_padstack_terminal_reference_pin\npython:str\noptional\ndotnet.database.edb_data.padstack_data.EDBPadstackInstance"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_padstack_terminal_reference_pin",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.ports.WavePort.get_padstack_terminal_reference_pin.html#pyedb.dotnet.database.edb_data.ports.WavePort.get_padstack_terminal_reference_pin",
        "title": "get_padstack_terminal_reference_pin > get_padstack_terminal_reference_pin > get_padstack_terminal_reference_pin",
        "section": "get_padstack_terminal_reference_pin > get_padstack_terminal_reference_pin",
        "text": "WavePort.get_padstack_terminal_reference_pin(gnd_net_name_preference=None)\n\nGet a list of pad stacks instances and serves Coax wave ports,\npingroup terminals, PadEdge terminals.\n\nParameters\n\ngnd_net_name_preference\n\npython:str, optional\n\nPreferred reference net name.\n\nReturns\n\ndotnet.database.edb_data.padstack_data.EDBPadstackInstance\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude: Optional set or mapping specifying which fields to include in the copied model.\nexclude: Optional set or mapping specifying which fields to exclude in the copied model.\nupdate: Optional dictionary of field-value pairs to override field values in the copied model.\ndeep: If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.copy",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.DiffPair.copy.html#pyedb.workflows.drc.drc.DiffPair.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "DiffPair.copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -> Self\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nArgs:\n\ninclude: Optional set or mapping specifying which fields to include in the copied model.\nexclude: Optional set or mapping specifying which fields to exclude in the copied model.\nupdate: Optional dictionary of field-value pairs to override field values in the copied model.\ndeep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileStackup.add_material",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileStackup.add_material.html#add_material",
        "title": "add_material",
        "section": "add_material",
        "text": "Add a new material.\nMaterial name.\nRelative permittivity. Default is 1.0.\nDielectric loss tangent. Default is 0.0.\nRelative permeability. Default is 1.0.\nConductivity (S/m). Default is 0.0.\nAdditional material properties. Overrides default parameters.\nCreated material object.\nadd_material\npython:str\npython:float\noptional\n1.0\npython:float\noptional\n0.0\npython:float\noptional\n1.0\npython:float\noptional\n0.0\npython:dict\noptional\nControlFileMaterial"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileStackup.add_material",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.control_file.ControlFileStackup.add_material.html#pyedb.grpc.database.control_file.ControlFileStackup.add_material",
        "title": "add_material > add_material > add_material",
        "section": "add_material > add_material",
        "text": "ControlFileStackup.add_material(material_name: str, permittivity: float = 1.0, dielectric_loss_tg: float = 0.0, permeability: float = 1.0, conductivity: float = 0.0, properties: Dict[str, Any] | None = None) -> ControlFileMaterial\n\nAdd a new material.\n\nParameters\n\nmaterial_name\n\npython:str\n\nMaterial name.\n\npermittivity\n\npython:float, optional\n\nRelative permittivity. Default is 1.0.\n\ndielectric_loss_tg\n\npython:float, optional\n\nDielectric loss tangent. Default is 0.0.\n\npermeability\n\npython:float, optional\n\nRelative permeability. Default is 1.0.\n\nconductivity\n\npython:float, optional\n\nConductivity (S/m). Default is 0.0.\n\nproperties\n\npython:dict, optional\n\nAdditional material properties. Overrides default parameters.\n\nReturns\n\nControlFileMaterial\n\nCreated material object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.in_polygon",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.in_polygon.html#in_polygon",
        "title": "in_polygon",
        "section": "in_polygon",
        "text": "Check if padstack Instance is in given polygon data.\nWhether to include partial intersecting instances. The default is True.\nWhether to perform a single check based on the padstack center or check the padstack bounding box.\nTrue when successful, False when failed.\nin_polygon\nPolygonData\nObject\noptional\nTrue\noptional\nTrue\nFalse"
    },
    {
        "objectID": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.in_polygon",
        "href": "dotnet_api/dotnet/edb_data/_autosummary/pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.in_polygon.html#pyedb.dotnet.database.edb_data.padstacks_data.EDBPadstackInstance.in_polygon",
        "title": "in_polygon > in_polygon > in_polygon",
        "section": "in_polygon > in_polygon",
        "text": "EDBPadstackInstance.in_polygon(polygon_data, include_partial=True, simple_check=False)\n\nCheck if padstack Instance is in given polygon data.\n\nParameters\n\npolygon_data\n\nPolygonData Object\n\n\n\ninclude_partial\n\nbool, optional\n\nWhether to include partial intersecting instances. The default is True.\n\nsimple_check\n\nbool, optional\n\nWhether to perform a single check based on the padstack center or check the padstack bounding box.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.classify_nets",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.classify_nets.html#classify_nets",
        "title": "classify_nets",
        "section": "classify_nets",
        "text": "Reassign net classifications as power/ground or signal.\nNets to classify as power/ground.\nNets to classify as signal.\nTrue if successful, False otherwise.\nclassify_nets\npython:str\npython:list\npython:str\noptional\npython:str\npython:list\npython:str\noptional"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.classify_nets",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.classify_nets.html#pyedb.grpc.database.nets.Nets.classify_nets",
        "title": "classify_nets > classify_nets > classify_nets",
        "section": "classify_nets > classify_nets",
        "text": "Nets.classify_nets(power_nets: str | List[str] | None = None, signal_nets: str | List[str] | None = None) -> bool\n\nReassign net classifications as power/ground or signal.\n\nParameters\n\npower_nets\n\npython:str | python:list[python:str], optional\n\nNets to classify as power/ground.\n\nsignal_nets\n\npython:str | python:list[python:str], optional\n\nNets to classify as signal.\n\nReturns\n\nbool\n\nTrue if successful, False otherwise.\n\nExamples\n\n>>> edb_nets.classify_nets(power_nets=[\"VDD_CPU\", \"VDD_MEM\"], signal_nets=[\"PCIe_TX\", \"ETH_RX\"])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_computed_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_computed_fields",
        "href": "workflows/drc/generated/pyedb.workflows.drc.drc.MinAnnularRing.model_computed_fields.html#pyedb.workflows.drc.drc.MinAnnularRing.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "MinAnnularRing.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "dotnet_api/index",
        "href": "dotnet_api/index.html#api-reference",
        "title": "API reference",
        "section": "API reference",
        "text": "This section describes EDB functions, classes, and methods\nfor EDB apps and modules. Use the search feature or click links\nto view API documentation.\nThe PyEDB API includes classes for apps and modules. You must initialize the\nEdb class to get access to all modules and methods. All other classes and\nmethods are inherited into the Edb class.\nIf EDB is launched within the HfssdLayout class, EDB is accessible in read-only mode.\nExample\nAPI reference\nEdb\nEdb\nHfssdLayout"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.get_powertree",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.get_powertree.html#get_powertree",
        "title": "get_powertree",
        "section": "get_powertree",
        "text": "Retrieve power tree for a given power net.\nName of the power net.\nList of ground net names.\n(component_list, component_list_columns, net_group)\nget_powertree\npython:str\npython:list\npython:tuple"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.get_powertree",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.nets.Nets.get_powertree.html#pyedb.grpc.database.nets.Nets.get_powertree",
        "title": "get_powertree > get_powertree > get_powertree",
        "section": "get_powertree > get_powertree",
        "text": "Nets.get_powertree(power_net_name: str, ground_nets: List[str]) -> Tuple[List[List[str]], List[str], List[str]]\n\nRetrieve power tree for a given power net.\n\nParameters\n\npower_net_name\n\npython:str\n\nName of the power net.\n\nground_nets\n\npython:list\n\nList of ground net names.\n\nReturns\n\npython:tuple\n\n(component_list, component_list_columns, net_group)\n\nExamples\n\n>>> comp_list, columns, net_group = edb_nets.get_powertree(power_net_name=\"VDD_CPU\", ground_nets=[\"GND\"])\n>>> print(\"Power tree components:\", comp_list)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_djordjecvic_sarkar_model",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_djordjecvic_sarkar_model.html#set_djordjecvic_sarkar_model",
        "title": "set_djordjecvic_sarkar_model",
        "section": "set_djordjecvic_sarkar_model",
        "text": "Set Djordjecvic-Sarkar model on current material.\nset_djordjecvic_sarkar_model"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_djordjecvic_sarkar_model",
        "href": "grpc_api/grpc/database/pyedb_lib/definition/_autosummary/pyedb.grpc.database.definition.materials.Material.set_djordjecvic_sarkar_model.html#pyedb.grpc.database.definition.materials.Material.set_djordjecvic_sarkar_model",
        "title": "set_djordjecvic_sarkar_model > set_djordjecvic_sarkar_model > set_djordjecvic_sarkar_model",
        "section": "set_djordjecvic_sarkar_model > set_djordjecvic_sarkar_model",
        "text": "Material.set_djordjecvic_sarkar_model()\n\nSet Djordjecvic-Sarkar model on current material.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileStackup.add_material",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileStackup.add_material.html#add_material",
        "title": "add_material",
        "section": "add_material",
        "text": "Add a new material with specific properties.\nMaterial name.\nMaterial permittivity. The default is 1.0.\nMaterial tangent losses. The default is 0.0.\nMaterial permeability. The default is 1.0.\nMaterial conductivity. The default is 0.0.\nSpecific material properties. The default is None.\nDictionary with key and material property value.\nadd_material\npython:str\npython:float\noptional\n1.0\npython:float\noptional\n0.0\npython:float\noptional\n1.0\npython:float\noptional\n0.0\npython:dict\noptional\nNone\npyedb.dotnet.database.edb_data.control_file.ControlFileMaterial"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileStackup.add_material",
        "href": "grpc_api/grpc/database/pyedb_lib/utility/_autosummary/pyedb.grpc.database.utility.xml_control_file.ControlFileStackup.add_material.html#pyedb.grpc.database.utility.xml_control_file.ControlFileStackup.add_material",
        "title": "add_material > add_material > add_material",
        "section": "add_material > add_material",
        "text": "ControlFileStackup.add_material(material_name, permittivity=1.0, dielectric_loss_tg=0.0, permeability=1.0, conductivity=0.0, properties=None)\n\nAdd a new material with specific properties.\n\nParameters\n\nmaterial_name\n\npython:str\n\nMaterial name.\n\npermittivity\n\npython:float, optional\n\nMaterial permittivity. The default is 1.0.\n\ndielectric_loss_tg\n\npython:float, optional\n\nMaterial tangent losses. The default is 0.0.\n\npermeability\n\npython:float, optional\n\nMaterial permeability. The default is 1.0.\n\nconductivity\n\npython:float, optional\n\nMaterial conductivity. The default is 0.0.\n\nproperties\n\npython:dict, optional\n\nSpecific material properties. The default is None.\nDictionary with key and material property value.\n\nReturns\n\npyedb.dotnet.database.edb_data.control_file.ControlFileMaterial\n\n\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.find_or_create_net",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.find_or_create_net.html#find_or_create_net",
        "title": "find_or_create_net",
        "section": "find_or_create_net",
        "text": "Find or create the net with the given name in the layout.\nName of the net to find or create. The default is \"\".\nAll net name starting with the string. Not case-sensitive.\nAll net name containing the string. Not case-sensitive.\nAll net name ending with the string. Not case-sensitive.\nNet Object.\nfind_or_create_net\npython:str\noptional\n\"\"\npython:str\noptional\npython:str\noptional\npython:str\noptional\nobject"
    },
    {
        "objectID": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.find_or_create_net",
        "href": "dotnet_api/dotnet/_autosummary/pyedb.dotnet.database.nets.EdbNets.find_or_create_net.html#pyedb.dotnet.database.nets.EdbNets.find_or_create_net",
        "title": "find_or_create_net > find_or_create_net > find_or_create_net",
        "section": "find_or_create_net > find_or_create_net",
        "text": "EdbNets.find_or_create_net(net_name='', start_with='', contain='', end_with='')\n\nFind or create the net with the given name in the layout.\n\nParameters\n\nnet_name\n\npython:str, optional\n\nName of the net to find or create. The default is \"\".\n\nstart_with\n\npython:str, optional\n\nAll net name starting with the string. Not case-sensitive.\n\ncontain\n\npython:str, optional\n\nAll net name containing the string. Not case-sensitive.\n\nend_with\n\npython:str, optional\n\nAll net name ending with the string. Not case-sensitive.\n\nReturns\n\nobject\n\nNet Object.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.remove_pads_from_padstack",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.remove_pads_from_padstack.html#remove_pads_from_padstack",
        "title": "remove_pads_from_padstack",
        "section": "remove_pads_from_padstack",
        "text": "Remove pads from a padstack definition on specified layers.\nPadstack definition name.\nLayer name(s). Applies to all layers if None.\nTrue when successful, False when failed.\nremove_pads_from_padstack\npython:str\npython:str\npython:list\noptional\nNone\nTrue\nFalse"
    },
    {
        "objectID": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.remove_pads_from_padstack",
        "href": "grpc_api/grpc/database/_autosummary/pyedb.grpc.database.padstacks.Padstacks.remove_pads_from_padstack.html#pyedb.grpc.database.padstacks.Padstacks.remove_pads_from_padstack",
        "title": "remove_pads_from_padstack > remove_pads_from_padstack > remove_pads_from_padstack",
        "section": "remove_pads_from_padstack > remove_pads_from_padstack",
        "text": "Padstacks.remove_pads_from_padstack(padstack_name: str, layer_name: str | None = None)\n\nRemove pads from a padstack definition on specified layers.\n\nParameters\n\npadstack_name\n\npython:str\n\nPadstack definition name.\n\nlayer_name\n\npython:str or python:list, optional\n\nLayer name(s). Applies to all layers if None.\n\nReturns\n\nbool\n\nTrue when successful, False when failed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.delete.html#delete",
        "title": "delete",
        "section": "delete",
        "text": "Delete the circle from the layout.\ndelete"
    },
    {
        "objectID": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.delete",
        "href": "grpc_api/grpc/database/pyedb_lib/primitive/_autosummary/pyedb.grpc.database.primitive.circle.Circle.delete.html#pyedb.grpc.database.primitive.circle.Circle.delete",
        "title": "delete > delete > delete",
        "section": "delete > delete",
        "text": "Circle.delete()\n\nDelete the circle from the layout.\n\n!! processed by numpydoc !!"
    }
]