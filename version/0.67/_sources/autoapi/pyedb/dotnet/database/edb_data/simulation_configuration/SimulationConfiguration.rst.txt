





:class:`SimulationConfiguration`
================================


.. py:class:: pyedb.dotnet.database.edb_data.simulation_configuration.SimulationConfiguration(filename=None, edb=None)

   Bases: :py:obj:`object`


   
   Provides an ASCII simulation configuration file parser.

   This parser supports all types of inputs for setting up and automating any kind
   of SI or PI simulation with HFSS 3D Layout or Siwave. If fields are omitted, default
   values are applied. This class can be instantiated directly from
   Configuration file.














   .. rubric:: Examples

   This class is very convenient to build HFSS and SIwave simulation projects from layout.
   It is leveraging EDB commands from Pyaedt but with keeping high level parameters making more easy PCB automation
   flow. SYZ and DC simulation can be addressed with this class.

   The class is instantiated from an open edb:

   >>> from pyedb import Edb
   >>> edb = Edb()
   >>> sim_setup = edb.new_simulation_configuration()

   The returned object sim_setup is a SimulationConfiguration object.
   From this class you can assign a lot of parameters related the project configuration but also solver options.
   Here is the list of parameters available:

   >>> from dotnet.generic.constants import SolverType
   >>> sim_setup.solver_type = SolverType.Hfss3dLayout

   Solver type can be selected, HFSS 3D Layout and Siwave are supported.

   >>> sim_setup.signal_nets = ["net1", "net2"]

   Set the list of net names you want to include for the simulation. These nets will
   have excitations ports created if corresponding pins are found on selected component. We usually refer to signal
   nets but power / reference nets can also be passed into this list if user wants to have ports created on these ones.

   >>> sim_setup.power_nets = ["gnd", "vcc"]

   Set the list on power and reference nets. These nets won't have excitation ports created
   on them and will be clipped during the project build if the cutout option is enabled.

   >>> sim_setup.components = ["comp1", "comp2"]

   Set the list of components which will be included in the simulation. These components will have ports created on
   pins belonging to the net list.

   >>> sim_setup.do_cutout_subdesign = True

   When true activates the layout cutout based on net signal net selection and cutout expansion.

   >>> from dotnet.generic.constants import CutoutSubdesignType
   >>> sim_setup.cutout_subdesign_type = CutoutSubdesignType.Conformal

   Define the type of cutout used for computing the clippingextent polygon. CutoutSubdesignType.Conformal
   CutoutSubdesignType.BBox are surpported.

   >>> sim_setup.cutout_subdesign_expansion = "4mm"

   Define the distance used for computing the extent polygon. Integer or string can be passed.
   For example 0.001 is in meter so here 1mm. You can also pass the string "1mm" for the same result.

   >>> sim_setup.cutout_subdesign_round_corner = True

   Boolean to allow using rounded corner for the cutout extent or not.

   >>> sim_setup.use_default_cutout = False

   When True use the native edb API command to process the cutout. Using False uses
   the Pyaedt one which improves the cutout speed.

   >>> sim_setup.generate_solder_balls = True

   Boolean to activate the solder ball generation on components. When HFSS solver is selected in combination with this
   parameter, coaxial ports will be created on solder balls for pins belonging to selected signal nets. If Siwave
   solver is selected this parameter will be ignored.

   >>> sim_setup.use_default_coax_port_radial_extension = True

   When ``True`` the default coaxial extent is used for the ports (only for HFSS).
   When the design is having dense solder balls close to each other (like typically package design), the default value
   might be too large and cause port overlapping, then solver failure. To prevent this issue set this parameter to
   ``False`` will use a smaller value.

   >>> sim_setup.output_aedb = r"C:    emp\my_edb.aedb"

   Specify the output edb file after building the project. The parameter must be the complete file path.
   leaving this parameter blank will oervwritte the current open edb.

   >>>  sim_setup.dielectric_extent = 0.01

   Gives the dielectric extent after cutout, keeping default value is advised unless for
   very specific application.

   >>> sim_setup.airbox_horizontal_extent = "5mm"

   Provide the air box horizonzal extent values. Unitless float value will be
   treated as ratio but string value like "5mm" is also supported.

   >>> sim_setup.airbox_negative_vertical_extent = "5mm"

   Provide the air box negative vertical extent values. Unitless float value will be
   treated as ratio but string value like "5mm" is also supported.

   >>> sim_setup.airbox_positive_vertical_extent = "5mm"

   Provide the air box positive vertical extent values. Unitless float value will be
   treated as ratio but string value like "5mm" is also supported.

   >>> sim_setup.use_radiation_boundary = True

   When ``True`` use radiation airbox boundary condition and perfect metal box when
   set to ``False``. Default value is ``True``, using enclosed metal box will greatly change simulation results.
   Setting this parameter as ``False`` must be used cautiously.

   >>> sim_setup.do_cutout_subdesign = True

   ``True`` activates the cutout with associated parameters. Setting ``False`` will
   keep the entire layout.
   Setting to ``False`` can impact the simulation run time or even memory failure if HFSS solver is used.

   >>> sim_setup.do_pin_group = False

   When circuit ports are used, setting to ``True`` will force to create pin groups on
   components having pins belonging to same net. Setting to ``False`` will generate port on each signal pin with
   taking the closest reference pin. The last configuration is more often used when users are creating ports on PDN
   (Power delivery Network) and want to connect all pins individually.

   >>> from dotnet.generic.constants import SweepType
   >>> sim_setup.sweep_type = SweepType.Linear

   Specify the frequency sweep type, Linear or Log sweep can be defined.

   SimulationCOnfiguration also inherit from SimulationConfigurationAc class for High frequency settings.

   >>> sim_setup.start_freq = "OHz"

   Define the start frequency from the sweep.

   >>> sim_setup.stop_freq = "40GHz"

   Define the stop frequency from the sweep.

   >>> sim_setup.step_freq = "10MHz"

   Define the step frequency from the sweep.

   >>> sim_setup.decade_count = 100

   Used when log sweep is defined and specify the number of points per decade.

   >>> sim_setup.enforce_causality = True

   Activate the option ``Enforce Causality`` for the solver, recommended for signal integrity application

   >>> sim_setup.enforce_passivity = True

   Activate the option ``Enforce Passivity`` for the solver, recommended for signal integrity application

   >>> sim_setup.do_lambda_refinement = True

   Activate the lambda refinement for the initial mesh (only for HFSS), default value is ``True``. Keeping this
   activated is highly recommended.

   >>> sim_setup.use_q3d_for_dc = False

   Enable when ``True`` the Q3D DC point computation. Only needed when very high accuracy is required for DC point.
   Can eventually cause extra computation time.

   >>> sim_setup.sweep_name = "Test_sweep"

   Define the frequency sweep name.

   >>> sim_setup.mesh_freq = "10GHz"

   Define the frequency used for adaptive meshing (available for both HFSS and SIwave).

   >>> from dotnet.generic.constants import RadiationBoxType
   >>> sim_setup.radiation_box = RadiationBoxType.ConvexHull

   Defined the radiation box type, Conformal, Bounding box and ConvexHull are supported (HFSS only).

   >>> sim_setup.max_num_passes = 30

   Default value is 30, specify the maximum number of adaptive passes (only HFSS). Reasonable high value is recommended
   to force the solver reaching the convergence criteria.

   >>> sim_setup.max_mag_delta_s = 0.02

   Define the convergence criteria

   >>> sim_setup.min_num_passes = 2

   specify the minimum number of consecutive coberged passes. Setting to 2 is a good practice to avoid converging on
   local minima.

   >>> from dotnet.generic.constants import BasisOrder
   >>> sim_setup.basis_order = BasisOrder.Single

   Select the order basis (HFSS only), Zero, Single, Double and Mixed are supported. For Signal integrity Single or
   Mixed should be used.

   >>> sim_setup.minimum_void_surface = 0

   Only for Siwave, specify the minimum void surface to be meshed. Void with lower surface value will be ignored by
   meshing.

   SimulationConfiguration also inherits from SimulationDc class to handle DC simulation projects.

   >>> sim_setup.dc_compute_inductance = True

   ``True`` activate the DC loop inductance computation (Siwave only), ``False`` is deactivated.

   >>> sim_setup.dc_slide_position = 1

   The provided value must be between 0 and 2 and correspond ti the SIwave DC slide position in GUI.
   0 : coarse
   1 : medium accuracy
   2 : high accuracy

   >>> sim_setup.dc_plot_jv = True

   ``True`` activate the current / voltage plot with Siwave DC solver, ``False`` deactivate.

   >>> sim_setup.dc_error_energy = 0.02

   Fix the DC error convergence criteria. In this example 2% is defined.

   >>> sim_setup.dc_max_num_pass = 6

   Provide the maximum number of passes during Siwave DC adaptive meshing.

   >>> sim_setup.dc_min_num_pass = 1

   Provide the minimum number of passes during Siwave DC adaptive meshing.

   >>> sim_setup.dc_mesh_bondwires = True

   ``True`` bondwires are meshed, ``False`` bond wires are ignored during meshing.

   >>> sim_setup.dc_num_bondwire_sides = 8

   Gives the number of facets wirebonds are discretized.

   >>> sim_setup.dc_refine_vias = True

   ``True`` meshing refinement on nondwires activated during meshing process. Deactivated when set to ``False``.

   >>> sim_setup.dc_report_show_Active_devices = True

   Activate when ``True`` the components showing in the DC report.

   >>> sim_setup.dc_export_thermal_data = True

   ``True`` thermal data are exported for Icepak simulation.

   >>> sim_setup.dc_full_report_path = r"C:    emp\my_report.html"

   Provides the file path for the DC report.

   >>> sim_setup.dc_icepak_temp_file = r"C:    emp\my_file"

   Provides icepak temporary files location.

   >>> sim_setup.dc_import_thermal_data = False

   Import DC thermal data when `True``

   >>> sim_setup.dc_per_pin_res_path = r"C:    emp\dc_pin_res_file"
   Provides the resistance per pin file path.

   >>> sim_setup.dc_per_pin_use_pin_format = True

   When ``True`` activate the pin format.

   >>> sim_setup.dc_use_loop_res_for_per_pin = True

   Activate the loop resistance usage per pin when ``True``

   >>> sim_setup.dc_via_report_path = "C:\temp\via_report_file"

   Define the via report path file.

   >>> sim_setup.add_current_source(name="test_isrc",
   >>>                                 current_value=1.2,
   >>>                                 phase_value=0.0,
   >>>                                 impedance=5e7,
   >>>                                 positive_node_component="comp1",
   >>>                                 positive_node_net="net1",
   >>>                                 negative_node_component="comp2",
   >>>                                 negative_node_net="net2"
   >>>                             )

   Define a current source.

   >>> sim_setup.add_dc_ground_source_term(source_name="test_isrc", node_to_ground=1)

   Define the pin from a source which has to be set to reference for DC simulation.

   >>> sim_setup.add_voltage_source(name="test_vsrc",
   >>>                                 current_value=1.33,
   >>>                                 phase_value=0.0,
   >>>                                 impedance=1e-6,
   >>>                                 positive_node_component="comp1",
   >>>                                 positive_node_net="net1",
   >>>                                 negative_node_component="comp2",
   >>>                                 negative_node_net="net2"
   >>>                             )

   Define a voltage source.

   >>> sim_setup.add_dc_ground_source_term(source_name="test_vsrc", node_to_ground=1)

   Define the pin from a source which has to be set to reference for DC simulation.

   >>> edb.build_simulation_project(sim_setup)

   Will build and save your project.

   ..
       !! processed by numpydoc !!




.. py:currentmodule:: SimulationConfiguration

Overview
--------

.. tab-set::



   .. tab-item:: Methods

      .. list-table::
          :header-rows: 0
          :widths: auto

          * - :py:attr:`~build_simulation_project`
            - Build active simulation project. This method requires to be run inside Edb Class.
          * - :py:attr:`~add_dc_ground_source_term`
            - Add a dc ground source terminal for Siwave.
          * - :py:attr:`~export_json`
            - Export Json file from SimulationConfiguration object.
          * - :py:attr:`~import_json`
            - Import Json file into SimulationConfiguration object instance.
          * - :py:attr:`~add_voltage_source`
            - Add a voltage source for the current SimulationConfiguration instance.
          * - :py:attr:`~add_current_source`
            - Add a current source for the current SimulationConfiguration instance.
          * - :py:attr:`~add_rlc`
            - Add a voltage source for the current SimulationConfiguration instance.


   .. tab-item:: Properties

      .. list-table::
          :header-rows: 0
          :widths: auto

          * - :py:attr:`~open_edb_after_build`
            - Either if open the Edb after the build or not.
          * - :py:attr:`~dc_settings`
            - DC Settings class.
          * - :py:attr:`~ac_settings`
            - AC Settings class.
          * - :py:attr:`~batch_solve_settings`
            - Cutout and Batch Settings class.
          * - :py:attr:`~solver_type`
            - Retrieve the SolverType class to select the solver to be called during the project build.
          * - :py:attr:`~filename`
            - Retrieve the file name loaded for mapping properties value.
          * - :py:attr:`~setup_name`
            - Retrieve setup name for the simulation.


   .. tab-item:: Attributes

      .. list-table::
          :header-rows: 0
          :widths: auto

          * - :py:attr:`~SOLVER_TYPE`
            - 



   .. tab-item:: Special methods

      .. list-table::
          :header-rows: 0
          :widths: auto

          * - :py:attr:`~__getattr__`
            - 
          * - :py:attr:`~__setattr__`
            - 




Import detail
-------------

.. code-block:: python

    from pyedb.dotnet.database.edb_data.simulation_configuration import SimulationConfiguration

Property detail
---------------

.. py:property:: open_edb_after_build

   
   Either if open the Edb after the build or not.





   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ..











   ..
       !! processed by numpydoc !!

.. py:property:: dc_settings
   :type: SimulationConfigurationDc


   
   DC Settings class.





   :Returns:

       :class:`pyedb.dotnet.database.edb_data.simulation_configuration.SimulationConfigurationDc`
           ..











   ..
       !! processed by numpydoc !!

.. py:property:: ac_settings
   :type: SimulationConfigurationAc


   
   AC Settings class.





   :Returns:

       :class:`pyedb.dotnet.database.edb_data.simulation_configuration.SimulationConfigurationAc`
           ..











   ..
       !! processed by numpydoc !!

.. py:property:: batch_solve_settings
   :type: SimulationConfigurationBatch


   
   Cutout and Batch Settings class.





   :Returns:

       :class:`pyedb.dotnet.database.edb_data.simulation_configuration.SimulationConfigurationBatch`
           ..











   ..
       !! processed by numpydoc !!

.. py:property:: solver_type

   
   Retrieve the SolverType class to select the solver to be called during the project build.





   :Returns:

       :class:`dotnet.generic.constants.SolverType`
           selections are supported, Hfss3dLayout and Siwave.











   ..
       !! processed by numpydoc !!

.. py:property:: filename

   
   Retrieve the file name loaded for mapping properties value.





   :Returns:

       :class:`python:str`
           the absolute path for the filename.











   ..
       !! processed by numpydoc !!

.. py:property:: setup_name

   
   Retrieve setup name for the simulation.





   :Returns:

       :class:`python:str`
           Setup name.











   ..
       !! processed by numpydoc !!



Attribute detail
----------------

.. py:attribute:: SOLVER_TYPE



Method detail
-------------

.. py:method:: __getattr__(item)

.. py:method:: __setattr__(key, value)

.. py:method:: build_simulation_project()

   
   Build active simulation project. This method requires to be run inside Edb Class.





   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ..











   ..
       !! processed by numpydoc !!

.. py:method:: add_dc_ground_source_term(source_name=None, node_to_ground=1)

   
   Add a dc ground source terminal for Siwave.


   :Parameters:

       **source_name** : :class:`python:str`, :obj:`optional`
           The source name to assign the reference node to.
           Default value is ``None``.

       **node_to_ground** : :class:`python:int`, :obj:`optional`
           Value must be ``0``: unspecified, ``1``: negative node, ``2``: positive node.
           Default value is ``1``.














   ..
       !! processed by numpydoc !!

.. py:method:: export_json(output_file)

   
   Export Json file from SimulationConfiguration object.


   :Parameters:

       **output_file** : :class:`python:str`
           Json file name.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           True when succeeded False when file name not provided.










   .. rubric:: Examples

   >>> from dotnet.database.edb_data.simulation_configuration import SimulationConfiguration
   >>> config = SimulationConfiguration()
   >>> config.export_json(r"C:\Temp        est_json        est.json")

   ..
       !! processed by numpydoc !!

.. py:method:: import_json(input_file)

   
   Import Json file into SimulationConfiguration object instance.


   :Parameters:

       **input_file** : :class:`python:str`
           Json file name.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           True when succeeded False when file name not provided.










   .. rubric:: Examples

   >>> from dotnet.database.edb_data.simulation_configuration import SimulationConfiguration
   >>> test = SimulationConfiguration()
   >>> test.import_json(r"C:\Temp  est_json        est.json")

   ..
       !! processed by numpydoc !!

.. py:method:: add_voltage_source(name='', voltage_value=1, phase_value=0, impedance=1e-06, positive_node_component='', positive_node_net='', negative_node_component='', negative_node_net='')

   
   Add a voltage source for the current SimulationConfiguration instance.


   :Parameters:

       **name** : :class:`python:str`
           Source name.

       **voltage_value** : :class:`python:float`
           Amplitude value of the source. Either amperes for current source or volts for
           voltage source.

       **phase_value** : :class:`python:float`
           Phase value of the source.

       **impedance** : :class:`python:float`
           Impedance value of the source.

       **positive_node_component** : :class:`python:str`
           Name of the component used for the positive node.

       **negative_node_component** : :class:`python:str`
           Name of the component used for the negative node.

       **positive_node_net** : :class:`python:str`
           Net used for the positive node.

       **negative_node_net** : :class:`python:str`
           Net used for the negative node.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ``True`` when successful, ``False`` when failed.










   .. rubric:: Examples

   >>> edb = Edb(target_file)
   >>> sim_setup = SimulationConfiguration()
   >>> sim_setup.add_voltage_source(voltage_value=1.0, phase_value=0, positive_node_component="V1",
   >>> positive_node_net="HSG", negative_node_component="V1", negative_node_net="SW")

   ..
       !! processed by numpydoc !!

.. py:method:: add_current_source(name='', current_value=0.1, phase_value=0, impedance=50000000.0, positive_node_component='', positive_node_net='', negative_node_component='', negative_node_net='')

   
   Add a current source for the current SimulationConfiguration instance.


   :Parameters:

       **name** : :class:`python:str`
           Source name.

       **current_value** : :class:`python:float`
           Amplitude value of the source. Either amperes for current source or volts for
           voltage source.

       **phase_value** : :class:`python:float`
           Phase value of the source.

       **impedance** : :class:`python:float`
           Impedance value of the source.

       **positive_node_component** : :class:`python:str`
           Name of the component used for the positive node.

       **negative_node_component** : :class:`python:str`
           Name of the component used for the negative node.

       **positive_node_net** : :class:`python:str`
           Net used for the positive node.

       **negative_node_net** : :class:`python:str`
           Net used for the negative node.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ``True`` when successful, ``False`` when failed.










   .. rubric:: Examples

   >>> edb = Edb(target_file)
   >>> sim_setup = SimulationConfiguration()
   >>> sim_setup.add_voltage_source(voltage_value=1.0, phase_value=0, positive_node_component="V1",
   >>> positive_node_net="HSG", negative_node_component="V1", negative_node_net="SW")

   ..
       !! processed by numpydoc !!

.. py:method:: add_rlc(name='', r_value=1.0, c_value=0.0, l_value=0.0, positive_node_component='', positive_node_net='', negative_node_component='', negative_node_net='', create_physical_rlc=True)

   
   Add a voltage source for the current SimulationConfiguration instance.


   :Parameters:

       **name** : :class:`python:str`
           Source name.

       **r_value** : :class:`python:float`
           Resistor value in Ohms.

       **l_value** : :class:`python:float`
           Inductance value in Henry.

       **c_value** : :class:`python:float`
           Capacitance value in Farrad.

       **positive_node_component** : :class:`python:str`
           Name of the component used for the positive node.

       **negative_node_component** : :class:`python:str`
           Name of the component used for the negative node.

       **positive_node_net** : :class:`python:str`
           Net used for the positive node.

       **negative_node_net** : :class:`python:str`
           Net used for the negative node.

       **create_physical_rlc** : :ref:`bool <python:bltin-boolean-values>`
           When True create a physical Rlc component. Recommended setting to True to be compatible with Siwave.



   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           ``True`` when successful, ``False`` when failed.










   .. rubric:: Examples

   >>> edb = Edb(target_file)
   >>> sim_setup = SimulationConfiguration()
   >>> sim_setup.add_voltage_source(voltage_value=1.0, phase_value=0, positive_node_component="V1",
   >>> positive_node_net="HSG", negative_node_component="V1", negative_node_net="SW")

   ..
       !! processed by numpydoc !!




